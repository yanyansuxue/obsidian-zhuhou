/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/.pnpm/plantuml-encoder@1.4.0/node_modules/plantuml-encoder/dist/plantuml-encoder.js
var require_plantuml_encoder = __commonJS({
  "../../node_modules/.pnpm/plantuml-encoder@1.4.0/node_modules/plantuml-encoder/dist/plantuml-encoder.js"(exports, module2) {
    (function(f) {
      if (typeof exports === "object" && typeof module2 !== "undefined") {
        module2.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.plantumlEncoder = f();
      }
    })(function() {
      var define2, module3, exports2;
      return function() {
        function r(e, n, t2) {
          function o(i2, f) {
            if (!n[i2]) {
              if (!e[i2]) {
                var c = "function" == typeof require && require;
                if (!f && c)
                  return c(i2, true);
                if (u)
                  return u(i2, true);
                var a = new Error("Cannot find module '" + i2 + "'");
                throw a.code = "MODULE_NOT_FOUND", a;
              }
              var p = n[i2] = { exports: {} };
              e[i2][0].call(p.exports, function(r2) {
                var n2 = e[i2][1][r2];
                return o(n2 || r2);
              }, p, p.exports, r, e, n, t2);
            }
            return n[i2].exports;
          }
          for (var u = "function" == typeof require && require, i = 0; i < t2.length; i++)
            o(t2[i]);
          return o;
        }
        return r;
      }()({ 1: [function(require2, module4, exports3) {
        "use strict";
        var pako = require2("pako/lib/deflate.js");
        module4.exports = function(data2) {
          return pako.deflateRaw(data2, { level: 9, to: "string" });
        };
      }, { "pako/lib/deflate.js": 4 }], 2: [function(require2, module4, exports3) {
        "use strict";
        function encode6bit(b) {
          if (b < 10) {
            return String.fromCharCode(48 + b);
          }
          b -= 10;
          if (b < 26) {
            return String.fromCharCode(65 + b);
          }
          b -= 26;
          if (b < 26) {
            return String.fromCharCode(97 + b);
          }
          b -= 26;
          if (b === 0) {
            return "-";
          }
          if (b === 1) {
            return "_";
          }
          return "?";
        }
        function append3bytes(b1, b2, b3) {
          var c1 = b1 >> 2;
          var c2 = (b1 & 3) << 4 | b2 >> 4;
          var c3 = (b2 & 15) << 2 | b3 >> 6;
          var c4 = b3 & 63;
          var r = "";
          r += encode6bit(c1 & 63);
          r += encode6bit(c2 & 63);
          r += encode6bit(c3 & 63);
          r += encode6bit(c4 & 63);
          return r;
        }
        module4.exports = function(data2) {
          var r = "";
          for (var i = 0; i < data2.length; i += 3) {
            if (i + 2 === data2.length) {
              r += append3bytes(data2.charCodeAt(i), data2.charCodeAt(i + 1), 0);
            } else if (i + 1 === data2.length) {
              r += append3bytes(data2.charCodeAt(i), 0, 0);
            } else {
              r += append3bytes(
                data2.charCodeAt(i),
                data2.charCodeAt(i + 1),
                data2.charCodeAt(i + 2)
              );
            }
          }
          return r;
        };
      }, {}], 3: [function(require2, module4, exports3) {
        "use strict";
        var deflate = require2("./deflate");
        var encode64 = require2("./encode64");
        module4.exports.encode = function(puml) {
          var deflated = deflate(puml);
          return encode64(deflated);
        };
      }, { "./deflate": 1, "./encode64": 2 }], 4: [function(require2, module4, exports3) {
        "use strict";
        var zlib_deflate = require2("./zlib/deflate");
        var utils = require2("./utils/common");
        var strings = require2("./utils/strings");
        var msg = require2("./zlib/messages");
        var ZStream = require2("./zlib/zstream");
        var toString2 = Object.prototype.toString;
        var Z_NO_FLUSH = 0;
        var Z_FINISH = 4;
        var Z_OK = 0;
        var Z_STREAM_END = 1;
        var Z_SYNC_FLUSH = 2;
        var Z_DEFAULT_COMPRESSION = -1;
        var Z_DEFAULT_STRATEGY = 0;
        var Z_DEFLATED = 8;
        function Deflate(options) {
          if (!(this instanceof Deflate))
            return new Deflate(options);
          this.options = utils.assign({
            level: Z_DEFAULT_COMPRESSION,
            method: Z_DEFLATED,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: Z_DEFAULT_STRATEGY,
            to: ""
          }, options || {});
          var opt = this.options;
          if (opt.raw && opt.windowBits > 0) {
            opt.windowBits = -opt.windowBits;
          } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
            opt.windowBits += 16;
          }
          this.err = 0;
          this.msg = "";
          this.ended = false;
          this.chunks = [];
          this.strm = new ZStream();
          this.strm.avail_out = 0;
          var status = zlib_deflate.deflateInit2(
            this.strm,
            opt.level,
            opt.method,
            opt.windowBits,
            opt.memLevel,
            opt.strategy
          );
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
          if (opt.header) {
            zlib_deflate.deflateSetHeader(this.strm, opt.header);
          }
          if (opt.dictionary) {
            var dict;
            if (typeof opt.dictionary === "string") {
              dict = strings.string2buf(opt.dictionary);
            } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
              dict = new Uint8Array(opt.dictionary);
            } else {
              dict = opt.dictionary;
            }
            status = zlib_deflate.deflateSetDictionary(this.strm, dict);
            if (status !== Z_OK) {
              throw new Error(msg[status]);
            }
            this._dict_set = true;
          }
        }
        Deflate.prototype.push = function(data2, mode) {
          var strm = this.strm;
          var chunkSize = this.options.chunkSize;
          var status, _mode;
          if (this.ended) {
            return false;
          }
          _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
          if (typeof data2 === "string") {
            strm.input = strings.string2buf(data2);
          } else if (toString2.call(data2) === "[object ArrayBuffer]") {
            strm.input = new Uint8Array(data2);
          } else {
            strm.input = data2;
          }
          strm.next_in = 0;
          strm.avail_in = strm.input.length;
          do {
            if (strm.avail_out === 0) {
              strm.output = new utils.Buf8(chunkSize);
              strm.next_out = 0;
              strm.avail_out = chunkSize;
            }
            status = zlib_deflate.deflate(strm, _mode);
            if (status !== Z_STREAM_END && status !== Z_OK) {
              this.onEnd(status);
              this.ended = true;
              return false;
            }
            if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
              if (this.options.to === "string") {
                this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
              } else {
                this.onData(utils.shrinkBuf(strm.output, strm.next_out));
              }
            }
          } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
          if (_mode === Z_FINISH) {
            status = zlib_deflate.deflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === Z_OK;
          }
          if (_mode === Z_SYNC_FLUSH) {
            this.onEnd(Z_OK);
            strm.avail_out = 0;
            return true;
          }
          return true;
        };
        Deflate.prototype.onData = function(chunk) {
          this.chunks.push(chunk);
        };
        Deflate.prototype.onEnd = function(status) {
          if (status === Z_OK) {
            if (this.options.to === "string") {
              this.result = this.chunks.join("");
            } else {
              this.result = utils.flattenChunks(this.chunks);
            }
          }
          this.chunks = [];
          this.err = status;
          this.msg = this.strm.msg;
        };
        function deflate(input, options) {
          var deflator = new Deflate(options);
          deflator.push(input, true);
          if (deflator.err) {
            throw deflator.msg || msg[deflator.err];
          }
          return deflator.result;
        }
        function deflateRaw(input, options) {
          options = options || {};
          options.raw = true;
          return deflate(input, options);
        }
        function gzip(input, options) {
          options = options || {};
          options.gzip = true;
          return deflate(input, options);
        }
        exports3.Deflate = Deflate;
        exports3.deflate = deflate;
        exports3.deflateRaw = deflateRaw;
        exports3.gzip = gzip;
      }, { "./utils/common": 5, "./utils/strings": 6, "./zlib/deflate": 9, "./zlib/messages": 10, "./zlib/zstream": 12 }], 5: [function(require2, module4, exports3) {
        "use strict";
        var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
        function _has(obj, key) {
          return Object.prototype.hasOwnProperty.call(obj, key);
        }
        exports3.assign = function(obj) {
          var sources = Array.prototype.slice.call(arguments, 1);
          while (sources.length) {
            var source = sources.shift();
            if (!source) {
              continue;
            }
            if (typeof source !== "object") {
              throw new TypeError(source + "must be non-object");
            }
            for (var p in source) {
              if (_has(source, p)) {
                obj[p] = source[p];
              }
            }
          }
          return obj;
        };
        exports3.shrinkBuf = function(buf, size) {
          if (buf.length === size) {
            return buf;
          }
          if (buf.subarray) {
            return buf.subarray(0, size);
          }
          buf.length = size;
          return buf;
        };
        var fnTyped = {
          arraySet: function(dest, src, src_offs, len, dest_offs) {
            if (src.subarray && dest.subarray) {
              dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
              return;
            }
            for (var i = 0; i < len; i++) {
              dest[dest_offs + i] = src[src_offs + i];
            }
          },
          flattenChunks: function(chunks) {
            var i, l, len, pos, chunk, result;
            len = 0;
            for (i = 0, l = chunks.length; i < l; i++) {
              len += chunks[i].length;
            }
            result = new Uint8Array(len);
            pos = 0;
            for (i = 0, l = chunks.length; i < l; i++) {
              chunk = chunks[i];
              result.set(chunk, pos);
              pos += chunk.length;
            }
            return result;
          }
        };
        var fnUntyped = {
          arraySet: function(dest, src, src_offs, len, dest_offs) {
            for (var i = 0; i < len; i++) {
              dest[dest_offs + i] = src[src_offs + i];
            }
          },
          flattenChunks: function(chunks) {
            return [].concat.apply([], chunks);
          }
        };
        exports3.setTyped = function(on) {
          if (on) {
            exports3.Buf8 = Uint8Array;
            exports3.Buf16 = Uint16Array;
            exports3.Buf32 = Int32Array;
            exports3.assign(exports3, fnTyped);
          } else {
            exports3.Buf8 = Array;
            exports3.Buf16 = Array;
            exports3.Buf32 = Array;
            exports3.assign(exports3, fnUntyped);
          }
        };
        exports3.setTyped(TYPED_OK);
      }, {}], 6: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("./common");
        var STR_APPLY_OK = true;
        var STR_APPLY_UIA_OK = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (__) {
          STR_APPLY_OK = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (__) {
          STR_APPLY_UIA_OK = false;
        }
        var _utf8len = new utils.Buf8(256);
        for (var q = 0; q < 256; q++) {
          _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
        }
        _utf8len[254] = _utf8len[254] = 1;
        exports3.string2buf = function(str) {
          var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
          for (m_pos = 0; m_pos < str_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
              c2 = str.charCodeAt(m_pos + 1);
              if ((c2 & 64512) === 56320) {
                c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                m_pos++;
              }
            }
            buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
          }
          buf = new utils.Buf8(buf_len);
          for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
              c2 = str.charCodeAt(m_pos + 1);
              if ((c2 & 64512) === 56320) {
                c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                m_pos++;
              }
            }
            if (c < 128) {
              buf[i++] = c;
            } else if (c < 2048) {
              buf[i++] = 192 | c >>> 6;
              buf[i++] = 128 | c & 63;
            } else if (c < 65536) {
              buf[i++] = 224 | c >>> 12;
              buf[i++] = 128 | c >>> 6 & 63;
              buf[i++] = 128 | c & 63;
            } else {
              buf[i++] = 240 | c >>> 18;
              buf[i++] = 128 | c >>> 12 & 63;
              buf[i++] = 128 | c >>> 6 & 63;
              buf[i++] = 128 | c & 63;
            }
          }
          return buf;
        };
        function buf2binstring(buf, len) {
          if (len < 65534) {
            if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
              return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
            }
          }
          var result = "";
          for (var i = 0; i < len; i++) {
            result += String.fromCharCode(buf[i]);
          }
          return result;
        }
        exports3.buf2binstring = function(buf) {
          return buf2binstring(buf, buf.length);
        };
        exports3.binstring2buf = function(str) {
          var buf = new utils.Buf8(str.length);
          for (var i = 0, len = buf.length; i < len; i++) {
            buf[i] = str.charCodeAt(i);
          }
          return buf;
        };
        exports3.buf2string = function(buf, max) {
          var i, out, c, c_len;
          var len = max || buf.length;
          var utf16buf = new Array(len * 2);
          for (out = 0, i = 0; i < len; ) {
            c = buf[i++];
            if (c < 128) {
              utf16buf[out++] = c;
              continue;
            }
            c_len = _utf8len[c];
            if (c_len > 4) {
              utf16buf[out++] = 65533;
              i += c_len - 1;
              continue;
            }
            c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
            while (c_len > 1 && i < len) {
              c = c << 6 | buf[i++] & 63;
              c_len--;
            }
            if (c_len > 1) {
              utf16buf[out++] = 65533;
              continue;
            }
            if (c < 65536) {
              utf16buf[out++] = c;
            } else {
              c -= 65536;
              utf16buf[out++] = 55296 | c >> 10 & 1023;
              utf16buf[out++] = 56320 | c & 1023;
            }
          }
          return buf2binstring(utf16buf, out);
        };
        exports3.utf8border = function(buf, max) {
          var pos;
          max = max || buf.length;
          if (max > buf.length) {
            max = buf.length;
          }
          pos = max - 1;
          while (pos >= 0 && (buf[pos] & 192) === 128) {
            pos--;
          }
          if (pos < 0) {
            return max;
          }
          if (pos === 0) {
            return max;
          }
          return pos + _utf8len[buf[pos]] > max ? pos : max;
        };
      }, { "./common": 5 }], 7: [function(require2, module4, exports3) {
        "use strict";
        function adler32(adler, buf, len, pos) {
          var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
          while (len !== 0) {
            n = len > 2e3 ? 2e3 : len;
            len -= n;
            do {
              s1 = s1 + buf[pos++] | 0;
              s2 = s2 + s1 | 0;
            } while (--n);
            s1 %= 65521;
            s2 %= 65521;
          }
          return s1 | s2 << 16 | 0;
        }
        module4.exports = adler32;
      }, {}], 8: [function(require2, module4, exports3) {
        "use strict";
        function makeTable() {
          var c, table2 = [];
          for (var n = 0; n < 256; n++) {
            c = n;
            for (var k = 0; k < 8; k++) {
              c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
            }
            table2[n] = c;
          }
          return table2;
        }
        var crcTable = makeTable();
        function crc32(crc, buf, len, pos) {
          var t2 = crcTable, end2 = pos + len;
          crc ^= -1;
          for (var i = pos; i < end2; i++) {
            crc = crc >>> 8 ^ t2[(crc ^ buf[i]) & 255];
          }
          return crc ^ -1;
        }
        module4.exports = crc32;
      }, {}], 9: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("../utils/common");
        var trees = require2("./trees");
        var adler32 = require2("./adler32");
        var crc32 = require2("./crc32");
        var msg = require2("./messages");
        var Z_NO_FLUSH = 0;
        var Z_PARTIAL_FLUSH = 1;
        var Z_FULL_FLUSH = 3;
        var Z_FINISH = 4;
        var Z_BLOCK = 5;
        var Z_OK = 0;
        var Z_STREAM_END = 1;
        var Z_STREAM_ERROR = -2;
        var Z_DATA_ERROR = -3;
        var Z_BUF_ERROR = -5;
        var Z_DEFAULT_COMPRESSION = -1;
        var Z_FILTERED = 1;
        var Z_HUFFMAN_ONLY = 2;
        var Z_RLE = 3;
        var Z_FIXED = 4;
        var Z_DEFAULT_STRATEGY = 0;
        var Z_UNKNOWN = 2;
        var Z_DEFLATED = 8;
        var MAX_MEM_LEVEL = 9;
        var MAX_WBITS = 15;
        var DEF_MEM_LEVEL = 8;
        var LENGTH_CODES = 29;
        var LITERALS = 256;
        var L_CODES = LITERALS + 1 + LENGTH_CODES;
        var D_CODES = 30;
        var BL_CODES = 19;
        var HEAP_SIZE = 2 * L_CODES + 1;
        var MAX_BITS = 15;
        var MIN_MATCH = 3;
        var MAX_MATCH = 258;
        var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
        var PRESET_DICT = 32;
        var INIT_STATE = 42;
        var EXTRA_STATE = 69;
        var NAME_STATE = 73;
        var COMMENT_STATE = 91;
        var HCRC_STATE = 103;
        var BUSY_STATE = 113;
        var FINISH_STATE = 666;
        var BS_NEED_MORE = 1;
        var BS_BLOCK_DONE = 2;
        var BS_FINISH_STARTED = 3;
        var BS_FINISH_DONE = 4;
        var OS_CODE = 3;
        function err(strm, errorCode) {
          strm.msg = msg[errorCode];
          return errorCode;
        }
        function rank(f) {
          return (f << 1) - (f > 4 ? 9 : 0);
        }
        function zero(buf) {
          var len = buf.length;
          while (--len >= 0) {
            buf[len] = 0;
          }
        }
        function flush_pending(strm) {
          var s = strm.state;
          var len = s.pending;
          if (len > strm.avail_out) {
            len = strm.avail_out;
          }
          if (len === 0) {
            return;
          }
          utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
          strm.next_out += len;
          s.pending_out += len;
          strm.total_out += len;
          strm.avail_out -= len;
          s.pending -= len;
          if (s.pending === 0) {
            s.pending_out = 0;
          }
        }
        function flush_block_only(s, last2) {
          trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last2);
          s.block_start = s.strstart;
          flush_pending(s.strm);
        }
        function put_byte(s, b) {
          s.pending_buf[s.pending++] = b;
        }
        function putShortMSB(s, b) {
          s.pending_buf[s.pending++] = b >>> 8 & 255;
          s.pending_buf[s.pending++] = b & 255;
        }
        function read_buf(strm, buf, start, size) {
          var len = strm.avail_in;
          if (len > size) {
            len = size;
          }
          if (len === 0) {
            return 0;
          }
          strm.avail_in -= len;
          utils.arraySet(buf, strm.input, strm.next_in, len, start);
          if (strm.state.wrap === 1) {
            strm.adler = adler32(strm.adler, buf, len, start);
          } else if (strm.state.wrap === 2) {
            strm.adler = crc32(strm.adler, buf, len, start);
          }
          strm.next_in += len;
          strm.total_in += len;
          return len;
        }
        function longest_match(s, cur_match) {
          var chain_length = s.max_chain_length;
          var scan = s.strstart;
          var match2;
          var len;
          var best_len = s.prev_length;
          var nice_match = s.nice_match;
          var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
          var _win = s.window;
          var wmask = s.w_mask;
          var prev2 = s.prev;
          var strend = s.strstart + MAX_MATCH;
          var scan_end1 = _win[scan + best_len - 1];
          var scan_end = _win[scan + best_len];
          if (s.prev_length >= s.good_match) {
            chain_length >>= 2;
          }
          if (nice_match > s.lookahead) {
            nice_match = s.lookahead;
          }
          do {
            match2 = cur_match;
            if (_win[match2 + best_len] !== scan_end || _win[match2 + best_len - 1] !== scan_end1 || _win[match2] !== _win[scan] || _win[++match2] !== _win[scan + 1]) {
              continue;
            }
            scan += 2;
            match2++;
            do {
            } while (_win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && scan < strend);
            len = MAX_MATCH - (strend - scan);
            scan = strend - MAX_MATCH;
            if (len > best_len) {
              s.match_start = cur_match;
              best_len = len;
              if (len >= nice_match) {
                break;
              }
              scan_end1 = _win[scan + best_len - 1];
              scan_end = _win[scan + best_len];
            }
          } while ((cur_match = prev2[cur_match & wmask]) > limit && --chain_length !== 0);
          if (best_len <= s.lookahead) {
            return best_len;
          }
          return s.lookahead;
        }
        function fill_window(s) {
          var _w_size = s.w_size;
          var p, n, m, more, str;
          do {
            more = s.window_size - s.lookahead - s.strstart;
            if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
              utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
              s.match_start -= _w_size;
              s.strstart -= _w_size;
              s.block_start -= _w_size;
              n = s.hash_size;
              p = n;
              do {
                m = s.head[--p];
                s.head[p] = m >= _w_size ? m - _w_size : 0;
              } while (--n);
              n = _w_size;
              p = n;
              do {
                m = s.prev[--p];
                s.prev[p] = m >= _w_size ? m - _w_size : 0;
              } while (--n);
              more += _w_size;
            }
            if (s.strm.avail_in === 0) {
              break;
            }
            n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
            s.lookahead += n;
            if (s.lookahead + s.insert >= MIN_MATCH) {
              str = s.strstart - s.insert;
              s.ins_h = s.window[str];
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
              while (s.insert) {
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                s.prev[str & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = str;
                str++;
                s.insert--;
                if (s.lookahead + s.insert < MIN_MATCH) {
                  break;
                }
              }
            }
          } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
        }
        function deflate_stored(s, flush) {
          var max_block_size = 65535;
          if (max_block_size > s.pending_buf_size - 5) {
            max_block_size = s.pending_buf_size - 5;
          }
          for (; ; ) {
            if (s.lookahead <= 1) {
              fill_window(s);
              if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s.lookahead === 0) {
                break;
              }
            }
            s.strstart += s.lookahead;
            s.lookahead = 0;
            var max_start = s.block_start + max_block_size;
            if (s.strstart === 0 || s.strstart >= max_start) {
              s.lookahead = s.strstart - max_start;
              s.strstart = max_start;
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
            if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s.insert = 0;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.strstart > s.block_start) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_NEED_MORE;
        }
        function deflate_fast(s, flush) {
          var hash_head;
          var bflush;
          for (; ; ) {
            if (s.lookahead < MIN_LOOKAHEAD) {
              fill_window(s);
              if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s.lookahead === 0) {
                break;
              }
            }
            hash_head = 0;
            if (s.lookahead >= MIN_MATCH) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
            if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
              s.match_length = longest_match(s, hash_head);
            }
            if (s.match_length >= MIN_MATCH) {
              bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
              s.lookahead -= s.match_length;
              if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
                s.match_length--;
                do {
                  s.strstart++;
                  s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                  hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                  s.head[s.ins_h] = s.strstart;
                } while (--s.match_length !== 0);
                s.strstart++;
              } else {
                s.strstart += s.match_length;
                s.match_length = 0;
                s.ins_h = s.window[s.strstart];
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
              }
            } else {
              bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
              s.lookahead--;
              s.strstart++;
            }
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        function deflate_slow(s, flush) {
          var hash_head;
          var bflush;
          var max_insert;
          for (; ; ) {
            if (s.lookahead < MIN_LOOKAHEAD) {
              fill_window(s);
              if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s.lookahead === 0) {
                break;
              }
            }
            hash_head = 0;
            if (s.lookahead >= MIN_MATCH) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
            s.prev_length = s.match_length;
            s.prev_match = s.match_start;
            s.match_length = MIN_MATCH - 1;
            if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
              s.match_length = longest_match(s, hash_head);
              if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
                s.match_length = MIN_MATCH - 1;
              }
            }
            if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
              max_insert = s.strstart + s.lookahead - MIN_MATCH;
              bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
              s.lookahead -= s.prev_length - 1;
              s.prev_length -= 2;
              do {
                if (++s.strstart <= max_insert) {
                  s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                  hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                  s.head[s.ins_h] = s.strstart;
                }
              } while (--s.prev_length !== 0);
              s.match_available = 0;
              s.match_length = MIN_MATCH - 1;
              s.strstart++;
              if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
              }
            } else if (s.match_available) {
              bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
              if (bflush) {
                flush_block_only(s, false);
              }
              s.strstart++;
              s.lookahead--;
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            } else {
              s.match_available = 1;
              s.strstart++;
              s.lookahead--;
            }
          }
          if (s.match_available) {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
            s.match_available = 0;
          }
          s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        function deflate_rle(s, flush) {
          var bflush;
          var prev2;
          var scan, strend;
          var _win = s.window;
          for (; ; ) {
            if (s.lookahead <= MAX_MATCH) {
              fill_window(s);
              if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s.lookahead === 0) {
                break;
              }
            }
            s.match_length = 0;
            if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
              scan = s.strstart - 1;
              prev2 = _win[scan];
              if (prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan]) {
                strend = s.strstart + MAX_MATCH;
                do {
                } while (prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && scan < strend);
                s.match_length = MAX_MATCH - (strend - scan);
                if (s.match_length > s.lookahead) {
                  s.match_length = s.lookahead;
                }
              }
            }
            if (s.match_length >= MIN_MATCH) {
              bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
              s.lookahead -= s.match_length;
              s.strstart += s.match_length;
              s.match_length = 0;
            } else {
              bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
              s.lookahead--;
              s.strstart++;
            }
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s.insert = 0;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        function deflate_huff(s, flush) {
          var bflush;
          for (; ; ) {
            if (s.lookahead === 0) {
              fill_window(s);
              if (s.lookahead === 0) {
                if (flush === Z_NO_FLUSH) {
                  return BS_NEED_MORE;
                }
                break;
              }
            }
            s.match_length = 0;
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s.insert = 0;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        function Config(good_length, max_lazy, nice_length, max_chain, func) {
          this.good_length = good_length;
          this.max_lazy = max_lazy;
          this.nice_length = nice_length;
          this.max_chain = max_chain;
          this.func = func;
        }
        var configuration_table;
        configuration_table = [
          new Config(0, 0, 0, 0, deflate_stored),
          new Config(4, 4, 8, 4, deflate_fast),
          new Config(4, 5, 16, 8, deflate_fast),
          new Config(4, 6, 32, 32, deflate_fast),
          new Config(4, 4, 16, 16, deflate_slow),
          new Config(8, 16, 32, 32, deflate_slow),
          new Config(8, 16, 128, 128, deflate_slow),
          new Config(8, 32, 128, 256, deflate_slow),
          new Config(32, 128, 258, 1024, deflate_slow),
          new Config(32, 258, 258, 4096, deflate_slow)
        ];
        function lm_init(s) {
          s.window_size = 2 * s.w_size;
          zero(s.head);
          s.max_lazy_match = configuration_table[s.level].max_lazy;
          s.good_match = configuration_table[s.level].good_length;
          s.nice_match = configuration_table[s.level].nice_length;
          s.max_chain_length = configuration_table[s.level].max_chain;
          s.strstart = 0;
          s.block_start = 0;
          s.lookahead = 0;
          s.insert = 0;
          s.match_length = s.prev_length = MIN_MATCH - 1;
          s.match_available = 0;
          s.ins_h = 0;
        }
        function DeflateState() {
          this.strm = null;
          this.status = 0;
          this.pending_buf = null;
          this.pending_buf_size = 0;
          this.pending_out = 0;
          this.pending = 0;
          this.wrap = 0;
          this.gzhead = null;
          this.gzindex = 0;
          this.method = Z_DEFLATED;
          this.last_flush = -1;
          this.w_size = 0;
          this.w_bits = 0;
          this.w_mask = 0;
          this.window = null;
          this.window_size = 0;
          this.prev = null;
          this.head = null;
          this.ins_h = 0;
          this.hash_size = 0;
          this.hash_bits = 0;
          this.hash_mask = 0;
          this.hash_shift = 0;
          this.block_start = 0;
          this.match_length = 0;
          this.prev_match = 0;
          this.match_available = 0;
          this.strstart = 0;
          this.match_start = 0;
          this.lookahead = 0;
          this.prev_length = 0;
          this.max_chain_length = 0;
          this.max_lazy_match = 0;
          this.level = 0;
          this.strategy = 0;
          this.good_match = 0;
          this.nice_match = 0;
          this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
          this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
          this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
          zero(this.dyn_ltree);
          zero(this.dyn_dtree);
          zero(this.bl_tree);
          this.l_desc = null;
          this.d_desc = null;
          this.bl_desc = null;
          this.bl_count = new utils.Buf16(MAX_BITS + 1);
          this.heap = new utils.Buf16(2 * L_CODES + 1);
          zero(this.heap);
          this.heap_len = 0;
          this.heap_max = 0;
          this.depth = new utils.Buf16(2 * L_CODES + 1);
          zero(this.depth);
          this.l_buf = 0;
          this.lit_bufsize = 0;
          this.last_lit = 0;
          this.d_buf = 0;
          this.opt_len = 0;
          this.static_len = 0;
          this.matches = 0;
          this.insert = 0;
          this.bi_buf = 0;
          this.bi_valid = 0;
        }
        function deflateResetKeep(strm) {
          var s;
          if (!strm || !strm.state) {
            return err(strm, Z_STREAM_ERROR);
          }
          strm.total_in = strm.total_out = 0;
          strm.data_type = Z_UNKNOWN;
          s = strm.state;
          s.pending = 0;
          s.pending_out = 0;
          if (s.wrap < 0) {
            s.wrap = -s.wrap;
          }
          s.status = s.wrap ? INIT_STATE : BUSY_STATE;
          strm.adler = s.wrap === 2 ? 0 : 1;
          s.last_flush = Z_NO_FLUSH;
          trees._tr_init(s);
          return Z_OK;
        }
        function deflateReset(strm) {
          var ret = deflateResetKeep(strm);
          if (ret === Z_OK) {
            lm_init(strm.state);
          }
          return ret;
        }
        function deflateSetHeader(strm, head) {
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          if (strm.state.wrap !== 2) {
            return Z_STREAM_ERROR;
          }
          strm.state.gzhead = head;
          return Z_OK;
        }
        function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
          if (!strm) {
            return Z_STREAM_ERROR;
          }
          var wrap2 = 1;
          if (level === Z_DEFAULT_COMPRESSION) {
            level = 6;
          }
          if (windowBits < 0) {
            wrap2 = 0;
            windowBits = -windowBits;
          } else if (windowBits > 15) {
            wrap2 = 2;
            windowBits -= 16;
          }
          if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
            return err(strm, Z_STREAM_ERROR);
          }
          if (windowBits === 8) {
            windowBits = 9;
          }
          var s = new DeflateState();
          strm.state = s;
          s.strm = strm;
          s.wrap = wrap2;
          s.gzhead = null;
          s.w_bits = windowBits;
          s.w_size = 1 << s.w_bits;
          s.w_mask = s.w_size - 1;
          s.hash_bits = memLevel + 7;
          s.hash_size = 1 << s.hash_bits;
          s.hash_mask = s.hash_size - 1;
          s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
          s.window = new utils.Buf8(s.w_size * 2);
          s.head = new utils.Buf16(s.hash_size);
          s.prev = new utils.Buf16(s.w_size);
          s.lit_bufsize = 1 << memLevel + 6;
          s.pending_buf_size = s.lit_bufsize * 4;
          s.pending_buf = new utils.Buf8(s.pending_buf_size);
          s.d_buf = 1 * s.lit_bufsize;
          s.l_buf = (1 + 2) * s.lit_bufsize;
          s.level = level;
          s.strategy = strategy;
          s.method = method;
          return deflateReset(strm);
        }
        function deflateInit(strm, level) {
          return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
        }
        function deflate(strm, flush) {
          var old_flush, s;
          var beg, val2;
          if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
            return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
          }
          s = strm.state;
          if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
            return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
          }
          s.strm = strm;
          old_flush = s.last_flush;
          s.last_flush = flush;
          if (s.status === INIT_STATE) {
            if (s.wrap === 2) {
              strm.adler = 0;
              put_byte(s, 31);
              put_byte(s, 139);
              put_byte(s, 8);
              if (!s.gzhead) {
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                put_byte(s, OS_CODE);
                s.status = BUSY_STATE;
              } else {
                put_byte(
                  s,
                  (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
                );
                put_byte(s, s.gzhead.time & 255);
                put_byte(s, s.gzhead.time >> 8 & 255);
                put_byte(s, s.gzhead.time >> 16 & 255);
                put_byte(s, s.gzhead.time >> 24 & 255);
                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                put_byte(s, s.gzhead.os & 255);
                if (s.gzhead.extra && s.gzhead.extra.length) {
                  put_byte(s, s.gzhead.extra.length & 255);
                  put_byte(s, s.gzhead.extra.length >> 8 & 255);
                }
                if (s.gzhead.hcrc) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
                }
                s.gzindex = 0;
                s.status = EXTRA_STATE;
              }
            } else {
              var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
              var level_flags = -1;
              if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                level_flags = 0;
              } else if (s.level < 6) {
                level_flags = 1;
              } else if (s.level === 6) {
                level_flags = 2;
              } else {
                level_flags = 3;
              }
              header |= level_flags << 6;
              if (s.strstart !== 0) {
                header |= PRESET_DICT;
              }
              header += 31 - header % 31;
              s.status = BUSY_STATE;
              putShortMSB(s, header);
              if (s.strstart !== 0) {
                putShortMSB(s, strm.adler >>> 16);
                putShortMSB(s, strm.adler & 65535);
              }
              strm.adler = 1;
            }
          }
          if (s.status === EXTRA_STATE) {
            if (s.gzhead.extra) {
              beg = s.pending;
              while (s.gzindex < (s.gzhead.extra.length & 65535)) {
                if (s.pending === s.pending_buf_size) {
                  if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                  }
                  flush_pending(strm);
                  beg = s.pending;
                  if (s.pending === s.pending_buf_size) {
                    break;
                  }
                }
                put_byte(s, s.gzhead.extra[s.gzindex] & 255);
                s.gzindex++;
              }
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              if (s.gzindex === s.gzhead.extra.length) {
                s.gzindex = 0;
                s.status = NAME_STATE;
              }
            } else {
              s.status = NAME_STATE;
            }
          }
          if (s.status === NAME_STATE) {
            if (s.gzhead.name) {
              beg = s.pending;
              do {
                if (s.pending === s.pending_buf_size) {
                  if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                  }
                  flush_pending(strm);
                  beg = s.pending;
                  if (s.pending === s.pending_buf_size) {
                    val2 = 1;
                    break;
                  }
                }
                if (s.gzindex < s.gzhead.name.length) {
                  val2 = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
                } else {
                  val2 = 0;
                }
                put_byte(s, val2);
              } while (val2 !== 0);
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              if (val2 === 0) {
                s.gzindex = 0;
                s.status = COMMENT_STATE;
              }
            } else {
              s.status = COMMENT_STATE;
            }
          }
          if (s.status === COMMENT_STATE) {
            if (s.gzhead.comment) {
              beg = s.pending;
              do {
                if (s.pending === s.pending_buf_size) {
                  if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                  }
                  flush_pending(strm);
                  beg = s.pending;
                  if (s.pending === s.pending_buf_size) {
                    val2 = 1;
                    break;
                  }
                }
                if (s.gzindex < s.gzhead.comment.length) {
                  val2 = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
                } else {
                  val2 = 0;
                }
                put_byte(s, val2);
              } while (val2 !== 0);
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              if (val2 === 0) {
                s.status = HCRC_STATE;
              }
            } else {
              s.status = HCRC_STATE;
            }
          }
          if (s.status === HCRC_STATE) {
            if (s.gzhead.hcrc) {
              if (s.pending + 2 > s.pending_buf_size) {
                flush_pending(strm);
              }
              if (s.pending + 2 <= s.pending_buf_size) {
                put_byte(s, strm.adler & 255);
                put_byte(s, strm.adler >> 8 & 255);
                strm.adler = 0;
                s.status = BUSY_STATE;
              }
            } else {
              s.status = BUSY_STATE;
            }
          }
          if (s.pending !== 0) {
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
            return err(strm, Z_BUF_ERROR);
          }
          if (s.status === FINISH_STATE && strm.avail_in !== 0) {
            return err(strm, Z_BUF_ERROR);
          }
          if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
            var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
            if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
              s.status = FINISH_STATE;
            }
            if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
              if (strm.avail_out === 0) {
                s.last_flush = -1;
              }
              return Z_OK;
            }
            if (bstate === BS_BLOCK_DONE) {
              if (flush === Z_PARTIAL_FLUSH) {
                trees._tr_align(s);
              } else if (flush !== Z_BLOCK) {
                trees._tr_stored_block(s, 0, 0, false);
                if (flush === Z_FULL_FLUSH) {
                  zero(s.head);
                  if (s.lookahead === 0) {
                    s.strstart = 0;
                    s.block_start = 0;
                    s.insert = 0;
                  }
                }
              }
              flush_pending(strm);
              if (strm.avail_out === 0) {
                s.last_flush = -1;
                return Z_OK;
              }
            }
          }
          if (flush !== Z_FINISH) {
            return Z_OK;
          }
          if (s.wrap <= 0) {
            return Z_STREAM_END;
          }
          if (s.wrap === 2) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            put_byte(s, strm.adler >> 16 & 255);
            put_byte(s, strm.adler >> 24 & 255);
            put_byte(s, strm.total_in & 255);
            put_byte(s, strm.total_in >> 8 & 255);
            put_byte(s, strm.total_in >> 16 & 255);
            put_byte(s, strm.total_in >> 24 & 255);
          } else {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          flush_pending(strm);
          if (s.wrap > 0) {
            s.wrap = -s.wrap;
          }
          return s.pending !== 0 ? Z_OK : Z_STREAM_END;
        }
        function deflateEnd(strm) {
          var status;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          status = strm.state.status;
          if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
            return err(strm, Z_STREAM_ERROR);
          }
          strm.state = null;
          return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
        }
        function deflateSetDictionary(strm, dictionary) {
          var dictLength = dictionary.length;
          var s;
          var str, n;
          var wrap2;
          var avail;
          var next2;
          var input;
          var tmpDict;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          s = strm.state;
          wrap2 = s.wrap;
          if (wrap2 === 2 || wrap2 === 1 && s.status !== INIT_STATE || s.lookahead) {
            return Z_STREAM_ERROR;
          }
          if (wrap2 === 1) {
            strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
          }
          s.wrap = 0;
          if (dictLength >= s.w_size) {
            if (wrap2 === 0) {
              zero(s.head);
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
            tmpDict = new utils.Buf8(s.w_size);
            utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
            dictionary = tmpDict;
            dictLength = s.w_size;
          }
          avail = strm.avail_in;
          next2 = strm.next_in;
          input = strm.input;
          strm.avail_in = dictLength;
          strm.next_in = 0;
          strm.input = dictionary;
          fill_window(s);
          while (s.lookahead >= MIN_MATCH) {
            str = s.strstart;
            n = s.lookahead - (MIN_MATCH - 1);
            do {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
              s.prev[str & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = str;
              str++;
            } while (--n);
            s.strstart = str;
            s.lookahead = MIN_MATCH - 1;
            fill_window(s);
          }
          s.strstart += s.lookahead;
          s.block_start = s.strstart;
          s.insert = s.lookahead;
          s.lookahead = 0;
          s.match_length = s.prev_length = MIN_MATCH - 1;
          s.match_available = 0;
          strm.next_in = next2;
          strm.input = input;
          strm.avail_in = avail;
          s.wrap = wrap2;
          return Z_OK;
        }
        exports3.deflateInit = deflateInit;
        exports3.deflateInit2 = deflateInit2;
        exports3.deflateReset = deflateReset;
        exports3.deflateResetKeep = deflateResetKeep;
        exports3.deflateSetHeader = deflateSetHeader;
        exports3.deflate = deflate;
        exports3.deflateEnd = deflateEnd;
        exports3.deflateSetDictionary = deflateSetDictionary;
        exports3.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 5, "./adler32": 7, "./crc32": 8, "./messages": 10, "./trees": 11 }], 10: [function(require2, module4, exports3) {
        "use strict";
        module4.exports = {
          2: "need dictionary",
          1: "stream end",
          0: "",
          "-1": "file error",
          "-2": "stream error",
          "-3": "data error",
          "-4": "insufficient memory",
          "-5": "buffer error",
          "-6": "incompatible version"
        };
      }, {}], 11: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("../utils/common");
        var Z_FIXED = 4;
        var Z_BINARY = 0;
        var Z_TEXT = 1;
        var Z_UNKNOWN = 2;
        function zero(buf) {
          var len = buf.length;
          while (--len >= 0) {
            buf[len] = 0;
          }
        }
        var STORED_BLOCK = 0;
        var STATIC_TREES = 1;
        var DYN_TREES = 2;
        var MIN_MATCH = 3;
        var MAX_MATCH = 258;
        var LENGTH_CODES = 29;
        var LITERALS = 256;
        var L_CODES = LITERALS + 1 + LENGTH_CODES;
        var D_CODES = 30;
        var BL_CODES = 19;
        var HEAP_SIZE = 2 * L_CODES + 1;
        var MAX_BITS = 15;
        var Buf_size = 16;
        var MAX_BL_BITS = 7;
        var END_BLOCK = 256;
        var REP_3_6 = 16;
        var REPZ_3_10 = 17;
        var REPZ_11_138 = 18;
        var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
        var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
        var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
        var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        var DIST_CODE_LEN = 512;
        var static_ltree = new Array((L_CODES + 2) * 2);
        zero(static_ltree);
        var static_dtree = new Array(D_CODES * 2);
        zero(static_dtree);
        var _dist_code = new Array(DIST_CODE_LEN);
        zero(_dist_code);
        var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
        zero(_length_code);
        var base_length = new Array(LENGTH_CODES);
        zero(base_length);
        var base_dist = new Array(D_CODES);
        zero(base_dist);
        function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
          this.static_tree = static_tree;
          this.extra_bits = extra_bits;
          this.extra_base = extra_base;
          this.elems = elems;
          this.max_length = max_length;
          this.has_stree = static_tree && static_tree.length;
        }
        var static_l_desc;
        var static_d_desc;
        var static_bl_desc;
        function TreeDesc(dyn_tree, stat_desc) {
          this.dyn_tree = dyn_tree;
          this.max_code = 0;
          this.stat_desc = stat_desc;
        }
        function d_code(dist) {
          return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
        }
        function put_short(s, w) {
          s.pending_buf[s.pending++] = w & 255;
          s.pending_buf[s.pending++] = w >>> 8 & 255;
        }
        function send_bits(s, value, length) {
          if (s.bi_valid > Buf_size - length) {
            s.bi_buf |= value << s.bi_valid & 65535;
            put_short(s, s.bi_buf);
            s.bi_buf = value >> Buf_size - s.bi_valid;
            s.bi_valid += length - Buf_size;
          } else {
            s.bi_buf |= value << s.bi_valid & 65535;
            s.bi_valid += length;
          }
        }
        function send_code(s, c, tree) {
          send_bits(s, tree[c * 2], tree[c * 2 + 1]);
        }
        function bi_reverse(code2, len) {
          var res = 0;
          do {
            res |= code2 & 1;
            code2 >>>= 1;
            res <<= 1;
          } while (--len > 0);
          return res >>> 1;
        }
        function bi_flush(s) {
          if (s.bi_valid === 16) {
            put_short(s, s.bi_buf);
            s.bi_buf = 0;
            s.bi_valid = 0;
          } else if (s.bi_valid >= 8) {
            s.pending_buf[s.pending++] = s.bi_buf & 255;
            s.bi_buf >>= 8;
            s.bi_valid -= 8;
          }
        }
        function gen_bitlen(s, desc) {
          var tree = desc.dyn_tree;
          var max_code = desc.max_code;
          var stree = desc.stat_desc.static_tree;
          var has_stree = desc.stat_desc.has_stree;
          var extra = desc.stat_desc.extra_bits;
          var base2 = desc.stat_desc.extra_base;
          var max_length = desc.stat_desc.max_length;
          var h2;
          var n, m;
          var bits;
          var xbits;
          var f;
          var overflow = 0;
          for (bits = 0; bits <= MAX_BITS; bits++) {
            s.bl_count[bits] = 0;
          }
          tree[s.heap[s.heap_max] * 2 + 1] = 0;
          for (h2 = s.heap_max + 1; h2 < HEAP_SIZE; h2++) {
            n = s.heap[h2];
            bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
            if (bits > max_length) {
              bits = max_length;
              overflow++;
            }
            tree[n * 2 + 1] = bits;
            if (n > max_code) {
              continue;
            }
            s.bl_count[bits]++;
            xbits = 0;
            if (n >= base2) {
              xbits = extra[n - base2];
            }
            f = tree[n * 2];
            s.opt_len += f * (bits + xbits);
            if (has_stree) {
              s.static_len += f * (stree[n * 2 + 1] + xbits);
            }
          }
          if (overflow === 0) {
            return;
          }
          do {
            bits = max_length - 1;
            while (s.bl_count[bits] === 0) {
              bits--;
            }
            s.bl_count[bits]--;
            s.bl_count[bits + 1] += 2;
            s.bl_count[max_length]--;
            overflow -= 2;
          } while (overflow > 0);
          for (bits = max_length; bits !== 0; bits--) {
            n = s.bl_count[bits];
            while (n !== 0) {
              m = s.heap[--h2];
              if (m > max_code) {
                continue;
              }
              if (tree[m * 2 + 1] !== bits) {
                s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                tree[m * 2 + 1] = bits;
              }
              n--;
            }
          }
        }
        function gen_codes(tree, max_code, bl_count) {
          var next_code = new Array(MAX_BITS + 1);
          var code2 = 0;
          var bits;
          var n;
          for (bits = 1; bits <= MAX_BITS; bits++) {
            next_code[bits] = code2 = code2 + bl_count[bits - 1] << 1;
          }
          for (n = 0; n <= max_code; n++) {
            var len = tree[n * 2 + 1];
            if (len === 0) {
              continue;
            }
            tree[n * 2] = bi_reverse(next_code[len]++, len);
          }
        }
        function tr_static_init() {
          var n;
          var bits;
          var length;
          var code2;
          var dist;
          var bl_count = new Array(MAX_BITS + 1);
          length = 0;
          for (code2 = 0; code2 < LENGTH_CODES - 1; code2++) {
            base_length[code2] = length;
            for (n = 0; n < 1 << extra_lbits[code2]; n++) {
              _length_code[length++] = code2;
            }
          }
          _length_code[length - 1] = code2;
          dist = 0;
          for (code2 = 0; code2 < 16; code2++) {
            base_dist[code2] = dist;
            for (n = 0; n < 1 << extra_dbits[code2]; n++) {
              _dist_code[dist++] = code2;
            }
          }
          dist >>= 7;
          for (; code2 < D_CODES; code2++) {
            base_dist[code2] = dist << 7;
            for (n = 0; n < 1 << extra_dbits[code2] - 7; n++) {
              _dist_code[256 + dist++] = code2;
            }
          }
          for (bits = 0; bits <= MAX_BITS; bits++) {
            bl_count[bits] = 0;
          }
          n = 0;
          while (n <= 143) {
            static_ltree[n * 2 + 1] = 8;
            n++;
            bl_count[8]++;
          }
          while (n <= 255) {
            static_ltree[n * 2 + 1] = 9;
            n++;
            bl_count[9]++;
          }
          while (n <= 279) {
            static_ltree[n * 2 + 1] = 7;
            n++;
            bl_count[7]++;
          }
          while (n <= 287) {
            static_ltree[n * 2 + 1] = 8;
            n++;
            bl_count[8]++;
          }
          gen_codes(static_ltree, L_CODES + 1, bl_count);
          for (n = 0; n < D_CODES; n++) {
            static_dtree[n * 2 + 1] = 5;
            static_dtree[n * 2] = bi_reverse(n, 5);
          }
          static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
          static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
          static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
        }
        function init_block(s) {
          var n;
          for (n = 0; n < L_CODES; n++) {
            s.dyn_ltree[n * 2] = 0;
          }
          for (n = 0; n < D_CODES; n++) {
            s.dyn_dtree[n * 2] = 0;
          }
          for (n = 0; n < BL_CODES; n++) {
            s.bl_tree[n * 2] = 0;
          }
          s.dyn_ltree[END_BLOCK * 2] = 1;
          s.opt_len = s.static_len = 0;
          s.last_lit = s.matches = 0;
        }
        function bi_windup(s) {
          if (s.bi_valid > 8) {
            put_short(s, s.bi_buf);
          } else if (s.bi_valid > 0) {
            s.pending_buf[s.pending++] = s.bi_buf;
          }
          s.bi_buf = 0;
          s.bi_valid = 0;
        }
        function copy_block(s, buf, len, header) {
          bi_windup(s);
          if (header) {
            put_short(s, len);
            put_short(s, ~len);
          }
          utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
          s.pending += len;
        }
        function smaller(tree, n, m, depth) {
          var _n2 = n * 2;
          var _m2 = m * 2;
          return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
        }
        function pqdownheap(s, tree, k) {
          var v = s.heap[k];
          var j = k << 1;
          while (j <= s.heap_len) {
            if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
              j++;
            }
            if (smaller(tree, v, s.heap[j], s.depth)) {
              break;
            }
            s.heap[k] = s.heap[j];
            k = j;
            j <<= 1;
          }
          s.heap[k] = v;
        }
        function compress_block(s, ltree, dtree) {
          var dist;
          var lc;
          var lx = 0;
          var code2;
          var extra;
          if (s.last_lit !== 0) {
            do {
              dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
              lc = s.pending_buf[s.l_buf + lx];
              lx++;
              if (dist === 0) {
                send_code(s, lc, ltree);
              } else {
                code2 = _length_code[lc];
                send_code(s, code2 + LITERALS + 1, ltree);
                extra = extra_lbits[code2];
                if (extra !== 0) {
                  lc -= base_length[code2];
                  send_bits(s, lc, extra);
                }
                dist--;
                code2 = d_code(dist);
                send_code(s, code2, dtree);
                extra = extra_dbits[code2];
                if (extra !== 0) {
                  dist -= base_dist[code2];
                  send_bits(s, dist, extra);
                }
              }
            } while (lx < s.last_lit);
          }
          send_code(s, END_BLOCK, ltree);
        }
        function build_tree(s, desc) {
          var tree = desc.dyn_tree;
          var stree = desc.stat_desc.static_tree;
          var has_stree = desc.stat_desc.has_stree;
          var elems = desc.stat_desc.elems;
          var n, m;
          var max_code = -1;
          var node;
          s.heap_len = 0;
          s.heap_max = HEAP_SIZE;
          for (n = 0; n < elems; n++) {
            if (tree[n * 2] !== 0) {
              s.heap[++s.heap_len] = max_code = n;
              s.depth[n] = 0;
            } else {
              tree[n * 2 + 1] = 0;
            }
          }
          while (s.heap_len < 2) {
            node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
            tree[node * 2] = 1;
            s.depth[node] = 0;
            s.opt_len--;
            if (has_stree) {
              s.static_len -= stree[node * 2 + 1];
            }
          }
          desc.max_code = max_code;
          for (n = s.heap_len >> 1; n >= 1; n--) {
            pqdownheap(s, tree, n);
          }
          node = elems;
          do {
            n = s.heap[1];
            s.heap[1] = s.heap[s.heap_len--];
            pqdownheap(s, tree, 1);
            m = s.heap[1];
            s.heap[--s.heap_max] = n;
            s.heap[--s.heap_max] = m;
            tree[node * 2] = tree[n * 2] + tree[m * 2];
            s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
            tree[n * 2 + 1] = tree[m * 2 + 1] = node;
            s.heap[1] = node++;
            pqdownheap(s, tree, 1);
          } while (s.heap_len >= 2);
          s.heap[--s.heap_max] = s.heap[1];
          gen_bitlen(s, desc);
          gen_codes(tree, max_code, s.bl_count);
        }
        function scan_tree(s, tree, max_code) {
          var n;
          var prevlen = -1;
          var curlen;
          var nextlen = tree[0 * 2 + 1];
          var count = 0;
          var max_count = 7;
          var min_count = 4;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          }
          tree[(max_code + 1) * 2 + 1] = 65535;
          for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
              continue;
            } else if (count < min_count) {
              s.bl_tree[curlen * 2] += count;
            } else if (curlen !== 0) {
              if (curlen !== prevlen) {
                s.bl_tree[curlen * 2]++;
              }
              s.bl_tree[REP_3_6 * 2]++;
            } else if (count <= 10) {
              s.bl_tree[REPZ_3_10 * 2]++;
            } else {
              s.bl_tree[REPZ_11_138 * 2]++;
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
              max_count = 138;
              min_count = 3;
            } else if (curlen === nextlen) {
              max_count = 6;
              min_count = 3;
            } else {
              max_count = 7;
              min_count = 4;
            }
          }
        }
        function send_tree(s, tree, max_code) {
          var n;
          var prevlen = -1;
          var curlen;
          var nextlen = tree[0 * 2 + 1];
          var count = 0;
          var max_count = 7;
          var min_count = 4;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          }
          for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
              continue;
            } else if (count < min_count) {
              do {
                send_code(s, curlen, s.bl_tree);
              } while (--count !== 0);
            } else if (curlen !== 0) {
              if (curlen !== prevlen) {
                send_code(s, curlen, s.bl_tree);
                count--;
              }
              send_code(s, REP_3_6, s.bl_tree);
              send_bits(s, count - 3, 2);
            } else if (count <= 10) {
              send_code(s, REPZ_3_10, s.bl_tree);
              send_bits(s, count - 3, 3);
            } else {
              send_code(s, REPZ_11_138, s.bl_tree);
              send_bits(s, count - 11, 7);
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
              max_count = 138;
              min_count = 3;
            } else if (curlen === nextlen) {
              max_count = 6;
              min_count = 3;
            } else {
              max_count = 7;
              min_count = 4;
            }
          }
        }
        function build_bl_tree(s) {
          var max_blindex;
          scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
          scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
          build_tree(s, s.bl_desc);
          for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
            if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
              break;
            }
          }
          s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
          return max_blindex;
        }
        function send_all_trees(s, lcodes, dcodes, blcodes) {
          var rank;
          send_bits(s, lcodes - 257, 5);
          send_bits(s, dcodes - 1, 5);
          send_bits(s, blcodes - 4, 4);
          for (rank = 0; rank < blcodes; rank++) {
            send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
          }
          send_tree(s, s.dyn_ltree, lcodes - 1);
          send_tree(s, s.dyn_dtree, dcodes - 1);
        }
        function detect_data_type(s) {
          var black_mask = 4093624447;
          var n;
          for (n = 0; n <= 31; n++, black_mask >>>= 1) {
            if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
              return Z_BINARY;
            }
          }
          if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
            return Z_TEXT;
          }
          for (n = 32; n < LITERALS; n++) {
            if (s.dyn_ltree[n * 2] !== 0) {
              return Z_TEXT;
            }
          }
          return Z_BINARY;
        }
        var static_init_done = false;
        function _tr_init(s) {
          if (!static_init_done) {
            tr_static_init();
            static_init_done = true;
          }
          s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
          s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
          s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
          s.bi_buf = 0;
          s.bi_valid = 0;
          init_block(s);
        }
        function _tr_stored_block(s, buf, stored_len, last2) {
          send_bits(s, (STORED_BLOCK << 1) + (last2 ? 1 : 0), 3);
          copy_block(s, buf, stored_len, true);
        }
        function _tr_align(s) {
          send_bits(s, STATIC_TREES << 1, 3);
          send_code(s, END_BLOCK, static_ltree);
          bi_flush(s);
        }
        function _tr_flush_block(s, buf, stored_len, last2) {
          var opt_lenb, static_lenb;
          var max_blindex = 0;
          if (s.level > 0) {
            if (s.strm.data_type === Z_UNKNOWN) {
              s.strm.data_type = detect_data_type(s);
            }
            build_tree(s, s.l_desc);
            build_tree(s, s.d_desc);
            max_blindex = build_bl_tree(s);
            opt_lenb = s.opt_len + 3 + 7 >>> 3;
            static_lenb = s.static_len + 3 + 7 >>> 3;
            if (static_lenb <= opt_lenb) {
              opt_lenb = static_lenb;
            }
          } else {
            opt_lenb = static_lenb = stored_len + 5;
          }
          if (stored_len + 4 <= opt_lenb && buf !== -1) {
            _tr_stored_block(s, buf, stored_len, last2);
          } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
            send_bits(s, (STATIC_TREES << 1) + (last2 ? 1 : 0), 3);
            compress_block(s, static_ltree, static_dtree);
          } else {
            send_bits(s, (DYN_TREES << 1) + (last2 ? 1 : 0), 3);
            send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
            compress_block(s, s.dyn_ltree, s.dyn_dtree);
          }
          init_block(s);
          if (last2) {
            bi_windup(s);
          }
        }
        function _tr_tally(s, dist, lc) {
          s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
          s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
          s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
          s.last_lit++;
          if (dist === 0) {
            s.dyn_ltree[lc * 2]++;
          } else {
            s.matches++;
            dist--;
            s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
            s.dyn_dtree[d_code(dist) * 2]++;
          }
          return s.last_lit === s.lit_bufsize - 1;
        }
        exports3._tr_init = _tr_init;
        exports3._tr_stored_block = _tr_stored_block;
        exports3._tr_flush_block = _tr_flush_block;
        exports3._tr_tally = _tr_tally;
        exports3._tr_align = _tr_align;
      }, { "../utils/common": 5 }], 12: [function(require2, module4, exports3) {
        "use strict";
        function ZStream() {
          this.input = null;
          this.next_in = 0;
          this.avail_in = 0;
          this.total_in = 0;
          this.output = null;
          this.next_out = 0;
          this.avail_out = 0;
          this.total_out = 0;
          this.msg = "";
          this.state = null;
          this.data_type = 2;
          this.adler = 0;
        }
        module4.exports = ZStream;
      }, {}] }, {}, [3])(3);
    });
  }
});

// ../../node_modules/.pnpm/plantuml-encoder@1.4.0/node_modules/plantuml-encoder/dist/plantuml-decoder.js
var require_plantuml_decoder = __commonJS({
  "../../node_modules/.pnpm/plantuml-encoder@1.4.0/node_modules/plantuml-encoder/dist/plantuml-decoder.js"(exports, module2) {
    (function(f) {
      if (typeof exports === "object" && typeof module2 !== "undefined") {
        module2.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.plantumlEncoder = f();
      }
    })(function() {
      var define2, module3, exports2;
      return function() {
        function r(e, n, t2) {
          function o(i2, f) {
            if (!n[i2]) {
              if (!e[i2]) {
                var c = "function" == typeof require && require;
                if (!f && c)
                  return c(i2, true);
                if (u)
                  return u(i2, true);
                var a = new Error("Cannot find module '" + i2 + "'");
                throw a.code = "MODULE_NOT_FOUND", a;
              }
              var p = n[i2] = { exports: {} };
              e[i2][0].call(p.exports, function(r2) {
                var n2 = e[i2][1][r2];
                return o(n2 || r2);
              }, p, p.exports, r, e, n, t2);
            }
            return n[i2].exports;
          }
          for (var u = "function" == typeof require && require, i = 0; i < t2.length; i++)
            o(t2[i]);
          return o;
        }
        return r;
      }()({ 1: [function(require2, module4, exports3) {
        "use strict";
        var pako = require2("pako/lib/inflate.js");
        module4.exports = function(data2) {
          return pako.inflateRaw(data2, { to: "string" });
        };
      }, { "pako/lib/inflate.js": 4 }], 2: [function(require2, module4, exports3) {
        "use strict";
        function decode6bit(cc) {
          var c = cc.charCodeAt(0);
          if (cc === "_")
            return 63;
          if (cc === "-")
            return 62;
          if (c >= 97)
            return c - 61;
          if (c >= 65)
            return c - 55;
          if (c >= 48)
            return c - 48;
          return "?";
        }
        function extract3bytes(data2) {
          var c1 = decode6bit(data2[0]);
          var c2 = decode6bit(data2[1]);
          var c3 = decode6bit(data2[2]);
          var c4 = decode6bit(data2[3]);
          var b1 = c1 << 2 | c2 >> 4 & 63;
          var b2 = c2 << 4 & 240 | c3 >> 2 & 15;
          var b3 = c3 << 6 & 192 | c4 & 63;
          return [b1, b2, b3];
        }
        module4.exports = function(data2) {
          var r = "";
          var i = 0;
          for (i = 0; i < data2.length; i += 4) {
            var t2 = extract3bytes(data2.substring(i, i + 4));
            r = r + String.fromCharCode(t2[0]);
            r = r + String.fromCharCode(t2[1]);
            r = r + String.fromCharCode(t2[2]);
          }
          return r;
        };
      }, {}], 3: [function(require2, module4, exports3) {
        "use strict";
        var inflate = require2("./inflate");
        var decode64 = require2("./decode64");
        module4.exports.decode = function(encoded) {
          var deflated = decode64(encoded);
          return inflate(deflated);
        };
      }, { "./decode64": 2, "./inflate": 1 }], 4: [function(require2, module4, exports3) {
        "use strict";
        var zlib_inflate = require2("./zlib/inflate");
        var utils = require2("./utils/common");
        var strings = require2("./utils/strings");
        var c = require2("./zlib/constants");
        var msg = require2("./zlib/messages");
        var ZStream = require2("./zlib/zstream");
        var GZheader = require2("./zlib/gzheader");
        var toString2 = Object.prototype.toString;
        function Inflate(options) {
          if (!(this instanceof Inflate))
            return new Inflate(options);
          this.options = utils.assign({
            chunkSize: 16384,
            windowBits: 0,
            to: ""
          }, options || {});
          var opt = this.options;
          if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
            opt.windowBits = -opt.windowBits;
            if (opt.windowBits === 0) {
              opt.windowBits = -15;
            }
          }
          if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
            opt.windowBits += 32;
          }
          if (opt.windowBits > 15 && opt.windowBits < 48) {
            if ((opt.windowBits & 15) === 0) {
              opt.windowBits |= 15;
            }
          }
          this.err = 0;
          this.msg = "";
          this.ended = false;
          this.chunks = [];
          this.strm = new ZStream();
          this.strm.avail_out = 0;
          var status = zlib_inflate.inflateInit2(
            this.strm,
            opt.windowBits
          );
          if (status !== c.Z_OK) {
            throw new Error(msg[status]);
          }
          this.header = new GZheader();
          zlib_inflate.inflateGetHeader(this.strm, this.header);
          if (opt.dictionary) {
            if (typeof opt.dictionary === "string") {
              opt.dictionary = strings.string2buf(opt.dictionary);
            } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
              opt.dictionary = new Uint8Array(opt.dictionary);
            }
            if (opt.raw) {
              status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
              if (status !== c.Z_OK) {
                throw new Error(msg[status]);
              }
            }
          }
        }
        Inflate.prototype.push = function(data2, mode) {
          var strm = this.strm;
          var chunkSize = this.options.chunkSize;
          var dictionary = this.options.dictionary;
          var status, _mode;
          var next_out_utf8, tail, utf8str;
          var allowBufError = false;
          if (this.ended) {
            return false;
          }
          _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
          if (typeof data2 === "string") {
            strm.input = strings.binstring2buf(data2);
          } else if (toString2.call(data2) === "[object ArrayBuffer]") {
            strm.input = new Uint8Array(data2);
          } else {
            strm.input = data2;
          }
          strm.next_in = 0;
          strm.avail_in = strm.input.length;
          do {
            if (strm.avail_out === 0) {
              strm.output = new utils.Buf8(chunkSize);
              strm.next_out = 0;
              strm.avail_out = chunkSize;
            }
            status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
            if (status === c.Z_NEED_DICT && dictionary) {
              status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
            }
            if (status === c.Z_BUF_ERROR && allowBufError === true) {
              status = c.Z_OK;
              allowBufError = false;
            }
            if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
              this.onEnd(status);
              this.ended = true;
              return false;
            }
            if (strm.next_out) {
              if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
                if (this.options.to === "string") {
                  next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                  tail = strm.next_out - next_out_utf8;
                  utf8str = strings.buf2string(strm.output, next_out_utf8);
                  strm.next_out = tail;
                  strm.avail_out = chunkSize - tail;
                  if (tail) {
                    utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
                  }
                  this.onData(utf8str);
                } else {
                  this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                }
              }
            }
            if (strm.avail_in === 0 && strm.avail_out === 0) {
              allowBufError = true;
            }
          } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
          if (status === c.Z_STREAM_END) {
            _mode = c.Z_FINISH;
          }
          if (_mode === c.Z_FINISH) {
            status = zlib_inflate.inflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === c.Z_OK;
          }
          if (_mode === c.Z_SYNC_FLUSH) {
            this.onEnd(c.Z_OK);
            strm.avail_out = 0;
            return true;
          }
          return true;
        };
        Inflate.prototype.onData = function(chunk) {
          this.chunks.push(chunk);
        };
        Inflate.prototype.onEnd = function(status) {
          if (status === c.Z_OK) {
            if (this.options.to === "string") {
              this.result = this.chunks.join("");
            } else {
              this.result = utils.flattenChunks(this.chunks);
            }
          }
          this.chunks = [];
          this.err = status;
          this.msg = this.strm.msg;
        };
        function inflate(input, options) {
          var inflator = new Inflate(options);
          inflator.push(input, true);
          if (inflator.err) {
            throw inflator.msg || msg[inflator.err];
          }
          return inflator.result;
        }
        function inflateRaw(input, options) {
          options = options || {};
          options.raw = true;
          return inflate(input, options);
        }
        exports3.Inflate = Inflate;
        exports3.inflate = inflate;
        exports3.inflateRaw = inflateRaw;
        exports3.ungzip = inflate;
      }, { "./utils/common": 5, "./utils/strings": 6, "./zlib/constants": 8, "./zlib/gzheader": 10, "./zlib/inflate": 12, "./zlib/messages": 14, "./zlib/zstream": 15 }], 5: [function(require2, module4, exports3) {
        "use strict";
        var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
        function _has(obj, key) {
          return Object.prototype.hasOwnProperty.call(obj, key);
        }
        exports3.assign = function(obj) {
          var sources = Array.prototype.slice.call(arguments, 1);
          while (sources.length) {
            var source = sources.shift();
            if (!source) {
              continue;
            }
            if (typeof source !== "object") {
              throw new TypeError(source + "must be non-object");
            }
            for (var p in source) {
              if (_has(source, p)) {
                obj[p] = source[p];
              }
            }
          }
          return obj;
        };
        exports3.shrinkBuf = function(buf, size) {
          if (buf.length === size) {
            return buf;
          }
          if (buf.subarray) {
            return buf.subarray(0, size);
          }
          buf.length = size;
          return buf;
        };
        var fnTyped = {
          arraySet: function(dest, src, src_offs, len, dest_offs) {
            if (src.subarray && dest.subarray) {
              dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
              return;
            }
            for (var i = 0; i < len; i++) {
              dest[dest_offs + i] = src[src_offs + i];
            }
          },
          flattenChunks: function(chunks) {
            var i, l, len, pos, chunk, result;
            len = 0;
            for (i = 0, l = chunks.length; i < l; i++) {
              len += chunks[i].length;
            }
            result = new Uint8Array(len);
            pos = 0;
            for (i = 0, l = chunks.length; i < l; i++) {
              chunk = chunks[i];
              result.set(chunk, pos);
              pos += chunk.length;
            }
            return result;
          }
        };
        var fnUntyped = {
          arraySet: function(dest, src, src_offs, len, dest_offs) {
            for (var i = 0; i < len; i++) {
              dest[dest_offs + i] = src[src_offs + i];
            }
          },
          flattenChunks: function(chunks) {
            return [].concat.apply([], chunks);
          }
        };
        exports3.setTyped = function(on) {
          if (on) {
            exports3.Buf8 = Uint8Array;
            exports3.Buf16 = Uint16Array;
            exports3.Buf32 = Int32Array;
            exports3.assign(exports3, fnTyped);
          } else {
            exports3.Buf8 = Array;
            exports3.Buf16 = Array;
            exports3.Buf32 = Array;
            exports3.assign(exports3, fnUntyped);
          }
        };
        exports3.setTyped(TYPED_OK);
      }, {}], 6: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("./common");
        var STR_APPLY_OK = true;
        var STR_APPLY_UIA_OK = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (__) {
          STR_APPLY_OK = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (__) {
          STR_APPLY_UIA_OK = false;
        }
        var _utf8len = new utils.Buf8(256);
        for (var q = 0; q < 256; q++) {
          _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
        }
        _utf8len[254] = _utf8len[254] = 1;
        exports3.string2buf = function(str) {
          var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
          for (m_pos = 0; m_pos < str_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
              c2 = str.charCodeAt(m_pos + 1);
              if ((c2 & 64512) === 56320) {
                c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                m_pos++;
              }
            }
            buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
          }
          buf = new utils.Buf8(buf_len);
          for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
              c2 = str.charCodeAt(m_pos + 1);
              if ((c2 & 64512) === 56320) {
                c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                m_pos++;
              }
            }
            if (c < 128) {
              buf[i++] = c;
            } else if (c < 2048) {
              buf[i++] = 192 | c >>> 6;
              buf[i++] = 128 | c & 63;
            } else if (c < 65536) {
              buf[i++] = 224 | c >>> 12;
              buf[i++] = 128 | c >>> 6 & 63;
              buf[i++] = 128 | c & 63;
            } else {
              buf[i++] = 240 | c >>> 18;
              buf[i++] = 128 | c >>> 12 & 63;
              buf[i++] = 128 | c >>> 6 & 63;
              buf[i++] = 128 | c & 63;
            }
          }
          return buf;
        };
        function buf2binstring(buf, len) {
          if (len < 65534) {
            if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
              return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
            }
          }
          var result = "";
          for (var i = 0; i < len; i++) {
            result += String.fromCharCode(buf[i]);
          }
          return result;
        }
        exports3.buf2binstring = function(buf) {
          return buf2binstring(buf, buf.length);
        };
        exports3.binstring2buf = function(str) {
          var buf = new utils.Buf8(str.length);
          for (var i = 0, len = buf.length; i < len; i++) {
            buf[i] = str.charCodeAt(i);
          }
          return buf;
        };
        exports3.buf2string = function(buf, max) {
          var i, out, c, c_len;
          var len = max || buf.length;
          var utf16buf = new Array(len * 2);
          for (out = 0, i = 0; i < len; ) {
            c = buf[i++];
            if (c < 128) {
              utf16buf[out++] = c;
              continue;
            }
            c_len = _utf8len[c];
            if (c_len > 4) {
              utf16buf[out++] = 65533;
              i += c_len - 1;
              continue;
            }
            c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
            while (c_len > 1 && i < len) {
              c = c << 6 | buf[i++] & 63;
              c_len--;
            }
            if (c_len > 1) {
              utf16buf[out++] = 65533;
              continue;
            }
            if (c < 65536) {
              utf16buf[out++] = c;
            } else {
              c -= 65536;
              utf16buf[out++] = 55296 | c >> 10 & 1023;
              utf16buf[out++] = 56320 | c & 1023;
            }
          }
          return buf2binstring(utf16buf, out);
        };
        exports3.utf8border = function(buf, max) {
          var pos;
          max = max || buf.length;
          if (max > buf.length) {
            max = buf.length;
          }
          pos = max - 1;
          while (pos >= 0 && (buf[pos] & 192) === 128) {
            pos--;
          }
          if (pos < 0) {
            return max;
          }
          if (pos === 0) {
            return max;
          }
          return pos + _utf8len[buf[pos]] > max ? pos : max;
        };
      }, { "./common": 5 }], 7: [function(require2, module4, exports3) {
        "use strict";
        function adler32(adler, buf, len, pos) {
          var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
          while (len !== 0) {
            n = len > 2e3 ? 2e3 : len;
            len -= n;
            do {
              s1 = s1 + buf[pos++] | 0;
              s2 = s2 + s1 | 0;
            } while (--n);
            s1 %= 65521;
            s2 %= 65521;
          }
          return s1 | s2 << 16 | 0;
        }
        module4.exports = adler32;
      }, {}], 8: [function(require2, module4, exports3) {
        "use strict";
        module4.exports = {
          Z_NO_FLUSH: 0,
          Z_PARTIAL_FLUSH: 1,
          Z_SYNC_FLUSH: 2,
          Z_FULL_FLUSH: 3,
          Z_FINISH: 4,
          Z_BLOCK: 5,
          Z_TREES: 6,
          Z_OK: 0,
          Z_STREAM_END: 1,
          Z_NEED_DICT: 2,
          Z_ERRNO: -1,
          Z_STREAM_ERROR: -2,
          Z_DATA_ERROR: -3,
          Z_BUF_ERROR: -5,
          Z_NO_COMPRESSION: 0,
          Z_BEST_SPEED: 1,
          Z_BEST_COMPRESSION: 9,
          Z_DEFAULT_COMPRESSION: -1,
          Z_FILTERED: 1,
          Z_HUFFMAN_ONLY: 2,
          Z_RLE: 3,
          Z_FIXED: 4,
          Z_DEFAULT_STRATEGY: 0,
          Z_BINARY: 0,
          Z_TEXT: 1,
          Z_UNKNOWN: 2,
          Z_DEFLATED: 8
        };
      }, {}], 9: [function(require2, module4, exports3) {
        "use strict";
        function makeTable() {
          var c, table2 = [];
          for (var n = 0; n < 256; n++) {
            c = n;
            for (var k = 0; k < 8; k++) {
              c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
            }
            table2[n] = c;
          }
          return table2;
        }
        var crcTable = makeTable();
        function crc32(crc, buf, len, pos) {
          var t2 = crcTable, end2 = pos + len;
          crc ^= -1;
          for (var i = pos; i < end2; i++) {
            crc = crc >>> 8 ^ t2[(crc ^ buf[i]) & 255];
          }
          return crc ^ -1;
        }
        module4.exports = crc32;
      }, {}], 10: [function(require2, module4, exports3) {
        "use strict";
        function GZheader() {
          this.text = 0;
          this.time = 0;
          this.xflags = 0;
          this.os = 0;
          this.extra = null;
          this.extra_len = 0;
          this.name = "";
          this.comment = "";
          this.hcrc = 0;
          this.done = false;
        }
        module4.exports = GZheader;
      }, {}], 11: [function(require2, module4, exports3) {
        "use strict";
        var BAD = 30;
        var TYPE = 12;
        module4.exports = function inflate_fast(strm, start) {
          var state;
          var _in;
          var last2;
          var _out;
          var beg;
          var end2;
          var dmax;
          var wsize;
          var whave;
          var wnext;
          var s_window;
          var hold;
          var bits;
          var lcode;
          var dcode;
          var lmask;
          var dmask;
          var here;
          var op;
          var len;
          var dist;
          var from;
          var from_source;
          var input, output;
          state = strm.state;
          _in = strm.next_in;
          input = strm.input;
          last2 = _in + (strm.avail_in - 5);
          _out = strm.next_out;
          output = strm.output;
          beg = _out - (start - strm.avail_out);
          end2 = _out + (strm.avail_out - 257);
          dmax = state.dmax;
          wsize = state.wsize;
          whave = state.whave;
          wnext = state.wnext;
          s_window = state.window;
          hold = state.hold;
          bits = state.bits;
          lcode = state.lencode;
          dcode = state.distcode;
          lmask = (1 << state.lenbits) - 1;
          dmask = (1 << state.distbits) - 1;
          top:
            do {
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = lcode[hold & lmask];
              dolen:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op === 0) {
                    output[_out++] = here & 65535;
                  } else if (op & 16) {
                    len = here & 65535;
                    op &= 15;
                    if (op) {
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                      len += hold & (1 << op) - 1;
                      hold >>>= op;
                      bits -= op;
                    }
                    if (bits < 15) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                    here = dcode[hold & dmask];
                    dodist:
                      for (; ; ) {
                        op = here >>> 24;
                        hold >>>= op;
                        bits -= op;
                        op = here >>> 16 & 255;
                        if (op & 16) {
                          dist = here & 65535;
                          op &= 15;
                          if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                            if (bits < op) {
                              hold += input[_in++] << bits;
                              bits += 8;
                            }
                          }
                          dist += hold & (1 << op) - 1;
                          if (dist > dmax) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                          hold >>>= op;
                          bits -= op;
                          op = _out - beg;
                          if (dist > op) {
                            op = dist - op;
                            if (op > whave) {
                              if (state.sane) {
                                strm.msg = "invalid distance too far back";
                                state.mode = BAD;
                                break top;
                              }
                            }
                            from = 0;
                            from_source = s_window;
                            if (wnext === 0) {
                              from += wsize - op;
                              if (op < len) {
                                len -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = _out - dist;
                                from_source = output;
                              }
                            } else if (wnext < op) {
                              from += wsize + wnext - op;
                              op -= wnext;
                              if (op < len) {
                                len -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = 0;
                                if (wnext < len) {
                                  op = wnext;
                                  len -= op;
                                  do {
                                    output[_out++] = s_window[from++];
                                  } while (--op);
                                  from = _out - dist;
                                  from_source = output;
                                }
                              }
                            } else {
                              from += wnext - op;
                              if (op < len) {
                                len -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = _out - dist;
                                from_source = output;
                              }
                            }
                            while (len > 2) {
                              output[_out++] = from_source[from++];
                              output[_out++] = from_source[from++];
                              output[_out++] = from_source[from++];
                              len -= 3;
                            }
                            if (len) {
                              output[_out++] = from_source[from++];
                              if (len > 1) {
                                output[_out++] = from_source[from++];
                              }
                            }
                          } else {
                            from = _out - dist;
                            do {
                              output[_out++] = output[from++];
                              output[_out++] = output[from++];
                              output[_out++] = output[from++];
                              len -= 3;
                            } while (len > 2);
                            if (len) {
                              output[_out++] = output[from++];
                              if (len > 1) {
                                output[_out++] = output[from++];
                              }
                            }
                          }
                        } else if ((op & 64) === 0) {
                          here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                          continue dodist;
                        } else {
                          strm.msg = "invalid distance code";
                          state.mode = BAD;
                          break top;
                        }
                        break;
                      }
                  } else if ((op & 64) === 0) {
                    here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dolen;
                  } else if (op & 32) {
                    state.mode = TYPE;
                    break top;
                  } else {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD;
                    break top;
                  }
                  break;
                }
            } while (_in < last2 && _out < end2);
          len = bits >> 3;
          _in -= len;
          bits -= len << 3;
          hold &= (1 << bits) - 1;
          strm.next_in = _in;
          strm.next_out = _out;
          strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
          strm.avail_out = _out < end2 ? 257 + (end2 - _out) : 257 - (_out - end2);
          state.hold = hold;
          state.bits = bits;
          return;
        };
      }, {}], 12: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("../utils/common");
        var adler32 = require2("./adler32");
        var crc32 = require2("./crc32");
        var inflate_fast = require2("./inffast");
        var inflate_table = require2("./inftrees");
        var CODES = 0;
        var LENS = 1;
        var DISTS = 2;
        var Z_FINISH = 4;
        var Z_BLOCK = 5;
        var Z_TREES = 6;
        var Z_OK = 0;
        var Z_STREAM_END = 1;
        var Z_NEED_DICT = 2;
        var Z_STREAM_ERROR = -2;
        var Z_DATA_ERROR = -3;
        var Z_MEM_ERROR = -4;
        var Z_BUF_ERROR = -5;
        var Z_DEFLATED = 8;
        var HEAD = 1;
        var FLAGS = 2;
        var TIME = 3;
        var OS = 4;
        var EXLEN = 5;
        var EXTRA = 6;
        var NAME = 7;
        var COMMENT = 8;
        var HCRC = 9;
        var DICTID = 10;
        var DICT = 11;
        var TYPE = 12;
        var TYPEDO = 13;
        var STORED = 14;
        var COPY_ = 15;
        var COPY = 16;
        var TABLE = 17;
        var LENLENS = 18;
        var CODELENS = 19;
        var LEN_ = 20;
        var LEN = 21;
        var LENEXT = 22;
        var DIST = 23;
        var DISTEXT = 24;
        var MATCH = 25;
        var LIT = 26;
        var CHECK = 27;
        var LENGTH = 28;
        var DONE = 29;
        var BAD = 30;
        var MEM = 31;
        var SYNC = 32;
        var ENOUGH_LENS = 852;
        var ENOUGH_DISTS = 592;
        var MAX_WBITS = 15;
        var DEF_WBITS = MAX_WBITS;
        function zswap32(q) {
          return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
        }
        function InflateState() {
          this.mode = 0;
          this.last = false;
          this.wrap = 0;
          this.havedict = false;
          this.flags = 0;
          this.dmax = 0;
          this.check = 0;
          this.total = 0;
          this.head = null;
          this.wbits = 0;
          this.wsize = 0;
          this.whave = 0;
          this.wnext = 0;
          this.window = null;
          this.hold = 0;
          this.bits = 0;
          this.length = 0;
          this.offset = 0;
          this.extra = 0;
          this.lencode = null;
          this.distcode = null;
          this.lenbits = 0;
          this.distbits = 0;
          this.ncode = 0;
          this.nlen = 0;
          this.ndist = 0;
          this.have = 0;
          this.next = null;
          this.lens = new utils.Buf16(320);
          this.work = new utils.Buf16(288);
          this.lendyn = null;
          this.distdyn = null;
          this.sane = 0;
          this.back = 0;
          this.was = 0;
        }
        function inflateResetKeep(strm) {
          var state;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          strm.total_in = strm.total_out = state.total = 0;
          strm.msg = "";
          if (state.wrap) {
            strm.adler = state.wrap & 1;
          }
          state.mode = HEAD;
          state.last = 0;
          state.havedict = 0;
          state.dmax = 32768;
          state.head = null;
          state.hold = 0;
          state.bits = 0;
          state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
          state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
          state.sane = 1;
          state.back = -1;
          return Z_OK;
        }
        function inflateReset(strm) {
          var state;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          state.wsize = 0;
          state.whave = 0;
          state.wnext = 0;
          return inflateResetKeep(strm);
        }
        function inflateReset2(strm, windowBits) {
          var wrap2;
          var state;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          if (windowBits < 0) {
            wrap2 = 0;
            windowBits = -windowBits;
          } else {
            wrap2 = (windowBits >> 4) + 1;
            if (windowBits < 48) {
              windowBits &= 15;
            }
          }
          if (windowBits && (windowBits < 8 || windowBits > 15)) {
            return Z_STREAM_ERROR;
          }
          if (state.window !== null && state.wbits !== windowBits) {
            state.window = null;
          }
          state.wrap = wrap2;
          state.wbits = windowBits;
          return inflateReset(strm);
        }
        function inflateInit2(strm, windowBits) {
          var ret;
          var state;
          if (!strm) {
            return Z_STREAM_ERROR;
          }
          state = new InflateState();
          strm.state = state;
          state.window = null;
          ret = inflateReset2(strm, windowBits);
          if (ret !== Z_OK) {
            strm.state = null;
          }
          return ret;
        }
        function inflateInit(strm) {
          return inflateInit2(strm, DEF_WBITS);
        }
        var virgin = true;
        var lenfix, distfix;
        function fixedtables(state) {
          if (virgin) {
            var sym;
            lenfix = new utils.Buf32(512);
            distfix = new utils.Buf32(32);
            sym = 0;
            while (sym < 144) {
              state.lens[sym++] = 8;
            }
            while (sym < 256) {
              state.lens[sym++] = 9;
            }
            while (sym < 280) {
              state.lens[sym++] = 7;
            }
            while (sym < 288) {
              state.lens[sym++] = 8;
            }
            inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
            sym = 0;
            while (sym < 32) {
              state.lens[sym++] = 5;
            }
            inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
            virgin = false;
          }
          state.lencode = lenfix;
          state.lenbits = 9;
          state.distcode = distfix;
          state.distbits = 5;
        }
        function updatewindow(strm, src, end2, copy) {
          var dist;
          var state = strm.state;
          if (state.window === null) {
            state.wsize = 1 << state.wbits;
            state.wnext = 0;
            state.whave = 0;
            state.window = new utils.Buf8(state.wsize);
          }
          if (copy >= state.wsize) {
            utils.arraySet(state.window, src, end2 - state.wsize, state.wsize, 0);
            state.wnext = 0;
            state.whave = state.wsize;
          } else {
            dist = state.wsize - state.wnext;
            if (dist > copy) {
              dist = copy;
            }
            utils.arraySet(state.window, src, end2 - copy, dist, state.wnext);
            copy -= dist;
            if (copy) {
              utils.arraySet(state.window, src, end2 - copy, copy, 0);
              state.wnext = copy;
              state.whave = state.wsize;
            } else {
              state.wnext += dist;
              if (state.wnext === state.wsize) {
                state.wnext = 0;
              }
              if (state.whave < state.wsize) {
                state.whave += dist;
              }
            }
          }
          return 0;
        }
        function inflate(strm, flush) {
          var state;
          var input, output;
          var next2;
          var put;
          var have, left;
          var hold;
          var bits;
          var _in, _out;
          var copy;
          var from;
          var from_source;
          var here = 0;
          var here_bits, here_op, here_val;
          var last_bits, last_op, last_val;
          var len;
          var ret;
          var hbuf = new utils.Buf8(4);
          var opts;
          var n;
          var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          if (state.mode === TYPE) {
            state.mode = TYPEDO;
          }
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next2 = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          _in = have;
          _out = left;
          ret = Z_OK;
          inf_leave:
            for (; ; ) {
              switch (state.mode) {
                case HEAD:
                  if (state.wrap === 0) {
                    state.mode = TYPEDO;
                    break;
                  }
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  if (state.wrap & 2 && hold === 35615) {
                    state.check = 0;
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                    hold = 0;
                    bits = 0;
                    state.mode = FLAGS;
                    break;
                  }
                  state.flags = 0;
                  if (state.head) {
                    state.head.done = false;
                  }
                  if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                    strm.msg = "incorrect header check";
                    state.mode = BAD;
                    break;
                  }
                  if ((hold & 15) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                  }
                  hold >>>= 4;
                  bits -= 4;
                  len = (hold & 15) + 8;
                  if (state.wbits === 0) {
                    state.wbits = len;
                  } else if (len > state.wbits) {
                    strm.msg = "invalid window size";
                    state.mode = BAD;
                    break;
                  }
                  state.dmax = 1 << len;
                  strm.adler = state.check = 1;
                  state.mode = hold & 512 ? DICTID : TYPE;
                  hold = 0;
                  bits = 0;
                  break;
                case FLAGS:
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  state.flags = hold;
                  if ((state.flags & 255) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                  }
                  if (state.flags & 57344) {
                    strm.msg = "unknown header flags set";
                    state.mode = BAD;
                    break;
                  }
                  if (state.head) {
                    state.head.text = hold >> 8 & 1;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = TIME;
                case TIME:
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  if (state.head) {
                    state.head.time = hold;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    hbuf[2] = hold >>> 16 & 255;
                    hbuf[3] = hold >>> 24 & 255;
                    state.check = crc32(state.check, hbuf, 4, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = OS;
                case OS:
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  if (state.head) {
                    state.head.xflags = hold & 255;
                    state.head.os = hold >> 8;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = EXLEN;
                case EXLEN:
                  if (state.flags & 1024) {
                    while (bits < 16) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    state.length = hold;
                    if (state.head) {
                      state.head.extra_len = hold;
                    }
                    if (state.flags & 512) {
                      hbuf[0] = hold & 255;
                      hbuf[1] = hold >>> 8 & 255;
                      state.check = crc32(state.check, hbuf, 2, 0);
                    }
                    hold = 0;
                    bits = 0;
                  } else if (state.head) {
                    state.head.extra = null;
                  }
                  state.mode = EXTRA;
                case EXTRA:
                  if (state.flags & 1024) {
                    copy = state.length;
                    if (copy > have) {
                      copy = have;
                    }
                    if (copy) {
                      if (state.head) {
                        len = state.head.extra_len - state.length;
                        if (!state.head.extra) {
                          state.head.extra = new Array(state.head.extra_len);
                        }
                        utils.arraySet(
                          state.head.extra,
                          input,
                          next2,
                          copy,
                          len
                        );
                      }
                      if (state.flags & 512) {
                        state.check = crc32(state.check, input, copy, next2);
                      }
                      have -= copy;
                      next2 += copy;
                      state.length -= copy;
                    }
                    if (state.length) {
                      break inf_leave;
                    }
                  }
                  state.length = 0;
                  state.mode = NAME;
                case NAME:
                  if (state.flags & 2048) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    copy = 0;
                    do {
                      len = input[next2 + copy++];
                      if (state.head && len && state.length < 65536) {
                        state.head.name += String.fromCharCode(len);
                      }
                    } while (len && copy < have);
                    if (state.flags & 512) {
                      state.check = crc32(state.check, input, copy, next2);
                    }
                    have -= copy;
                    next2 += copy;
                    if (len) {
                      break inf_leave;
                    }
                  } else if (state.head) {
                    state.head.name = null;
                  }
                  state.length = 0;
                  state.mode = COMMENT;
                case COMMENT:
                  if (state.flags & 4096) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    copy = 0;
                    do {
                      len = input[next2 + copy++];
                      if (state.head && len && state.length < 65536) {
                        state.head.comment += String.fromCharCode(len);
                      }
                    } while (len && copy < have);
                    if (state.flags & 512) {
                      state.check = crc32(state.check, input, copy, next2);
                    }
                    have -= copy;
                    next2 += copy;
                    if (len) {
                      break inf_leave;
                    }
                  } else if (state.head) {
                    state.head.comment = null;
                  }
                  state.mode = HCRC;
                case HCRC:
                  if (state.flags & 512) {
                    while (bits < 16) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    if (hold !== (state.check & 65535)) {
                      strm.msg = "header crc mismatch";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  if (state.head) {
                    state.head.hcrc = state.flags >> 9 & 1;
                    state.head.done = true;
                  }
                  strm.adler = state.check = 0;
                  state.mode = TYPE;
                  break;
                case DICTID:
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  strm.adler = state.check = zswap32(hold);
                  hold = 0;
                  bits = 0;
                  state.mode = DICT;
                case DICT:
                  if (state.havedict === 0) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next2;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    return Z_NEED_DICT;
                  }
                  strm.adler = state.check = 1;
                  state.mode = TYPE;
                case TYPE:
                  if (flush === Z_BLOCK || flush === Z_TREES) {
                    break inf_leave;
                  }
                case TYPEDO:
                  if (state.last) {
                    hold >>>= bits & 7;
                    bits -= bits & 7;
                    state.mode = CHECK;
                    break;
                  }
                  while (bits < 3) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  state.last = hold & 1;
                  hold >>>= 1;
                  bits -= 1;
                  switch (hold & 3) {
                    case 0:
                      state.mode = STORED;
                      break;
                    case 1:
                      fixedtables(state);
                      state.mode = LEN_;
                      if (flush === Z_TREES) {
                        hold >>>= 2;
                        bits -= 2;
                        break inf_leave;
                      }
                      break;
                    case 2:
                      state.mode = TABLE;
                      break;
                    case 3:
                      strm.msg = "invalid block type";
                      state.mode = BAD;
                  }
                  hold >>>= 2;
                  bits -= 2;
                  break;
                case STORED:
                  hold >>>= bits & 7;
                  bits -= bits & 7;
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                    strm.msg = "invalid stored block lengths";
                    state.mode = BAD;
                    break;
                  }
                  state.length = hold & 65535;
                  hold = 0;
                  bits = 0;
                  state.mode = COPY_;
                  if (flush === Z_TREES) {
                    break inf_leave;
                  }
                case COPY_:
                  state.mode = COPY;
                case COPY:
                  copy = state.length;
                  if (copy) {
                    if (copy > have) {
                      copy = have;
                    }
                    if (copy > left) {
                      copy = left;
                    }
                    if (copy === 0) {
                      break inf_leave;
                    }
                    utils.arraySet(output, input, next2, copy, put);
                    have -= copy;
                    next2 += copy;
                    left -= copy;
                    put += copy;
                    state.length -= copy;
                    break;
                  }
                  state.mode = TYPE;
                  break;
                case TABLE:
                  while (bits < 14) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  state.nlen = (hold & 31) + 257;
                  hold >>>= 5;
                  bits -= 5;
                  state.ndist = (hold & 31) + 1;
                  hold >>>= 5;
                  bits -= 5;
                  state.ncode = (hold & 15) + 4;
                  hold >>>= 4;
                  bits -= 4;
                  if (state.nlen > 286 || state.ndist > 30) {
                    strm.msg = "too many length or distance symbols";
                    state.mode = BAD;
                    break;
                  }
                  state.have = 0;
                  state.mode = LENLENS;
                case LENLENS:
                  while (state.have < state.ncode) {
                    while (bits < 3) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    state.lens[order[state.have++]] = hold & 7;
                    hold >>>= 3;
                    bits -= 3;
                  }
                  while (state.have < 19) {
                    state.lens[order[state.have++]] = 0;
                  }
                  state.lencode = state.lendyn;
                  state.lenbits = 7;
                  opts = { bits: state.lenbits };
                  ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                  state.lenbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid code lengths set";
                    state.mode = BAD;
                    break;
                  }
                  state.have = 0;
                  state.mode = CODELENS;
                case CODELENS:
                  while (state.have < state.nlen + state.ndist) {
                    for (; ; ) {
                      here = state.lencode[hold & (1 << state.lenbits) - 1];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    if (here_val < 16) {
                      hold >>>= here_bits;
                      bits -= here_bits;
                      state.lens[state.have++] = here_val;
                    } else {
                      if (here_val === 16) {
                        n = here_bits + 2;
                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next2++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        if (state.have === 0) {
                          strm.msg = "invalid bit length repeat";
                          state.mode = BAD;
                          break;
                        }
                        len = state.lens[state.have - 1];
                        copy = 3 + (hold & 3);
                        hold >>>= 2;
                        bits -= 2;
                      } else if (here_val === 17) {
                        n = here_bits + 3;
                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next2++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        len = 0;
                        copy = 3 + (hold & 7);
                        hold >>>= 3;
                        bits -= 3;
                      } else {
                        n = here_bits + 7;
                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next2++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        len = 0;
                        copy = 11 + (hold & 127);
                        hold >>>= 7;
                        bits -= 7;
                      }
                      if (state.have + copy > state.nlen + state.ndist) {
                        strm.msg = "invalid bit length repeat";
                        state.mode = BAD;
                        break;
                      }
                      while (copy--) {
                        state.lens[state.have++] = len;
                      }
                    }
                  }
                  if (state.mode === BAD) {
                    break;
                  }
                  if (state.lens[256] === 0) {
                    strm.msg = "invalid code -- missing end-of-block";
                    state.mode = BAD;
                    break;
                  }
                  state.lenbits = 9;
                  opts = { bits: state.lenbits };
                  ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                  state.lenbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid literal/lengths set";
                    state.mode = BAD;
                    break;
                  }
                  state.distbits = 6;
                  state.distcode = state.distdyn;
                  opts = { bits: state.distbits };
                  ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                  state.distbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid distances set";
                    state.mode = BAD;
                    break;
                  }
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    break inf_leave;
                  }
                case LEN_:
                  state.mode = LEN;
                case LEN:
                  if (have >= 6 && left >= 258) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next2;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    inflate_fast(strm, _out);
                    put = strm.next_out;
                    output = strm.output;
                    left = strm.avail_out;
                    next2 = strm.next_in;
                    input = strm.input;
                    have = strm.avail_in;
                    hold = state.hold;
                    bits = state.bits;
                    if (state.mode === TYPE) {
                      state.back = -1;
                    }
                    break;
                  }
                  state.back = 0;
                  for (; ; ) {
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  if (here_op && (here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for (; ; ) {
                      here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (last_bits + here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.back += here_bits;
                  state.length = here_val;
                  if (here_op === 0) {
                    state.mode = LIT;
                    break;
                  }
                  if (here_op & 32) {
                    state.back = -1;
                    state.mode = TYPE;
                    break;
                  }
                  if (here_op & 64) {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD;
                    break;
                  }
                  state.extra = here_op & 15;
                  state.mode = LENEXT;
                case LENEXT:
                  if (state.extra) {
                    n = state.extra;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    state.length += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                  }
                  state.was = state.length;
                  state.mode = DIST;
                case DIST:
                  for (; ; ) {
                    here = state.distcode[hold & (1 << state.distbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  if ((here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for (; ; ) {
                      here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (last_bits + here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.back += here_bits;
                  if (here_op & 64) {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break;
                  }
                  state.offset = here_val;
                  state.extra = here_op & 15;
                  state.mode = DISTEXT;
                case DISTEXT:
                  if (state.extra) {
                    n = state.extra;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    state.offset += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                  }
                  if (state.offset > state.dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                  state.mode = MATCH;
                case MATCH:
                  if (left === 0) {
                    break inf_leave;
                  }
                  copy = _out - left;
                  if (state.offset > copy) {
                    copy = state.offset - copy;
                    if (copy > state.whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break;
                      }
                    }
                    if (copy > state.wnext) {
                      copy -= state.wnext;
                      from = state.wsize - copy;
                    } else {
                      from = state.wnext - copy;
                    }
                    if (copy > state.length) {
                      copy = state.length;
                    }
                    from_source = state.window;
                  } else {
                    from_source = output;
                    from = put - state.offset;
                    copy = state.length;
                  }
                  if (copy > left) {
                    copy = left;
                  }
                  left -= copy;
                  state.length -= copy;
                  do {
                    output[put++] = from_source[from++];
                  } while (--copy);
                  if (state.length === 0) {
                    state.mode = LEN;
                  }
                  break;
                case LIT:
                  if (left === 0) {
                    break inf_leave;
                  }
                  output[put++] = state.length;
                  left--;
                  state.mode = LEN;
                  break;
                case CHECK:
                  if (state.wrap) {
                    while (bits < 32) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold |= input[next2++] << bits;
                      bits += 8;
                    }
                    _out -= left;
                    strm.total_out += _out;
                    state.total += _out;
                    if (_out) {
                      strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                    }
                    _out = left;
                    if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                      strm.msg = "incorrect data check";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  state.mode = LENGTH;
                case LENGTH:
                  if (state.wrap && state.flags) {
                    while (bits < 32) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    if (hold !== (state.total & 4294967295)) {
                      strm.msg = "incorrect length check";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  state.mode = DONE;
                case DONE:
                  ret = Z_STREAM_END;
                  break inf_leave;
                case BAD:
                  ret = Z_DATA_ERROR;
                  break inf_leave;
                case MEM:
                  return Z_MEM_ERROR;
                case SYNC:
                default:
                  return Z_STREAM_ERROR;
              }
            }
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next2;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
            if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
              state.mode = MEM;
              return Z_MEM_ERROR;
            }
          }
          _in -= strm.avail_in;
          _out -= strm.avail_out;
          strm.total_in += _in;
          strm.total_out += _out;
          state.total += _out;
          if (state.wrap && _out) {
            strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
          }
          strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
          if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
            ret = Z_BUF_ERROR;
          }
          return ret;
        }
        function inflateEnd(strm) {
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          var state = strm.state;
          if (state.window) {
            state.window = null;
          }
          strm.state = null;
          return Z_OK;
        }
        function inflateGetHeader(strm, head) {
          var state;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          if ((state.wrap & 2) === 0) {
            return Z_STREAM_ERROR;
          }
          state.head = head;
          head.done = false;
          return Z_OK;
        }
        function inflateSetDictionary(strm, dictionary) {
          var dictLength = dictionary.length;
          var state;
          var dictid;
          var ret;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          if (state.wrap !== 0 && state.mode !== DICT) {
            return Z_STREAM_ERROR;
          }
          if (state.mode === DICT) {
            dictid = 1;
            dictid = adler32(dictid, dictionary, dictLength, 0);
            if (dictid !== state.check) {
              return Z_DATA_ERROR;
            }
          }
          ret = updatewindow(strm, dictionary, dictLength, dictLength);
          if (ret) {
            state.mode = MEM;
            return Z_MEM_ERROR;
          }
          state.havedict = 1;
          return Z_OK;
        }
        exports3.inflateReset = inflateReset;
        exports3.inflateReset2 = inflateReset2;
        exports3.inflateResetKeep = inflateResetKeep;
        exports3.inflateInit = inflateInit;
        exports3.inflateInit2 = inflateInit2;
        exports3.inflate = inflate;
        exports3.inflateEnd = inflateEnd;
        exports3.inflateGetHeader = inflateGetHeader;
        exports3.inflateSetDictionary = inflateSetDictionary;
        exports3.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 5, "./adler32": 7, "./crc32": 9, "./inffast": 11, "./inftrees": 13 }], 13: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("../utils/common");
        var MAXBITS = 15;
        var ENOUGH_LENS = 852;
        var ENOUGH_DISTS = 592;
        var CODES = 0;
        var LENS = 1;
        var DISTS = 2;
        var lbase = [
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          13,
          15,
          17,
          19,
          23,
          27,
          31,
          35,
          43,
          51,
          59,
          67,
          83,
          99,
          115,
          131,
          163,
          195,
          227,
          258,
          0,
          0
        ];
        var lext = [
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          17,
          17,
          17,
          17,
          18,
          18,
          18,
          18,
          19,
          19,
          19,
          19,
          20,
          20,
          20,
          20,
          21,
          21,
          21,
          21,
          16,
          72,
          78
        ];
        var dbase = [
          1,
          2,
          3,
          4,
          5,
          7,
          9,
          13,
          17,
          25,
          33,
          49,
          65,
          97,
          129,
          193,
          257,
          385,
          513,
          769,
          1025,
          1537,
          2049,
          3073,
          4097,
          6145,
          8193,
          12289,
          16385,
          24577,
          0,
          0
        ];
        var dext = [
          16,
          16,
          16,
          16,
          17,
          17,
          18,
          18,
          19,
          19,
          20,
          20,
          21,
          21,
          22,
          22,
          23,
          23,
          24,
          24,
          25,
          25,
          26,
          26,
          27,
          27,
          28,
          28,
          29,
          29,
          64,
          64
        ];
        module4.exports = function inflate_table(type, lens, lens_index, codes, table2, table_index, work, opts) {
          var bits = opts.bits;
          var len = 0;
          var sym = 0;
          var min = 0, max = 0;
          var root3 = 0;
          var curr = 0;
          var drop = 0;
          var left = 0;
          var used = 0;
          var huff = 0;
          var incr;
          var fill;
          var low;
          var mask;
          var next2;
          var base2 = null;
          var base_index = 0;
          var end2;
          var count = new utils.Buf16(MAXBITS + 1);
          var offs = new utils.Buf16(MAXBITS + 1);
          var extra = null;
          var extra_index = 0;
          var here_bits, here_op, here_val;
          for (len = 0; len <= MAXBITS; len++) {
            count[len] = 0;
          }
          for (sym = 0; sym < codes; sym++) {
            count[lens[lens_index + sym]]++;
          }
          root3 = bits;
          for (max = MAXBITS; max >= 1; max--) {
            if (count[max] !== 0) {
              break;
            }
          }
          if (root3 > max) {
            root3 = max;
          }
          if (max === 0) {
            table2[table_index++] = 1 << 24 | 64 << 16 | 0;
            table2[table_index++] = 1 << 24 | 64 << 16 | 0;
            opts.bits = 1;
            return 0;
          }
          for (min = 1; min < max; min++) {
            if (count[min] !== 0) {
              break;
            }
          }
          if (root3 < min) {
            root3 = min;
          }
          left = 1;
          for (len = 1; len <= MAXBITS; len++) {
            left <<= 1;
            left -= count[len];
            if (left < 0) {
              return -1;
            }
          }
          if (left > 0 && (type === CODES || max !== 1)) {
            return -1;
          }
          offs[1] = 0;
          for (len = 1; len < MAXBITS; len++) {
            offs[len + 1] = offs[len] + count[len];
          }
          for (sym = 0; sym < codes; sym++) {
            if (lens[lens_index + sym] !== 0) {
              work[offs[lens[lens_index + sym]]++] = sym;
            }
          }
          if (type === CODES) {
            base2 = extra = work;
            end2 = 19;
          } else if (type === LENS) {
            base2 = lbase;
            base_index -= 257;
            extra = lext;
            extra_index -= 257;
            end2 = 256;
          } else {
            base2 = dbase;
            extra = dext;
            end2 = -1;
          }
          huff = 0;
          sym = 0;
          len = min;
          next2 = table_index;
          curr = root3;
          drop = 0;
          low = -1;
          used = 1 << root3;
          mask = used - 1;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          for (; ; ) {
            here_bits = len - drop;
            if (work[sym] < end2) {
              here_op = 0;
              here_val = work[sym];
            } else if (work[sym] > end2) {
              here_op = extra[extra_index + work[sym]];
              here_val = base2[base_index + work[sym]];
            } else {
              here_op = 32 + 64;
              here_val = 0;
            }
            incr = 1 << len - drop;
            fill = 1 << curr;
            min = fill;
            do {
              fill -= incr;
              table2[next2 + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
            } while (fill !== 0);
            incr = 1 << len - 1;
            while (huff & incr) {
              incr >>= 1;
            }
            if (incr !== 0) {
              huff &= incr - 1;
              huff += incr;
            } else {
              huff = 0;
            }
            sym++;
            if (--count[len] === 0) {
              if (len === max) {
                break;
              }
              len = lens[lens_index + work[sym]];
            }
            if (len > root3 && (huff & mask) !== low) {
              if (drop === 0) {
                drop = root3;
              }
              next2 += min;
              curr = len - drop;
              left = 1 << curr;
              while (curr + drop < max) {
                left -= count[curr + drop];
                if (left <= 0) {
                  break;
                }
                curr++;
                left <<= 1;
              }
              used += 1 << curr;
              if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
                return 1;
              }
              low = huff & mask;
              table2[low] = root3 << 24 | curr << 16 | next2 - table_index | 0;
            }
          }
          if (huff !== 0) {
            table2[next2 + huff] = len - drop << 24 | 64 << 16 | 0;
          }
          opts.bits = root3;
          return 0;
        };
      }, { "../utils/common": 5 }], 14: [function(require2, module4, exports3) {
        "use strict";
        module4.exports = {
          2: "need dictionary",
          1: "stream end",
          0: "",
          "-1": "file error",
          "-2": "stream error",
          "-3": "data error",
          "-4": "insufficient memory",
          "-5": "buffer error",
          "-6": "incompatible version"
        };
      }, {}], 15: [function(require2, module4, exports3) {
        "use strict";
        function ZStream() {
          this.input = null;
          this.next_in = 0;
          this.avail_in = 0;
          this.total_in = 0;
          this.output = null;
          this.next_out = 0;
          this.avail_out = 0;
          this.total_out = 0;
          this.msg = "";
          this.state = null;
          this.data_type = 2;
          this.adler = 0;
        }
        module4.exports = ZStream;
      }, {}] }, {}, [3])(3);
    });
  }
});

// ../../node_modules/.pnpm/plantuml-encoder@1.4.0/node_modules/plantuml-encoder/browser-index.js
var require_browser_index = __commonJS({
  "../../node_modules/.pnpm/plantuml-encoder@1.4.0/node_modules/plantuml-encoder/browser-index.js"(exports, module2) {
    module2.exports = {
      encode: require_plantuml_encoder().encode,
      decode: require_plantuml_decoder().decode
    };
  }
});

// ../../node_modules/.pnpm/boolbase@1.0.0/node_modules/boolbase/index.js
var require_boolbase = __commonJS({
  "../../node_modules/.pnpm/boolbase@1.0.0/node_modules/boolbase/index.js"(exports, module2) {
    module2.exports = {
      trueFunc: function trueFunc2() {
        return true;
      },
      falseFunc: function falseFunc() {
        return false;
      }
    };
  }
});

// ../../node_modules/.pnpm/katex@0.12.0/node_modules/katex/dist/katex.js
var require_katex = __commonJS({
  "../../node_modules/.pnpm/katex@0.12.0/node_modules/katex/dist/katex.js"(exports, module2) {
    (function webpackUniversalModuleDefinition(root3, factory) {
      if (typeof exports === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["katex"] = factory();
      else
        root3["katex"] = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module3 = installedModules[moduleId] = {
            i: moduleId,
            l: false,
            exports: {}
          };
          modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
          module3.l = true;
          return module3.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports2, name2, getter) {
          if (!__webpack_require__.o(exports2, name2)) {
            Object.defineProperty(exports2, name2, { enumerable: true, get: getter });
          }
        };
        __webpack_require__.r = function(exports2) {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
        __webpack_require__.t = function(value, mode) {
          if (mode & 1)
            value = __webpack_require__(value);
          if (mode & 8)
            return value;
          if (mode & 4 && typeof value === "object" && value && value.__esModule)
            return value;
          var ns = /* @__PURE__ */ Object.create(null);
          __webpack_require__.r(ns);
          Object.defineProperty(ns, "default", { enumerable: true, value });
          if (mode & 2 && typeof value != "string")
            for (var key in value)
              __webpack_require__.d(ns, key, function(key2) {
                return value[key2];
              }.bind(null, key));
          return ns;
        };
        __webpack_require__.n = function(module3) {
          var getter = module3 && module3.__esModule ? function getDefault() {
            return module3["default"];
          } : function getModuleExports() {
            return module3;
          };
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = 1);
      }([
        function(module3, exports2, __webpack_require__) {
        },
        function(module3, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.r(__webpack_exports__);
          var katex = __webpack_require__(0);
          var SourceLocation = /* @__PURE__ */ function() {
            function SourceLocation2(lexer, start, end2) {
              this.lexer = void 0;
              this.start = void 0;
              this.end = void 0;
              this.lexer = lexer;
              this.start = start;
              this.end = end2;
            }
            SourceLocation2.range = function range(first2, second) {
              if (!second) {
                return first2 && first2.loc;
              } else if (!first2 || !first2.loc || !second.loc || first2.loc.lexer !== second.loc.lexer) {
                return null;
              } else {
                return new SourceLocation2(first2.loc.lexer, first2.loc.start, second.loc.end);
              }
            };
            return SourceLocation2;
          }();
          var Token_Token = /* @__PURE__ */ function() {
            function Token2(text4, loc) {
              this.text = void 0;
              this.loc = void 0;
              this.noexpand = void 0;
              this.treatAsRelax = void 0;
              this.text = text4;
              this.loc = loc;
            }
            var _proto = Token2.prototype;
            _proto.range = function range(endToken, text4) {
              return new Token2(text4, SourceLocation.range(this, endToken));
            };
            return Token2;
          }();
          var ParseError = function ParseError2(message, token) {
            this.position = void 0;
            var error2 = "KaTeX parse error: " + message;
            var start;
            var loc = token && token.loc;
            if (loc && loc.start <= loc.end) {
              var input = loc.lexer.input;
              start = loc.start;
              var end2 = loc.end;
              if (start === input.length) {
                error2 += " at end of input: ";
              } else {
                error2 += " at position " + (start + 1) + ": ";
              }
              var underlined = input.slice(start, end2).replace(/[^]/g, "$&\u0332");
              var left;
              if (start > 15) {
                left = "\u2026" + input.slice(start - 15, start);
              } else {
                left = input.slice(0, start);
              }
              var right;
              if (end2 + 15 < input.length) {
                right = input.slice(end2, end2 + 15) + "\u2026";
              } else {
                right = input.slice(end2);
              }
              error2 += left + underlined + right;
            }
            var self2 = new Error(error2);
            self2.name = "ParseError";
            self2.__proto__ = ParseError2.prototype;
            self2.position = start;
            return self2;
          };
          ParseError.prototype.__proto__ = Error.prototype;
          var src_ParseError = ParseError;
          var contains3 = function contains4(list2, elem) {
            return list2.indexOf(elem) !== -1;
          };
          var deflt = function deflt2(setting, defaultIfUndefined) {
            return setting === void 0 ? defaultIfUndefined : setting;
          };
          var uppercase = /([A-Z])/g;
          var hyphenate = function hyphenate2(str) {
            return str.replace(uppercase, "-$1").toLowerCase();
          };
          var ESCAPE_LOOKUP = {
            "&": "&amp;",
            ">": "&gt;",
            "<": "&lt;",
            '"': "&quot;",
            "'": "&#x27;"
          };
          var ESCAPE_REGEX = /[&><"']/g;
          function utils_escape(text4) {
            return String(text4).replace(ESCAPE_REGEX, function(match2) {
              return ESCAPE_LOOKUP[match2];
            });
          }
          var getBaseElem = function getBaseElem2(group) {
            if (group.type === "ordgroup") {
              if (group.body.length === 1) {
                return getBaseElem2(group.body[0]);
              } else {
                return group;
              }
            } else if (group.type === "color") {
              if (group.body.length === 1) {
                return getBaseElem2(group.body[0]);
              } else {
                return group;
              }
            } else if (group.type === "font") {
              return getBaseElem2(group.body);
            } else {
              return group;
            }
          };
          var utils_isCharacterBox = function isCharacterBox(group) {
            var baseElem = getBaseElem(group);
            return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
          };
          var assert = function assert2(value) {
            if (!value) {
              throw new Error("Expected non-null, but got " + String(value));
            }
            return value;
          };
          var protocolFromUrl = function protocolFromUrl2(url) {
            var protocol = /^\s*([^\\/#]*?)(?::|&#0*58|&#x0*3a)/i.exec(url);
            return protocol != null ? protocol[1] : "_relative";
          };
          var utils = {
            contains: contains3,
            deflt,
            escape: utils_escape,
            hyphenate,
            getBaseElem,
            isCharacterBox: utils_isCharacterBox,
            protocolFromUrl
          };
          var Settings_Settings = /* @__PURE__ */ function() {
            function Settings(options) {
              this.displayMode = void 0;
              this.output = void 0;
              this.leqno = void 0;
              this.fleqn = void 0;
              this.throwOnError = void 0;
              this.errorColor = void 0;
              this.macros = void 0;
              this.minRuleThickness = void 0;
              this.colorIsTextColor = void 0;
              this.strict = void 0;
              this.trust = void 0;
              this.maxSize = void 0;
              this.maxExpand = void 0;
              this.globalGroup = void 0;
              options = options || {};
              this.displayMode = utils.deflt(options.displayMode, false);
              this.output = utils.deflt(options.output, "htmlAndMathml");
              this.leqno = utils.deflt(options.leqno, false);
              this.fleqn = utils.deflt(options.fleqn, false);
              this.throwOnError = utils.deflt(options.throwOnError, true);
              this.errorColor = utils.deflt(options.errorColor, "#cc0000");
              this.macros = options.macros || {};
              this.minRuleThickness = Math.max(0, utils.deflt(options.minRuleThickness, 0));
              this.colorIsTextColor = utils.deflt(options.colorIsTextColor, false);
              this.strict = utils.deflt(options.strict, "warn");
              this.trust = utils.deflt(options.trust, false);
              this.maxSize = Math.max(0, utils.deflt(options.maxSize, Infinity));
              this.maxExpand = Math.max(0, utils.deflt(options.maxExpand, 1e3));
              this.globalGroup = utils.deflt(options.globalGroup, false);
            }
            var _proto = Settings.prototype;
            _proto.reportNonstrict = function reportNonstrict(errorCode, errorMsg, token) {
              var strict = this.strict;
              if (typeof strict === "function") {
                strict = strict(errorCode, errorMsg, token);
              }
              if (!strict || strict === "ignore") {
                return;
              } else if (strict === true || strict === "error") {
                throw new src_ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
              } else if (strict === "warn") {
                typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
              } else {
                typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
              }
            };
            _proto.useStrictBehavior = function useStrictBehavior(errorCode, errorMsg, token) {
              var strict = this.strict;
              if (typeof strict === "function") {
                try {
                  strict = strict(errorCode, errorMsg, token);
                } catch (error2) {
                  strict = "error";
                }
              }
              if (!strict || strict === "ignore") {
                return false;
              } else if (strict === true || strict === "error") {
                return true;
              } else if (strict === "warn") {
                typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
                return false;
              } else {
                typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
                return false;
              }
            };
            _proto.isTrusted = function isTrusted(context) {
              if (context.url && !context.protocol) {
                context.protocol = utils.protocolFromUrl(context.url);
              }
              var trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
              return Boolean(trust);
            };
            return Settings;
          }();
          var Style2 = /* @__PURE__ */ function() {
            function Style3(id, size, cramped) {
              this.id = void 0;
              this.size = void 0;
              this.cramped = void 0;
              this.id = id;
              this.size = size;
              this.cramped = cramped;
            }
            var _proto = Style3.prototype;
            _proto.sup = function sup() {
              return Style_styles[_sup[this.id]];
            };
            _proto.sub = function sub() {
              return Style_styles[_sub[this.id]];
            };
            _proto.fracNum = function fracNum() {
              return Style_styles[_fracNum[this.id]];
            };
            _proto.fracDen = function fracDen() {
              return Style_styles[_fracDen[this.id]];
            };
            _proto.cramp = function cramp() {
              return Style_styles[_cramp[this.id]];
            };
            _proto.text = function text4() {
              return Style_styles[_text[this.id]];
            };
            _proto.isTight = function isTight() {
              return this.size >= 2;
            };
            return Style3;
          }();
          var D = 0;
          var Dc = 1;
          var T = 2;
          var Tc = 3;
          var S = 4;
          var Sc = 5;
          var SS = 6;
          var SSc = 7;
          var Style_styles = [new Style2(D, 0, false), new Style2(Dc, 0, true), new Style2(T, 1, false), new Style2(Tc, 1, true), new Style2(S, 2, false), new Style2(Sc, 2, true), new Style2(SS, 3, false), new Style2(SSc, 3, true)];
          var _sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
          var _sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
          var _fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
          var _fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
          var _cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
          var _text = [D, Dc, T, Tc, T, Tc, T, Tc];
          var src_Style = {
            DISPLAY: Style_styles[D],
            TEXT: Style_styles[T],
            SCRIPT: Style_styles[S],
            SCRIPTSCRIPT: Style_styles[SS]
          };
          var scriptData = [{
            name: "latin",
            blocks: [
              [256, 591],
              [768, 879]
            ]
          }, {
            name: "cyrillic",
            blocks: [[1024, 1279]]
          }, {
            name: "brahmic",
            blocks: [[2304, 4255]]
          }, {
            name: "georgian",
            blocks: [[4256, 4351]]
          }, {
            name: "cjk",
            blocks: [
              [12288, 12543],
              [19968, 40879],
              [65280, 65376]
            ]
          }, {
            name: "hangul",
            blocks: [[44032, 55215]]
          }];
          function scriptFromCodepoint(codepoint) {
            for (var i = 0; i < scriptData.length; i++) {
              var script = scriptData[i];
              for (var _i = 0; _i < script.blocks.length; _i++) {
                var block2 = script.blocks[_i];
                if (codepoint >= block2[0] && codepoint <= block2[1]) {
                  return script.name;
                }
              }
            }
            return null;
          }
          var allBlocks = [];
          scriptData.forEach(function(s) {
            return s.blocks.forEach(function(b) {
              return allBlocks.push.apply(allBlocks, b);
            });
          });
          function supportedCodepoint(codepoint) {
            for (var i = 0; i < allBlocks.length; i += 2) {
              if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {
                return true;
              }
            }
            return false;
          }
          var hLinePad = 80;
          var sqrtMain = function sqrtMain2(extraViniculum, hLinePad2) {
            return "M95," + (622 + extraViniculum + hLinePad2) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraViniculum / 2.075 + " -" + extraViniculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraViniculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "h-400000z";
          };
          var sqrtSize1 = function sqrtSize12(extraViniculum, hLinePad2) {
            return "M263," + (601 + extraViniculum + hLinePad2) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraViniculum / 2.084 + " -" + extraViniculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraViniculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "h-400000z";
          };
          var sqrtSize2 = function sqrtSize22(extraViniculum, hLinePad2) {
            return "M983 " + (10 + extraViniculum + hLinePad2) + "\nl" + extraViniculum / 3.13 + " -" + extraViniculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraViniculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "h-400000z";
          };
          var sqrtSize3 = function sqrtSize32(extraViniculum, hLinePad2) {
            return "M424," + (2398 + extraViniculum + hLinePad2) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraViniculum / 4.223 + " -" + extraViniculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraViniculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraViniculum) + " " + hLinePad2 + "\nh400000v" + (40 + extraViniculum) + "h-400000z";
          };
          var sqrtSize4 = function sqrtSize42(extraViniculum, hLinePad2) {
            return "M473," + (2713 + extraViniculum + hLinePad2) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraViniculum / 5.298 + " -" + extraViniculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraViniculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "H1017.7z";
          };
          var sqrtTall = function sqrtTall2(extraViniculum, hLinePad2, viewBoxHeight) {
            var vertSegment = viewBoxHeight - 54 - hLinePad2 - extraViniculum;
            return "M702 " + (extraViniculum + hLinePad2) + "H400000" + (40 + extraViniculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad2 + "H400000v" + (40 + extraViniculum) + "H742z";
          };
          var sqrtPath = function sqrtPath2(size, extraViniculum, viewBoxHeight) {
            extraViniculum = 1e3 * extraViniculum;
            var path = "";
            switch (size) {
              case "sqrtMain":
                path = sqrtMain(extraViniculum, hLinePad);
                break;
              case "sqrtSize1":
                path = sqrtSize1(extraViniculum, hLinePad);
                break;
              case "sqrtSize2":
                path = sqrtSize2(extraViniculum, hLinePad);
                break;
              case "sqrtSize3":
                path = sqrtSize3(extraViniculum, hLinePad);
                break;
              case "sqrtSize4":
                path = sqrtSize4(extraViniculum, hLinePad);
                break;
              case "sqrtTall":
                path = sqrtTall(extraViniculum, hLinePad, viewBoxHeight);
            }
            return path;
          };
          var svgGeometry_path = {
            leftParenInner: "M291 0 H417 V300 H291 z",
            rightParenInner: "M457 0 H583 V300 H457 z",
            doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
            doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
            leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
            leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
            leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
            leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
            leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
            leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
            leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
            leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
            leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
            lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
            leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
            leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
            leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
            longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
            midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
            midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
            oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
            oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
            oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
            oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
            rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
            rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
            rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
            rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
            rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
            rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
            rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
            rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
            rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
            righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
            rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
            rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
            twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
            twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
            tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
            tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
            tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
            tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
            vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
            widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
            widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
            widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
            widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
            widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
            widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
            widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
            widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
            baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
            rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
            baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
            rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
            shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
            shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
          };
          var tree_DocumentFragment = /* @__PURE__ */ function() {
            function DocumentFragment(children2) {
              this.children = void 0;
              this.classes = void 0;
              this.height = void 0;
              this.depth = void 0;
              this.maxFontSize = void 0;
              this.style = void 0;
              this.children = children2;
              this.classes = [];
              this.height = 0;
              this.depth = 0;
              this.maxFontSize = 0;
              this.style = {};
            }
            var _proto = DocumentFragment.prototype;
            _proto.hasClass = function hasClass2(className) {
              return utils.contains(this.classes, className);
            };
            _proto.toNode = function toNode() {
              var frag = document.createDocumentFragment();
              for (var i = 0; i < this.children.length; i++) {
                frag.appendChild(this.children[i].toNode());
              }
              return frag;
            };
            _proto.toMarkup = function toMarkup() {
              var markup = "";
              for (var i = 0; i < this.children.length; i++) {
                markup += this.children[i].toMarkup();
              }
              return markup;
            };
            _proto.toText = function toText() {
              var toText2 = function toText3(child) {
                return child.toText();
              };
              return this.children.map(toText2).join("");
            };
            return DocumentFragment;
          }();
          var createClass = function createClass2(classes) {
            return classes.filter(function(cls) {
              return cls;
            }).join(" ");
          };
          var initNode = function initNode2(classes, options, style) {
            this.classes = classes || [];
            this.attributes = {};
            this.height = 0;
            this.depth = 0;
            this.maxFontSize = 0;
            this.style = style || {};
            if (options) {
              if (options.style.isTight()) {
                this.classes.push("mtight");
              }
              var color = options.getColor();
              if (color) {
                this.style.color = color;
              }
            }
          };
          var _toNode = function toNode(tagName) {
            var node = document.createElement(tagName);
            node.className = createClass(this.classes);
            for (var style in this.style) {
              if (this.style.hasOwnProperty(style)) {
                node.style[style] = this.style[style];
              }
            }
            for (var attr2 in this.attributes) {
              if (this.attributes.hasOwnProperty(attr2)) {
                node.setAttribute(attr2, this.attributes[attr2]);
              }
            }
            for (var i = 0; i < this.children.length; i++) {
              node.appendChild(this.children[i].toNode());
            }
            return node;
          };
          var _toMarkup = function toMarkup(tagName) {
            var markup = "<" + tagName;
            if (this.classes.length) {
              markup += ' class="' + utils.escape(createClass(this.classes)) + '"';
            }
            var styles2 = "";
            for (var style in this.style) {
              if (this.style.hasOwnProperty(style)) {
                styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
              }
            }
            if (styles2) {
              markup += ' style="' + utils.escape(styles2) + '"';
            }
            for (var attr2 in this.attributes) {
              if (this.attributes.hasOwnProperty(attr2)) {
                markup += " " + attr2 + '="' + utils.escape(this.attributes[attr2]) + '"';
              }
            }
            markup += ">";
            for (var i = 0; i < this.children.length; i++) {
              markup += this.children[i].toMarkup();
            }
            markup += "</" + tagName + ">";
            return markup;
          };
          var domTree_Span = /* @__PURE__ */ function() {
            function Span(classes, children2, options, style) {
              this.children = void 0;
              this.attributes = void 0;
              this.classes = void 0;
              this.height = void 0;
              this.depth = void 0;
              this.width = void 0;
              this.maxFontSize = void 0;
              this.style = void 0;
              initNode.call(this, classes, options, style);
              this.children = children2 || [];
            }
            var _proto = Span.prototype;
            _proto.setAttribute = function setAttribute(attribute2, value) {
              this.attributes[attribute2] = value;
            };
            _proto.hasClass = function hasClass2(className) {
              return utils.contains(this.classes, className);
            };
            _proto.toNode = function toNode() {
              return _toNode.call(this, "span");
            };
            _proto.toMarkup = function toMarkup() {
              return _toMarkup.call(this, "span");
            };
            return Span;
          }();
          var domTree_Anchor = /* @__PURE__ */ function() {
            function Anchor(href, classes, children2, options) {
              this.children = void 0;
              this.attributes = void 0;
              this.classes = void 0;
              this.height = void 0;
              this.depth = void 0;
              this.maxFontSize = void 0;
              this.style = void 0;
              initNode.call(this, classes, options);
              this.children = children2 || [];
              this.setAttribute("href", href);
            }
            var _proto2 = Anchor.prototype;
            _proto2.setAttribute = function setAttribute(attribute2, value) {
              this.attributes[attribute2] = value;
            };
            _proto2.hasClass = function hasClass2(className) {
              return utils.contains(this.classes, className);
            };
            _proto2.toNode = function toNode() {
              return _toNode.call(this, "a");
            };
            _proto2.toMarkup = function toMarkup() {
              return _toMarkup.call(this, "a");
            };
            return Anchor;
          }();
          var domTree_Img = /* @__PURE__ */ function() {
            function Img(src, alt, style) {
              this.src = void 0;
              this.alt = void 0;
              this.classes = void 0;
              this.height = void 0;
              this.depth = void 0;
              this.maxFontSize = void 0;
              this.style = void 0;
              this.alt = alt;
              this.src = src;
              this.classes = ["mord"];
              this.style = style;
            }
            var _proto3 = Img.prototype;
            _proto3.hasClass = function hasClass2(className) {
              return utils.contains(this.classes, className);
            };
            _proto3.toNode = function toNode() {
              var node = document.createElement("img");
              node.src = this.src;
              node.alt = this.alt;
              node.className = "mord";
              for (var style in this.style) {
                if (this.style.hasOwnProperty(style)) {
                  node.style[style] = this.style[style];
                }
              }
              return node;
            };
            _proto3.toMarkup = function toMarkup() {
              var markup = "<img  src='" + this.src + " 'alt='" + this.alt + "' ";
              var styles2 = "";
              for (var style in this.style) {
                if (this.style.hasOwnProperty(style)) {
                  styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
                }
              }
              if (styles2) {
                markup += ' style="' + utils.escape(styles2) + '"';
              }
              markup += "'/>";
              return markup;
            };
            return Img;
          }();
          var iCombinations = {
            "\xEE": "\u0131\u0302",
            "\xEF": "\u0131\u0308",
            "\xED": "\u0131\u0301",
            "\xEC": "\u0131\u0300"
          };
          var domTree_SymbolNode = /* @__PURE__ */ function() {
            function SymbolNode(text4, height, depth, italic, skew2, width, classes, style) {
              this.text = void 0;
              this.height = void 0;
              this.depth = void 0;
              this.italic = void 0;
              this.skew = void 0;
              this.width = void 0;
              this.maxFontSize = void 0;
              this.classes = void 0;
              this.style = void 0;
              this.text = text4;
              this.height = height || 0;
              this.depth = depth || 0;
              this.italic = italic || 0;
              this.skew = skew2 || 0;
              this.width = width || 0;
              this.classes = classes || [];
              this.style = style || {};
              this.maxFontSize = 0;
              var script = scriptFromCodepoint(this.text.charCodeAt(0));
              if (script) {
                this.classes.push(script + "_fallback");
              }
              if (/[îïíì]/.test(this.text)) {
                this.text = iCombinations[this.text];
              }
            }
            var _proto4 = SymbolNode.prototype;
            _proto4.hasClass = function hasClass2(className) {
              return utils.contains(this.classes, className);
            };
            _proto4.toNode = function toNode() {
              var node = document.createTextNode(this.text);
              var span = null;
              if (this.italic > 0) {
                span = document.createElement("span");
                span.style.marginRight = this.italic + "em";
              }
              if (this.classes.length > 0) {
                span = span || document.createElement("span");
                span.className = createClass(this.classes);
              }
              for (var style in this.style) {
                if (this.style.hasOwnProperty(style)) {
                  span = span || document.createElement("span");
                  span.style[style] = this.style[style];
                }
              }
              if (span) {
                span.appendChild(node);
                return span;
              } else {
                return node;
              }
            };
            _proto4.toMarkup = function toMarkup() {
              var needsSpan = false;
              var markup = "<span";
              if (this.classes.length) {
                needsSpan = true;
                markup += ' class="';
                markup += utils.escape(createClass(this.classes));
                markup += '"';
              }
              var styles2 = "";
              if (this.italic > 0) {
                styles2 += "margin-right:" + this.italic + "em;";
              }
              for (var style in this.style) {
                if (this.style.hasOwnProperty(style)) {
                  styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
                }
              }
              if (styles2) {
                needsSpan = true;
                markup += ' style="' + utils.escape(styles2) + '"';
              }
              var escaped = utils.escape(this.text);
              if (needsSpan) {
                markup += ">";
                markup += escaped;
                markup += "</span>";
                return markup;
              } else {
                return escaped;
              }
            };
            return SymbolNode;
          }();
          var SvgNode = /* @__PURE__ */ function() {
            function SvgNode2(children2, attributes2) {
              this.children = void 0;
              this.attributes = void 0;
              this.children = children2 || [];
              this.attributes = attributes2 || {};
            }
            var _proto5 = SvgNode2.prototype;
            _proto5.toNode = function toNode() {
              var svgNS = "http://www.w3.org/2000/svg";
              var node = document.createElementNS(svgNS, "svg");
              for (var attr2 in this.attributes) {
                if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                  node.setAttribute(attr2, this.attributes[attr2]);
                }
              }
              for (var i = 0; i < this.children.length; i++) {
                node.appendChild(this.children[i].toNode());
              }
              return node;
            };
            _proto5.toMarkup = function toMarkup() {
              var markup = "<svg";
              for (var attr2 in this.attributes) {
                if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                  markup += " " + attr2 + "='" + this.attributes[attr2] + "'";
                }
              }
              markup += ">";
              for (var i = 0; i < this.children.length; i++) {
                markup += this.children[i].toMarkup();
              }
              markup += "</svg>";
              return markup;
            };
            return SvgNode2;
          }();
          var domTree_PathNode = /* @__PURE__ */ function() {
            function PathNode(pathName, alternate) {
              this.pathName = void 0;
              this.alternate = void 0;
              this.pathName = pathName;
              this.alternate = alternate;
            }
            var _proto6 = PathNode.prototype;
            _proto6.toNode = function toNode() {
              var svgNS = "http://www.w3.org/2000/svg";
              var node = document.createElementNS(svgNS, "path");
              if (this.alternate) {
                node.setAttribute("d", this.alternate);
              } else {
                node.setAttribute("d", svgGeometry_path[this.pathName]);
              }
              return node;
            };
            _proto6.toMarkup = function toMarkup() {
              if (this.alternate) {
                return "<path d='" + this.alternate + "'/>";
              } else {
                return "<path d='" + svgGeometry_path[this.pathName] + "'/>";
              }
            };
            return PathNode;
          }();
          var LineNode = /* @__PURE__ */ function() {
            function LineNode2(attributes2) {
              this.attributes = void 0;
              this.attributes = attributes2 || {};
            }
            var _proto7 = LineNode2.prototype;
            _proto7.toNode = function toNode() {
              var svgNS = "http://www.w3.org/2000/svg";
              var node = document.createElementNS(svgNS, "line");
              for (var attr2 in this.attributes) {
                if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                  node.setAttribute(attr2, this.attributes[attr2]);
                }
              }
              return node;
            };
            _proto7.toMarkup = function toMarkup() {
              var markup = "<line";
              for (var attr2 in this.attributes) {
                if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                  markup += " " + attr2 + "='" + this.attributes[attr2] + "'";
                }
              }
              markup += "/>";
              return markup;
            };
            return LineNode2;
          }();
          function assertSymbolDomNode(group) {
            if (group instanceof domTree_SymbolNode) {
              return group;
            } else {
              throw new Error("Expected symbolNode but got " + String(group) + ".");
            }
          }
          function assertSpan(group) {
            if (group instanceof domTree_Span) {
              return group;
            } else {
              throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
            }
          }
          var fontMetricsData = {
            "AMS-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "65": [0, 0.68889, 0, 0, 0.72222],
              "66": [0, 0.68889, 0, 0, 0.66667],
              "67": [0, 0.68889, 0, 0, 0.72222],
              "68": [0, 0.68889, 0, 0, 0.72222],
              "69": [0, 0.68889, 0, 0, 0.66667],
              "70": [0, 0.68889, 0, 0, 0.61111],
              "71": [0, 0.68889, 0, 0, 0.77778],
              "72": [0, 0.68889, 0, 0, 0.77778],
              "73": [0, 0.68889, 0, 0, 0.38889],
              "74": [0.16667, 0.68889, 0, 0, 0.5],
              "75": [0, 0.68889, 0, 0, 0.77778],
              "76": [0, 0.68889, 0, 0, 0.66667],
              "77": [0, 0.68889, 0, 0, 0.94445],
              "78": [0, 0.68889, 0, 0, 0.72222],
              "79": [0.16667, 0.68889, 0, 0, 0.77778],
              "80": [0, 0.68889, 0, 0, 0.61111],
              "81": [0.16667, 0.68889, 0, 0, 0.77778],
              "82": [0, 0.68889, 0, 0, 0.72222],
              "83": [0, 0.68889, 0, 0, 0.55556],
              "84": [0, 0.68889, 0, 0, 0.66667],
              "85": [0, 0.68889, 0, 0, 0.72222],
              "86": [0, 0.68889, 0, 0, 0.72222],
              "87": [0, 0.68889, 0, 0, 1],
              "88": [0, 0.68889, 0, 0, 0.72222],
              "89": [0, 0.68889, 0, 0, 0.72222],
              "90": [0, 0.68889, 0, 0, 0.66667],
              "107": [0, 0.68889, 0, 0, 0.55556],
              "160": [0, 0, 0, 0, 0.25],
              "165": [0, 0.675, 0.025, 0, 0.75],
              "174": [0.15559, 0.69224, 0, 0, 0.94666],
              "240": [0, 0.68889, 0, 0, 0.55556],
              "295": [0, 0.68889, 0, 0, 0.54028],
              "710": [0, 0.825, 0, 0, 2.33334],
              "732": [0, 0.9, 0, 0, 2.33334],
              "770": [0, 0.825, 0, 0, 2.33334],
              "771": [0, 0.9, 0, 0, 2.33334],
              "989": [0.08167, 0.58167, 0, 0, 0.77778],
              "1008": [0, 0.43056, 0.04028, 0, 0.66667],
              "8245": [0, 0.54986, 0, 0, 0.275],
              "8463": [0, 0.68889, 0, 0, 0.54028],
              "8487": [0, 0.68889, 0, 0, 0.72222],
              "8498": [0, 0.68889, 0, 0, 0.55556],
              "8502": [0, 0.68889, 0, 0, 0.66667],
              "8503": [0, 0.68889, 0, 0, 0.44445],
              "8504": [0, 0.68889, 0, 0, 0.66667],
              "8513": [0, 0.68889, 0, 0, 0.63889],
              "8592": [-0.03598, 0.46402, 0, 0, 0.5],
              "8594": [-0.03598, 0.46402, 0, 0, 0.5],
              "8602": [-0.13313, 0.36687, 0, 0, 1],
              "8603": [-0.13313, 0.36687, 0, 0, 1],
              "8606": [0.01354, 0.52239, 0, 0, 1],
              "8608": [0.01354, 0.52239, 0, 0, 1],
              "8610": [0.01354, 0.52239, 0, 0, 1.11111],
              "8611": [0.01354, 0.52239, 0, 0, 1.11111],
              "8619": [0, 0.54986, 0, 0, 1],
              "8620": [0, 0.54986, 0, 0, 1],
              "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
              "8622": [-0.13313, 0.36687, 0, 0, 1],
              "8624": [0, 0.69224, 0, 0, 0.5],
              "8625": [0, 0.69224, 0, 0, 0.5],
              "8630": [0, 0.43056, 0, 0, 1],
              "8631": [0, 0.43056, 0, 0, 1],
              "8634": [0.08198, 0.58198, 0, 0, 0.77778],
              "8635": [0.08198, 0.58198, 0, 0, 0.77778],
              "8638": [0.19444, 0.69224, 0, 0, 0.41667],
              "8639": [0.19444, 0.69224, 0, 0, 0.41667],
              "8642": [0.19444, 0.69224, 0, 0, 0.41667],
              "8643": [0.19444, 0.69224, 0, 0, 0.41667],
              "8644": [0.1808, 0.675, 0, 0, 1],
              "8646": [0.1808, 0.675, 0, 0, 1],
              "8647": [0.1808, 0.675, 0, 0, 1],
              "8648": [0.19444, 0.69224, 0, 0, 0.83334],
              "8649": [0.1808, 0.675, 0, 0, 1],
              "8650": [0.19444, 0.69224, 0, 0, 0.83334],
              "8651": [0.01354, 0.52239, 0, 0, 1],
              "8652": [0.01354, 0.52239, 0, 0, 1],
              "8653": [-0.13313, 0.36687, 0, 0, 1],
              "8654": [-0.13313, 0.36687, 0, 0, 1],
              "8655": [-0.13313, 0.36687, 0, 0, 1],
              "8666": [0.13667, 0.63667, 0, 0, 1],
              "8667": [0.13667, 0.63667, 0, 0, 1],
              "8669": [-0.13313, 0.37788, 0, 0, 1],
              "8672": [-0.064, 0.437, 0, 0, 1.334],
              "8674": [-0.064, 0.437, 0, 0, 1.334],
              "8705": [0, 0.825, 0, 0, 0.5],
              "8708": [0, 0.68889, 0, 0, 0.55556],
              "8709": [0.08167, 0.58167, 0, 0, 0.77778],
              "8717": [0, 0.43056, 0, 0, 0.42917],
              "8722": [-0.03598, 0.46402, 0, 0, 0.5],
              "8724": [0.08198, 0.69224, 0, 0, 0.77778],
              "8726": [0.08167, 0.58167, 0, 0, 0.77778],
              "8733": [0, 0.69224, 0, 0, 0.77778],
              "8736": [0, 0.69224, 0, 0, 0.72222],
              "8737": [0, 0.69224, 0, 0, 0.72222],
              "8738": [0.03517, 0.52239, 0, 0, 0.72222],
              "8739": [0.08167, 0.58167, 0, 0, 0.22222],
              "8740": [0.25142, 0.74111, 0, 0, 0.27778],
              "8741": [0.08167, 0.58167, 0, 0, 0.38889],
              "8742": [0.25142, 0.74111, 0, 0, 0.5],
              "8756": [0, 0.69224, 0, 0, 0.66667],
              "8757": [0, 0.69224, 0, 0, 0.66667],
              "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
              "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
              "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
              "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
              "8774": [0.30274, 0.79383, 0, 0, 0.77778],
              "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
              "8778": [0.08167, 0.58167, 0, 0, 0.77778],
              "8782": [0.06062, 0.54986, 0, 0, 0.77778],
              "8783": [0.06062, 0.54986, 0, 0, 0.77778],
              "8785": [0.08198, 0.58198, 0, 0, 0.77778],
              "8786": [0.08198, 0.58198, 0, 0, 0.77778],
              "8787": [0.08198, 0.58198, 0, 0, 0.77778],
              "8790": [0, 0.69224, 0, 0, 0.77778],
              "8791": [0.22958, 0.72958, 0, 0, 0.77778],
              "8796": [0.08198, 0.91667, 0, 0, 0.77778],
              "8806": [0.25583, 0.75583, 0, 0, 0.77778],
              "8807": [0.25583, 0.75583, 0, 0, 0.77778],
              "8808": [0.25142, 0.75726, 0, 0, 0.77778],
              "8809": [0.25142, 0.75726, 0, 0, 0.77778],
              "8812": [0.25583, 0.75583, 0, 0, 0.5],
              "8814": [0.20576, 0.70576, 0, 0, 0.77778],
              "8815": [0.20576, 0.70576, 0, 0, 0.77778],
              "8816": [0.30274, 0.79383, 0, 0, 0.77778],
              "8817": [0.30274, 0.79383, 0, 0, 0.77778],
              "8818": [0.22958, 0.72958, 0, 0, 0.77778],
              "8819": [0.22958, 0.72958, 0, 0, 0.77778],
              "8822": [0.1808, 0.675, 0, 0, 0.77778],
              "8823": [0.1808, 0.675, 0, 0, 0.77778],
              "8828": [0.13667, 0.63667, 0, 0, 0.77778],
              "8829": [0.13667, 0.63667, 0, 0, 0.77778],
              "8830": [0.22958, 0.72958, 0, 0, 0.77778],
              "8831": [0.22958, 0.72958, 0, 0, 0.77778],
              "8832": [0.20576, 0.70576, 0, 0, 0.77778],
              "8833": [0.20576, 0.70576, 0, 0, 0.77778],
              "8840": [0.30274, 0.79383, 0, 0, 0.77778],
              "8841": [0.30274, 0.79383, 0, 0, 0.77778],
              "8842": [0.13597, 0.63597, 0, 0, 0.77778],
              "8843": [0.13597, 0.63597, 0, 0, 0.77778],
              "8847": [0.03517, 0.54986, 0, 0, 0.77778],
              "8848": [0.03517, 0.54986, 0, 0, 0.77778],
              "8858": [0.08198, 0.58198, 0, 0, 0.77778],
              "8859": [0.08198, 0.58198, 0, 0, 0.77778],
              "8861": [0.08198, 0.58198, 0, 0, 0.77778],
              "8862": [0, 0.675, 0, 0, 0.77778],
              "8863": [0, 0.675, 0, 0, 0.77778],
              "8864": [0, 0.675, 0, 0, 0.77778],
              "8865": [0, 0.675, 0, 0, 0.77778],
              "8872": [0, 0.69224, 0, 0, 0.61111],
              "8873": [0, 0.69224, 0, 0, 0.72222],
              "8874": [0, 0.69224, 0, 0, 0.88889],
              "8876": [0, 0.68889, 0, 0, 0.61111],
              "8877": [0, 0.68889, 0, 0, 0.61111],
              "8878": [0, 0.68889, 0, 0, 0.72222],
              "8879": [0, 0.68889, 0, 0, 0.72222],
              "8882": [0.03517, 0.54986, 0, 0, 0.77778],
              "8883": [0.03517, 0.54986, 0, 0, 0.77778],
              "8884": [0.13667, 0.63667, 0, 0, 0.77778],
              "8885": [0.13667, 0.63667, 0, 0, 0.77778],
              "8888": [0, 0.54986, 0, 0, 1.11111],
              "8890": [0.19444, 0.43056, 0, 0, 0.55556],
              "8891": [0.19444, 0.69224, 0, 0, 0.61111],
              "8892": [0.19444, 0.69224, 0, 0, 0.61111],
              "8901": [0, 0.54986, 0, 0, 0.27778],
              "8903": [0.08167, 0.58167, 0, 0, 0.77778],
              "8905": [0.08167, 0.58167, 0, 0, 0.77778],
              "8906": [0.08167, 0.58167, 0, 0, 0.77778],
              "8907": [0, 0.69224, 0, 0, 0.77778],
              "8908": [0, 0.69224, 0, 0, 0.77778],
              "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
              "8910": [0, 0.54986, 0, 0, 0.76042],
              "8911": [0, 0.54986, 0, 0, 0.76042],
              "8912": [0.03517, 0.54986, 0, 0, 0.77778],
              "8913": [0.03517, 0.54986, 0, 0, 0.77778],
              "8914": [0, 0.54986, 0, 0, 0.66667],
              "8915": [0, 0.54986, 0, 0, 0.66667],
              "8916": [0, 0.69224, 0, 0, 0.66667],
              "8918": [0.0391, 0.5391, 0, 0, 0.77778],
              "8919": [0.0391, 0.5391, 0, 0, 0.77778],
              "8920": [0.03517, 0.54986, 0, 0, 1.33334],
              "8921": [0.03517, 0.54986, 0, 0, 1.33334],
              "8922": [0.38569, 0.88569, 0, 0, 0.77778],
              "8923": [0.38569, 0.88569, 0, 0, 0.77778],
              "8926": [0.13667, 0.63667, 0, 0, 0.77778],
              "8927": [0.13667, 0.63667, 0, 0, 0.77778],
              "8928": [0.30274, 0.79383, 0, 0, 0.77778],
              "8929": [0.30274, 0.79383, 0, 0, 0.77778],
              "8934": [0.23222, 0.74111, 0, 0, 0.77778],
              "8935": [0.23222, 0.74111, 0, 0, 0.77778],
              "8936": [0.23222, 0.74111, 0, 0, 0.77778],
              "8937": [0.23222, 0.74111, 0, 0, 0.77778],
              "8938": [0.20576, 0.70576, 0, 0, 0.77778],
              "8939": [0.20576, 0.70576, 0, 0, 0.77778],
              "8940": [0.30274, 0.79383, 0, 0, 0.77778],
              "8941": [0.30274, 0.79383, 0, 0, 0.77778],
              "8994": [0.19444, 0.69224, 0, 0, 0.77778],
              "8995": [0.19444, 0.69224, 0, 0, 0.77778],
              "9416": [0.15559, 0.69224, 0, 0, 0.90222],
              "9484": [0, 0.69224, 0, 0, 0.5],
              "9488": [0, 0.69224, 0, 0, 0.5],
              "9492": [0, 0.37788, 0, 0, 0.5],
              "9496": [0, 0.37788, 0, 0, 0.5],
              "9585": [0.19444, 0.68889, 0, 0, 0.88889],
              "9586": [0.19444, 0.74111, 0, 0, 0.88889],
              "9632": [0, 0.675, 0, 0, 0.77778],
              "9633": [0, 0.675, 0, 0, 0.77778],
              "9650": [0, 0.54986, 0, 0, 0.72222],
              "9651": [0, 0.54986, 0, 0, 0.72222],
              "9654": [0.03517, 0.54986, 0, 0, 0.77778],
              "9660": [0, 0.54986, 0, 0, 0.72222],
              "9661": [0, 0.54986, 0, 0, 0.72222],
              "9664": [0.03517, 0.54986, 0, 0, 0.77778],
              "9674": [0.11111, 0.69224, 0, 0, 0.66667],
              "9733": [0.19444, 0.69224, 0, 0, 0.94445],
              "10003": [0, 0.69224, 0, 0, 0.83334],
              "10016": [0, 0.69224, 0, 0, 0.83334],
              "10731": [0.11111, 0.69224, 0, 0, 0.66667],
              "10846": [0.19444, 0.75583, 0, 0, 0.61111],
              "10877": [0.13667, 0.63667, 0, 0, 0.77778],
              "10878": [0.13667, 0.63667, 0, 0, 0.77778],
              "10885": [0.25583, 0.75583, 0, 0, 0.77778],
              "10886": [0.25583, 0.75583, 0, 0, 0.77778],
              "10887": [0.13597, 0.63597, 0, 0, 0.77778],
              "10888": [0.13597, 0.63597, 0, 0, 0.77778],
              "10889": [0.26167, 0.75726, 0, 0, 0.77778],
              "10890": [0.26167, 0.75726, 0, 0, 0.77778],
              "10891": [0.48256, 0.98256, 0, 0, 0.77778],
              "10892": [0.48256, 0.98256, 0, 0, 0.77778],
              "10901": [0.13667, 0.63667, 0, 0, 0.77778],
              "10902": [0.13667, 0.63667, 0, 0, 0.77778],
              "10933": [0.25142, 0.75726, 0, 0, 0.77778],
              "10934": [0.25142, 0.75726, 0, 0, 0.77778],
              "10935": [0.26167, 0.75726, 0, 0, 0.77778],
              "10936": [0.26167, 0.75726, 0, 0, 0.77778],
              "10937": [0.26167, 0.75726, 0, 0, 0.77778],
              "10938": [0.26167, 0.75726, 0, 0, 0.77778],
              "10949": [0.25583, 0.75583, 0, 0, 0.77778],
              "10950": [0.25583, 0.75583, 0, 0, 0.77778],
              "10955": [0.28481, 0.79383, 0, 0, 0.77778],
              "10956": [0.28481, 0.79383, 0, 0, 0.77778],
              "57350": [0.08167, 0.58167, 0, 0, 0.22222],
              "57351": [0.08167, 0.58167, 0, 0, 0.38889],
              "57352": [0.08167, 0.58167, 0, 0, 0.77778],
              "57353": [0, 0.43056, 0.04028, 0, 0.66667],
              "57356": [0.25142, 0.75726, 0, 0, 0.77778],
              "57357": [0.25142, 0.75726, 0, 0, 0.77778],
              "57358": [0.41951, 0.91951, 0, 0, 0.77778],
              "57359": [0.30274, 0.79383, 0, 0, 0.77778],
              "57360": [0.30274, 0.79383, 0, 0, 0.77778],
              "57361": [0.41951, 0.91951, 0, 0, 0.77778],
              "57366": [0.25142, 0.75726, 0, 0, 0.77778],
              "57367": [0.25142, 0.75726, 0, 0, 0.77778],
              "57368": [0.25142, 0.75726, 0, 0, 0.77778],
              "57369": [0.25142, 0.75726, 0, 0, 0.77778],
              "57370": [0.13597, 0.63597, 0, 0, 0.77778],
              "57371": [0.13597, 0.63597, 0, 0, 0.77778]
            },
            "Caligraphic-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "65": [0, 0.68333, 0, 0.19445, 0.79847],
              "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
              "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
              "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
              "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
              "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
              "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
              "72": [0, 0.68333, 965e-5, 0.11111, 0.84452],
              "73": [0, 0.68333, 0.07382, 0, 0.54452],
              "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
              "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
              "76": [0, 0.68333, 0, 0.13889, 0.68972],
              "77": [0, 0.68333, 0, 0.13889, 1.2009],
              "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
              "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
              "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
              "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
              "82": [0, 0.68333, 0, 0.08334, 0.8475],
              "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
              "84": [0, 0.68333, 0.25417, 0, 0.54464],
              "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
              "86": [0, 0.68333, 0.08222, 0, 0.61278],
              "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
              "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
              "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
              "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
              "160": [0, 0, 0, 0, 0.25]
            },
            "Fraktur-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69141, 0, 0, 0.29574],
              "34": [0, 0.69141, 0, 0, 0.21471],
              "38": [0, 0.69141, 0, 0, 0.73786],
              "39": [0, 0.69141, 0, 0, 0.21201],
              "40": [0.24982, 0.74947, 0, 0, 0.38865],
              "41": [0.24982, 0.74947, 0, 0, 0.38865],
              "42": [0, 0.62119, 0, 0, 0.27764],
              "43": [0.08319, 0.58283, 0, 0, 0.75623],
              "44": [0, 0.10803, 0, 0, 0.27764],
              "45": [0.08319, 0.58283, 0, 0, 0.75623],
              "46": [0, 0.10803, 0, 0, 0.27764],
              "47": [0.24982, 0.74947, 0, 0, 0.50181],
              "48": [0, 0.47534, 0, 0, 0.50181],
              "49": [0, 0.47534, 0, 0, 0.50181],
              "50": [0, 0.47534, 0, 0, 0.50181],
              "51": [0.18906, 0.47534, 0, 0, 0.50181],
              "52": [0.18906, 0.47534, 0, 0, 0.50181],
              "53": [0.18906, 0.47534, 0, 0, 0.50181],
              "54": [0, 0.69141, 0, 0, 0.50181],
              "55": [0.18906, 0.47534, 0, 0, 0.50181],
              "56": [0, 0.69141, 0, 0, 0.50181],
              "57": [0.18906, 0.47534, 0, 0, 0.50181],
              "58": [0, 0.47534, 0, 0, 0.21606],
              "59": [0.12604, 0.47534, 0, 0, 0.21606],
              "61": [-0.13099, 0.36866, 0, 0, 0.75623],
              "63": [0, 0.69141, 0, 0, 0.36245],
              "65": [0, 0.69141, 0, 0, 0.7176],
              "66": [0, 0.69141, 0, 0, 0.88397],
              "67": [0, 0.69141, 0, 0, 0.61254],
              "68": [0, 0.69141, 0, 0, 0.83158],
              "69": [0, 0.69141, 0, 0, 0.66278],
              "70": [0.12604, 0.69141, 0, 0, 0.61119],
              "71": [0, 0.69141, 0, 0, 0.78539],
              "72": [0.06302, 0.69141, 0, 0, 0.7203],
              "73": [0, 0.69141, 0, 0, 0.55448],
              "74": [0.12604, 0.69141, 0, 0, 0.55231],
              "75": [0, 0.69141, 0, 0, 0.66845],
              "76": [0, 0.69141, 0, 0, 0.66602],
              "77": [0, 0.69141, 0, 0, 1.04953],
              "78": [0, 0.69141, 0, 0, 0.83212],
              "79": [0, 0.69141, 0, 0, 0.82699],
              "80": [0.18906, 0.69141, 0, 0, 0.82753],
              "81": [0.03781, 0.69141, 0, 0, 0.82699],
              "82": [0, 0.69141, 0, 0, 0.82807],
              "83": [0, 0.69141, 0, 0, 0.82861],
              "84": [0, 0.69141, 0, 0, 0.66899],
              "85": [0, 0.69141, 0, 0, 0.64576],
              "86": [0, 0.69141, 0, 0, 0.83131],
              "87": [0, 0.69141, 0, 0, 1.04602],
              "88": [0, 0.69141, 0, 0, 0.71922],
              "89": [0.18906, 0.69141, 0, 0, 0.83293],
              "90": [0.12604, 0.69141, 0, 0, 0.60201],
              "91": [0.24982, 0.74947, 0, 0, 0.27764],
              "93": [0.24982, 0.74947, 0, 0, 0.27764],
              "94": [0, 0.69141, 0, 0, 0.49965],
              "97": [0, 0.47534, 0, 0, 0.50046],
              "98": [0, 0.69141, 0, 0, 0.51315],
              "99": [0, 0.47534, 0, 0, 0.38946],
              "100": [0, 0.62119, 0, 0, 0.49857],
              "101": [0, 0.47534, 0, 0, 0.40053],
              "102": [0.18906, 0.69141, 0, 0, 0.32626],
              "103": [0.18906, 0.47534, 0, 0, 0.5037],
              "104": [0.18906, 0.69141, 0, 0, 0.52126],
              "105": [0, 0.69141, 0, 0, 0.27899],
              "106": [0, 0.69141, 0, 0, 0.28088],
              "107": [0, 0.69141, 0, 0, 0.38946],
              "108": [0, 0.69141, 0, 0, 0.27953],
              "109": [0, 0.47534, 0, 0, 0.76676],
              "110": [0, 0.47534, 0, 0, 0.52666],
              "111": [0, 0.47534, 0, 0, 0.48885],
              "112": [0.18906, 0.52396, 0, 0, 0.50046],
              "113": [0.18906, 0.47534, 0, 0, 0.48912],
              "114": [0, 0.47534, 0, 0, 0.38919],
              "115": [0, 0.47534, 0, 0, 0.44266],
              "116": [0, 0.62119, 0, 0, 0.33301],
              "117": [0, 0.47534, 0, 0, 0.5172],
              "118": [0, 0.52396, 0, 0, 0.5118],
              "119": [0, 0.52396, 0, 0, 0.77351],
              "120": [0.18906, 0.47534, 0, 0, 0.38865],
              "121": [0.18906, 0.47534, 0, 0, 0.49884],
              "122": [0.18906, 0.47534, 0, 0, 0.39054],
              "160": [0, 0, 0, 0, 0.25],
              "8216": [0, 0.69141, 0, 0, 0.21471],
              "8217": [0, 0.69141, 0, 0, 0.21471],
              "58112": [0, 0.62119, 0, 0, 0.49749],
              "58113": [0, 0.62119, 0, 0, 0.4983],
              "58114": [0.18906, 0.69141, 0, 0, 0.33328],
              "58115": [0.18906, 0.69141, 0, 0, 0.32923],
              "58116": [0.18906, 0.47534, 0, 0, 0.50343],
              "58117": [0, 0.69141, 0, 0, 0.33301],
              "58118": [0, 0.62119, 0, 0, 0.33409],
              "58119": [0, 0.47534, 0, 0, 0.50073]
            },
            "Main-Bold": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69444, 0, 0, 0.35],
              "34": [0, 0.69444, 0, 0, 0.60278],
              "35": [0.19444, 0.69444, 0, 0, 0.95833],
              "36": [0.05556, 0.75, 0, 0, 0.575],
              "37": [0.05556, 0.75, 0, 0, 0.95833],
              "38": [0, 0.69444, 0, 0, 0.89444],
              "39": [0, 0.69444, 0, 0, 0.31944],
              "40": [0.25, 0.75, 0, 0, 0.44722],
              "41": [0.25, 0.75, 0, 0, 0.44722],
              "42": [0, 0.75, 0, 0, 0.575],
              "43": [0.13333, 0.63333, 0, 0, 0.89444],
              "44": [0.19444, 0.15556, 0, 0, 0.31944],
              "45": [0, 0.44444, 0, 0, 0.38333],
              "46": [0, 0.15556, 0, 0, 0.31944],
              "47": [0.25, 0.75, 0, 0, 0.575],
              "48": [0, 0.64444, 0, 0, 0.575],
              "49": [0, 0.64444, 0, 0, 0.575],
              "50": [0, 0.64444, 0, 0, 0.575],
              "51": [0, 0.64444, 0, 0, 0.575],
              "52": [0, 0.64444, 0, 0, 0.575],
              "53": [0, 0.64444, 0, 0, 0.575],
              "54": [0, 0.64444, 0, 0, 0.575],
              "55": [0, 0.64444, 0, 0, 0.575],
              "56": [0, 0.64444, 0, 0, 0.575],
              "57": [0, 0.64444, 0, 0, 0.575],
              "58": [0, 0.44444, 0, 0, 0.31944],
              "59": [0.19444, 0.44444, 0, 0, 0.31944],
              "60": [0.08556, 0.58556, 0, 0, 0.89444],
              "61": [-0.10889, 0.39111, 0, 0, 0.89444],
              "62": [0.08556, 0.58556, 0, 0, 0.89444],
              "63": [0, 0.69444, 0, 0, 0.54305],
              "64": [0, 0.69444, 0, 0, 0.89444],
              "65": [0, 0.68611, 0, 0, 0.86944],
              "66": [0, 0.68611, 0, 0, 0.81805],
              "67": [0, 0.68611, 0, 0, 0.83055],
              "68": [0, 0.68611, 0, 0, 0.88194],
              "69": [0, 0.68611, 0, 0, 0.75555],
              "70": [0, 0.68611, 0, 0, 0.72361],
              "71": [0, 0.68611, 0, 0, 0.90416],
              "72": [0, 0.68611, 0, 0, 0.9],
              "73": [0, 0.68611, 0, 0, 0.43611],
              "74": [0, 0.68611, 0, 0, 0.59444],
              "75": [0, 0.68611, 0, 0, 0.90138],
              "76": [0, 0.68611, 0, 0, 0.69166],
              "77": [0, 0.68611, 0, 0, 1.09166],
              "78": [0, 0.68611, 0, 0, 0.9],
              "79": [0, 0.68611, 0, 0, 0.86388],
              "80": [0, 0.68611, 0, 0, 0.78611],
              "81": [0.19444, 0.68611, 0, 0, 0.86388],
              "82": [0, 0.68611, 0, 0, 0.8625],
              "83": [0, 0.68611, 0, 0, 0.63889],
              "84": [0, 0.68611, 0, 0, 0.8],
              "85": [0, 0.68611, 0, 0, 0.88472],
              "86": [0, 0.68611, 0.01597, 0, 0.86944],
              "87": [0, 0.68611, 0.01597, 0, 1.18888],
              "88": [0, 0.68611, 0, 0, 0.86944],
              "89": [0, 0.68611, 0.02875, 0, 0.86944],
              "90": [0, 0.68611, 0, 0, 0.70277],
              "91": [0.25, 0.75, 0, 0, 0.31944],
              "92": [0.25, 0.75, 0, 0, 0.575],
              "93": [0.25, 0.75, 0, 0, 0.31944],
              "94": [0, 0.69444, 0, 0, 0.575],
              "95": [0.31, 0.13444, 0.03194, 0, 0.575],
              "97": [0, 0.44444, 0, 0, 0.55902],
              "98": [0, 0.69444, 0, 0, 0.63889],
              "99": [0, 0.44444, 0, 0, 0.51111],
              "100": [0, 0.69444, 0, 0, 0.63889],
              "101": [0, 0.44444, 0, 0, 0.52708],
              "102": [0, 0.69444, 0.10903, 0, 0.35139],
              "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
              "104": [0, 0.69444, 0, 0, 0.63889],
              "105": [0, 0.69444, 0, 0, 0.31944],
              "106": [0.19444, 0.69444, 0, 0, 0.35139],
              "107": [0, 0.69444, 0, 0, 0.60694],
              "108": [0, 0.69444, 0, 0, 0.31944],
              "109": [0, 0.44444, 0, 0, 0.95833],
              "110": [0, 0.44444, 0, 0, 0.63889],
              "111": [0, 0.44444, 0, 0, 0.575],
              "112": [0.19444, 0.44444, 0, 0, 0.63889],
              "113": [0.19444, 0.44444, 0, 0, 0.60694],
              "114": [0, 0.44444, 0, 0, 0.47361],
              "115": [0, 0.44444, 0, 0, 0.45361],
              "116": [0, 0.63492, 0, 0, 0.44722],
              "117": [0, 0.44444, 0, 0, 0.63889],
              "118": [0, 0.44444, 0.01597, 0, 0.60694],
              "119": [0, 0.44444, 0.01597, 0, 0.83055],
              "120": [0, 0.44444, 0, 0, 0.60694],
              "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
              "122": [0, 0.44444, 0, 0, 0.51111],
              "123": [0.25, 0.75, 0, 0, 0.575],
              "124": [0.25, 0.75, 0, 0, 0.31944],
              "125": [0.25, 0.75, 0, 0, 0.575],
              "126": [0.35, 0.34444, 0, 0, 0.575],
              "160": [0, 0, 0, 0, 0.25],
              "163": [0, 0.69444, 0, 0, 0.86853],
              "168": [0, 0.69444, 0, 0, 0.575],
              "172": [0, 0.44444, 0, 0, 0.76666],
              "176": [0, 0.69444, 0, 0, 0.86944],
              "177": [0.13333, 0.63333, 0, 0, 0.89444],
              "184": [0.17014, 0, 0, 0, 0.51111],
              "198": [0, 0.68611, 0, 0, 1.04166],
              "215": [0.13333, 0.63333, 0, 0, 0.89444],
              "216": [0.04861, 0.73472, 0, 0, 0.89444],
              "223": [0, 0.69444, 0, 0, 0.59722],
              "230": [0, 0.44444, 0, 0, 0.83055],
              "247": [0.13333, 0.63333, 0, 0, 0.89444],
              "248": [0.09722, 0.54167, 0, 0, 0.575],
              "305": [0, 0.44444, 0, 0, 0.31944],
              "338": [0, 0.68611, 0, 0, 1.16944],
              "339": [0, 0.44444, 0, 0, 0.89444],
              "567": [0.19444, 0.44444, 0, 0, 0.35139],
              "710": [0, 0.69444, 0, 0, 0.575],
              "711": [0, 0.63194, 0, 0, 0.575],
              "713": [0, 0.59611, 0, 0, 0.575],
              "714": [0, 0.69444, 0, 0, 0.575],
              "715": [0, 0.69444, 0, 0, 0.575],
              "728": [0, 0.69444, 0, 0, 0.575],
              "729": [0, 0.69444, 0, 0, 0.31944],
              "730": [0, 0.69444, 0, 0, 0.86944],
              "732": [0, 0.69444, 0, 0, 0.575],
              "733": [0, 0.69444, 0, 0, 0.575],
              "915": [0, 0.68611, 0, 0, 0.69166],
              "916": [0, 0.68611, 0, 0, 0.95833],
              "920": [0, 0.68611, 0, 0, 0.89444],
              "923": [0, 0.68611, 0, 0, 0.80555],
              "926": [0, 0.68611, 0, 0, 0.76666],
              "928": [0, 0.68611, 0, 0, 0.9],
              "931": [0, 0.68611, 0, 0, 0.83055],
              "933": [0, 0.68611, 0, 0, 0.89444],
              "934": [0, 0.68611, 0, 0, 0.83055],
              "936": [0, 0.68611, 0, 0, 0.89444],
              "937": [0, 0.68611, 0, 0, 0.83055],
              "8211": [0, 0.44444, 0.03194, 0, 0.575],
              "8212": [0, 0.44444, 0.03194, 0, 1.14999],
              "8216": [0, 0.69444, 0, 0, 0.31944],
              "8217": [0, 0.69444, 0, 0, 0.31944],
              "8220": [0, 0.69444, 0, 0, 0.60278],
              "8221": [0, 0.69444, 0, 0, 0.60278],
              "8224": [0.19444, 0.69444, 0, 0, 0.51111],
              "8225": [0.19444, 0.69444, 0, 0, 0.51111],
              "8242": [0, 0.55556, 0, 0, 0.34444],
              "8407": [0, 0.72444, 0.15486, 0, 0.575],
              "8463": [0, 0.69444, 0, 0, 0.66759],
              "8465": [0, 0.69444, 0, 0, 0.83055],
              "8467": [0, 0.69444, 0, 0, 0.47361],
              "8472": [0.19444, 0.44444, 0, 0, 0.74027],
              "8476": [0, 0.69444, 0, 0, 0.83055],
              "8501": [0, 0.69444, 0, 0, 0.70277],
              "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8593": [0.19444, 0.69444, 0, 0, 0.575],
              "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8595": [0.19444, 0.69444, 0, 0, 0.575],
              "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8597": [0.25, 0.75, 0, 0, 0.575],
              "8598": [0.19444, 0.69444, 0, 0, 1.14999],
              "8599": [0.19444, 0.69444, 0, 0, 1.14999],
              "8600": [0.19444, 0.69444, 0, 0, 1.14999],
              "8601": [0.19444, 0.69444, 0, 0, 1.14999],
              "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8657": [0.19444, 0.69444, 0, 0, 0.70277],
              "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8659": [0.19444, 0.69444, 0, 0, 0.70277],
              "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8661": [0.25, 0.75, 0, 0, 0.70277],
              "8704": [0, 0.69444, 0, 0, 0.63889],
              "8706": [0, 0.69444, 0.06389, 0, 0.62847],
              "8707": [0, 0.69444, 0, 0, 0.63889],
              "8709": [0.05556, 0.75, 0, 0, 0.575],
              "8711": [0, 0.68611, 0, 0, 0.95833],
              "8712": [0.08556, 0.58556, 0, 0, 0.76666],
              "8715": [0.08556, 0.58556, 0, 0, 0.76666],
              "8722": [0.13333, 0.63333, 0, 0, 0.89444],
              "8723": [0.13333, 0.63333, 0, 0, 0.89444],
              "8725": [0.25, 0.75, 0, 0, 0.575],
              "8726": [0.25, 0.75, 0, 0, 0.575],
              "8727": [-0.02778, 0.47222, 0, 0, 0.575],
              "8728": [-0.02639, 0.47361, 0, 0, 0.575],
              "8729": [-0.02639, 0.47361, 0, 0, 0.575],
              "8730": [0.18, 0.82, 0, 0, 0.95833],
              "8733": [0, 0.44444, 0, 0, 0.89444],
              "8734": [0, 0.44444, 0, 0, 1.14999],
              "8736": [0, 0.69224, 0, 0, 0.72222],
              "8739": [0.25, 0.75, 0, 0, 0.31944],
              "8741": [0.25, 0.75, 0, 0, 0.575],
              "8743": [0, 0.55556, 0, 0, 0.76666],
              "8744": [0, 0.55556, 0, 0, 0.76666],
              "8745": [0, 0.55556, 0, 0, 0.76666],
              "8746": [0, 0.55556, 0, 0, 0.76666],
              "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
              "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
              "8768": [0.19444, 0.69444, 0, 0, 0.31944],
              "8771": [222e-5, 0.50222, 0, 0, 0.89444],
              "8776": [0.02444, 0.52444, 0, 0, 0.89444],
              "8781": [222e-5, 0.50222, 0, 0, 0.89444],
              "8801": [222e-5, 0.50222, 0, 0, 0.89444],
              "8804": [0.19667, 0.69667, 0, 0, 0.89444],
              "8805": [0.19667, 0.69667, 0, 0, 0.89444],
              "8810": [0.08556, 0.58556, 0, 0, 1.14999],
              "8811": [0.08556, 0.58556, 0, 0, 1.14999],
              "8826": [0.08556, 0.58556, 0, 0, 0.89444],
              "8827": [0.08556, 0.58556, 0, 0, 0.89444],
              "8834": [0.08556, 0.58556, 0, 0, 0.89444],
              "8835": [0.08556, 0.58556, 0, 0, 0.89444],
              "8838": [0.19667, 0.69667, 0, 0, 0.89444],
              "8839": [0.19667, 0.69667, 0, 0, 0.89444],
              "8846": [0, 0.55556, 0, 0, 0.76666],
              "8849": [0.19667, 0.69667, 0, 0, 0.89444],
              "8850": [0.19667, 0.69667, 0, 0, 0.89444],
              "8851": [0, 0.55556, 0, 0, 0.76666],
              "8852": [0, 0.55556, 0, 0, 0.76666],
              "8853": [0.13333, 0.63333, 0, 0, 0.89444],
              "8854": [0.13333, 0.63333, 0, 0, 0.89444],
              "8855": [0.13333, 0.63333, 0, 0, 0.89444],
              "8856": [0.13333, 0.63333, 0, 0, 0.89444],
              "8857": [0.13333, 0.63333, 0, 0, 0.89444],
              "8866": [0, 0.69444, 0, 0, 0.70277],
              "8867": [0, 0.69444, 0, 0, 0.70277],
              "8868": [0, 0.69444, 0, 0, 0.89444],
              "8869": [0, 0.69444, 0, 0, 0.89444],
              "8900": [-0.02639, 0.47361, 0, 0, 0.575],
              "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
              "8902": [-0.02778, 0.47222, 0, 0, 0.575],
              "8968": [0.25, 0.75, 0, 0, 0.51111],
              "8969": [0.25, 0.75, 0, 0, 0.51111],
              "8970": [0.25, 0.75, 0, 0, 0.51111],
              "8971": [0.25, 0.75, 0, 0, 0.51111],
              "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
              "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
              "9651": [0.19444, 0.69444, 0, 0, 1.02222],
              "9657": [-0.02778, 0.47222, 0, 0, 0.575],
              "9661": [0.19444, 0.69444, 0, 0, 1.02222],
              "9667": [-0.02778, 0.47222, 0, 0, 0.575],
              "9711": [0.19444, 0.69444, 0, 0, 1.14999],
              "9824": [0.12963, 0.69444, 0, 0, 0.89444],
              "9825": [0.12963, 0.69444, 0, 0, 0.89444],
              "9826": [0.12963, 0.69444, 0, 0, 0.89444],
              "9827": [0.12963, 0.69444, 0, 0, 0.89444],
              "9837": [0, 0.75, 0, 0, 0.44722],
              "9838": [0.19444, 0.69444, 0, 0, 0.44722],
              "9839": [0.19444, 0.69444, 0, 0, 0.44722],
              "10216": [0.25, 0.75, 0, 0, 0.44722],
              "10217": [0.25, 0.75, 0, 0, 0.44722],
              "10815": [0, 0.68611, 0, 0, 0.9],
              "10927": [0.19667, 0.69667, 0, 0, 0.89444],
              "10928": [0.19667, 0.69667, 0, 0, 0.89444],
              "57376": [0.19444, 0.69444, 0, 0, 0]
            },
            "Main-BoldItalic": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69444, 0.11417, 0, 0.38611],
              "34": [0, 0.69444, 0.07939, 0, 0.62055],
              "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
              "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
              "38": [0, 0.69444, 0.08528, 0, 0.88555],
              "39": [0, 0.69444, 0.12945, 0, 0.35555],
              "40": [0.25, 0.75, 0.15806, 0, 0.47333],
              "41": [0.25, 0.75, 0.03306, 0, 0.47333],
              "42": [0, 0.75, 0.14333, 0, 0.59111],
              "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
              "44": [0.19444, 0.14722, 0, 0, 0.35555],
              "45": [0, 0.44444, 0.02611, 0, 0.41444],
              "46": [0, 0.14722, 0, 0, 0.35555],
              "47": [0.25, 0.75, 0.15806, 0, 0.59111],
              "48": [0, 0.64444, 0.13167, 0, 0.59111],
              "49": [0, 0.64444, 0.13167, 0, 0.59111],
              "50": [0, 0.64444, 0.13167, 0, 0.59111],
              "51": [0, 0.64444, 0.13167, 0, 0.59111],
              "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
              "53": [0, 0.64444, 0.13167, 0, 0.59111],
              "54": [0, 0.64444, 0.13167, 0, 0.59111],
              "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
              "56": [0, 0.64444, 0.13167, 0, 0.59111],
              "57": [0, 0.64444, 0.13167, 0, 0.59111],
              "58": [0, 0.44444, 0.06695, 0, 0.35555],
              "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
              "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
              "63": [0, 0.69444, 0.11472, 0, 0.59111],
              "64": [0, 0.69444, 0.09208, 0, 0.88555],
              "65": [0, 0.68611, 0, 0, 0.86555],
              "66": [0, 0.68611, 0.0992, 0, 0.81666],
              "67": [0, 0.68611, 0.14208, 0, 0.82666],
              "68": [0, 0.68611, 0.09062, 0, 0.87555],
              "69": [0, 0.68611, 0.11431, 0, 0.75666],
              "70": [0, 0.68611, 0.12903, 0, 0.72722],
              "71": [0, 0.68611, 0.07347, 0, 0.89527],
              "72": [0, 0.68611, 0.17208, 0, 0.8961],
              "73": [0, 0.68611, 0.15681, 0, 0.47166],
              "74": [0, 0.68611, 0.145, 0, 0.61055],
              "75": [0, 0.68611, 0.14208, 0, 0.89499],
              "76": [0, 0.68611, 0, 0, 0.69777],
              "77": [0, 0.68611, 0.17208, 0, 1.07277],
              "78": [0, 0.68611, 0.17208, 0, 0.8961],
              "79": [0, 0.68611, 0.09062, 0, 0.85499],
              "80": [0, 0.68611, 0.0992, 0, 0.78721],
              "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
              "82": [0, 0.68611, 0.02559, 0, 0.85944],
              "83": [0, 0.68611, 0.11264, 0, 0.64999],
              "84": [0, 0.68611, 0.12903, 0, 0.7961],
              "85": [0, 0.68611, 0.17208, 0, 0.88083],
              "86": [0, 0.68611, 0.18625, 0, 0.86555],
              "87": [0, 0.68611, 0.18625, 0, 1.15999],
              "88": [0, 0.68611, 0.15681, 0, 0.86555],
              "89": [0, 0.68611, 0.19803, 0, 0.86555],
              "90": [0, 0.68611, 0.14208, 0, 0.70888],
              "91": [0.25, 0.75, 0.1875, 0, 0.35611],
              "93": [0.25, 0.75, 0.09972, 0, 0.35611],
              "94": [0, 0.69444, 0.06709, 0, 0.59111],
              "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
              "97": [0, 0.44444, 0.09426, 0, 0.59111],
              "98": [0, 0.69444, 0.07861, 0, 0.53222],
              "99": [0, 0.44444, 0.05222, 0, 0.53222],
              "100": [0, 0.69444, 0.10861, 0, 0.59111],
              "101": [0, 0.44444, 0.085, 0, 0.53222],
              "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
              "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
              "104": [0, 0.69444, 0.09426, 0, 0.59111],
              "105": [0, 0.69326, 0.11387, 0, 0.35555],
              "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
              "107": [0, 0.69444, 0.11111, 0, 0.53222],
              "108": [0, 0.69444, 0.10861, 0, 0.29666],
              "109": [0, 0.44444, 0.09426, 0, 0.94444],
              "110": [0, 0.44444, 0.09426, 0, 0.64999],
              "111": [0, 0.44444, 0.07861, 0, 0.59111],
              "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
              "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
              "114": [0, 0.44444, 0.11111, 0, 0.50167],
              "115": [0, 0.44444, 0.08167, 0, 0.48694],
              "116": [0, 0.63492, 0.09639, 0, 0.385],
              "117": [0, 0.44444, 0.09426, 0, 0.62055],
              "118": [0, 0.44444, 0.11111, 0, 0.53222],
              "119": [0, 0.44444, 0.11111, 0, 0.76777],
              "120": [0, 0.44444, 0.12583, 0, 0.56055],
              "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
              "122": [0, 0.44444, 0.13889, 0, 0.49055],
              "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
              "160": [0, 0, 0, 0, 0.25],
              "168": [0, 0.69444, 0.11473, 0, 0.59111],
              "176": [0, 0.69444, 0, 0, 0.94888],
              "184": [0.17014, 0, 0, 0, 0.53222],
              "198": [0, 0.68611, 0.11431, 0, 1.02277],
              "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
              "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
              "230": [0, 0.44444, 0.085, 0, 0.82666],
              "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
              "305": [0, 0.44444, 0.09426, 0, 0.35555],
              "338": [0, 0.68611, 0.11431, 0, 1.14054],
              "339": [0, 0.44444, 0.085, 0, 0.82666],
              "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
              "710": [0, 0.69444, 0.06709, 0, 0.59111],
              "711": [0, 0.63194, 0.08271, 0, 0.59111],
              "713": [0, 0.59444, 0.10444, 0, 0.59111],
              "714": [0, 0.69444, 0.08528, 0, 0.59111],
              "715": [0, 0.69444, 0, 0, 0.59111],
              "728": [0, 0.69444, 0.10333, 0, 0.59111],
              "729": [0, 0.69444, 0.12945, 0, 0.35555],
              "730": [0, 0.69444, 0, 0, 0.94888],
              "732": [0, 0.69444, 0.11472, 0, 0.59111],
              "733": [0, 0.69444, 0.11472, 0, 0.59111],
              "915": [0, 0.68611, 0.12903, 0, 0.69777],
              "916": [0, 0.68611, 0, 0, 0.94444],
              "920": [0, 0.68611, 0.09062, 0, 0.88555],
              "923": [0, 0.68611, 0, 0, 0.80666],
              "926": [0, 0.68611, 0.15092, 0, 0.76777],
              "928": [0, 0.68611, 0.17208, 0, 0.8961],
              "931": [0, 0.68611, 0.11431, 0, 0.82666],
              "933": [0, 0.68611, 0.10778, 0, 0.88555],
              "934": [0, 0.68611, 0.05632, 0, 0.82666],
              "936": [0, 0.68611, 0.10778, 0, 0.88555],
              "937": [0, 0.68611, 0.0992, 0, 0.82666],
              "8211": [0, 0.44444, 0.09811, 0, 0.59111],
              "8212": [0, 0.44444, 0.09811, 0, 1.18221],
              "8216": [0, 0.69444, 0.12945, 0, 0.35555],
              "8217": [0, 0.69444, 0.12945, 0, 0.35555],
              "8220": [0, 0.69444, 0.16772, 0, 0.62055],
              "8221": [0, 0.69444, 0.07939, 0, 0.62055]
            },
            "Main-Italic": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69444, 0.12417, 0, 0.30667],
              "34": [0, 0.69444, 0.06961, 0, 0.51444],
              "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
              "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
              "38": [0, 0.69444, 0.09694, 0, 0.76666],
              "39": [0, 0.69444, 0.12417, 0, 0.30667],
              "40": [0.25, 0.75, 0.16194, 0, 0.40889],
              "41": [0.25, 0.75, 0.03694, 0, 0.40889],
              "42": [0, 0.75, 0.14917, 0, 0.51111],
              "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
              "44": [0.19444, 0.10556, 0, 0, 0.30667],
              "45": [0, 0.43056, 0.02826, 0, 0.35778],
              "46": [0, 0.10556, 0, 0, 0.30667],
              "47": [0.25, 0.75, 0.16194, 0, 0.51111],
              "48": [0, 0.64444, 0.13556, 0, 0.51111],
              "49": [0, 0.64444, 0.13556, 0, 0.51111],
              "50": [0, 0.64444, 0.13556, 0, 0.51111],
              "51": [0, 0.64444, 0.13556, 0, 0.51111],
              "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
              "53": [0, 0.64444, 0.13556, 0, 0.51111],
              "54": [0, 0.64444, 0.13556, 0, 0.51111],
              "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
              "56": [0, 0.64444, 0.13556, 0, 0.51111],
              "57": [0, 0.64444, 0.13556, 0, 0.51111],
              "58": [0, 0.43056, 0.0582, 0, 0.30667],
              "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
              "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
              "63": [0, 0.69444, 0.1225, 0, 0.51111],
              "64": [0, 0.69444, 0.09597, 0, 0.76666],
              "65": [0, 0.68333, 0, 0, 0.74333],
              "66": [0, 0.68333, 0.10257, 0, 0.70389],
              "67": [0, 0.68333, 0.14528, 0, 0.71555],
              "68": [0, 0.68333, 0.09403, 0, 0.755],
              "69": [0, 0.68333, 0.12028, 0, 0.67833],
              "70": [0, 0.68333, 0.13305, 0, 0.65277],
              "71": [0, 0.68333, 0.08722, 0, 0.77361],
              "72": [0, 0.68333, 0.16389, 0, 0.74333],
              "73": [0, 0.68333, 0.15806, 0, 0.38555],
              "74": [0, 0.68333, 0.14028, 0, 0.525],
              "75": [0, 0.68333, 0.14528, 0, 0.76888],
              "76": [0, 0.68333, 0, 0, 0.62722],
              "77": [0, 0.68333, 0.16389, 0, 0.89666],
              "78": [0, 0.68333, 0.16389, 0, 0.74333],
              "79": [0, 0.68333, 0.09403, 0, 0.76666],
              "80": [0, 0.68333, 0.10257, 0, 0.67833],
              "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
              "82": [0, 0.68333, 0.03868, 0, 0.72944],
              "83": [0, 0.68333, 0.11972, 0, 0.56222],
              "84": [0, 0.68333, 0.13305, 0, 0.71555],
              "85": [0, 0.68333, 0.16389, 0, 0.74333],
              "86": [0, 0.68333, 0.18361, 0, 0.74333],
              "87": [0, 0.68333, 0.18361, 0, 0.99888],
              "88": [0, 0.68333, 0.15806, 0, 0.74333],
              "89": [0, 0.68333, 0.19383, 0, 0.74333],
              "90": [0, 0.68333, 0.14528, 0, 0.61333],
              "91": [0.25, 0.75, 0.1875, 0, 0.30667],
              "93": [0.25, 0.75, 0.10528, 0, 0.30667],
              "94": [0, 0.69444, 0.06646, 0, 0.51111],
              "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
              "97": [0, 0.43056, 0.07671, 0, 0.51111],
              "98": [0, 0.69444, 0.06312, 0, 0.46],
              "99": [0, 0.43056, 0.05653, 0, 0.46],
              "100": [0, 0.69444, 0.10333, 0, 0.51111],
              "101": [0, 0.43056, 0.07514, 0, 0.46],
              "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
              "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
              "104": [0, 0.69444, 0.07671, 0, 0.51111],
              "105": [0, 0.65536, 0.1019, 0, 0.30667],
              "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
              "107": [0, 0.69444, 0.10764, 0, 0.46],
              "108": [0, 0.69444, 0.10333, 0, 0.25555],
              "109": [0, 0.43056, 0.07671, 0, 0.81777],
              "110": [0, 0.43056, 0.07671, 0, 0.56222],
              "111": [0, 0.43056, 0.06312, 0, 0.51111],
              "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
              "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
              "114": [0, 0.43056, 0.10764, 0, 0.42166],
              "115": [0, 0.43056, 0.08208, 0, 0.40889],
              "116": [0, 0.61508, 0.09486, 0, 0.33222],
              "117": [0, 0.43056, 0.07671, 0, 0.53666],
              "118": [0, 0.43056, 0.10764, 0, 0.46],
              "119": [0, 0.43056, 0.10764, 0, 0.66444],
              "120": [0, 0.43056, 0.12042, 0, 0.46389],
              "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
              "122": [0, 0.43056, 0.12292, 0, 0.40889],
              "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
              "160": [0, 0, 0, 0, 0.25],
              "168": [0, 0.66786, 0.10474, 0, 0.51111],
              "176": [0, 0.69444, 0, 0, 0.83129],
              "184": [0.17014, 0, 0, 0, 0.46],
              "198": [0, 0.68333, 0.12028, 0, 0.88277],
              "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
              "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
              "230": [0, 0.43056, 0.07514, 0, 0.71555],
              "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
              "338": [0, 0.68333, 0.12028, 0, 0.98499],
              "339": [0, 0.43056, 0.07514, 0, 0.71555],
              "710": [0, 0.69444, 0.06646, 0, 0.51111],
              "711": [0, 0.62847, 0.08295, 0, 0.51111],
              "713": [0, 0.56167, 0.10333, 0, 0.51111],
              "714": [0, 0.69444, 0.09694, 0, 0.51111],
              "715": [0, 0.69444, 0, 0, 0.51111],
              "728": [0, 0.69444, 0.10806, 0, 0.51111],
              "729": [0, 0.66786, 0.11752, 0, 0.30667],
              "730": [0, 0.69444, 0, 0, 0.83129],
              "732": [0, 0.66786, 0.11585, 0, 0.51111],
              "733": [0, 0.69444, 0.1225, 0, 0.51111],
              "915": [0, 0.68333, 0.13305, 0, 0.62722],
              "916": [0, 0.68333, 0, 0, 0.81777],
              "920": [0, 0.68333, 0.09403, 0, 0.76666],
              "923": [0, 0.68333, 0, 0, 0.69222],
              "926": [0, 0.68333, 0.15294, 0, 0.66444],
              "928": [0, 0.68333, 0.16389, 0, 0.74333],
              "931": [0, 0.68333, 0.12028, 0, 0.71555],
              "933": [0, 0.68333, 0.11111, 0, 0.76666],
              "934": [0, 0.68333, 0.05986, 0, 0.71555],
              "936": [0, 0.68333, 0.11111, 0, 0.76666],
              "937": [0, 0.68333, 0.10257, 0, 0.71555],
              "8211": [0, 0.43056, 0.09208, 0, 0.51111],
              "8212": [0, 0.43056, 0.09208, 0, 1.02222],
              "8216": [0, 0.69444, 0.12417, 0, 0.30667],
              "8217": [0, 0.69444, 0.12417, 0, 0.30667],
              "8220": [0, 0.69444, 0.1685, 0, 0.51444],
              "8221": [0, 0.69444, 0.06961, 0, 0.51444],
              "8463": [0, 0.68889, 0, 0, 0.54028]
            },
            "Main-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69444, 0, 0, 0.27778],
              "34": [0, 0.69444, 0, 0, 0.5],
              "35": [0.19444, 0.69444, 0, 0, 0.83334],
              "36": [0.05556, 0.75, 0, 0, 0.5],
              "37": [0.05556, 0.75, 0, 0, 0.83334],
              "38": [0, 0.69444, 0, 0, 0.77778],
              "39": [0, 0.69444, 0, 0, 0.27778],
              "40": [0.25, 0.75, 0, 0, 0.38889],
              "41": [0.25, 0.75, 0, 0, 0.38889],
              "42": [0, 0.75, 0, 0, 0.5],
              "43": [0.08333, 0.58333, 0, 0, 0.77778],
              "44": [0.19444, 0.10556, 0, 0, 0.27778],
              "45": [0, 0.43056, 0, 0, 0.33333],
              "46": [0, 0.10556, 0, 0, 0.27778],
              "47": [0.25, 0.75, 0, 0, 0.5],
              "48": [0, 0.64444, 0, 0, 0.5],
              "49": [0, 0.64444, 0, 0, 0.5],
              "50": [0, 0.64444, 0, 0, 0.5],
              "51": [0, 0.64444, 0, 0, 0.5],
              "52": [0, 0.64444, 0, 0, 0.5],
              "53": [0, 0.64444, 0, 0, 0.5],
              "54": [0, 0.64444, 0, 0, 0.5],
              "55": [0, 0.64444, 0, 0, 0.5],
              "56": [0, 0.64444, 0, 0, 0.5],
              "57": [0, 0.64444, 0, 0, 0.5],
              "58": [0, 0.43056, 0, 0, 0.27778],
              "59": [0.19444, 0.43056, 0, 0, 0.27778],
              "60": [0.0391, 0.5391, 0, 0, 0.77778],
              "61": [-0.13313, 0.36687, 0, 0, 0.77778],
              "62": [0.0391, 0.5391, 0, 0, 0.77778],
              "63": [0, 0.69444, 0, 0, 0.47222],
              "64": [0, 0.69444, 0, 0, 0.77778],
              "65": [0, 0.68333, 0, 0, 0.75],
              "66": [0, 0.68333, 0, 0, 0.70834],
              "67": [0, 0.68333, 0, 0, 0.72222],
              "68": [0, 0.68333, 0, 0, 0.76389],
              "69": [0, 0.68333, 0, 0, 0.68056],
              "70": [0, 0.68333, 0, 0, 0.65278],
              "71": [0, 0.68333, 0, 0, 0.78472],
              "72": [0, 0.68333, 0, 0, 0.75],
              "73": [0, 0.68333, 0, 0, 0.36111],
              "74": [0, 0.68333, 0, 0, 0.51389],
              "75": [0, 0.68333, 0, 0, 0.77778],
              "76": [0, 0.68333, 0, 0, 0.625],
              "77": [0, 0.68333, 0, 0, 0.91667],
              "78": [0, 0.68333, 0, 0, 0.75],
              "79": [0, 0.68333, 0, 0, 0.77778],
              "80": [0, 0.68333, 0, 0, 0.68056],
              "81": [0.19444, 0.68333, 0, 0, 0.77778],
              "82": [0, 0.68333, 0, 0, 0.73611],
              "83": [0, 0.68333, 0, 0, 0.55556],
              "84": [0, 0.68333, 0, 0, 0.72222],
              "85": [0, 0.68333, 0, 0, 0.75],
              "86": [0, 0.68333, 0.01389, 0, 0.75],
              "87": [0, 0.68333, 0.01389, 0, 1.02778],
              "88": [0, 0.68333, 0, 0, 0.75],
              "89": [0, 0.68333, 0.025, 0, 0.75],
              "90": [0, 0.68333, 0, 0, 0.61111],
              "91": [0.25, 0.75, 0, 0, 0.27778],
              "92": [0.25, 0.75, 0, 0, 0.5],
              "93": [0.25, 0.75, 0, 0, 0.27778],
              "94": [0, 0.69444, 0, 0, 0.5],
              "95": [0.31, 0.12056, 0.02778, 0, 0.5],
              "97": [0, 0.43056, 0, 0, 0.5],
              "98": [0, 0.69444, 0, 0, 0.55556],
              "99": [0, 0.43056, 0, 0, 0.44445],
              "100": [0, 0.69444, 0, 0, 0.55556],
              "101": [0, 0.43056, 0, 0, 0.44445],
              "102": [0, 0.69444, 0.07778, 0, 0.30556],
              "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
              "104": [0, 0.69444, 0, 0, 0.55556],
              "105": [0, 0.66786, 0, 0, 0.27778],
              "106": [0.19444, 0.66786, 0, 0, 0.30556],
              "107": [0, 0.69444, 0, 0, 0.52778],
              "108": [0, 0.69444, 0, 0, 0.27778],
              "109": [0, 0.43056, 0, 0, 0.83334],
              "110": [0, 0.43056, 0, 0, 0.55556],
              "111": [0, 0.43056, 0, 0, 0.5],
              "112": [0.19444, 0.43056, 0, 0, 0.55556],
              "113": [0.19444, 0.43056, 0, 0, 0.52778],
              "114": [0, 0.43056, 0, 0, 0.39167],
              "115": [0, 0.43056, 0, 0, 0.39445],
              "116": [0, 0.61508, 0, 0, 0.38889],
              "117": [0, 0.43056, 0, 0, 0.55556],
              "118": [0, 0.43056, 0.01389, 0, 0.52778],
              "119": [0, 0.43056, 0.01389, 0, 0.72222],
              "120": [0, 0.43056, 0, 0, 0.52778],
              "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
              "122": [0, 0.43056, 0, 0, 0.44445],
              "123": [0.25, 0.75, 0, 0, 0.5],
              "124": [0.25, 0.75, 0, 0, 0.27778],
              "125": [0.25, 0.75, 0, 0, 0.5],
              "126": [0.35, 0.31786, 0, 0, 0.5],
              "160": [0, 0, 0, 0, 0.25],
              "163": [0, 0.69444, 0, 0, 0.76909],
              "167": [0.19444, 0.69444, 0, 0, 0.44445],
              "168": [0, 0.66786, 0, 0, 0.5],
              "172": [0, 0.43056, 0, 0, 0.66667],
              "176": [0, 0.69444, 0, 0, 0.75],
              "177": [0.08333, 0.58333, 0, 0, 0.77778],
              "182": [0.19444, 0.69444, 0, 0, 0.61111],
              "184": [0.17014, 0, 0, 0, 0.44445],
              "198": [0, 0.68333, 0, 0, 0.90278],
              "215": [0.08333, 0.58333, 0, 0, 0.77778],
              "216": [0.04861, 0.73194, 0, 0, 0.77778],
              "223": [0, 0.69444, 0, 0, 0.5],
              "230": [0, 0.43056, 0, 0, 0.72222],
              "247": [0.08333, 0.58333, 0, 0, 0.77778],
              "248": [0.09722, 0.52778, 0, 0, 0.5],
              "305": [0, 0.43056, 0, 0, 0.27778],
              "338": [0, 0.68333, 0, 0, 1.01389],
              "339": [0, 0.43056, 0, 0, 0.77778],
              "567": [0.19444, 0.43056, 0, 0, 0.30556],
              "710": [0, 0.69444, 0, 0, 0.5],
              "711": [0, 0.62847, 0, 0, 0.5],
              "713": [0, 0.56778, 0, 0, 0.5],
              "714": [0, 0.69444, 0, 0, 0.5],
              "715": [0, 0.69444, 0, 0, 0.5],
              "728": [0, 0.69444, 0, 0, 0.5],
              "729": [0, 0.66786, 0, 0, 0.27778],
              "730": [0, 0.69444, 0, 0, 0.75],
              "732": [0, 0.66786, 0, 0, 0.5],
              "733": [0, 0.69444, 0, 0, 0.5],
              "915": [0, 0.68333, 0, 0, 0.625],
              "916": [0, 0.68333, 0, 0, 0.83334],
              "920": [0, 0.68333, 0, 0, 0.77778],
              "923": [0, 0.68333, 0, 0, 0.69445],
              "926": [0, 0.68333, 0, 0, 0.66667],
              "928": [0, 0.68333, 0, 0, 0.75],
              "931": [0, 0.68333, 0, 0, 0.72222],
              "933": [0, 0.68333, 0, 0, 0.77778],
              "934": [0, 0.68333, 0, 0, 0.72222],
              "936": [0, 0.68333, 0, 0, 0.77778],
              "937": [0, 0.68333, 0, 0, 0.72222],
              "8211": [0, 0.43056, 0.02778, 0, 0.5],
              "8212": [0, 0.43056, 0.02778, 0, 1],
              "8216": [0, 0.69444, 0, 0, 0.27778],
              "8217": [0, 0.69444, 0, 0, 0.27778],
              "8220": [0, 0.69444, 0, 0, 0.5],
              "8221": [0, 0.69444, 0, 0, 0.5],
              "8224": [0.19444, 0.69444, 0, 0, 0.44445],
              "8225": [0.19444, 0.69444, 0, 0, 0.44445],
              "8230": [0, 0.12, 0, 0, 1.172],
              "8242": [0, 0.55556, 0, 0, 0.275],
              "8407": [0, 0.71444, 0.15382, 0, 0.5],
              "8463": [0, 0.68889, 0, 0, 0.54028],
              "8465": [0, 0.69444, 0, 0, 0.72222],
              "8467": [0, 0.69444, 0, 0.11111, 0.41667],
              "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
              "8476": [0, 0.69444, 0, 0, 0.72222],
              "8501": [0, 0.69444, 0, 0, 0.61111],
              "8592": [-0.13313, 0.36687, 0, 0, 1],
              "8593": [0.19444, 0.69444, 0, 0, 0.5],
              "8594": [-0.13313, 0.36687, 0, 0, 1],
              "8595": [0.19444, 0.69444, 0, 0, 0.5],
              "8596": [-0.13313, 0.36687, 0, 0, 1],
              "8597": [0.25, 0.75, 0, 0, 0.5],
              "8598": [0.19444, 0.69444, 0, 0, 1],
              "8599": [0.19444, 0.69444, 0, 0, 1],
              "8600": [0.19444, 0.69444, 0, 0, 1],
              "8601": [0.19444, 0.69444, 0, 0, 1],
              "8614": [0.011, 0.511, 0, 0, 1],
              "8617": [0.011, 0.511, 0, 0, 1.126],
              "8618": [0.011, 0.511, 0, 0, 1.126],
              "8636": [-0.13313, 0.36687, 0, 0, 1],
              "8637": [-0.13313, 0.36687, 0, 0, 1],
              "8640": [-0.13313, 0.36687, 0, 0, 1],
              "8641": [-0.13313, 0.36687, 0, 0, 1],
              "8652": [0.011, 0.671, 0, 0, 1],
              "8656": [-0.13313, 0.36687, 0, 0, 1],
              "8657": [0.19444, 0.69444, 0, 0, 0.61111],
              "8658": [-0.13313, 0.36687, 0, 0, 1],
              "8659": [0.19444, 0.69444, 0, 0, 0.61111],
              "8660": [-0.13313, 0.36687, 0, 0, 1],
              "8661": [0.25, 0.75, 0, 0, 0.61111],
              "8704": [0, 0.69444, 0, 0, 0.55556],
              "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
              "8707": [0, 0.69444, 0, 0, 0.55556],
              "8709": [0.05556, 0.75, 0, 0, 0.5],
              "8711": [0, 0.68333, 0, 0, 0.83334],
              "8712": [0.0391, 0.5391, 0, 0, 0.66667],
              "8715": [0.0391, 0.5391, 0, 0, 0.66667],
              "8722": [0.08333, 0.58333, 0, 0, 0.77778],
              "8723": [0.08333, 0.58333, 0, 0, 0.77778],
              "8725": [0.25, 0.75, 0, 0, 0.5],
              "8726": [0.25, 0.75, 0, 0, 0.5],
              "8727": [-0.03472, 0.46528, 0, 0, 0.5],
              "8728": [-0.05555, 0.44445, 0, 0, 0.5],
              "8729": [-0.05555, 0.44445, 0, 0, 0.5],
              "8730": [0.2, 0.8, 0, 0, 0.83334],
              "8733": [0, 0.43056, 0, 0, 0.77778],
              "8734": [0, 0.43056, 0, 0, 1],
              "8736": [0, 0.69224, 0, 0, 0.72222],
              "8739": [0.25, 0.75, 0, 0, 0.27778],
              "8741": [0.25, 0.75, 0, 0, 0.5],
              "8743": [0, 0.55556, 0, 0, 0.66667],
              "8744": [0, 0.55556, 0, 0, 0.66667],
              "8745": [0, 0.55556, 0, 0, 0.66667],
              "8746": [0, 0.55556, 0, 0, 0.66667],
              "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
              "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
              "8768": [0.19444, 0.69444, 0, 0, 0.27778],
              "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
              "8773": [-0.022, 0.589, 0, 0, 1],
              "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
              "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
              "8784": [-0.133, 0.67, 0, 0, 0.778],
              "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
              "8804": [0.13597, 0.63597, 0, 0, 0.77778],
              "8805": [0.13597, 0.63597, 0, 0, 0.77778],
              "8810": [0.0391, 0.5391, 0, 0, 1],
              "8811": [0.0391, 0.5391, 0, 0, 1],
              "8826": [0.0391, 0.5391, 0, 0, 0.77778],
              "8827": [0.0391, 0.5391, 0, 0, 0.77778],
              "8834": [0.0391, 0.5391, 0, 0, 0.77778],
              "8835": [0.0391, 0.5391, 0, 0, 0.77778],
              "8838": [0.13597, 0.63597, 0, 0, 0.77778],
              "8839": [0.13597, 0.63597, 0, 0, 0.77778],
              "8846": [0, 0.55556, 0, 0, 0.66667],
              "8849": [0.13597, 0.63597, 0, 0, 0.77778],
              "8850": [0.13597, 0.63597, 0, 0, 0.77778],
              "8851": [0, 0.55556, 0, 0, 0.66667],
              "8852": [0, 0.55556, 0, 0, 0.66667],
              "8853": [0.08333, 0.58333, 0, 0, 0.77778],
              "8854": [0.08333, 0.58333, 0, 0, 0.77778],
              "8855": [0.08333, 0.58333, 0, 0, 0.77778],
              "8856": [0.08333, 0.58333, 0, 0, 0.77778],
              "8857": [0.08333, 0.58333, 0, 0, 0.77778],
              "8866": [0, 0.69444, 0, 0, 0.61111],
              "8867": [0, 0.69444, 0, 0, 0.61111],
              "8868": [0, 0.69444, 0, 0, 0.77778],
              "8869": [0, 0.69444, 0, 0, 0.77778],
              "8872": [0.249, 0.75, 0, 0, 0.867],
              "8900": [-0.05555, 0.44445, 0, 0, 0.5],
              "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
              "8902": [-0.03472, 0.46528, 0, 0, 0.5],
              "8904": [5e-3, 0.505, 0, 0, 0.9],
              "8942": [0.03, 0.9, 0, 0, 0.278],
              "8943": [-0.19, 0.31, 0, 0, 1.172],
              "8945": [-0.1, 0.82, 0, 0, 1.282],
              "8968": [0.25, 0.75, 0, 0, 0.44445],
              "8969": [0.25, 0.75, 0, 0, 0.44445],
              "8970": [0.25, 0.75, 0, 0, 0.44445],
              "8971": [0.25, 0.75, 0, 0, 0.44445],
              "8994": [-0.14236, 0.35764, 0, 0, 1],
              "8995": [-0.14236, 0.35764, 0, 0, 1],
              "9136": [0.244, 0.744, 0, 0, 0.412],
              "9137": [0.244, 0.744, 0, 0, 0.412],
              "9651": [0.19444, 0.69444, 0, 0, 0.88889],
              "9657": [-0.03472, 0.46528, 0, 0, 0.5],
              "9661": [0.19444, 0.69444, 0, 0, 0.88889],
              "9667": [-0.03472, 0.46528, 0, 0, 0.5],
              "9711": [0.19444, 0.69444, 0, 0, 1],
              "9824": [0.12963, 0.69444, 0, 0, 0.77778],
              "9825": [0.12963, 0.69444, 0, 0, 0.77778],
              "9826": [0.12963, 0.69444, 0, 0, 0.77778],
              "9827": [0.12963, 0.69444, 0, 0, 0.77778],
              "9837": [0, 0.75, 0, 0, 0.38889],
              "9838": [0.19444, 0.69444, 0, 0, 0.38889],
              "9839": [0.19444, 0.69444, 0, 0, 0.38889],
              "10216": [0.25, 0.75, 0, 0, 0.38889],
              "10217": [0.25, 0.75, 0, 0, 0.38889],
              "10222": [0.244, 0.744, 0, 0, 0.412],
              "10223": [0.244, 0.744, 0, 0, 0.412],
              "10229": [0.011, 0.511, 0, 0, 1.609],
              "10230": [0.011, 0.511, 0, 0, 1.638],
              "10231": [0.011, 0.511, 0, 0, 1.859],
              "10232": [0.024, 0.525, 0, 0, 1.609],
              "10233": [0.024, 0.525, 0, 0, 1.638],
              "10234": [0.024, 0.525, 0, 0, 1.858],
              "10236": [0.011, 0.511, 0, 0, 1.638],
              "10815": [0, 0.68333, 0, 0, 0.75],
              "10927": [0.13597, 0.63597, 0, 0, 0.77778],
              "10928": [0.13597, 0.63597, 0, 0, 0.77778],
              "57376": [0.19444, 0.69444, 0, 0, 0]
            },
            "Math-BoldItalic": {
              "32": [0, 0, 0, 0, 0.25],
              "48": [0, 0.44444, 0, 0, 0.575],
              "49": [0, 0.44444, 0, 0, 0.575],
              "50": [0, 0.44444, 0, 0, 0.575],
              "51": [0.19444, 0.44444, 0, 0, 0.575],
              "52": [0.19444, 0.44444, 0, 0, 0.575],
              "53": [0.19444, 0.44444, 0, 0, 0.575],
              "54": [0, 0.64444, 0, 0, 0.575],
              "55": [0.19444, 0.44444, 0, 0, 0.575],
              "56": [0, 0.64444, 0, 0, 0.575],
              "57": [0.19444, 0.44444, 0, 0, 0.575],
              "65": [0, 0.68611, 0, 0, 0.86944],
              "66": [0, 0.68611, 0.04835, 0, 0.8664],
              "67": [0, 0.68611, 0.06979, 0, 0.81694],
              "68": [0, 0.68611, 0.03194, 0, 0.93812],
              "69": [0, 0.68611, 0.05451, 0, 0.81007],
              "70": [0, 0.68611, 0.15972, 0, 0.68889],
              "71": [0, 0.68611, 0, 0, 0.88673],
              "72": [0, 0.68611, 0.08229, 0, 0.98229],
              "73": [0, 0.68611, 0.07778, 0, 0.51111],
              "74": [0, 0.68611, 0.10069, 0, 0.63125],
              "75": [0, 0.68611, 0.06979, 0, 0.97118],
              "76": [0, 0.68611, 0, 0, 0.75555],
              "77": [0, 0.68611, 0.11424, 0, 1.14201],
              "78": [0, 0.68611, 0.11424, 0, 0.95034],
              "79": [0, 0.68611, 0.03194, 0, 0.83666],
              "80": [0, 0.68611, 0.15972, 0, 0.72309],
              "81": [0.19444, 0.68611, 0, 0, 0.86861],
              "82": [0, 0.68611, 421e-5, 0, 0.87235],
              "83": [0, 0.68611, 0.05382, 0, 0.69271],
              "84": [0, 0.68611, 0.15972, 0, 0.63663],
              "85": [0, 0.68611, 0.11424, 0, 0.80027],
              "86": [0, 0.68611, 0.25555, 0, 0.67778],
              "87": [0, 0.68611, 0.15972, 0, 1.09305],
              "88": [0, 0.68611, 0.07778, 0, 0.94722],
              "89": [0, 0.68611, 0.25555, 0, 0.67458],
              "90": [0, 0.68611, 0.06979, 0, 0.77257],
              "97": [0, 0.44444, 0, 0, 0.63287],
              "98": [0, 0.69444, 0, 0, 0.52083],
              "99": [0, 0.44444, 0, 0, 0.51342],
              "100": [0, 0.69444, 0, 0, 0.60972],
              "101": [0, 0.44444, 0, 0, 0.55361],
              "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
              "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
              "104": [0, 0.69444, 0, 0, 0.66759],
              "105": [0, 0.69326, 0, 0, 0.4048],
              "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
              "107": [0, 0.69444, 0.01852, 0, 0.6037],
              "108": [0, 0.69444, 88e-4, 0, 0.34815],
              "109": [0, 0.44444, 0, 0, 1.0324],
              "110": [0, 0.44444, 0, 0, 0.71296],
              "111": [0, 0.44444, 0, 0, 0.58472],
              "112": [0.19444, 0.44444, 0, 0, 0.60092],
              "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
              "114": [0, 0.44444, 0.03194, 0, 0.5287],
              "115": [0, 0.44444, 0, 0, 0.53125],
              "116": [0, 0.63492, 0, 0, 0.41528],
              "117": [0, 0.44444, 0, 0, 0.68102],
              "118": [0, 0.44444, 0.03704, 0, 0.56666],
              "119": [0, 0.44444, 0.02778, 0, 0.83148],
              "120": [0, 0.44444, 0, 0, 0.65903],
              "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
              "122": [0, 0.44444, 0.04213, 0, 0.55509],
              "160": [0, 0, 0, 0, 0.25],
              "915": [0, 0.68611, 0.15972, 0, 0.65694],
              "916": [0, 0.68611, 0, 0, 0.95833],
              "920": [0, 0.68611, 0.03194, 0, 0.86722],
              "923": [0, 0.68611, 0, 0, 0.80555],
              "926": [0, 0.68611, 0.07458, 0, 0.84125],
              "928": [0, 0.68611, 0.08229, 0, 0.98229],
              "931": [0, 0.68611, 0.05451, 0, 0.88507],
              "933": [0, 0.68611, 0.15972, 0, 0.67083],
              "934": [0, 0.68611, 0, 0, 0.76666],
              "936": [0, 0.68611, 0.11653, 0, 0.71402],
              "937": [0, 0.68611, 0.04835, 0, 0.8789],
              "945": [0, 0.44444, 0, 0, 0.76064],
              "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
              "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
              "948": [0, 0.69444, 0.03819, 0, 0.52222],
              "949": [0, 0.44444, 0, 0, 0.52882],
              "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
              "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
              "952": [0, 0.69444, 0.03194, 0, 0.5618],
              "953": [0, 0.44444, 0, 0, 0.41204],
              "954": [0, 0.44444, 0, 0, 0.66759],
              "955": [0, 0.69444, 0, 0, 0.67083],
              "956": [0.19444, 0.44444, 0, 0, 0.70787],
              "957": [0, 0.44444, 0.06898, 0, 0.57685],
              "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
              "959": [0, 0.44444, 0, 0, 0.58472],
              "960": [0, 0.44444, 0.03704, 0, 0.68241],
              "961": [0.19444, 0.44444, 0, 0, 0.6118],
              "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
              "963": [0, 0.44444, 0.03704, 0, 0.68588],
              "964": [0, 0.44444, 0.13472, 0, 0.52083],
              "965": [0, 0.44444, 0.03704, 0, 0.63055],
              "966": [0.19444, 0.44444, 0, 0, 0.74722],
              "967": [0.19444, 0.44444, 0, 0, 0.71805],
              "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
              "969": [0, 0.44444, 0.03704, 0, 0.71782],
              "977": [0, 0.69444, 0, 0, 0.69155],
              "981": [0.19444, 0.69444, 0, 0, 0.7125],
              "982": [0, 0.44444, 0.03194, 0, 0.975],
              "1009": [0.19444, 0.44444, 0, 0, 0.6118],
              "1013": [0, 0.44444, 0, 0, 0.48333],
              "57649": [0, 0.44444, 0, 0, 0.39352],
              "57911": [0.19444, 0.44444, 0, 0, 0.43889]
            },
            "Math-Italic": {
              "32": [0, 0, 0, 0, 0.25],
              "48": [0, 0.43056, 0, 0, 0.5],
              "49": [0, 0.43056, 0, 0, 0.5],
              "50": [0, 0.43056, 0, 0, 0.5],
              "51": [0.19444, 0.43056, 0, 0, 0.5],
              "52": [0.19444, 0.43056, 0, 0, 0.5],
              "53": [0.19444, 0.43056, 0, 0, 0.5],
              "54": [0, 0.64444, 0, 0, 0.5],
              "55": [0.19444, 0.43056, 0, 0, 0.5],
              "56": [0, 0.64444, 0, 0, 0.5],
              "57": [0.19444, 0.43056, 0, 0, 0.5],
              "65": [0, 0.68333, 0, 0.13889, 0.75],
              "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
              "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
              "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
              "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
              "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
              "71": [0, 0.68333, 0, 0.08334, 0.78625],
              "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
              "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
              "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
              "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
              "76": [0, 0.68333, 0, 0.02778, 0.68056],
              "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
              "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
              "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
              "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
              "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
              "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
              "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
              "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
              "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
              "86": [0, 0.68333, 0.22222, 0, 0.58333],
              "87": [0, 0.68333, 0.13889, 0, 0.94445],
              "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
              "89": [0, 0.68333, 0.22222, 0, 0.58056],
              "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
              "97": [0, 0.43056, 0, 0, 0.52859],
              "98": [0, 0.69444, 0, 0, 0.42917],
              "99": [0, 0.43056, 0, 0.05556, 0.43276],
              "100": [0, 0.69444, 0, 0.16667, 0.52049],
              "101": [0, 0.43056, 0, 0.05556, 0.46563],
              "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
              "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
              "104": [0, 0.69444, 0, 0, 0.57616],
              "105": [0, 0.65952, 0, 0, 0.34451],
              "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
              "107": [0, 0.69444, 0.03148, 0, 0.5206],
              "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
              "109": [0, 0.43056, 0, 0, 0.87801],
              "110": [0, 0.43056, 0, 0, 0.60023],
              "111": [0, 0.43056, 0, 0.05556, 0.48472],
              "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
              "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
              "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
              "115": [0, 0.43056, 0, 0.05556, 0.46875],
              "116": [0, 0.61508, 0, 0.08334, 0.36111],
              "117": [0, 0.43056, 0, 0.02778, 0.57246],
              "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
              "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
              "120": [0, 0.43056, 0, 0.02778, 0.57153],
              "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
              "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
              "160": [0, 0, 0, 0, 0.25],
              "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
              "916": [0, 0.68333, 0, 0.16667, 0.83334],
              "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
              "923": [0, 0.68333, 0, 0.16667, 0.69445],
              "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
              "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
              "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
              "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
              "934": [0, 0.68333, 0, 0.08334, 0.66667],
              "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
              "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
              "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
              "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
              "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
              "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
              "949": [0, 0.43056, 0, 0.08334, 0.46632],
              "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
              "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
              "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
              "953": [0, 0.43056, 0, 0.05556, 0.35394],
              "954": [0, 0.43056, 0, 0, 0.57616],
              "955": [0, 0.69444, 0, 0, 0.58334],
              "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
              "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
              "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
              "959": [0, 0.43056, 0, 0.05556, 0.48472],
              "960": [0, 0.43056, 0.03588, 0, 0.57003],
              "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
              "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
              "963": [0, 0.43056, 0.03588, 0, 0.57141],
              "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
              "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
              "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
              "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
              "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
              "969": [0, 0.43056, 0.03588, 0, 0.62245],
              "977": [0, 0.69444, 0, 0.08334, 0.59144],
              "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
              "982": [0, 0.43056, 0.02778, 0, 0.82813],
              "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
              "1013": [0, 0.43056, 0, 0.05556, 0.4059],
              "57649": [0, 0.43056, 0, 0.02778, 0.32246],
              "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
            },
            "SansSerif-Bold": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69444, 0, 0, 0.36667],
              "34": [0, 0.69444, 0, 0, 0.55834],
              "35": [0.19444, 0.69444, 0, 0, 0.91667],
              "36": [0.05556, 0.75, 0, 0, 0.55],
              "37": [0.05556, 0.75, 0, 0, 1.02912],
              "38": [0, 0.69444, 0, 0, 0.83056],
              "39": [0, 0.69444, 0, 0, 0.30556],
              "40": [0.25, 0.75, 0, 0, 0.42778],
              "41": [0.25, 0.75, 0, 0, 0.42778],
              "42": [0, 0.75, 0, 0, 0.55],
              "43": [0.11667, 0.61667, 0, 0, 0.85556],
              "44": [0.10556, 0.13056, 0, 0, 0.30556],
              "45": [0, 0.45833, 0, 0, 0.36667],
              "46": [0, 0.13056, 0, 0, 0.30556],
              "47": [0.25, 0.75, 0, 0, 0.55],
              "48": [0, 0.69444, 0, 0, 0.55],
              "49": [0, 0.69444, 0, 0, 0.55],
              "50": [0, 0.69444, 0, 0, 0.55],
              "51": [0, 0.69444, 0, 0, 0.55],
              "52": [0, 0.69444, 0, 0, 0.55],
              "53": [0, 0.69444, 0, 0, 0.55],
              "54": [0, 0.69444, 0, 0, 0.55],
              "55": [0, 0.69444, 0, 0, 0.55],
              "56": [0, 0.69444, 0, 0, 0.55],
              "57": [0, 0.69444, 0, 0, 0.55],
              "58": [0, 0.45833, 0, 0, 0.30556],
              "59": [0.10556, 0.45833, 0, 0, 0.30556],
              "61": [-0.09375, 0.40625, 0, 0, 0.85556],
              "63": [0, 0.69444, 0, 0, 0.51945],
              "64": [0, 0.69444, 0, 0, 0.73334],
              "65": [0, 0.69444, 0, 0, 0.73334],
              "66": [0, 0.69444, 0, 0, 0.73334],
              "67": [0, 0.69444, 0, 0, 0.70278],
              "68": [0, 0.69444, 0, 0, 0.79445],
              "69": [0, 0.69444, 0, 0, 0.64167],
              "70": [0, 0.69444, 0, 0, 0.61111],
              "71": [0, 0.69444, 0, 0, 0.73334],
              "72": [0, 0.69444, 0, 0, 0.79445],
              "73": [0, 0.69444, 0, 0, 0.33056],
              "74": [0, 0.69444, 0, 0, 0.51945],
              "75": [0, 0.69444, 0, 0, 0.76389],
              "76": [0, 0.69444, 0, 0, 0.58056],
              "77": [0, 0.69444, 0, 0, 0.97778],
              "78": [0, 0.69444, 0, 0, 0.79445],
              "79": [0, 0.69444, 0, 0, 0.79445],
              "80": [0, 0.69444, 0, 0, 0.70278],
              "81": [0.10556, 0.69444, 0, 0, 0.79445],
              "82": [0, 0.69444, 0, 0, 0.70278],
              "83": [0, 0.69444, 0, 0, 0.61111],
              "84": [0, 0.69444, 0, 0, 0.73334],
              "85": [0, 0.69444, 0, 0, 0.76389],
              "86": [0, 0.69444, 0.01528, 0, 0.73334],
              "87": [0, 0.69444, 0.01528, 0, 1.03889],
              "88": [0, 0.69444, 0, 0, 0.73334],
              "89": [0, 0.69444, 0.0275, 0, 0.73334],
              "90": [0, 0.69444, 0, 0, 0.67223],
              "91": [0.25, 0.75, 0, 0, 0.34306],
              "93": [0.25, 0.75, 0, 0, 0.34306],
              "94": [0, 0.69444, 0, 0, 0.55],
              "95": [0.35, 0.10833, 0.03056, 0, 0.55],
              "97": [0, 0.45833, 0, 0, 0.525],
              "98": [0, 0.69444, 0, 0, 0.56111],
              "99": [0, 0.45833, 0, 0, 0.48889],
              "100": [0, 0.69444, 0, 0, 0.56111],
              "101": [0, 0.45833, 0, 0, 0.51111],
              "102": [0, 0.69444, 0.07639, 0, 0.33611],
              "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
              "104": [0, 0.69444, 0, 0, 0.56111],
              "105": [0, 0.69444, 0, 0, 0.25556],
              "106": [0.19444, 0.69444, 0, 0, 0.28611],
              "107": [0, 0.69444, 0, 0, 0.53056],
              "108": [0, 0.69444, 0, 0, 0.25556],
              "109": [0, 0.45833, 0, 0, 0.86667],
              "110": [0, 0.45833, 0, 0, 0.56111],
              "111": [0, 0.45833, 0, 0, 0.55],
              "112": [0.19444, 0.45833, 0, 0, 0.56111],
              "113": [0.19444, 0.45833, 0, 0, 0.56111],
              "114": [0, 0.45833, 0.01528, 0, 0.37222],
              "115": [0, 0.45833, 0, 0, 0.42167],
              "116": [0, 0.58929, 0, 0, 0.40417],
              "117": [0, 0.45833, 0, 0, 0.56111],
              "118": [0, 0.45833, 0.01528, 0, 0.5],
              "119": [0, 0.45833, 0.01528, 0, 0.74445],
              "120": [0, 0.45833, 0, 0, 0.5],
              "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
              "122": [0, 0.45833, 0, 0, 0.47639],
              "126": [0.35, 0.34444, 0, 0, 0.55],
              "160": [0, 0, 0, 0, 0.25],
              "168": [0, 0.69444, 0, 0, 0.55],
              "176": [0, 0.69444, 0, 0, 0.73334],
              "180": [0, 0.69444, 0, 0, 0.55],
              "184": [0.17014, 0, 0, 0, 0.48889],
              "305": [0, 0.45833, 0, 0, 0.25556],
              "567": [0.19444, 0.45833, 0, 0, 0.28611],
              "710": [0, 0.69444, 0, 0, 0.55],
              "711": [0, 0.63542, 0, 0, 0.55],
              "713": [0, 0.63778, 0, 0, 0.55],
              "728": [0, 0.69444, 0, 0, 0.55],
              "729": [0, 0.69444, 0, 0, 0.30556],
              "730": [0, 0.69444, 0, 0, 0.73334],
              "732": [0, 0.69444, 0, 0, 0.55],
              "733": [0, 0.69444, 0, 0, 0.55],
              "915": [0, 0.69444, 0, 0, 0.58056],
              "916": [0, 0.69444, 0, 0, 0.91667],
              "920": [0, 0.69444, 0, 0, 0.85556],
              "923": [0, 0.69444, 0, 0, 0.67223],
              "926": [0, 0.69444, 0, 0, 0.73334],
              "928": [0, 0.69444, 0, 0, 0.79445],
              "931": [0, 0.69444, 0, 0, 0.79445],
              "933": [0, 0.69444, 0, 0, 0.85556],
              "934": [0, 0.69444, 0, 0, 0.79445],
              "936": [0, 0.69444, 0, 0, 0.85556],
              "937": [0, 0.69444, 0, 0, 0.79445],
              "8211": [0, 0.45833, 0.03056, 0, 0.55],
              "8212": [0, 0.45833, 0.03056, 0, 1.10001],
              "8216": [0, 0.69444, 0, 0, 0.30556],
              "8217": [0, 0.69444, 0, 0, 0.30556],
              "8220": [0, 0.69444, 0, 0, 0.55834],
              "8221": [0, 0.69444, 0, 0, 0.55834]
            },
            "SansSerif-Italic": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69444, 0.05733, 0, 0.31945],
              "34": [0, 0.69444, 316e-5, 0, 0.5],
              "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
              "36": [0.05556, 0.75, 0.11156, 0, 0.5],
              "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
              "38": [0, 0.69444, 0.03058, 0, 0.75834],
              "39": [0, 0.69444, 0.07816, 0, 0.27778],
              "40": [0.25, 0.75, 0.13164, 0, 0.38889],
              "41": [0.25, 0.75, 0.02536, 0, 0.38889],
              "42": [0, 0.75, 0.11775, 0, 0.5],
              "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
              "44": [0.125, 0.08333, 0, 0, 0.27778],
              "45": [0, 0.44444, 0.01946, 0, 0.33333],
              "46": [0, 0.08333, 0, 0, 0.27778],
              "47": [0.25, 0.75, 0.13164, 0, 0.5],
              "48": [0, 0.65556, 0.11156, 0, 0.5],
              "49": [0, 0.65556, 0.11156, 0, 0.5],
              "50": [0, 0.65556, 0.11156, 0, 0.5],
              "51": [0, 0.65556, 0.11156, 0, 0.5],
              "52": [0, 0.65556, 0.11156, 0, 0.5],
              "53": [0, 0.65556, 0.11156, 0, 0.5],
              "54": [0, 0.65556, 0.11156, 0, 0.5],
              "55": [0, 0.65556, 0.11156, 0, 0.5],
              "56": [0, 0.65556, 0.11156, 0, 0.5],
              "57": [0, 0.65556, 0.11156, 0, 0.5],
              "58": [0, 0.44444, 0.02502, 0, 0.27778],
              "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
              "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
              "63": [0, 0.69444, 0.11809, 0, 0.47222],
              "64": [0, 0.69444, 0.07555, 0, 0.66667],
              "65": [0, 0.69444, 0, 0, 0.66667],
              "66": [0, 0.69444, 0.08293, 0, 0.66667],
              "67": [0, 0.69444, 0.11983, 0, 0.63889],
              "68": [0, 0.69444, 0.07555, 0, 0.72223],
              "69": [0, 0.69444, 0.11983, 0, 0.59722],
              "70": [0, 0.69444, 0.13372, 0, 0.56945],
              "71": [0, 0.69444, 0.11983, 0, 0.66667],
              "72": [0, 0.69444, 0.08094, 0, 0.70834],
              "73": [0, 0.69444, 0.13372, 0, 0.27778],
              "74": [0, 0.69444, 0.08094, 0, 0.47222],
              "75": [0, 0.69444, 0.11983, 0, 0.69445],
              "76": [0, 0.69444, 0, 0, 0.54167],
              "77": [0, 0.69444, 0.08094, 0, 0.875],
              "78": [0, 0.69444, 0.08094, 0, 0.70834],
              "79": [0, 0.69444, 0.07555, 0, 0.73611],
              "80": [0, 0.69444, 0.08293, 0, 0.63889],
              "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
              "82": [0, 0.69444, 0.08293, 0, 0.64584],
              "83": [0, 0.69444, 0.09205, 0, 0.55556],
              "84": [0, 0.69444, 0.13372, 0, 0.68056],
              "85": [0, 0.69444, 0.08094, 0, 0.6875],
              "86": [0, 0.69444, 0.1615, 0, 0.66667],
              "87": [0, 0.69444, 0.1615, 0, 0.94445],
              "88": [0, 0.69444, 0.13372, 0, 0.66667],
              "89": [0, 0.69444, 0.17261, 0, 0.66667],
              "90": [0, 0.69444, 0.11983, 0, 0.61111],
              "91": [0.25, 0.75, 0.15942, 0, 0.28889],
              "93": [0.25, 0.75, 0.08719, 0, 0.28889],
              "94": [0, 0.69444, 0.0799, 0, 0.5],
              "95": [0.35, 0.09444, 0.08616, 0, 0.5],
              "97": [0, 0.44444, 981e-5, 0, 0.48056],
              "98": [0, 0.69444, 0.03057, 0, 0.51667],
              "99": [0, 0.44444, 0.08336, 0, 0.44445],
              "100": [0, 0.69444, 0.09483, 0, 0.51667],
              "101": [0, 0.44444, 0.06778, 0, 0.44445],
              "102": [0, 0.69444, 0.21705, 0, 0.30556],
              "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
              "104": [0, 0.69444, 0.01778, 0, 0.51667],
              "105": [0, 0.67937, 0.09718, 0, 0.23889],
              "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
              "107": [0, 0.69444, 0.08336, 0, 0.48889],
              "108": [0, 0.69444, 0.09483, 0, 0.23889],
              "109": [0, 0.44444, 0.01778, 0, 0.79445],
              "110": [0, 0.44444, 0.01778, 0, 0.51667],
              "111": [0, 0.44444, 0.06613, 0, 0.5],
              "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
              "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
              "114": [0, 0.44444, 0.10836, 0, 0.34167],
              "115": [0, 0.44444, 0.0778, 0, 0.38333],
              "116": [0, 0.57143, 0.07225, 0, 0.36111],
              "117": [0, 0.44444, 0.04169, 0, 0.51667],
              "118": [0, 0.44444, 0.10836, 0, 0.46111],
              "119": [0, 0.44444, 0.10836, 0, 0.68334],
              "120": [0, 0.44444, 0.09169, 0, 0.46111],
              "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
              "122": [0, 0.44444, 0.08752, 0, 0.43472],
              "126": [0.35, 0.32659, 0.08826, 0, 0.5],
              "160": [0, 0, 0, 0, 0.25],
              "168": [0, 0.67937, 0.06385, 0, 0.5],
              "176": [0, 0.69444, 0, 0, 0.73752],
              "184": [0.17014, 0, 0, 0, 0.44445],
              "305": [0, 0.44444, 0.04169, 0, 0.23889],
              "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
              "710": [0, 0.69444, 0.0799, 0, 0.5],
              "711": [0, 0.63194, 0.08432, 0, 0.5],
              "713": [0, 0.60889, 0.08776, 0, 0.5],
              "714": [0, 0.69444, 0.09205, 0, 0.5],
              "715": [0, 0.69444, 0, 0, 0.5],
              "728": [0, 0.69444, 0.09483, 0, 0.5],
              "729": [0, 0.67937, 0.07774, 0, 0.27778],
              "730": [0, 0.69444, 0, 0, 0.73752],
              "732": [0, 0.67659, 0.08826, 0, 0.5],
              "733": [0, 0.69444, 0.09205, 0, 0.5],
              "915": [0, 0.69444, 0.13372, 0, 0.54167],
              "916": [0, 0.69444, 0, 0, 0.83334],
              "920": [0, 0.69444, 0.07555, 0, 0.77778],
              "923": [0, 0.69444, 0, 0, 0.61111],
              "926": [0, 0.69444, 0.12816, 0, 0.66667],
              "928": [0, 0.69444, 0.08094, 0, 0.70834],
              "931": [0, 0.69444, 0.11983, 0, 0.72222],
              "933": [0, 0.69444, 0.09031, 0, 0.77778],
              "934": [0, 0.69444, 0.04603, 0, 0.72222],
              "936": [0, 0.69444, 0.09031, 0, 0.77778],
              "937": [0, 0.69444, 0.08293, 0, 0.72222],
              "8211": [0, 0.44444, 0.08616, 0, 0.5],
              "8212": [0, 0.44444, 0.08616, 0, 1],
              "8216": [0, 0.69444, 0.07816, 0, 0.27778],
              "8217": [0, 0.69444, 0.07816, 0, 0.27778],
              "8220": [0, 0.69444, 0.14205, 0, 0.5],
              "8221": [0, 0.69444, 316e-5, 0, 0.5]
            },
            "SansSerif-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69444, 0, 0, 0.31945],
              "34": [0, 0.69444, 0, 0, 0.5],
              "35": [0.19444, 0.69444, 0, 0, 0.83334],
              "36": [0.05556, 0.75, 0, 0, 0.5],
              "37": [0.05556, 0.75, 0, 0, 0.83334],
              "38": [0, 0.69444, 0, 0, 0.75834],
              "39": [0, 0.69444, 0, 0, 0.27778],
              "40": [0.25, 0.75, 0, 0, 0.38889],
              "41": [0.25, 0.75, 0, 0, 0.38889],
              "42": [0, 0.75, 0, 0, 0.5],
              "43": [0.08333, 0.58333, 0, 0, 0.77778],
              "44": [0.125, 0.08333, 0, 0, 0.27778],
              "45": [0, 0.44444, 0, 0, 0.33333],
              "46": [0, 0.08333, 0, 0, 0.27778],
              "47": [0.25, 0.75, 0, 0, 0.5],
              "48": [0, 0.65556, 0, 0, 0.5],
              "49": [0, 0.65556, 0, 0, 0.5],
              "50": [0, 0.65556, 0, 0, 0.5],
              "51": [0, 0.65556, 0, 0, 0.5],
              "52": [0, 0.65556, 0, 0, 0.5],
              "53": [0, 0.65556, 0, 0, 0.5],
              "54": [0, 0.65556, 0, 0, 0.5],
              "55": [0, 0.65556, 0, 0, 0.5],
              "56": [0, 0.65556, 0, 0, 0.5],
              "57": [0, 0.65556, 0, 0, 0.5],
              "58": [0, 0.44444, 0, 0, 0.27778],
              "59": [0.125, 0.44444, 0, 0, 0.27778],
              "61": [-0.13, 0.37, 0, 0, 0.77778],
              "63": [0, 0.69444, 0, 0, 0.47222],
              "64": [0, 0.69444, 0, 0, 0.66667],
              "65": [0, 0.69444, 0, 0, 0.66667],
              "66": [0, 0.69444, 0, 0, 0.66667],
              "67": [0, 0.69444, 0, 0, 0.63889],
              "68": [0, 0.69444, 0, 0, 0.72223],
              "69": [0, 0.69444, 0, 0, 0.59722],
              "70": [0, 0.69444, 0, 0, 0.56945],
              "71": [0, 0.69444, 0, 0, 0.66667],
              "72": [0, 0.69444, 0, 0, 0.70834],
              "73": [0, 0.69444, 0, 0, 0.27778],
              "74": [0, 0.69444, 0, 0, 0.47222],
              "75": [0, 0.69444, 0, 0, 0.69445],
              "76": [0, 0.69444, 0, 0, 0.54167],
              "77": [0, 0.69444, 0, 0, 0.875],
              "78": [0, 0.69444, 0, 0, 0.70834],
              "79": [0, 0.69444, 0, 0, 0.73611],
              "80": [0, 0.69444, 0, 0, 0.63889],
              "81": [0.125, 0.69444, 0, 0, 0.73611],
              "82": [0, 0.69444, 0, 0, 0.64584],
              "83": [0, 0.69444, 0, 0, 0.55556],
              "84": [0, 0.69444, 0, 0, 0.68056],
              "85": [0, 0.69444, 0, 0, 0.6875],
              "86": [0, 0.69444, 0.01389, 0, 0.66667],
              "87": [0, 0.69444, 0.01389, 0, 0.94445],
              "88": [0, 0.69444, 0, 0, 0.66667],
              "89": [0, 0.69444, 0.025, 0, 0.66667],
              "90": [0, 0.69444, 0, 0, 0.61111],
              "91": [0.25, 0.75, 0, 0, 0.28889],
              "93": [0.25, 0.75, 0, 0, 0.28889],
              "94": [0, 0.69444, 0, 0, 0.5],
              "95": [0.35, 0.09444, 0.02778, 0, 0.5],
              "97": [0, 0.44444, 0, 0, 0.48056],
              "98": [0, 0.69444, 0, 0, 0.51667],
              "99": [0, 0.44444, 0, 0, 0.44445],
              "100": [0, 0.69444, 0, 0, 0.51667],
              "101": [0, 0.44444, 0, 0, 0.44445],
              "102": [0, 0.69444, 0.06944, 0, 0.30556],
              "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
              "104": [0, 0.69444, 0, 0, 0.51667],
              "105": [0, 0.67937, 0, 0, 0.23889],
              "106": [0.19444, 0.67937, 0, 0, 0.26667],
              "107": [0, 0.69444, 0, 0, 0.48889],
              "108": [0, 0.69444, 0, 0, 0.23889],
              "109": [0, 0.44444, 0, 0, 0.79445],
              "110": [0, 0.44444, 0, 0, 0.51667],
              "111": [0, 0.44444, 0, 0, 0.5],
              "112": [0.19444, 0.44444, 0, 0, 0.51667],
              "113": [0.19444, 0.44444, 0, 0, 0.51667],
              "114": [0, 0.44444, 0.01389, 0, 0.34167],
              "115": [0, 0.44444, 0, 0, 0.38333],
              "116": [0, 0.57143, 0, 0, 0.36111],
              "117": [0, 0.44444, 0, 0, 0.51667],
              "118": [0, 0.44444, 0.01389, 0, 0.46111],
              "119": [0, 0.44444, 0.01389, 0, 0.68334],
              "120": [0, 0.44444, 0, 0, 0.46111],
              "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
              "122": [0, 0.44444, 0, 0, 0.43472],
              "126": [0.35, 0.32659, 0, 0, 0.5],
              "160": [0, 0, 0, 0, 0.25],
              "168": [0, 0.67937, 0, 0, 0.5],
              "176": [0, 0.69444, 0, 0, 0.66667],
              "184": [0.17014, 0, 0, 0, 0.44445],
              "305": [0, 0.44444, 0, 0, 0.23889],
              "567": [0.19444, 0.44444, 0, 0, 0.26667],
              "710": [0, 0.69444, 0, 0, 0.5],
              "711": [0, 0.63194, 0, 0, 0.5],
              "713": [0, 0.60889, 0, 0, 0.5],
              "714": [0, 0.69444, 0, 0, 0.5],
              "715": [0, 0.69444, 0, 0, 0.5],
              "728": [0, 0.69444, 0, 0, 0.5],
              "729": [0, 0.67937, 0, 0, 0.27778],
              "730": [0, 0.69444, 0, 0, 0.66667],
              "732": [0, 0.67659, 0, 0, 0.5],
              "733": [0, 0.69444, 0, 0, 0.5],
              "915": [0, 0.69444, 0, 0, 0.54167],
              "916": [0, 0.69444, 0, 0, 0.83334],
              "920": [0, 0.69444, 0, 0, 0.77778],
              "923": [0, 0.69444, 0, 0, 0.61111],
              "926": [0, 0.69444, 0, 0, 0.66667],
              "928": [0, 0.69444, 0, 0, 0.70834],
              "931": [0, 0.69444, 0, 0, 0.72222],
              "933": [0, 0.69444, 0, 0, 0.77778],
              "934": [0, 0.69444, 0, 0, 0.72222],
              "936": [0, 0.69444, 0, 0, 0.77778],
              "937": [0, 0.69444, 0, 0, 0.72222],
              "8211": [0, 0.44444, 0.02778, 0, 0.5],
              "8212": [0, 0.44444, 0.02778, 0, 1],
              "8216": [0, 0.69444, 0, 0, 0.27778],
              "8217": [0, 0.69444, 0, 0, 0.27778],
              "8220": [0, 0.69444, 0, 0, 0.5],
              "8221": [0, 0.69444, 0, 0, 0.5]
            },
            "Script-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "65": [0, 0.7, 0.22925, 0, 0.80253],
              "66": [0, 0.7, 0.04087, 0, 0.90757],
              "67": [0, 0.7, 0.1689, 0, 0.66619],
              "68": [0, 0.7, 0.09371, 0, 0.77443],
              "69": [0, 0.7, 0.18583, 0, 0.56162],
              "70": [0, 0.7, 0.13634, 0, 0.89544],
              "71": [0, 0.7, 0.17322, 0, 0.60961],
              "72": [0, 0.7, 0.29694, 0, 0.96919],
              "73": [0, 0.7, 0.19189, 0, 0.80907],
              "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
              "75": [0, 0.7, 0.31259, 0, 0.91364],
              "76": [0, 0.7, 0.19189, 0, 0.87373],
              "77": [0, 0.7, 0.15981, 0, 1.08031],
              "78": [0, 0.7, 0.3525, 0, 0.9015],
              "79": [0, 0.7, 0.08078, 0, 0.73787],
              "80": [0, 0.7, 0.08078, 0, 1.01262],
              "81": [0, 0.7, 0.03305, 0, 0.88282],
              "82": [0, 0.7, 0.06259, 0, 0.85],
              "83": [0, 0.7, 0.19189, 0, 0.86767],
              "84": [0, 0.7, 0.29087, 0, 0.74697],
              "85": [0, 0.7, 0.25815, 0, 0.79996],
              "86": [0, 0.7, 0.27523, 0, 0.62204],
              "87": [0, 0.7, 0.27523, 0, 0.80532],
              "88": [0, 0.7, 0.26006, 0, 0.94445],
              "89": [0, 0.7, 0.2939, 0, 0.70961],
              "90": [0, 0.7, 0.24037, 0, 0.8212],
              "160": [0, 0, 0, 0, 0.25]
            },
            "Size1-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "40": [0.35001, 0.85, 0, 0, 0.45834],
              "41": [0.35001, 0.85, 0, 0, 0.45834],
              "47": [0.35001, 0.85, 0, 0, 0.57778],
              "91": [0.35001, 0.85, 0, 0, 0.41667],
              "92": [0.35001, 0.85, 0, 0, 0.57778],
              "93": [0.35001, 0.85, 0, 0, 0.41667],
              "123": [0.35001, 0.85, 0, 0, 0.58334],
              "125": [0.35001, 0.85, 0, 0, 0.58334],
              "160": [0, 0, 0, 0, 0.25],
              "710": [0, 0.72222, 0, 0, 0.55556],
              "732": [0, 0.72222, 0, 0, 0.55556],
              "770": [0, 0.72222, 0, 0, 0.55556],
              "771": [0, 0.72222, 0, 0, 0.55556],
              "8214": [-99e-5, 0.601, 0, 0, 0.77778],
              "8593": [1e-5, 0.6, 0, 0, 0.66667],
              "8595": [1e-5, 0.6, 0, 0, 0.66667],
              "8657": [1e-5, 0.6, 0, 0, 0.77778],
              "8659": [1e-5, 0.6, 0, 0, 0.77778],
              "8719": [0.25001, 0.75, 0, 0, 0.94445],
              "8720": [0.25001, 0.75, 0, 0, 0.94445],
              "8721": [0.25001, 0.75, 0, 0, 1.05556],
              "8730": [0.35001, 0.85, 0, 0, 1],
              "8739": [-599e-5, 0.606, 0, 0, 0.33333],
              "8741": [-599e-5, 0.606, 0, 0, 0.55556],
              "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
              "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
              "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
              "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
              "8896": [0.25001, 0.75, 0, 0, 0.83334],
              "8897": [0.25001, 0.75, 0, 0, 0.83334],
              "8898": [0.25001, 0.75, 0, 0, 0.83334],
              "8899": [0.25001, 0.75, 0, 0, 0.83334],
              "8968": [0.35001, 0.85, 0, 0, 0.47222],
              "8969": [0.35001, 0.85, 0, 0, 0.47222],
              "8970": [0.35001, 0.85, 0, 0, 0.47222],
              "8971": [0.35001, 0.85, 0, 0, 0.47222],
              "9168": [-99e-5, 0.601, 0, 0, 0.66667],
              "10216": [0.35001, 0.85, 0, 0, 0.47222],
              "10217": [0.35001, 0.85, 0, 0, 0.47222],
              "10752": [0.25001, 0.75, 0, 0, 1.11111],
              "10753": [0.25001, 0.75, 0, 0, 1.11111],
              "10754": [0.25001, 0.75, 0, 0, 1.11111],
              "10756": [0.25001, 0.75, 0, 0, 0.83334],
              "10758": [0.25001, 0.75, 0, 0, 0.83334]
            },
            "Size2-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "40": [0.65002, 1.15, 0, 0, 0.59722],
              "41": [0.65002, 1.15, 0, 0, 0.59722],
              "47": [0.65002, 1.15, 0, 0, 0.81111],
              "91": [0.65002, 1.15, 0, 0, 0.47222],
              "92": [0.65002, 1.15, 0, 0, 0.81111],
              "93": [0.65002, 1.15, 0, 0, 0.47222],
              "123": [0.65002, 1.15, 0, 0, 0.66667],
              "125": [0.65002, 1.15, 0, 0, 0.66667],
              "160": [0, 0, 0, 0, 0.25],
              "710": [0, 0.75, 0, 0, 1],
              "732": [0, 0.75, 0, 0, 1],
              "770": [0, 0.75, 0, 0, 1],
              "771": [0, 0.75, 0, 0, 1],
              "8719": [0.55001, 1.05, 0, 0, 1.27778],
              "8720": [0.55001, 1.05, 0, 0, 1.27778],
              "8721": [0.55001, 1.05, 0, 0, 1.44445],
              "8730": [0.65002, 1.15, 0, 0, 1],
              "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
              "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
              "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
              "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
              "8896": [0.55001, 1.05, 0, 0, 1.11111],
              "8897": [0.55001, 1.05, 0, 0, 1.11111],
              "8898": [0.55001, 1.05, 0, 0, 1.11111],
              "8899": [0.55001, 1.05, 0, 0, 1.11111],
              "8968": [0.65002, 1.15, 0, 0, 0.52778],
              "8969": [0.65002, 1.15, 0, 0, 0.52778],
              "8970": [0.65002, 1.15, 0, 0, 0.52778],
              "8971": [0.65002, 1.15, 0, 0, 0.52778],
              "10216": [0.65002, 1.15, 0, 0, 0.61111],
              "10217": [0.65002, 1.15, 0, 0, 0.61111],
              "10752": [0.55001, 1.05, 0, 0, 1.51112],
              "10753": [0.55001, 1.05, 0, 0, 1.51112],
              "10754": [0.55001, 1.05, 0, 0, 1.51112],
              "10756": [0.55001, 1.05, 0, 0, 1.11111],
              "10758": [0.55001, 1.05, 0, 0, 1.11111]
            },
            "Size3-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "40": [0.95003, 1.45, 0, 0, 0.73611],
              "41": [0.95003, 1.45, 0, 0, 0.73611],
              "47": [0.95003, 1.45, 0, 0, 1.04445],
              "91": [0.95003, 1.45, 0, 0, 0.52778],
              "92": [0.95003, 1.45, 0, 0, 1.04445],
              "93": [0.95003, 1.45, 0, 0, 0.52778],
              "123": [0.95003, 1.45, 0, 0, 0.75],
              "125": [0.95003, 1.45, 0, 0, 0.75],
              "160": [0, 0, 0, 0, 0.25],
              "710": [0, 0.75, 0, 0, 1.44445],
              "732": [0, 0.75, 0, 0, 1.44445],
              "770": [0, 0.75, 0, 0, 1.44445],
              "771": [0, 0.75, 0, 0, 1.44445],
              "8730": [0.95003, 1.45, 0, 0, 1],
              "8968": [0.95003, 1.45, 0, 0, 0.58334],
              "8969": [0.95003, 1.45, 0, 0, 0.58334],
              "8970": [0.95003, 1.45, 0, 0, 0.58334],
              "8971": [0.95003, 1.45, 0, 0, 0.58334],
              "10216": [0.95003, 1.45, 0, 0, 0.75],
              "10217": [0.95003, 1.45, 0, 0, 0.75]
            },
            "Size4-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "40": [1.25003, 1.75, 0, 0, 0.79167],
              "41": [1.25003, 1.75, 0, 0, 0.79167],
              "47": [1.25003, 1.75, 0, 0, 1.27778],
              "91": [1.25003, 1.75, 0, 0, 0.58334],
              "92": [1.25003, 1.75, 0, 0, 1.27778],
              "93": [1.25003, 1.75, 0, 0, 0.58334],
              "123": [1.25003, 1.75, 0, 0, 0.80556],
              "125": [1.25003, 1.75, 0, 0, 0.80556],
              "160": [0, 0, 0, 0, 0.25],
              "710": [0, 0.825, 0, 0, 1.8889],
              "732": [0, 0.825, 0, 0, 1.8889],
              "770": [0, 0.825, 0, 0, 1.8889],
              "771": [0, 0.825, 0, 0, 1.8889],
              "8730": [1.25003, 1.75, 0, 0, 1],
              "8968": [1.25003, 1.75, 0, 0, 0.63889],
              "8969": [1.25003, 1.75, 0, 0, 0.63889],
              "8970": [1.25003, 1.75, 0, 0, 0.63889],
              "8971": [1.25003, 1.75, 0, 0, 0.63889],
              "9115": [0.64502, 1.155, 0, 0, 0.875],
              "9116": [1e-5, 0.6, 0, 0, 0.875],
              "9117": [0.64502, 1.155, 0, 0, 0.875],
              "9118": [0.64502, 1.155, 0, 0, 0.875],
              "9119": [1e-5, 0.6, 0, 0, 0.875],
              "9120": [0.64502, 1.155, 0, 0, 0.875],
              "9121": [0.64502, 1.155, 0, 0, 0.66667],
              "9122": [-99e-5, 0.601, 0, 0, 0.66667],
              "9123": [0.64502, 1.155, 0, 0, 0.66667],
              "9124": [0.64502, 1.155, 0, 0, 0.66667],
              "9125": [-99e-5, 0.601, 0, 0, 0.66667],
              "9126": [0.64502, 1.155, 0, 0, 0.66667],
              "9127": [1e-5, 0.9, 0, 0, 0.88889],
              "9128": [0.65002, 1.15, 0, 0, 0.88889],
              "9129": [0.90001, 0, 0, 0, 0.88889],
              "9130": [0, 0.3, 0, 0, 0.88889],
              "9131": [1e-5, 0.9, 0, 0, 0.88889],
              "9132": [0.65002, 1.15, 0, 0, 0.88889],
              "9133": [0.90001, 0, 0, 0, 0.88889],
              "9143": [0.88502, 0.915, 0, 0, 1.05556],
              "10216": [1.25003, 1.75, 0, 0, 0.80556],
              "10217": [1.25003, 1.75, 0, 0, 0.80556],
              "57344": [-499e-5, 0.605, 0, 0, 1.05556],
              "57345": [-499e-5, 0.605, 0, 0, 1.05556],
              "57680": [0, 0.12, 0, 0, 0.45],
              "57681": [0, 0.12, 0, 0, 0.45],
              "57682": [0, 0.12, 0, 0, 0.45],
              "57683": [0, 0.12, 0, 0, 0.45]
            },
            "Typewriter-Regular": {
              "32": [0, 0, 0, 0, 0.525],
              "33": [0, 0.61111, 0, 0, 0.525],
              "34": [0, 0.61111, 0, 0, 0.525],
              "35": [0, 0.61111, 0, 0, 0.525],
              "36": [0.08333, 0.69444, 0, 0, 0.525],
              "37": [0.08333, 0.69444, 0, 0, 0.525],
              "38": [0, 0.61111, 0, 0, 0.525],
              "39": [0, 0.61111, 0, 0, 0.525],
              "40": [0.08333, 0.69444, 0, 0, 0.525],
              "41": [0.08333, 0.69444, 0, 0, 0.525],
              "42": [0, 0.52083, 0, 0, 0.525],
              "43": [-0.08056, 0.53055, 0, 0, 0.525],
              "44": [0.13889, 0.125, 0, 0, 0.525],
              "45": [-0.08056, 0.53055, 0, 0, 0.525],
              "46": [0, 0.125, 0, 0, 0.525],
              "47": [0.08333, 0.69444, 0, 0, 0.525],
              "48": [0, 0.61111, 0, 0, 0.525],
              "49": [0, 0.61111, 0, 0, 0.525],
              "50": [0, 0.61111, 0, 0, 0.525],
              "51": [0, 0.61111, 0, 0, 0.525],
              "52": [0, 0.61111, 0, 0, 0.525],
              "53": [0, 0.61111, 0, 0, 0.525],
              "54": [0, 0.61111, 0, 0, 0.525],
              "55": [0, 0.61111, 0, 0, 0.525],
              "56": [0, 0.61111, 0, 0, 0.525],
              "57": [0, 0.61111, 0, 0, 0.525],
              "58": [0, 0.43056, 0, 0, 0.525],
              "59": [0.13889, 0.43056, 0, 0, 0.525],
              "60": [-0.05556, 0.55556, 0, 0, 0.525],
              "61": [-0.19549, 0.41562, 0, 0, 0.525],
              "62": [-0.05556, 0.55556, 0, 0, 0.525],
              "63": [0, 0.61111, 0, 0, 0.525],
              "64": [0, 0.61111, 0, 0, 0.525],
              "65": [0, 0.61111, 0, 0, 0.525],
              "66": [0, 0.61111, 0, 0, 0.525],
              "67": [0, 0.61111, 0, 0, 0.525],
              "68": [0, 0.61111, 0, 0, 0.525],
              "69": [0, 0.61111, 0, 0, 0.525],
              "70": [0, 0.61111, 0, 0, 0.525],
              "71": [0, 0.61111, 0, 0, 0.525],
              "72": [0, 0.61111, 0, 0, 0.525],
              "73": [0, 0.61111, 0, 0, 0.525],
              "74": [0, 0.61111, 0, 0, 0.525],
              "75": [0, 0.61111, 0, 0, 0.525],
              "76": [0, 0.61111, 0, 0, 0.525],
              "77": [0, 0.61111, 0, 0, 0.525],
              "78": [0, 0.61111, 0, 0, 0.525],
              "79": [0, 0.61111, 0, 0, 0.525],
              "80": [0, 0.61111, 0, 0, 0.525],
              "81": [0.13889, 0.61111, 0, 0, 0.525],
              "82": [0, 0.61111, 0, 0, 0.525],
              "83": [0, 0.61111, 0, 0, 0.525],
              "84": [0, 0.61111, 0, 0, 0.525],
              "85": [0, 0.61111, 0, 0, 0.525],
              "86": [0, 0.61111, 0, 0, 0.525],
              "87": [0, 0.61111, 0, 0, 0.525],
              "88": [0, 0.61111, 0, 0, 0.525],
              "89": [0, 0.61111, 0, 0, 0.525],
              "90": [0, 0.61111, 0, 0, 0.525],
              "91": [0.08333, 0.69444, 0, 0, 0.525],
              "92": [0.08333, 0.69444, 0, 0, 0.525],
              "93": [0.08333, 0.69444, 0, 0, 0.525],
              "94": [0, 0.61111, 0, 0, 0.525],
              "95": [0.09514, 0, 0, 0, 0.525],
              "96": [0, 0.61111, 0, 0, 0.525],
              "97": [0, 0.43056, 0, 0, 0.525],
              "98": [0, 0.61111, 0, 0, 0.525],
              "99": [0, 0.43056, 0, 0, 0.525],
              "100": [0, 0.61111, 0, 0, 0.525],
              "101": [0, 0.43056, 0, 0, 0.525],
              "102": [0, 0.61111, 0, 0, 0.525],
              "103": [0.22222, 0.43056, 0, 0, 0.525],
              "104": [0, 0.61111, 0, 0, 0.525],
              "105": [0, 0.61111, 0, 0, 0.525],
              "106": [0.22222, 0.61111, 0, 0, 0.525],
              "107": [0, 0.61111, 0, 0, 0.525],
              "108": [0, 0.61111, 0, 0, 0.525],
              "109": [0, 0.43056, 0, 0, 0.525],
              "110": [0, 0.43056, 0, 0, 0.525],
              "111": [0, 0.43056, 0, 0, 0.525],
              "112": [0.22222, 0.43056, 0, 0, 0.525],
              "113": [0.22222, 0.43056, 0, 0, 0.525],
              "114": [0, 0.43056, 0, 0, 0.525],
              "115": [0, 0.43056, 0, 0, 0.525],
              "116": [0, 0.55358, 0, 0, 0.525],
              "117": [0, 0.43056, 0, 0, 0.525],
              "118": [0, 0.43056, 0, 0, 0.525],
              "119": [0, 0.43056, 0, 0, 0.525],
              "120": [0, 0.43056, 0, 0, 0.525],
              "121": [0.22222, 0.43056, 0, 0, 0.525],
              "122": [0, 0.43056, 0, 0, 0.525],
              "123": [0.08333, 0.69444, 0, 0, 0.525],
              "124": [0.08333, 0.69444, 0, 0, 0.525],
              "125": [0.08333, 0.69444, 0, 0, 0.525],
              "126": [0, 0.61111, 0, 0, 0.525],
              "127": [0, 0.61111, 0, 0, 0.525],
              "160": [0, 0, 0, 0, 0.525],
              "176": [0, 0.61111, 0, 0, 0.525],
              "184": [0.19445, 0, 0, 0, 0.525],
              "305": [0, 0.43056, 0, 0, 0.525],
              "567": [0.22222, 0.43056, 0, 0, 0.525],
              "711": [0, 0.56597, 0, 0, 0.525],
              "713": [0, 0.56555, 0, 0, 0.525],
              "714": [0, 0.61111, 0, 0, 0.525],
              "715": [0, 0.61111, 0, 0, 0.525],
              "728": [0, 0.61111, 0, 0, 0.525],
              "730": [0, 0.61111, 0, 0, 0.525],
              "770": [0, 0.61111, 0, 0, 0.525],
              "771": [0, 0.61111, 0, 0, 0.525],
              "776": [0, 0.61111, 0, 0, 0.525],
              "915": [0, 0.61111, 0, 0, 0.525],
              "916": [0, 0.61111, 0, 0, 0.525],
              "920": [0, 0.61111, 0, 0, 0.525],
              "923": [0, 0.61111, 0, 0, 0.525],
              "926": [0, 0.61111, 0, 0, 0.525],
              "928": [0, 0.61111, 0, 0, 0.525],
              "931": [0, 0.61111, 0, 0, 0.525],
              "933": [0, 0.61111, 0, 0, 0.525],
              "934": [0, 0.61111, 0, 0, 0.525],
              "936": [0, 0.61111, 0, 0, 0.525],
              "937": [0, 0.61111, 0, 0, 0.525],
              "8216": [0, 0.61111, 0, 0, 0.525],
              "8217": [0, 0.61111, 0, 0, 0.525],
              "8242": [0, 0.61111, 0, 0, 0.525],
              "9251": [0.11111, 0.21944, 0, 0, 0.525]
            }
          };
          var sigmasAndXis = {
            slant: [0.25, 0.25, 0.25],
            space: [0, 0, 0],
            stretch: [0, 0, 0],
            shrink: [0, 0, 0],
            xHeight: [0.431, 0.431, 0.431],
            quad: [1, 1.171, 1.472],
            extraSpace: [0, 0, 0],
            num1: [0.677, 0.732, 0.925],
            num2: [0.394, 0.384, 0.387],
            num3: [0.444, 0.471, 0.504],
            denom1: [0.686, 0.752, 1.025],
            denom2: [0.345, 0.344, 0.532],
            sup1: [0.413, 0.503, 0.504],
            sup2: [0.363, 0.431, 0.404],
            sup3: [0.289, 0.286, 0.294],
            sub1: [0.15, 0.143, 0.2],
            sub2: [0.247, 0.286, 0.4],
            supDrop: [0.386, 0.353, 0.494],
            subDrop: [0.05, 0.071, 0.1],
            delim1: [2.39, 1.7, 1.98],
            delim2: [1.01, 1.157, 1.42],
            axisHeight: [0.25, 0.25, 0.25],
            defaultRuleThickness: [0.04, 0.049, 0.049],
            bigOpSpacing1: [0.111, 0.111, 0.111],
            bigOpSpacing2: [0.166, 0.166, 0.166],
            bigOpSpacing3: [0.2, 0.2, 0.2],
            bigOpSpacing4: [0.6, 0.611, 0.611],
            bigOpSpacing5: [0.1, 0.143, 0.143],
            sqrtRuleThickness: [0.04, 0.04, 0.04],
            ptPerEm: [10, 10, 10],
            doubleRuleSep: [0.2, 0.2, 0.2],
            arrayRuleWidth: [0.04, 0.04, 0.04],
            fboxsep: [0.3, 0.3, 0.3],
            fboxrule: [0.04, 0.04, 0.04]
          };
          var extraCharacterMap = {
            "\xC5": "A",
            "\xC7": "C",
            "\xD0": "D",
            "\xDE": "o",
            "\xE5": "a",
            "\xE7": "c",
            "\xF0": "d",
            "\xFE": "o",
            "\u0410": "A",
            "\u0411": "B",
            "\u0412": "B",
            "\u0413": "F",
            "\u0414": "A",
            "\u0415": "E",
            "\u0416": "K",
            "\u0417": "3",
            "\u0418": "N",
            "\u0419": "N",
            "\u041A": "K",
            "\u041B": "N",
            "\u041C": "M",
            "\u041D": "H",
            "\u041E": "O",
            "\u041F": "N",
            "\u0420": "P",
            "\u0421": "C",
            "\u0422": "T",
            "\u0423": "y",
            "\u0424": "O",
            "\u0425": "X",
            "\u0426": "U",
            "\u0427": "h",
            "\u0428": "W",
            "\u0429": "W",
            "\u042A": "B",
            "\u042B": "X",
            "\u042C": "B",
            "\u042D": "3",
            "\u042E": "X",
            "\u042F": "R",
            "\u0430": "a",
            "\u0431": "b",
            "\u0432": "a",
            "\u0433": "r",
            "\u0434": "y",
            "\u0435": "e",
            "\u0436": "m",
            "\u0437": "e",
            "\u0438": "n",
            "\u0439": "n",
            "\u043A": "n",
            "\u043B": "n",
            "\u043C": "m",
            "\u043D": "n",
            "\u043E": "o",
            "\u043F": "n",
            "\u0440": "p",
            "\u0441": "c",
            "\u0442": "o",
            "\u0443": "y",
            "\u0444": "b",
            "\u0445": "x",
            "\u0446": "n",
            "\u0447": "n",
            "\u0448": "w",
            "\u0449": "w",
            "\u044A": "a",
            "\u044B": "m",
            "\u044C": "a",
            "\u044D": "e",
            "\u044E": "m",
            "\u044F": "r"
          };
          function setFontMetrics(fontName, metrics) {
            fontMetricsData[fontName] = metrics;
          }
          function getCharacterMetrics(character, font, mode) {
            if (!fontMetricsData[font]) {
              throw new Error("Font metrics not found for font: " + font + ".");
            }
            var ch = character.charCodeAt(0);
            var metrics = fontMetricsData[font][ch];
            if (!metrics && character[0] in extraCharacterMap) {
              ch = extraCharacterMap[character[0]].charCodeAt(0);
              metrics = fontMetricsData[font][ch];
            }
            if (!metrics && mode === "text") {
              if (supportedCodepoint(ch)) {
                metrics = fontMetricsData[font][77];
              }
            }
            if (metrics) {
              return {
                depth: metrics[0],
                height: metrics[1],
                italic: metrics[2],
                skew: metrics[3],
                width: metrics[4]
              };
            }
          }
          var fontMetricsBySizeIndex = {};
          function getGlobalMetrics(size) {
            var sizeIndex;
            if (size >= 5) {
              sizeIndex = 0;
            } else if (size >= 3) {
              sizeIndex = 1;
            } else {
              sizeIndex = 2;
            }
            if (!fontMetricsBySizeIndex[sizeIndex]) {
              var metrics = fontMetricsBySizeIndex[sizeIndex] = {
                cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
              };
              for (var key in sigmasAndXis) {
                if (sigmasAndXis.hasOwnProperty(key)) {
                  metrics[key] = sigmasAndXis[key][sizeIndex];
                }
              }
            }
            return fontMetricsBySizeIndex[sizeIndex];
          }
          var ATOMS = {
            "bin": 1,
            "close": 1,
            "inner": 1,
            "open": 1,
            "punct": 1,
            "rel": 1
          };
          var NON_ATOMS = {
            "accent-token": 1,
            "mathord": 1,
            "op-token": 1,
            "spacing": 1,
            "textord": 1
          };
          var symbols = {
            "math": {},
            "text": {}
          };
          var src_symbols = symbols;
          function defineSymbol(mode, font, group, replace2, name2, acceptUnicodeChar) {
            symbols[mode][name2] = {
              font,
              group,
              replace: replace2
            };
            if (acceptUnicodeChar && replace2) {
              symbols[mode][replace2] = symbols[mode][name2];
            }
          }
          var symbols_math = "math";
          var symbols_text = "text";
          var main = "main";
          var ams = "ams";
          var symbols_accent = "accent-token";
          var bin = "bin";
          var symbols_close = "close";
          var symbols_inner = "inner";
          var mathord = "mathord";
          var op = "op-token";
          var symbols_open = "open";
          var punct = "punct";
          var rel = "rel";
          var symbols_spacing = "spacing";
          var symbols_textord = "textord";
          defineSymbol(symbols_math, main, rel, "\u2261", "\\equiv", true);
          defineSymbol(symbols_math, main, rel, "\u227A", "\\prec", true);
          defineSymbol(symbols_math, main, rel, "\u227B", "\\succ", true);
          defineSymbol(symbols_math, main, rel, "\u223C", "\\sim", true);
          defineSymbol(symbols_math, main, rel, "\u22A5", "\\perp");
          defineSymbol(symbols_math, main, rel, "\u2AAF", "\\preceq", true);
          defineSymbol(symbols_math, main, rel, "\u2AB0", "\\succeq", true);
          defineSymbol(symbols_math, main, rel, "\u2243", "\\simeq", true);
          defineSymbol(symbols_math, main, rel, "\u2223", "\\mid", true);
          defineSymbol(symbols_math, main, rel, "\u226A", "\\ll", true);
          defineSymbol(symbols_math, main, rel, "\u226B", "\\gg", true);
          defineSymbol(symbols_math, main, rel, "\u224D", "\\asymp", true);
          defineSymbol(symbols_math, main, rel, "\u2225", "\\parallel");
          defineSymbol(symbols_math, main, rel, "\u22C8", "\\bowtie", true);
          defineSymbol(symbols_math, main, rel, "\u2323", "\\smile", true);
          defineSymbol(symbols_math, main, rel, "\u2291", "\\sqsubseteq", true);
          defineSymbol(symbols_math, main, rel, "\u2292", "\\sqsupseteq", true);
          defineSymbol(symbols_math, main, rel, "\u2250", "\\doteq", true);
          defineSymbol(symbols_math, main, rel, "\u2322", "\\frown", true);
          defineSymbol(symbols_math, main, rel, "\u220B", "\\ni", true);
          defineSymbol(symbols_math, main, rel, "\u221D", "\\propto", true);
          defineSymbol(symbols_math, main, rel, "\u22A2", "\\vdash", true);
          defineSymbol(symbols_math, main, rel, "\u22A3", "\\dashv", true);
          defineSymbol(symbols_math, main, rel, "\u220B", "\\owns");
          defineSymbol(symbols_math, main, punct, ".", "\\ldotp");
          defineSymbol(symbols_math, main, punct, "\u22C5", "\\cdotp");
          defineSymbol(symbols_math, main, symbols_textord, "#", "\\#");
          defineSymbol(symbols_text, main, symbols_textord, "#", "\\#");
          defineSymbol(symbols_math, main, symbols_textord, "&", "\\&");
          defineSymbol(symbols_text, main, symbols_textord, "&", "\\&");
          defineSymbol(symbols_math, main, symbols_textord, "\u2135", "\\aleph", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u2200", "\\forall", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u210F", "\\hbar", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u2203", "\\exists", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u2207", "\\nabla", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u266D", "\\flat", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u2113", "\\ell", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u266E", "\\natural", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u2663", "\\clubsuit", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u2118", "\\wp", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u266F", "\\sharp", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u2662", "\\diamondsuit", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u211C", "\\Re", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u2661", "\\heartsuit", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u2111", "\\Im", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u2660", "\\spadesuit", true);
          defineSymbol(symbols_text, main, symbols_textord, "\xA7", "\\S", true);
          defineSymbol(symbols_text, main, symbols_textord, "\xB6", "\\P", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u2020", "\\dag");
          defineSymbol(symbols_text, main, symbols_textord, "\u2020", "\\dag");
          defineSymbol(symbols_text, main, symbols_textord, "\u2020", "\\textdagger");
          defineSymbol(symbols_math, main, symbols_textord, "\u2021", "\\ddag");
          defineSymbol(symbols_text, main, symbols_textord, "\u2021", "\\ddag");
          defineSymbol(symbols_text, main, symbols_textord, "\u2021", "\\textdaggerdbl");
          defineSymbol(symbols_math, main, symbols_close, "\u23B1", "\\rmoustache", true);
          defineSymbol(symbols_math, main, symbols_open, "\u23B0", "\\lmoustache", true);
          defineSymbol(symbols_math, main, symbols_close, "\u27EF", "\\rgroup", true);
          defineSymbol(symbols_math, main, symbols_open, "\u27EE", "\\lgroup", true);
          defineSymbol(symbols_math, main, bin, "\u2213", "\\mp", true);
          defineSymbol(symbols_math, main, bin, "\u2296", "\\ominus", true);
          defineSymbol(symbols_math, main, bin, "\u228E", "\\uplus", true);
          defineSymbol(symbols_math, main, bin, "\u2293", "\\sqcap", true);
          defineSymbol(symbols_math, main, bin, "\u2217", "\\ast");
          defineSymbol(symbols_math, main, bin, "\u2294", "\\sqcup", true);
          defineSymbol(symbols_math, main, bin, "\u25EF", "\\bigcirc");
          defineSymbol(symbols_math, main, bin, "\u2219", "\\bullet");
          defineSymbol(symbols_math, main, bin, "\u2021", "\\ddagger");
          defineSymbol(symbols_math, main, bin, "\u2240", "\\wr", true);
          defineSymbol(symbols_math, main, bin, "\u2A3F", "\\amalg");
          defineSymbol(symbols_math, main, bin, "&", "\\And");
          defineSymbol(symbols_math, main, rel, "\u27F5", "\\longleftarrow", true);
          defineSymbol(symbols_math, main, rel, "\u21D0", "\\Leftarrow", true);
          defineSymbol(symbols_math, main, rel, "\u27F8", "\\Longleftarrow", true);
          defineSymbol(symbols_math, main, rel, "\u27F6", "\\longrightarrow", true);
          defineSymbol(symbols_math, main, rel, "\u21D2", "\\Rightarrow", true);
          defineSymbol(symbols_math, main, rel, "\u27F9", "\\Longrightarrow", true);
          defineSymbol(symbols_math, main, rel, "\u2194", "\\leftrightarrow", true);
          defineSymbol(symbols_math, main, rel, "\u27F7", "\\longleftrightarrow", true);
          defineSymbol(symbols_math, main, rel, "\u21D4", "\\Leftrightarrow", true);
          defineSymbol(symbols_math, main, rel, "\u27FA", "\\Longleftrightarrow", true);
          defineSymbol(symbols_math, main, rel, "\u21A6", "\\mapsto", true);
          defineSymbol(symbols_math, main, rel, "\u27FC", "\\longmapsto", true);
          defineSymbol(symbols_math, main, rel, "\u2197", "\\nearrow", true);
          defineSymbol(symbols_math, main, rel, "\u21A9", "\\hookleftarrow", true);
          defineSymbol(symbols_math, main, rel, "\u21AA", "\\hookrightarrow", true);
          defineSymbol(symbols_math, main, rel, "\u2198", "\\searrow", true);
          defineSymbol(symbols_math, main, rel, "\u21BC", "\\leftharpoonup", true);
          defineSymbol(symbols_math, main, rel, "\u21C0", "\\rightharpoonup", true);
          defineSymbol(symbols_math, main, rel, "\u2199", "\\swarrow", true);
          defineSymbol(symbols_math, main, rel, "\u21BD", "\\leftharpoondown", true);
          defineSymbol(symbols_math, main, rel, "\u21C1", "\\rightharpoondown", true);
          defineSymbol(symbols_math, main, rel, "\u2196", "\\nwarrow", true);
          defineSymbol(symbols_math, main, rel, "\u21CC", "\\rightleftharpoons", true);
          defineSymbol(symbols_math, ams, rel, "\u226E", "\\nless", true);
          defineSymbol(symbols_math, ams, rel, "\uE010", "\\@nleqslant");
          defineSymbol(symbols_math, ams, rel, "\uE011", "\\@nleqq");
          defineSymbol(symbols_math, ams, rel, "\u2A87", "\\lneq", true);
          defineSymbol(symbols_math, ams, rel, "\u2268", "\\lneqq", true);
          defineSymbol(symbols_math, ams, rel, "\uE00C", "\\@lvertneqq");
          defineSymbol(symbols_math, ams, rel, "\u22E6", "\\lnsim", true);
          defineSymbol(symbols_math, ams, rel, "\u2A89", "\\lnapprox", true);
          defineSymbol(symbols_math, ams, rel, "\u2280", "\\nprec", true);
          defineSymbol(symbols_math, ams, rel, "\u22E0", "\\npreceq", true);
          defineSymbol(symbols_math, ams, rel, "\u22E8", "\\precnsim", true);
          defineSymbol(symbols_math, ams, rel, "\u2AB9", "\\precnapprox", true);
          defineSymbol(symbols_math, ams, rel, "\u2241", "\\nsim", true);
          defineSymbol(symbols_math, ams, rel, "\uE006", "\\@nshortmid");
          defineSymbol(symbols_math, ams, rel, "\u2224", "\\nmid", true);
          defineSymbol(symbols_math, ams, rel, "\u22AC", "\\nvdash", true);
          defineSymbol(symbols_math, ams, rel, "\u22AD", "\\nvDash", true);
          defineSymbol(symbols_math, ams, rel, "\u22EA", "\\ntriangleleft");
          defineSymbol(symbols_math, ams, rel, "\u22EC", "\\ntrianglelefteq", true);
          defineSymbol(symbols_math, ams, rel, "\u228A", "\\subsetneq", true);
          defineSymbol(symbols_math, ams, rel, "\uE01A", "\\@varsubsetneq");
          defineSymbol(symbols_math, ams, rel, "\u2ACB", "\\subsetneqq", true);
          defineSymbol(symbols_math, ams, rel, "\uE017", "\\@varsubsetneqq");
          defineSymbol(symbols_math, ams, rel, "\u226F", "\\ngtr", true);
          defineSymbol(symbols_math, ams, rel, "\uE00F", "\\@ngeqslant");
          defineSymbol(symbols_math, ams, rel, "\uE00E", "\\@ngeqq");
          defineSymbol(symbols_math, ams, rel, "\u2A88", "\\gneq", true);
          defineSymbol(symbols_math, ams, rel, "\u2269", "\\gneqq", true);
          defineSymbol(symbols_math, ams, rel, "\uE00D", "\\@gvertneqq");
          defineSymbol(symbols_math, ams, rel, "\u22E7", "\\gnsim", true);
          defineSymbol(symbols_math, ams, rel, "\u2A8A", "\\gnapprox", true);
          defineSymbol(symbols_math, ams, rel, "\u2281", "\\nsucc", true);
          defineSymbol(symbols_math, ams, rel, "\u22E1", "\\nsucceq", true);
          defineSymbol(symbols_math, ams, rel, "\u22E9", "\\succnsim", true);
          defineSymbol(symbols_math, ams, rel, "\u2ABA", "\\succnapprox", true);
          defineSymbol(symbols_math, ams, rel, "\u2246", "\\ncong", true);
          defineSymbol(symbols_math, ams, rel, "\uE007", "\\@nshortparallel");
          defineSymbol(symbols_math, ams, rel, "\u2226", "\\nparallel", true);
          defineSymbol(symbols_math, ams, rel, "\u22AF", "\\nVDash", true);
          defineSymbol(symbols_math, ams, rel, "\u22EB", "\\ntriangleright");
          defineSymbol(symbols_math, ams, rel, "\u22ED", "\\ntrianglerighteq", true);
          defineSymbol(symbols_math, ams, rel, "\uE018", "\\@nsupseteqq");
          defineSymbol(symbols_math, ams, rel, "\u228B", "\\supsetneq", true);
          defineSymbol(symbols_math, ams, rel, "\uE01B", "\\@varsupsetneq");
          defineSymbol(symbols_math, ams, rel, "\u2ACC", "\\supsetneqq", true);
          defineSymbol(symbols_math, ams, rel, "\uE019", "\\@varsupsetneqq");
          defineSymbol(symbols_math, ams, rel, "\u22AE", "\\nVdash", true);
          defineSymbol(symbols_math, ams, rel, "\u2AB5", "\\precneqq", true);
          defineSymbol(symbols_math, ams, rel, "\u2AB6", "\\succneqq", true);
          defineSymbol(symbols_math, ams, rel, "\uE016", "\\@nsubseteqq");
          defineSymbol(symbols_math, ams, bin, "\u22B4", "\\unlhd");
          defineSymbol(symbols_math, ams, bin, "\u22B5", "\\unrhd");
          defineSymbol(symbols_math, ams, rel, "\u219A", "\\nleftarrow", true);
          defineSymbol(symbols_math, ams, rel, "\u219B", "\\nrightarrow", true);
          defineSymbol(symbols_math, ams, rel, "\u21CD", "\\nLeftarrow", true);
          defineSymbol(symbols_math, ams, rel, "\u21CF", "\\nRightarrow", true);
          defineSymbol(symbols_math, ams, rel, "\u21AE", "\\nleftrightarrow", true);
          defineSymbol(symbols_math, ams, rel, "\u21CE", "\\nLeftrightarrow", true);
          defineSymbol(symbols_math, ams, rel, "\u25B3", "\\vartriangle");
          defineSymbol(symbols_math, ams, symbols_textord, "\u210F", "\\hslash");
          defineSymbol(symbols_math, ams, symbols_textord, "\u25BD", "\\triangledown");
          defineSymbol(symbols_math, ams, symbols_textord, "\u25CA", "\\lozenge");
          defineSymbol(symbols_math, ams, symbols_textord, "\u24C8", "\\circledS");
          defineSymbol(symbols_math, ams, symbols_textord, "\xAE", "\\circledR");
          defineSymbol(symbols_text, ams, symbols_textord, "\xAE", "\\circledR");
          defineSymbol(symbols_math, ams, symbols_textord, "\u2221", "\\measuredangle", true);
          defineSymbol(symbols_math, ams, symbols_textord, "\u2204", "\\nexists");
          defineSymbol(symbols_math, ams, symbols_textord, "\u2127", "\\mho");
          defineSymbol(symbols_math, ams, symbols_textord, "\u2132", "\\Finv", true);
          defineSymbol(symbols_math, ams, symbols_textord, "\u2141", "\\Game", true);
          defineSymbol(symbols_math, ams, symbols_textord, "\u2035", "\\backprime");
          defineSymbol(symbols_math, ams, symbols_textord, "\u25B2", "\\blacktriangle");
          defineSymbol(symbols_math, ams, symbols_textord, "\u25BC", "\\blacktriangledown");
          defineSymbol(symbols_math, ams, symbols_textord, "\u25A0", "\\blacksquare");
          defineSymbol(symbols_math, ams, symbols_textord, "\u29EB", "\\blacklozenge");
          defineSymbol(symbols_math, ams, symbols_textord, "\u2605", "\\bigstar");
          defineSymbol(symbols_math, ams, symbols_textord, "\u2222", "\\sphericalangle", true);
          defineSymbol(symbols_math, ams, symbols_textord, "\u2201", "\\complement", true);
          defineSymbol(symbols_math, ams, symbols_textord, "\xF0", "\\eth", true);
          defineSymbol(symbols_text, main, symbols_textord, "\xF0", "\xF0");
          defineSymbol(symbols_math, ams, symbols_textord, "\u2571", "\\diagup");
          defineSymbol(symbols_math, ams, symbols_textord, "\u2572", "\\diagdown");
          defineSymbol(symbols_math, ams, symbols_textord, "\u25A1", "\\square");
          defineSymbol(symbols_math, ams, symbols_textord, "\u25A1", "\\Box");
          defineSymbol(symbols_math, ams, symbols_textord, "\u25CA", "\\Diamond");
          defineSymbol(symbols_math, ams, symbols_textord, "\xA5", "\\yen", true);
          defineSymbol(symbols_text, ams, symbols_textord, "\xA5", "\\yen", true);
          defineSymbol(symbols_math, ams, symbols_textord, "\u2713", "\\checkmark", true);
          defineSymbol(symbols_text, ams, symbols_textord, "\u2713", "\\checkmark");
          defineSymbol(symbols_math, ams, symbols_textord, "\u2136", "\\beth", true);
          defineSymbol(symbols_math, ams, symbols_textord, "\u2138", "\\daleth", true);
          defineSymbol(symbols_math, ams, symbols_textord, "\u2137", "\\gimel", true);
          defineSymbol(symbols_math, ams, symbols_textord, "\u03DD", "\\digamma", true);
          defineSymbol(symbols_math, ams, symbols_textord, "\u03F0", "\\varkappa");
          defineSymbol(symbols_math, ams, symbols_open, "\u250C", "\\@ulcorner", true);
          defineSymbol(symbols_math, ams, symbols_close, "\u2510", "\\@urcorner", true);
          defineSymbol(symbols_math, ams, symbols_open, "\u2514", "\\@llcorner", true);
          defineSymbol(symbols_math, ams, symbols_close, "\u2518", "\\@lrcorner", true);
          defineSymbol(symbols_math, ams, rel, "\u2266", "\\leqq", true);
          defineSymbol(symbols_math, ams, rel, "\u2A7D", "\\leqslant", true);
          defineSymbol(symbols_math, ams, rel, "\u2A95", "\\eqslantless", true);
          defineSymbol(symbols_math, ams, rel, "\u2272", "\\lesssim", true);
          defineSymbol(symbols_math, ams, rel, "\u2A85", "\\lessapprox", true);
          defineSymbol(symbols_math, ams, rel, "\u224A", "\\approxeq", true);
          defineSymbol(symbols_math, ams, bin, "\u22D6", "\\lessdot");
          defineSymbol(symbols_math, ams, rel, "\u22D8", "\\lll", true);
          defineSymbol(symbols_math, ams, rel, "\u2276", "\\lessgtr", true);
          defineSymbol(symbols_math, ams, rel, "\u22DA", "\\lesseqgtr", true);
          defineSymbol(symbols_math, ams, rel, "\u2A8B", "\\lesseqqgtr", true);
          defineSymbol(symbols_math, ams, rel, "\u2251", "\\doteqdot");
          defineSymbol(symbols_math, ams, rel, "\u2253", "\\risingdotseq", true);
          defineSymbol(symbols_math, ams, rel, "\u2252", "\\fallingdotseq", true);
          defineSymbol(symbols_math, ams, rel, "\u223D", "\\backsim", true);
          defineSymbol(symbols_math, ams, rel, "\u22CD", "\\backsimeq", true);
          defineSymbol(symbols_math, ams, rel, "\u2AC5", "\\subseteqq", true);
          defineSymbol(symbols_math, ams, rel, "\u22D0", "\\Subset", true);
          defineSymbol(symbols_math, ams, rel, "\u228F", "\\sqsubset", true);
          defineSymbol(symbols_math, ams, rel, "\u227C", "\\preccurlyeq", true);
          defineSymbol(symbols_math, ams, rel, "\u22DE", "\\curlyeqprec", true);
          defineSymbol(symbols_math, ams, rel, "\u227E", "\\precsim", true);
          defineSymbol(symbols_math, ams, rel, "\u2AB7", "\\precapprox", true);
          defineSymbol(symbols_math, ams, rel, "\u22B2", "\\vartriangleleft");
          defineSymbol(symbols_math, ams, rel, "\u22B4", "\\trianglelefteq");
          defineSymbol(symbols_math, ams, rel, "\u22A8", "\\vDash", true);
          defineSymbol(symbols_math, ams, rel, "\u22AA", "\\Vvdash", true);
          defineSymbol(symbols_math, ams, rel, "\u2323", "\\smallsmile");
          defineSymbol(symbols_math, ams, rel, "\u2322", "\\smallfrown");
          defineSymbol(symbols_math, ams, rel, "\u224F", "\\bumpeq", true);
          defineSymbol(symbols_math, ams, rel, "\u224E", "\\Bumpeq", true);
          defineSymbol(symbols_math, ams, rel, "\u2267", "\\geqq", true);
          defineSymbol(symbols_math, ams, rel, "\u2A7E", "\\geqslant", true);
          defineSymbol(symbols_math, ams, rel, "\u2A96", "\\eqslantgtr", true);
          defineSymbol(symbols_math, ams, rel, "\u2273", "\\gtrsim", true);
          defineSymbol(symbols_math, ams, rel, "\u2A86", "\\gtrapprox", true);
          defineSymbol(symbols_math, ams, bin, "\u22D7", "\\gtrdot");
          defineSymbol(symbols_math, ams, rel, "\u22D9", "\\ggg", true);
          defineSymbol(symbols_math, ams, rel, "\u2277", "\\gtrless", true);
          defineSymbol(symbols_math, ams, rel, "\u22DB", "\\gtreqless", true);
          defineSymbol(symbols_math, ams, rel, "\u2A8C", "\\gtreqqless", true);
          defineSymbol(symbols_math, ams, rel, "\u2256", "\\eqcirc", true);
          defineSymbol(symbols_math, ams, rel, "\u2257", "\\circeq", true);
          defineSymbol(symbols_math, ams, rel, "\u225C", "\\triangleq", true);
          defineSymbol(symbols_math, ams, rel, "\u223C", "\\thicksim");
          defineSymbol(symbols_math, ams, rel, "\u2248", "\\thickapprox");
          defineSymbol(symbols_math, ams, rel, "\u2AC6", "\\supseteqq", true);
          defineSymbol(symbols_math, ams, rel, "\u22D1", "\\Supset", true);
          defineSymbol(symbols_math, ams, rel, "\u2290", "\\sqsupset", true);
          defineSymbol(symbols_math, ams, rel, "\u227D", "\\succcurlyeq", true);
          defineSymbol(symbols_math, ams, rel, "\u22DF", "\\curlyeqsucc", true);
          defineSymbol(symbols_math, ams, rel, "\u227F", "\\succsim", true);
          defineSymbol(symbols_math, ams, rel, "\u2AB8", "\\succapprox", true);
          defineSymbol(symbols_math, ams, rel, "\u22B3", "\\vartriangleright");
          defineSymbol(symbols_math, ams, rel, "\u22B5", "\\trianglerighteq");
          defineSymbol(symbols_math, ams, rel, "\u22A9", "\\Vdash", true);
          defineSymbol(symbols_math, ams, rel, "\u2223", "\\shortmid");
          defineSymbol(symbols_math, ams, rel, "\u2225", "\\shortparallel");
          defineSymbol(symbols_math, ams, rel, "\u226C", "\\between", true);
          defineSymbol(symbols_math, ams, rel, "\u22D4", "\\pitchfork", true);
          defineSymbol(symbols_math, ams, rel, "\u221D", "\\varpropto");
          defineSymbol(symbols_math, ams, rel, "\u25C0", "\\blacktriangleleft");
          defineSymbol(symbols_math, ams, rel, "\u2234", "\\therefore", true);
          defineSymbol(symbols_math, ams, rel, "\u220D", "\\backepsilon");
          defineSymbol(symbols_math, ams, rel, "\u25B6", "\\blacktriangleright");
          defineSymbol(symbols_math, ams, rel, "\u2235", "\\because", true);
          defineSymbol(symbols_math, ams, rel, "\u22D8", "\\llless");
          defineSymbol(symbols_math, ams, rel, "\u22D9", "\\gggtr");
          defineSymbol(symbols_math, ams, bin, "\u22B2", "\\lhd");
          defineSymbol(symbols_math, ams, bin, "\u22B3", "\\rhd");
          defineSymbol(symbols_math, ams, rel, "\u2242", "\\eqsim", true);
          defineSymbol(symbols_math, main, rel, "\u22C8", "\\Join");
          defineSymbol(symbols_math, ams, rel, "\u2251", "\\Doteq", true);
          defineSymbol(symbols_math, ams, bin, "\u2214", "\\dotplus", true);
          defineSymbol(symbols_math, ams, bin, "\u2216", "\\smallsetminus");
          defineSymbol(symbols_math, ams, bin, "\u22D2", "\\Cap", true);
          defineSymbol(symbols_math, ams, bin, "\u22D3", "\\Cup", true);
          defineSymbol(symbols_math, ams, bin, "\u2A5E", "\\doublebarwedge", true);
          defineSymbol(symbols_math, ams, bin, "\u229F", "\\boxminus", true);
          defineSymbol(symbols_math, ams, bin, "\u229E", "\\boxplus", true);
          defineSymbol(symbols_math, ams, bin, "\u22C7", "\\divideontimes", true);
          defineSymbol(symbols_math, ams, bin, "\u22C9", "\\ltimes", true);
          defineSymbol(symbols_math, ams, bin, "\u22CA", "\\rtimes", true);
          defineSymbol(symbols_math, ams, bin, "\u22CB", "\\leftthreetimes", true);
          defineSymbol(symbols_math, ams, bin, "\u22CC", "\\rightthreetimes", true);
          defineSymbol(symbols_math, ams, bin, "\u22CF", "\\curlywedge", true);
          defineSymbol(symbols_math, ams, bin, "\u22CE", "\\curlyvee", true);
          defineSymbol(symbols_math, ams, bin, "\u229D", "\\circleddash", true);
          defineSymbol(symbols_math, ams, bin, "\u229B", "\\circledast", true);
          defineSymbol(symbols_math, ams, bin, "\u22C5", "\\centerdot");
          defineSymbol(symbols_math, ams, bin, "\u22BA", "\\intercal", true);
          defineSymbol(symbols_math, ams, bin, "\u22D2", "\\doublecap");
          defineSymbol(symbols_math, ams, bin, "\u22D3", "\\doublecup");
          defineSymbol(symbols_math, ams, bin, "\u22A0", "\\boxtimes", true);
          defineSymbol(symbols_math, ams, rel, "\u21E2", "\\dashrightarrow", true);
          defineSymbol(symbols_math, ams, rel, "\u21E0", "\\dashleftarrow", true);
          defineSymbol(symbols_math, ams, rel, "\u21C7", "\\leftleftarrows", true);
          defineSymbol(symbols_math, ams, rel, "\u21C6", "\\leftrightarrows", true);
          defineSymbol(symbols_math, ams, rel, "\u21DA", "\\Lleftarrow", true);
          defineSymbol(symbols_math, ams, rel, "\u219E", "\\twoheadleftarrow", true);
          defineSymbol(symbols_math, ams, rel, "\u21A2", "\\leftarrowtail", true);
          defineSymbol(symbols_math, ams, rel, "\u21AB", "\\looparrowleft", true);
          defineSymbol(symbols_math, ams, rel, "\u21CB", "\\leftrightharpoons", true);
          defineSymbol(symbols_math, ams, rel, "\u21B6", "\\curvearrowleft", true);
          defineSymbol(symbols_math, ams, rel, "\u21BA", "\\circlearrowleft", true);
          defineSymbol(symbols_math, ams, rel, "\u21B0", "\\Lsh", true);
          defineSymbol(symbols_math, ams, rel, "\u21C8", "\\upuparrows", true);
          defineSymbol(symbols_math, ams, rel, "\u21BF", "\\upharpoonleft", true);
          defineSymbol(symbols_math, ams, rel, "\u21C3", "\\downharpoonleft", true);
          defineSymbol(symbols_math, ams, rel, "\u22B8", "\\multimap", true);
          defineSymbol(symbols_math, ams, rel, "\u21AD", "\\leftrightsquigarrow", true);
          defineSymbol(symbols_math, ams, rel, "\u21C9", "\\rightrightarrows", true);
          defineSymbol(symbols_math, ams, rel, "\u21C4", "\\rightleftarrows", true);
          defineSymbol(symbols_math, ams, rel, "\u21A0", "\\twoheadrightarrow", true);
          defineSymbol(symbols_math, ams, rel, "\u21A3", "\\rightarrowtail", true);
          defineSymbol(symbols_math, ams, rel, "\u21AC", "\\looparrowright", true);
          defineSymbol(symbols_math, ams, rel, "\u21B7", "\\curvearrowright", true);
          defineSymbol(symbols_math, ams, rel, "\u21BB", "\\circlearrowright", true);
          defineSymbol(symbols_math, ams, rel, "\u21B1", "\\Rsh", true);
          defineSymbol(symbols_math, ams, rel, "\u21CA", "\\downdownarrows", true);
          defineSymbol(symbols_math, ams, rel, "\u21BE", "\\upharpoonright", true);
          defineSymbol(symbols_math, ams, rel, "\u21C2", "\\downharpoonright", true);
          defineSymbol(symbols_math, ams, rel, "\u21DD", "\\rightsquigarrow", true);
          defineSymbol(symbols_math, ams, rel, "\u21DD", "\\leadsto");
          defineSymbol(symbols_math, ams, rel, "\u21DB", "\\Rrightarrow", true);
          defineSymbol(symbols_math, ams, rel, "\u21BE", "\\restriction");
          defineSymbol(symbols_math, main, symbols_textord, "\u2018", "`");
          defineSymbol(symbols_math, main, symbols_textord, "$", "\\$");
          defineSymbol(symbols_text, main, symbols_textord, "$", "\\$");
          defineSymbol(symbols_text, main, symbols_textord, "$", "\\textdollar");
          defineSymbol(symbols_math, main, symbols_textord, "%", "\\%");
          defineSymbol(symbols_text, main, symbols_textord, "%", "\\%");
          defineSymbol(symbols_math, main, symbols_textord, "_", "\\_");
          defineSymbol(symbols_text, main, symbols_textord, "_", "\\_");
          defineSymbol(symbols_text, main, symbols_textord, "_", "\\textunderscore");
          defineSymbol(symbols_math, main, symbols_textord, "\u2220", "\\angle", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u221E", "\\infty", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u2032", "\\prime");
          defineSymbol(symbols_math, main, symbols_textord, "\u25B3", "\\triangle");
          defineSymbol(symbols_math, main, symbols_textord, "\u0393", "\\Gamma", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u0394", "\\Delta", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u0398", "\\Theta", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u039B", "\\Lambda", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u039E", "\\Xi", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u03A0", "\\Pi", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u03A3", "\\Sigma", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u03A5", "\\Upsilon", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u03A6", "\\Phi", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u03A8", "\\Psi", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u03A9", "\\Omega", true);
          defineSymbol(symbols_math, main, symbols_textord, "A", "\u0391");
          defineSymbol(symbols_math, main, symbols_textord, "B", "\u0392");
          defineSymbol(symbols_math, main, symbols_textord, "E", "\u0395");
          defineSymbol(symbols_math, main, symbols_textord, "Z", "\u0396");
          defineSymbol(symbols_math, main, symbols_textord, "H", "\u0397");
          defineSymbol(symbols_math, main, symbols_textord, "I", "\u0399");
          defineSymbol(symbols_math, main, symbols_textord, "K", "\u039A");
          defineSymbol(symbols_math, main, symbols_textord, "M", "\u039C");
          defineSymbol(symbols_math, main, symbols_textord, "N", "\u039D");
          defineSymbol(symbols_math, main, symbols_textord, "O", "\u039F");
          defineSymbol(symbols_math, main, symbols_textord, "P", "\u03A1");
          defineSymbol(symbols_math, main, symbols_textord, "T", "\u03A4");
          defineSymbol(symbols_math, main, symbols_textord, "X", "\u03A7");
          defineSymbol(symbols_math, main, symbols_textord, "\xAC", "\\neg", true);
          defineSymbol(symbols_math, main, symbols_textord, "\xAC", "\\lnot");
          defineSymbol(symbols_math, main, symbols_textord, "\u22A4", "\\top");
          defineSymbol(symbols_math, main, symbols_textord, "\u22A5", "\\bot");
          defineSymbol(symbols_math, main, symbols_textord, "\u2205", "\\emptyset");
          defineSymbol(symbols_math, ams, symbols_textord, "\u2205", "\\varnothing");
          defineSymbol(symbols_math, main, mathord, "\u03B1", "\\alpha", true);
          defineSymbol(symbols_math, main, mathord, "\u03B2", "\\beta", true);
          defineSymbol(symbols_math, main, mathord, "\u03B3", "\\gamma", true);
          defineSymbol(symbols_math, main, mathord, "\u03B4", "\\delta", true);
          defineSymbol(symbols_math, main, mathord, "\u03F5", "\\epsilon", true);
          defineSymbol(symbols_math, main, mathord, "\u03B6", "\\zeta", true);
          defineSymbol(symbols_math, main, mathord, "\u03B7", "\\eta", true);
          defineSymbol(symbols_math, main, mathord, "\u03B8", "\\theta", true);
          defineSymbol(symbols_math, main, mathord, "\u03B9", "\\iota", true);
          defineSymbol(symbols_math, main, mathord, "\u03BA", "\\kappa", true);
          defineSymbol(symbols_math, main, mathord, "\u03BB", "\\lambda", true);
          defineSymbol(symbols_math, main, mathord, "\u03BC", "\\mu", true);
          defineSymbol(symbols_math, main, mathord, "\u03BD", "\\nu", true);
          defineSymbol(symbols_math, main, mathord, "\u03BE", "\\xi", true);
          defineSymbol(symbols_math, main, mathord, "\u03BF", "\\omicron", true);
          defineSymbol(symbols_math, main, mathord, "\u03C0", "\\pi", true);
          defineSymbol(symbols_math, main, mathord, "\u03C1", "\\rho", true);
          defineSymbol(symbols_math, main, mathord, "\u03C3", "\\sigma", true);
          defineSymbol(symbols_math, main, mathord, "\u03C4", "\\tau", true);
          defineSymbol(symbols_math, main, mathord, "\u03C5", "\\upsilon", true);
          defineSymbol(symbols_math, main, mathord, "\u03D5", "\\phi", true);
          defineSymbol(symbols_math, main, mathord, "\u03C7", "\\chi", true);
          defineSymbol(symbols_math, main, mathord, "\u03C8", "\\psi", true);
          defineSymbol(symbols_math, main, mathord, "\u03C9", "\\omega", true);
          defineSymbol(symbols_math, main, mathord, "\u03B5", "\\varepsilon", true);
          defineSymbol(symbols_math, main, mathord, "\u03D1", "\\vartheta", true);
          defineSymbol(symbols_math, main, mathord, "\u03D6", "\\varpi", true);
          defineSymbol(symbols_math, main, mathord, "\u03F1", "\\varrho", true);
          defineSymbol(symbols_math, main, mathord, "\u03C2", "\\varsigma", true);
          defineSymbol(symbols_math, main, mathord, "\u03C6", "\\varphi", true);
          defineSymbol(symbols_math, main, bin, "\u2217", "*");
          defineSymbol(symbols_math, main, bin, "+", "+");
          defineSymbol(symbols_math, main, bin, "\u2212", "-");
          defineSymbol(symbols_math, main, bin, "\u22C5", "\\cdot", true);
          defineSymbol(symbols_math, main, bin, "\u2218", "\\circ");
          defineSymbol(symbols_math, main, bin, "\xF7", "\\div", true);
          defineSymbol(symbols_math, main, bin, "\xB1", "\\pm", true);
          defineSymbol(symbols_math, main, bin, "\xD7", "\\times", true);
          defineSymbol(symbols_math, main, bin, "\u2229", "\\cap", true);
          defineSymbol(symbols_math, main, bin, "\u222A", "\\cup", true);
          defineSymbol(symbols_math, main, bin, "\u2216", "\\setminus");
          defineSymbol(symbols_math, main, bin, "\u2227", "\\land");
          defineSymbol(symbols_math, main, bin, "\u2228", "\\lor");
          defineSymbol(symbols_math, main, bin, "\u2227", "\\wedge", true);
          defineSymbol(symbols_math, main, bin, "\u2228", "\\vee", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u221A", "\\surd");
          defineSymbol(symbols_math, main, symbols_open, "\u27E8", "\\langle", true);
          defineSymbol(symbols_math, main, symbols_open, "\u2223", "\\lvert");
          defineSymbol(symbols_math, main, symbols_open, "\u2225", "\\lVert");
          defineSymbol(symbols_math, main, symbols_close, "?", "?");
          defineSymbol(symbols_math, main, symbols_close, "!", "!");
          defineSymbol(symbols_math, main, symbols_close, "\u27E9", "\\rangle", true);
          defineSymbol(symbols_math, main, symbols_close, "\u2223", "\\rvert");
          defineSymbol(symbols_math, main, symbols_close, "\u2225", "\\rVert");
          defineSymbol(symbols_math, main, rel, "=", "=");
          defineSymbol(symbols_math, main, rel, ":", ":");
          defineSymbol(symbols_math, main, rel, "\u2248", "\\approx", true);
          defineSymbol(symbols_math, main, rel, "\u2245", "\\cong", true);
          defineSymbol(symbols_math, main, rel, "\u2265", "\\ge");
          defineSymbol(symbols_math, main, rel, "\u2265", "\\geq", true);
          defineSymbol(symbols_math, main, rel, "\u2190", "\\gets");
          defineSymbol(symbols_math, main, rel, ">", "\\gt", true);
          defineSymbol(symbols_math, main, rel, "\u2208", "\\in", true);
          defineSymbol(symbols_math, main, rel, "\uE020", "\\@not");
          defineSymbol(symbols_math, main, rel, "\u2282", "\\subset", true);
          defineSymbol(symbols_math, main, rel, "\u2283", "\\supset", true);
          defineSymbol(symbols_math, main, rel, "\u2286", "\\subseteq", true);
          defineSymbol(symbols_math, main, rel, "\u2287", "\\supseteq", true);
          defineSymbol(symbols_math, ams, rel, "\u2288", "\\nsubseteq", true);
          defineSymbol(symbols_math, ams, rel, "\u2289", "\\nsupseteq", true);
          defineSymbol(symbols_math, main, rel, "\u22A8", "\\models");
          defineSymbol(symbols_math, main, rel, "\u2190", "\\leftarrow", true);
          defineSymbol(symbols_math, main, rel, "\u2264", "\\le");
          defineSymbol(symbols_math, main, rel, "\u2264", "\\leq", true);
          defineSymbol(symbols_math, main, rel, "<", "\\lt", true);
          defineSymbol(symbols_math, main, rel, "\u2192", "\\rightarrow", true);
          defineSymbol(symbols_math, main, rel, "\u2192", "\\to");
          defineSymbol(symbols_math, ams, rel, "\u2271", "\\ngeq", true);
          defineSymbol(symbols_math, ams, rel, "\u2270", "\\nleq", true);
          defineSymbol(symbols_math, main, symbols_spacing, "\xA0", "\\ ");
          defineSymbol(symbols_math, main, symbols_spacing, "\xA0", "~");
          defineSymbol(symbols_math, main, symbols_spacing, "\xA0", "\\space");
          defineSymbol(symbols_math, main, symbols_spacing, "\xA0", "\\nobreakspace");
          defineSymbol(symbols_text, main, symbols_spacing, "\xA0", "\\ ");
          defineSymbol(symbols_text, main, symbols_spacing, "\xA0", " ");
          defineSymbol(symbols_text, main, symbols_spacing, "\xA0", "~");
          defineSymbol(symbols_text, main, symbols_spacing, "\xA0", "\\space");
          defineSymbol(symbols_text, main, symbols_spacing, "\xA0", "\\nobreakspace");
          defineSymbol(symbols_math, main, symbols_spacing, null, "\\nobreak");
          defineSymbol(symbols_math, main, symbols_spacing, null, "\\allowbreak");
          defineSymbol(symbols_math, main, punct, ",", ",");
          defineSymbol(symbols_math, main, punct, ";", ";");
          defineSymbol(symbols_math, ams, bin, "\u22BC", "\\barwedge", true);
          defineSymbol(symbols_math, ams, bin, "\u22BB", "\\veebar", true);
          defineSymbol(symbols_math, main, bin, "\u2299", "\\odot", true);
          defineSymbol(symbols_math, main, bin, "\u2295", "\\oplus", true);
          defineSymbol(symbols_math, main, bin, "\u2297", "\\otimes", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u2202", "\\partial", true);
          defineSymbol(symbols_math, main, bin, "\u2298", "\\oslash", true);
          defineSymbol(symbols_math, ams, bin, "\u229A", "\\circledcirc", true);
          defineSymbol(symbols_math, ams, bin, "\u22A1", "\\boxdot", true);
          defineSymbol(symbols_math, main, bin, "\u25B3", "\\bigtriangleup");
          defineSymbol(symbols_math, main, bin, "\u25BD", "\\bigtriangledown");
          defineSymbol(symbols_math, main, bin, "\u2020", "\\dagger");
          defineSymbol(symbols_math, main, bin, "\u22C4", "\\diamond");
          defineSymbol(symbols_math, main, bin, "\u22C6", "\\star");
          defineSymbol(symbols_math, main, bin, "\u25C3", "\\triangleleft");
          defineSymbol(symbols_math, main, bin, "\u25B9", "\\triangleright");
          defineSymbol(symbols_math, main, symbols_open, "{", "\\{");
          defineSymbol(symbols_text, main, symbols_textord, "{", "\\{");
          defineSymbol(symbols_text, main, symbols_textord, "{", "\\textbraceleft");
          defineSymbol(symbols_math, main, symbols_close, "}", "\\}");
          defineSymbol(symbols_text, main, symbols_textord, "}", "\\}");
          defineSymbol(symbols_text, main, symbols_textord, "}", "\\textbraceright");
          defineSymbol(symbols_math, main, symbols_open, "{", "\\lbrace");
          defineSymbol(symbols_math, main, symbols_close, "}", "\\rbrace");
          defineSymbol(symbols_math, main, symbols_open, "[", "\\lbrack", true);
          defineSymbol(symbols_text, main, symbols_textord, "[", "\\lbrack", true);
          defineSymbol(symbols_math, main, symbols_close, "]", "\\rbrack", true);
          defineSymbol(symbols_text, main, symbols_textord, "]", "\\rbrack", true);
          defineSymbol(symbols_math, main, symbols_open, "(", "\\lparen", true);
          defineSymbol(symbols_math, main, symbols_close, ")", "\\rparen", true);
          defineSymbol(symbols_text, main, symbols_textord, "<", "\\textless", true);
          defineSymbol(symbols_text, main, symbols_textord, ">", "\\textgreater", true);
          defineSymbol(symbols_math, main, symbols_open, "\u230A", "\\lfloor", true);
          defineSymbol(symbols_math, main, symbols_close, "\u230B", "\\rfloor", true);
          defineSymbol(symbols_math, main, symbols_open, "\u2308", "\\lceil", true);
          defineSymbol(symbols_math, main, symbols_close, "\u2309", "\\rceil", true);
          defineSymbol(symbols_math, main, symbols_textord, "\\", "\\backslash");
          defineSymbol(symbols_math, main, symbols_textord, "\u2223", "|");
          defineSymbol(symbols_math, main, symbols_textord, "\u2223", "\\vert");
          defineSymbol(symbols_text, main, symbols_textord, "|", "\\textbar", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u2225", "\\|");
          defineSymbol(symbols_math, main, symbols_textord, "\u2225", "\\Vert");
          defineSymbol(symbols_text, main, symbols_textord, "\u2225", "\\textbardbl");
          defineSymbol(symbols_text, main, symbols_textord, "~", "\\textasciitilde");
          defineSymbol(symbols_text, main, symbols_textord, "\\", "\\textbackslash");
          defineSymbol(symbols_text, main, symbols_textord, "^", "\\textasciicircum");
          defineSymbol(symbols_math, main, rel, "\u2191", "\\uparrow", true);
          defineSymbol(symbols_math, main, rel, "\u21D1", "\\Uparrow", true);
          defineSymbol(symbols_math, main, rel, "\u2193", "\\downarrow", true);
          defineSymbol(symbols_math, main, rel, "\u21D3", "\\Downarrow", true);
          defineSymbol(symbols_math, main, rel, "\u2195", "\\updownarrow", true);
          defineSymbol(symbols_math, main, rel, "\u21D5", "\\Updownarrow", true);
          defineSymbol(symbols_math, main, op, "\u2210", "\\coprod");
          defineSymbol(symbols_math, main, op, "\u22C1", "\\bigvee");
          defineSymbol(symbols_math, main, op, "\u22C0", "\\bigwedge");
          defineSymbol(symbols_math, main, op, "\u2A04", "\\biguplus");
          defineSymbol(symbols_math, main, op, "\u22C2", "\\bigcap");
          defineSymbol(symbols_math, main, op, "\u22C3", "\\bigcup");
          defineSymbol(symbols_math, main, op, "\u222B", "\\int");
          defineSymbol(symbols_math, main, op, "\u222B", "\\intop");
          defineSymbol(symbols_math, main, op, "\u222C", "\\iint");
          defineSymbol(symbols_math, main, op, "\u222D", "\\iiint");
          defineSymbol(symbols_math, main, op, "\u220F", "\\prod");
          defineSymbol(symbols_math, main, op, "\u2211", "\\sum");
          defineSymbol(symbols_math, main, op, "\u2A02", "\\bigotimes");
          defineSymbol(symbols_math, main, op, "\u2A01", "\\bigoplus");
          defineSymbol(symbols_math, main, op, "\u2A00", "\\bigodot");
          defineSymbol(symbols_math, main, op, "\u222E", "\\oint");
          defineSymbol(symbols_math, main, op, "\u2A06", "\\bigsqcup");
          defineSymbol(symbols_math, main, op, "\u222B", "\\smallint");
          defineSymbol(symbols_text, main, symbols_inner, "\u2026", "\\textellipsis");
          defineSymbol(symbols_math, main, symbols_inner, "\u2026", "\\mathellipsis");
          defineSymbol(symbols_text, main, symbols_inner, "\u2026", "\\ldots", true);
          defineSymbol(symbols_math, main, symbols_inner, "\u2026", "\\ldots", true);
          defineSymbol(symbols_math, main, symbols_inner, "\u22EF", "\\@cdots", true);
          defineSymbol(symbols_math, main, symbols_inner, "\u22F1", "\\ddots", true);
          defineSymbol(symbols_math, main, symbols_textord, "\u22EE", "\\varvdots");
          defineSymbol(symbols_math, main, symbols_accent, "\u02CA", "\\acute");
          defineSymbol(symbols_math, main, symbols_accent, "\u02CB", "\\grave");
          defineSymbol(symbols_math, main, symbols_accent, "\xA8", "\\ddot");
          defineSymbol(symbols_math, main, symbols_accent, "~", "\\tilde");
          defineSymbol(symbols_math, main, symbols_accent, "\u02C9", "\\bar");
          defineSymbol(symbols_math, main, symbols_accent, "\u02D8", "\\breve");
          defineSymbol(symbols_math, main, symbols_accent, "\u02C7", "\\check");
          defineSymbol(symbols_math, main, symbols_accent, "^", "\\hat");
          defineSymbol(symbols_math, main, symbols_accent, "\u20D7", "\\vec");
          defineSymbol(symbols_math, main, symbols_accent, "\u02D9", "\\dot");
          defineSymbol(symbols_math, main, symbols_accent, "\u02DA", "\\mathring");
          defineSymbol(symbols_math, main, mathord, "\uE131", "\\@imath");
          defineSymbol(symbols_math, main, mathord, "\uE237", "\\@jmath");
          defineSymbol(symbols_math, main, symbols_textord, "\u0131", "\u0131");
          defineSymbol(symbols_math, main, symbols_textord, "\u0237", "\u0237");
          defineSymbol(symbols_text, main, symbols_textord, "\u0131", "\\i", true);
          defineSymbol(symbols_text, main, symbols_textord, "\u0237", "\\j", true);
          defineSymbol(symbols_text, main, symbols_textord, "\xDF", "\\ss", true);
          defineSymbol(symbols_text, main, symbols_textord, "\xE6", "\\ae", true);
          defineSymbol(symbols_text, main, symbols_textord, "\u0153", "\\oe", true);
          defineSymbol(symbols_text, main, symbols_textord, "\xF8", "\\o", true);
          defineSymbol(symbols_text, main, symbols_textord, "\xC6", "\\AE", true);
          defineSymbol(symbols_text, main, symbols_textord, "\u0152", "\\OE", true);
          defineSymbol(symbols_text, main, symbols_textord, "\xD8", "\\O", true);
          defineSymbol(symbols_text, main, symbols_accent, "\u02CA", "\\'");
          defineSymbol(symbols_text, main, symbols_accent, "\u02CB", "\\`");
          defineSymbol(symbols_text, main, symbols_accent, "\u02C6", "\\^");
          defineSymbol(symbols_text, main, symbols_accent, "\u02DC", "\\~");
          defineSymbol(symbols_text, main, symbols_accent, "\u02C9", "\\=");
          defineSymbol(symbols_text, main, symbols_accent, "\u02D8", "\\u");
          defineSymbol(symbols_text, main, symbols_accent, "\u02D9", "\\.");
          defineSymbol(symbols_text, main, symbols_accent, "\u02DA", "\\r");
          defineSymbol(symbols_text, main, symbols_accent, "\u02C7", "\\v");
          defineSymbol(symbols_text, main, symbols_accent, "\xA8", '\\"');
          defineSymbol(symbols_text, main, symbols_accent, "\u02DD", "\\H");
          defineSymbol(symbols_text, main, symbols_accent, "\u25EF", "\\textcircled");
          var ligatures = {
            "--": true,
            "---": true,
            "``": true,
            "''": true
          };
          defineSymbol(symbols_text, main, symbols_textord, "\u2013", "--", true);
          defineSymbol(symbols_text, main, symbols_textord, "\u2013", "\\textendash");
          defineSymbol(symbols_text, main, symbols_textord, "\u2014", "---", true);
          defineSymbol(symbols_text, main, symbols_textord, "\u2014", "\\textemdash");
          defineSymbol(symbols_text, main, symbols_textord, "\u2018", "`", true);
          defineSymbol(symbols_text, main, symbols_textord, "\u2018", "\\textquoteleft");
          defineSymbol(symbols_text, main, symbols_textord, "\u2019", "'", true);
          defineSymbol(symbols_text, main, symbols_textord, "\u2019", "\\textquoteright");
          defineSymbol(symbols_text, main, symbols_textord, "\u201C", "``", true);
          defineSymbol(symbols_text, main, symbols_textord, "\u201C", "\\textquotedblleft");
          defineSymbol(symbols_text, main, symbols_textord, "\u201D", "''", true);
          defineSymbol(symbols_text, main, symbols_textord, "\u201D", "\\textquotedblright");
          defineSymbol(symbols_math, main, symbols_textord, "\xB0", "\\degree", true);
          defineSymbol(symbols_text, main, symbols_textord, "\xB0", "\\degree");
          defineSymbol(symbols_text, main, symbols_textord, "\xB0", "\\textdegree", true);
          defineSymbol(symbols_math, main, symbols_textord, "\xA3", "\\pounds");
          defineSymbol(symbols_math, main, symbols_textord, "\xA3", "\\mathsterling", true);
          defineSymbol(symbols_text, main, symbols_textord, "\xA3", "\\pounds");
          defineSymbol(symbols_text, main, symbols_textord, "\xA3", "\\textsterling", true);
          defineSymbol(symbols_math, ams, symbols_textord, "\u2720", "\\maltese");
          defineSymbol(symbols_text, ams, symbols_textord, "\u2720", "\\maltese");
          var mathTextSymbols = '0123456789/@."';
          for (var symbols_i = 0; symbols_i < mathTextSymbols.length; symbols_i++) {
            var symbols_ch = mathTextSymbols.charAt(symbols_i);
            defineSymbol(symbols_math, main, symbols_textord, symbols_ch, symbols_ch);
          }
          var textSymbols = '0123456789!@*()-=+";:?/.,';
          for (var src_symbols_i = 0; src_symbols_i < textSymbols.length; src_symbols_i++) {
            var _ch = textSymbols.charAt(src_symbols_i);
            defineSymbol(symbols_text, main, symbols_textord, _ch, _ch);
          }
          var letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
          for (var symbols_i2 = 0; symbols_i2 < letters.length; symbols_i2++) {
            var _ch2 = letters.charAt(symbols_i2);
            defineSymbol(symbols_math, main, mathord, _ch2, _ch2);
            defineSymbol(symbols_text, main, symbols_textord, _ch2, _ch2);
          }
          defineSymbol(symbols_math, ams, symbols_textord, "C", "\u2102");
          defineSymbol(symbols_text, ams, symbols_textord, "C", "\u2102");
          defineSymbol(symbols_math, ams, symbols_textord, "H", "\u210D");
          defineSymbol(symbols_text, ams, symbols_textord, "H", "\u210D");
          defineSymbol(symbols_math, ams, symbols_textord, "N", "\u2115");
          defineSymbol(symbols_text, ams, symbols_textord, "N", "\u2115");
          defineSymbol(symbols_math, ams, symbols_textord, "P", "\u2119");
          defineSymbol(symbols_text, ams, symbols_textord, "P", "\u2119");
          defineSymbol(symbols_math, ams, symbols_textord, "Q", "\u211A");
          defineSymbol(symbols_text, ams, symbols_textord, "Q", "\u211A");
          defineSymbol(symbols_math, ams, symbols_textord, "R", "\u211D");
          defineSymbol(symbols_text, ams, symbols_textord, "R", "\u211D");
          defineSymbol(symbols_math, ams, symbols_textord, "Z", "\u2124");
          defineSymbol(symbols_text, ams, symbols_textord, "Z", "\u2124");
          defineSymbol(symbols_math, main, mathord, "h", "\u210E");
          defineSymbol(symbols_text, main, mathord, "h", "\u210E");
          var symbols_wideChar = "";
          for (var symbols_i3 = 0; symbols_i3 < letters.length; symbols_i3++) {
            var _ch3 = letters.charAt(symbols_i3);
            symbols_wideChar = String.fromCharCode(55349, 56320 + symbols_i3);
            defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
            defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
            symbols_wideChar = String.fromCharCode(55349, 56372 + symbols_i3);
            defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
            defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
            symbols_wideChar = String.fromCharCode(55349, 56424 + symbols_i3);
            defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
            defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
            symbols_wideChar = String.fromCharCode(55349, 56580 + symbols_i3);
            defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
            defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
            symbols_wideChar = String.fromCharCode(55349, 56736 + symbols_i3);
            defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
            defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
            symbols_wideChar = String.fromCharCode(55349, 56788 + symbols_i3);
            defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
            defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
            symbols_wideChar = String.fromCharCode(55349, 56840 + symbols_i3);
            defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
            defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
            symbols_wideChar = String.fromCharCode(55349, 56944 + symbols_i3);
            defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
            defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
            if (symbols_i3 < 26) {
              symbols_wideChar = String.fromCharCode(55349, 56632 + symbols_i3);
              defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
              symbols_wideChar = String.fromCharCode(55349, 56476 + symbols_i3);
              defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
            }
          }
          symbols_wideChar = String.fromCharCode(55349, 56668);
          defineSymbol(symbols_math, main, mathord, "k", symbols_wideChar);
          defineSymbol(symbols_text, main, symbols_textord, "k", symbols_wideChar);
          for (var symbols_i4 = 0; symbols_i4 < 10; symbols_i4++) {
            var _ch4 = symbols_i4.toString();
            symbols_wideChar = String.fromCharCode(55349, 57294 + symbols_i4);
            defineSymbol(symbols_math, main, mathord, _ch4, symbols_wideChar);
            defineSymbol(symbols_text, main, symbols_textord, _ch4, symbols_wideChar);
            symbols_wideChar = String.fromCharCode(55349, 57314 + symbols_i4);
            defineSymbol(symbols_math, main, mathord, _ch4, symbols_wideChar);
            defineSymbol(symbols_text, main, symbols_textord, _ch4, symbols_wideChar);
            symbols_wideChar = String.fromCharCode(55349, 57324 + symbols_i4);
            defineSymbol(symbols_math, main, mathord, _ch4, symbols_wideChar);
            defineSymbol(symbols_text, main, symbols_textord, _ch4, symbols_wideChar);
            symbols_wideChar = String.fromCharCode(55349, 57334 + symbols_i4);
            defineSymbol(symbols_math, main, mathord, _ch4, symbols_wideChar);
            defineSymbol(symbols_text, main, symbols_textord, _ch4, symbols_wideChar);
          }
          var extraLatin = "\xC7\xD0\xDE\xE7\xFE";
          for (var _i5 = 0; _i5 < extraLatin.length; _i5++) {
            var _ch5 = extraLatin.charAt(_i5);
            defineSymbol(symbols_math, main, mathord, _ch5, _ch5);
            defineSymbol(symbols_text, main, symbols_textord, _ch5, _ch5);
          }
          var wideLatinLetterData = [
            ["mathbf", "textbf", "Main-Bold"],
            ["mathbf", "textbf", "Main-Bold"],
            ["mathnormal", "textit", "Math-Italic"],
            ["mathnormal", "textit", "Math-Italic"],
            ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
            ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
            ["mathscr", "textscr", "Script-Regular"],
            ["", "", ""],
            ["", "", ""],
            ["", "", ""],
            ["mathfrak", "textfrak", "Fraktur-Regular"],
            ["mathfrak", "textfrak", "Fraktur-Regular"],
            ["mathbb", "textbb", "AMS-Regular"],
            ["mathbb", "textbb", "AMS-Regular"],
            ["", "", ""],
            ["", "", ""],
            ["mathsf", "textsf", "SansSerif-Regular"],
            ["mathsf", "textsf", "SansSerif-Regular"],
            ["mathboldsf", "textboldsf", "SansSerif-Bold"],
            ["mathboldsf", "textboldsf", "SansSerif-Bold"],
            ["mathitsf", "textitsf", "SansSerif-Italic"],
            ["mathitsf", "textitsf", "SansSerif-Italic"],
            ["", "", ""],
            ["", "", ""],
            ["mathtt", "texttt", "Typewriter-Regular"],
            ["mathtt", "texttt", "Typewriter-Regular"]
          ];
          var wideNumeralData = [
            ["mathbf", "textbf", "Main-Bold"],
            ["", "", ""],
            ["mathsf", "textsf", "SansSerif-Regular"],
            ["mathboldsf", "textboldsf", "SansSerif-Bold"],
            ["mathtt", "texttt", "Typewriter-Regular"]
          ];
          var wide_character_wideCharacterFont = function wideCharacterFont(wideChar, mode) {
            var H = wideChar.charCodeAt(0);
            var L = wideChar.charCodeAt(1);
            var codePoint = (H - 55296) * 1024 + (L - 56320) + 65536;
            var j = mode === "math" ? 0 : 1;
            if (119808 <= codePoint && codePoint < 120484) {
              var i = Math.floor((codePoint - 119808) / 26);
              return [wideLatinLetterData[i][2], wideLatinLetterData[i][j]];
            } else if (120782 <= codePoint && codePoint <= 120831) {
              var _i = Math.floor((codePoint - 120782) / 10);
              return [wideNumeralData[_i][2], wideNumeralData[_i][j]];
            } else if (codePoint === 120485 || codePoint === 120486) {
              return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];
            } else if (120486 < codePoint && codePoint < 120782) {
              return ["", ""];
            } else {
              throw new src_ParseError("Unsupported character: " + wideChar);
            }
          };
          var sizeStyleMap = [
            [1, 1, 1],
            [2, 1, 1],
            [3, 1, 1],
            [4, 2, 1],
            [5, 2, 1],
            [6, 3, 1],
            [7, 4, 2],
            [8, 6, 3],
            [9, 7, 6],
            [10, 8, 7],
            [11, 10, 9]
          ];
          var sizeMultipliers = [
            0.5,
            0.6,
            0.7,
            0.8,
            0.9,
            1,
            1.2,
            1.44,
            1.728,
            2.074,
            2.488
          ];
          var sizeAtStyle = function sizeAtStyle2(size, style) {
            return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];
          };
          var Options_Options = /* @__PURE__ */ function() {
            function Options(data2) {
              this.style = void 0;
              this.color = void 0;
              this.size = void 0;
              this.textSize = void 0;
              this.phantom = void 0;
              this.font = void 0;
              this.fontFamily = void 0;
              this.fontWeight = void 0;
              this.fontShape = void 0;
              this.sizeMultiplier = void 0;
              this.maxSize = void 0;
              this.minRuleThickness = void 0;
              this._fontMetrics = void 0;
              this.style = data2.style;
              this.color = data2.color;
              this.size = data2.size || Options.BASESIZE;
              this.textSize = data2.textSize || this.size;
              this.phantom = !!data2.phantom;
              this.font = data2.font || "";
              this.fontFamily = data2.fontFamily || "";
              this.fontWeight = data2.fontWeight || "";
              this.fontShape = data2.fontShape || "";
              this.sizeMultiplier = sizeMultipliers[this.size - 1];
              this.maxSize = data2.maxSize;
              this.minRuleThickness = data2.minRuleThickness;
              this._fontMetrics = void 0;
            }
            var _proto = Options.prototype;
            _proto.extend = function extend(extension) {
              var data2 = {
                style: this.style,
                size: this.size,
                textSize: this.textSize,
                color: this.color,
                phantom: this.phantom,
                font: this.font,
                fontFamily: this.fontFamily,
                fontWeight: this.fontWeight,
                fontShape: this.fontShape,
                maxSize: this.maxSize,
                minRuleThickness: this.minRuleThickness
              };
              for (var key in extension) {
                if (extension.hasOwnProperty(key)) {
                  data2[key] = extension[key];
                }
              }
              return new Options(data2);
            };
            _proto.havingStyle = function havingStyle(style) {
              if (this.style === style) {
                return this;
              } else {
                return this.extend({
                  style,
                  size: sizeAtStyle(this.textSize, style)
                });
              }
            };
            _proto.havingCrampedStyle = function havingCrampedStyle() {
              return this.havingStyle(this.style.cramp());
            };
            _proto.havingSize = function havingSize(size) {
              if (this.size === size && this.textSize === size) {
                return this;
              } else {
                return this.extend({
                  style: this.style.text(),
                  size,
                  textSize: size,
                  sizeMultiplier: sizeMultipliers[size - 1]
                });
              }
            };
            _proto.havingBaseStyle = function havingBaseStyle(style) {
              style = style || this.style.text();
              var wantSize = sizeAtStyle(Options.BASESIZE, style);
              if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {
                return this;
              } else {
                return this.extend({
                  style,
                  size: wantSize
                });
              }
            };
            _proto.havingBaseSizing = function havingBaseSizing() {
              var size;
              switch (this.style.id) {
                case 4:
                case 5:
                  size = 3;
                  break;
                case 6:
                case 7:
                  size = 1;
                  break;
                default:
                  size = 6;
              }
              return this.extend({
                style: this.style.text(),
                size
              });
            };
            _proto.withColor = function withColor(color) {
              return this.extend({
                color
              });
            };
            _proto.withPhantom = function withPhantom() {
              return this.extend({
                phantom: true
              });
            };
            _proto.withFont = function withFont(font) {
              return this.extend({
                font
              });
            };
            _proto.withTextFontFamily = function withTextFontFamily(fontFamily) {
              return this.extend({
                fontFamily,
                font: ""
              });
            };
            _proto.withTextFontWeight = function withTextFontWeight(fontWeight) {
              return this.extend({
                fontWeight,
                font: ""
              });
            };
            _proto.withTextFontShape = function withTextFontShape(fontShape) {
              return this.extend({
                fontShape,
                font: ""
              });
            };
            _proto.sizingClasses = function sizingClasses(oldOptions) {
              if (oldOptions.size !== this.size) {
                return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
              } else {
                return [];
              }
            };
            _proto.baseSizingClasses = function baseSizingClasses() {
              if (this.size !== Options.BASESIZE) {
                return ["sizing", "reset-size" + this.size, "size" + Options.BASESIZE];
              } else {
                return [];
              }
            };
            _proto.fontMetrics = function fontMetrics() {
              if (!this._fontMetrics) {
                this._fontMetrics = getGlobalMetrics(this.size);
              }
              return this._fontMetrics;
            };
            _proto.getColor = function getColor() {
              if (this.phantom) {
                return "transparent";
              } else {
                return this.color;
              }
            };
            return Options;
          }();
          Options_Options.BASESIZE = 6;
          var src_Options = Options_Options;
          var ptPerUnit = {
            "pt": 1,
            "mm": 7227 / 2540,
            "cm": 7227 / 254,
            "in": 72.27,
            "bp": 803 / 800,
            "pc": 12,
            "dd": 1238 / 1157,
            "cc": 14856 / 1157,
            "nd": 685 / 642,
            "nc": 1370 / 107,
            "sp": 1 / 65536,
            "px": 803 / 800
          };
          var relativeUnit = {
            "ex": true,
            "em": true,
            "mu": true
          };
          var validUnit = function validUnit2(unit) {
            if (typeof unit !== "string") {
              unit = unit.unit;
            }
            return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
          };
          var units_calculateSize = function calculateSize(sizeValue, options) {
            var scale;
            if (sizeValue.unit in ptPerUnit) {
              scale = ptPerUnit[sizeValue.unit] / options.fontMetrics().ptPerEm / options.sizeMultiplier;
            } else if (sizeValue.unit === "mu") {
              scale = options.fontMetrics().cssEmPerMu;
            } else {
              var unitOptions;
              if (options.style.isTight()) {
                unitOptions = options.havingStyle(options.style.text());
              } else {
                unitOptions = options;
              }
              if (sizeValue.unit === "ex") {
                scale = unitOptions.fontMetrics().xHeight;
              } else if (sizeValue.unit === "em") {
                scale = unitOptions.fontMetrics().quad;
              } else {
                throw new src_ParseError("Invalid unit: '" + sizeValue.unit + "'");
              }
              if (unitOptions !== options) {
                scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
              }
            }
            return Math.min(sizeValue.number * scale, options.maxSize);
          };
          var buildCommon_lookupSymbol = function lookupSymbol(value, fontName, mode) {
            if (src_symbols[mode][value] && src_symbols[mode][value].replace) {
              value = src_symbols[mode][value].replace;
            }
            return {
              value,
              metrics: getCharacterMetrics(value, fontName, mode)
            };
          };
          var buildCommon_makeSymbol = function makeSymbol(value, fontName, mode, options, classes) {
            var lookup = buildCommon_lookupSymbol(value, fontName, mode);
            var metrics = lookup.metrics;
            value = lookup.value;
            var symbolNode;
            if (metrics) {
              var italic = metrics.italic;
              if (mode === "text" || options && options.font === "mathit") {
                italic = 0;
              }
              symbolNode = new domTree_SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
            } else {
              typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
              symbolNode = new domTree_SymbolNode(value, 0, 0, 0, 0, 0, classes);
            }
            if (options) {
              symbolNode.maxFontSize = options.sizeMultiplier;
              if (options.style.isTight()) {
                symbolNode.classes.push("mtight");
              }
              var color = options.getColor();
              if (color) {
                symbolNode.style.color = color;
              }
            }
            return symbolNode;
          };
          var buildCommon_mathsym = function mathsym(value, mode, options, classes) {
            if (classes === void 0) {
              classes = [];
            }
            if (options.font === "boldsymbol" && buildCommon_lookupSymbol(value, "Main-Bold", mode).metrics) {
              return buildCommon_makeSymbol(value, "Main-Bold", mode, options, classes.concat(["mathbf"]));
            } else if (value === "\\" || src_symbols[mode][value].font === "main") {
              return buildCommon_makeSymbol(value, "Main-Regular", mode, options, classes);
            } else {
              return buildCommon_makeSymbol(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
            }
          };
          var boldsymbol = function boldsymbol2(value, mode, options, classes, type) {
            if (type !== "textord" && buildCommon_lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
              return {
                fontName: "Math-BoldItalic",
                fontClass: "boldsymbol"
              };
            } else {
              return {
                fontName: "Main-Bold",
                fontClass: "mathbf"
              };
            }
          };
          var buildCommon_makeOrd = function makeOrd(group, options, type) {
            var mode = group.mode;
            var text4 = group.text;
            var classes = ["mord"];
            var isFont = mode === "math" || mode === "text" && options.font;
            var fontOrFamily = isFont ? options.font : options.fontFamily;
            if (text4.charCodeAt(0) === 55349) {
              var _wideCharacterFont = wide_character_wideCharacterFont(text4, mode), wideFontName = _wideCharacterFont[0], wideFontClass = _wideCharacterFont[1];
              return buildCommon_makeSymbol(text4, wideFontName, mode, options, classes.concat(wideFontClass));
            } else if (fontOrFamily) {
              var fontName;
              var fontClasses;
              if (fontOrFamily === "boldsymbol") {
                var fontData = boldsymbol(text4, mode, options, classes, type);
                fontName = fontData.fontName;
                fontClasses = [fontData.fontClass];
              } else if (isFont) {
                fontName = fontMap[fontOrFamily].fontName;
                fontClasses = [fontOrFamily];
              } else {
                fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
                fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
              }
              if (buildCommon_lookupSymbol(text4, fontName, mode).metrics) {
                return buildCommon_makeSymbol(text4, fontName, mode, options, classes.concat(fontClasses));
              } else if (ligatures.hasOwnProperty(text4) && fontName.substr(0, 10) === "Typewriter") {
                var parts = [];
                for (var i = 0; i < text4.length; i++) {
                  parts.push(buildCommon_makeSymbol(text4[i], fontName, mode, options, classes.concat(fontClasses)));
                }
                return buildCommon_makeFragment(parts);
              }
            }
            if (type === "mathord") {
              return buildCommon_makeSymbol(text4, "Math-Italic", mode, options, classes.concat(["mathnormal"]));
            } else if (type === "textord") {
              var font = src_symbols[mode][text4] && src_symbols[mode][text4].font;
              if (font === "ams") {
                var _fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);
                return buildCommon_makeSymbol(text4, _fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
              } else if (font === "main" || !font) {
                var _fontName2 = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);
                return buildCommon_makeSymbol(text4, _fontName2, mode, options, classes.concat(options.fontWeight, options.fontShape));
              } else {
                var _fontName3 = retrieveTextFontName(font, options.fontWeight, options.fontShape);
                return buildCommon_makeSymbol(text4, _fontName3, mode, options, classes.concat(_fontName3, options.fontWeight, options.fontShape));
              }
            } else {
              throw new Error("unexpected type: " + type + " in makeOrd");
            }
          };
          var buildCommon_canCombine = function canCombine(prev2, next2) {
            if (createClass(prev2.classes) !== createClass(next2.classes) || prev2.skew !== next2.skew || prev2.maxFontSize !== next2.maxFontSize) {
              return false;
            }
            for (var style in prev2.style) {
              if (prev2.style.hasOwnProperty(style) && prev2.style[style] !== next2.style[style]) {
                return false;
              }
            }
            for (var _style in next2.style) {
              if (next2.style.hasOwnProperty(_style) && prev2.style[_style] !== next2.style[_style]) {
                return false;
              }
            }
            return true;
          };
          var buildCommon_tryCombineChars = function tryCombineChars(chars) {
            for (var i = 0; i < chars.length - 1; i++) {
              var prev2 = chars[i];
              var next2 = chars[i + 1];
              if (prev2 instanceof domTree_SymbolNode && next2 instanceof domTree_SymbolNode && buildCommon_canCombine(prev2, next2)) {
                prev2.text += next2.text;
                prev2.height = Math.max(prev2.height, next2.height);
                prev2.depth = Math.max(prev2.depth, next2.depth);
                prev2.italic = next2.italic;
                chars.splice(i + 1, 1);
                i--;
              }
            }
            return chars;
          };
          var sizeElementFromChildren = function sizeElementFromChildren2(elem) {
            var height = 0;
            var depth = 0;
            var maxFontSize = 0;
            for (var i = 0; i < elem.children.length; i++) {
              var child = elem.children[i];
              if (child.height > height) {
                height = child.height;
              }
              if (child.depth > depth) {
                depth = child.depth;
              }
              if (child.maxFontSize > maxFontSize) {
                maxFontSize = child.maxFontSize;
              }
            }
            elem.height = height;
            elem.depth = depth;
            elem.maxFontSize = maxFontSize;
          };
          var buildCommon_makeSpan = function makeSpan(classes, children2, options, style) {
            var span = new domTree_Span(classes, children2, options, style);
            sizeElementFromChildren(span);
            return span;
          };
          var buildCommon_makeSvgSpan = function makeSvgSpan(classes, children2, options, style) {
            return new domTree_Span(classes, children2, options, style);
          };
          var makeLineSpan = function makeLineSpan2(className, options, thickness) {
            var line = buildCommon_makeSpan([className], [], options);
            line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
            line.style.borderBottomWidth = line.height + "em";
            line.maxFontSize = 1;
            return line;
          };
          var buildCommon_makeAnchor = function makeAnchor(href, classes, children2, options) {
            var anchor = new domTree_Anchor(href, classes, children2, options);
            sizeElementFromChildren(anchor);
            return anchor;
          };
          var buildCommon_makeFragment = function makeFragment(children2) {
            var fragment = new tree_DocumentFragment(children2);
            sizeElementFromChildren(fragment);
            return fragment;
          };
          var buildCommon_wrapFragment = function wrapFragment(group, options) {
            if (group instanceof tree_DocumentFragment) {
              return buildCommon_makeSpan([], [group], options);
            }
            return group;
          };
          var getVListChildrenAndDepth = function getVListChildrenAndDepth2(params) {
            if (params.positionType === "individualShift") {
              var oldChildren = params.children;
              var children2 = [oldChildren[0]];
              var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
              var currPos = _depth;
              for (var i = 1; i < oldChildren.length; i++) {
                var diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;
                var size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);
                currPos = currPos + diff;
                children2.push({
                  type: "kern",
                  size
                });
                children2.push(oldChildren[i]);
              }
              return {
                children: children2,
                depth: _depth
              };
            }
            var depth;
            if (params.positionType === "top") {
              var bottom = params.positionData;
              for (var _i = 0; _i < params.children.length; _i++) {
                var child = params.children[_i];
                bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
              }
              depth = bottom;
            } else if (params.positionType === "bottom") {
              depth = -params.positionData;
            } else {
              var firstChild = params.children[0];
              if (firstChild.type !== "elem") {
                throw new Error('First child must have type "elem".');
              }
              if (params.positionType === "shift") {
                depth = -firstChild.elem.depth - params.positionData;
              } else if (params.positionType === "firstBaseline") {
                depth = -firstChild.elem.depth;
              } else {
                throw new Error("Invalid positionType " + params.positionType + ".");
              }
            }
            return {
              children: params.children,
              depth
            };
          };
          var buildCommon_makeVList = function makeVList(params, options) {
            var _getVListChildrenAndD = getVListChildrenAndDepth(params), children2 = _getVListChildrenAndD.children, depth = _getVListChildrenAndD.depth;
            var pstrutSize = 0;
            for (var i = 0; i < children2.length; i++) {
              var child = children2[i];
              if (child.type === "elem") {
                var elem = child.elem;
                pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
              }
            }
            pstrutSize += 2;
            var pstrut = buildCommon_makeSpan(["pstrut"], []);
            pstrut.style.height = pstrutSize + "em";
            var realChildren = [];
            var minPos = depth;
            var maxPos = depth;
            var currPos = depth;
            for (var _i2 = 0; _i2 < children2.length; _i2++) {
              var _child = children2[_i2];
              if (_child.type === "kern") {
                currPos += _child.size;
              } else {
                var _elem = _child.elem;
                var classes = _child.wrapperClasses || [];
                var style = _child.wrapperStyle || {};
                var childWrap = buildCommon_makeSpan(classes, [pstrut, _elem], void 0, style);
                childWrap.style.top = -pstrutSize - currPos - _elem.depth + "em";
                if (_child.marginLeft) {
                  childWrap.style.marginLeft = _child.marginLeft;
                }
                if (_child.marginRight) {
                  childWrap.style.marginRight = _child.marginRight;
                }
                realChildren.push(childWrap);
                currPos += _elem.height + _elem.depth;
              }
              minPos = Math.min(minPos, currPos);
              maxPos = Math.max(maxPos, currPos);
            }
            var vlist = buildCommon_makeSpan(["vlist"], realChildren);
            vlist.style.height = maxPos + "em";
            var rows;
            if (minPos < 0) {
              var emptySpan = buildCommon_makeSpan([], []);
              var depthStrut = buildCommon_makeSpan(["vlist"], [emptySpan]);
              depthStrut.style.height = -minPos + "em";
              var topStrut = buildCommon_makeSpan(["vlist-s"], [new domTree_SymbolNode("\u200B")]);
              rows = [buildCommon_makeSpan(["vlist-r"], [vlist, topStrut]), buildCommon_makeSpan(["vlist-r"], [depthStrut])];
            } else {
              rows = [buildCommon_makeSpan(["vlist-r"], [vlist])];
            }
            var vtable = buildCommon_makeSpan(["vlist-t"], rows);
            if (rows.length === 2) {
              vtable.classes.push("vlist-t2");
            }
            vtable.height = maxPos;
            vtable.depth = -minPos;
            return vtable;
          };
          var buildCommon_makeGlue = function makeGlue(measurement, options) {
            var rule = buildCommon_makeSpan(["mspace"], [], options);
            var size = units_calculateSize(measurement, options);
            rule.style.marginRight = size + "em";
            return rule;
          };
          var retrieveTextFontName = function retrieveTextFontName2(fontFamily, fontWeight, fontShape) {
            var baseFontName = "";
            switch (fontFamily) {
              case "amsrm":
                baseFontName = "AMS";
                break;
              case "textrm":
                baseFontName = "Main";
                break;
              case "textsf":
                baseFontName = "SansSerif";
                break;
              case "texttt":
                baseFontName = "Typewriter";
                break;
              default:
                baseFontName = fontFamily;
            }
            var fontStylesName;
            if (fontWeight === "textbf" && fontShape === "textit") {
              fontStylesName = "BoldItalic";
            } else if (fontWeight === "textbf") {
              fontStylesName = "Bold";
            } else if (fontWeight === "textit") {
              fontStylesName = "Italic";
            } else {
              fontStylesName = "Regular";
            }
            return baseFontName + "-" + fontStylesName;
          };
          var fontMap = {
            "mathbf": {
              variant: "bold",
              fontName: "Main-Bold"
            },
            "mathrm": {
              variant: "normal",
              fontName: "Main-Regular"
            },
            "textit": {
              variant: "italic",
              fontName: "Main-Italic"
            },
            "mathit": {
              variant: "italic",
              fontName: "Main-Italic"
            },
            "mathnormal": {
              variant: "italic",
              fontName: "Math-Italic"
            },
            "mathbb": {
              variant: "double-struck",
              fontName: "AMS-Regular"
            },
            "mathcal": {
              variant: "script",
              fontName: "Caligraphic-Regular"
            },
            "mathfrak": {
              variant: "fraktur",
              fontName: "Fraktur-Regular"
            },
            "mathscr": {
              variant: "script",
              fontName: "Script-Regular"
            },
            "mathsf": {
              variant: "sans-serif",
              fontName: "SansSerif-Regular"
            },
            "mathtt": {
              variant: "monospace",
              fontName: "Typewriter-Regular"
            }
          };
          var svgData = {
            vec: ["vec", 0.471, 0.714],
            oiintSize1: ["oiintSize1", 0.957, 0.499],
            oiintSize2: ["oiintSize2", 1.472, 0.659],
            oiiintSize1: ["oiiintSize1", 1.304, 0.499],
            oiiintSize2: ["oiiintSize2", 1.98, 0.659],
            leftParenInner: ["leftParenInner", 0.875, 0.3],
            rightParenInner: ["rightParenInner", 0.875, 0.3]
          };
          var buildCommon_staticSvg = function staticSvg(value, options) {
            var _svgData$value = svgData[value], pathName = _svgData$value[0], width = _svgData$value[1], height = _svgData$value[2];
            var path = new domTree_PathNode(pathName);
            var svgNode = new SvgNode([path], {
              "width": width + "em",
              "height": height + "em",
              "style": "width:" + width + "em",
              "viewBox": "0 0 " + 1e3 * width + " " + 1e3 * height,
              "preserveAspectRatio": "xMinYMin"
            });
            var span = buildCommon_makeSvgSpan(["overlay"], [svgNode], options);
            span.height = height;
            span.style.height = height + "em";
            span.style.width = width + "em";
            return span;
          };
          var buildCommon = {
            fontMap,
            makeSymbol: buildCommon_makeSymbol,
            mathsym: buildCommon_mathsym,
            makeSpan: buildCommon_makeSpan,
            makeSvgSpan: buildCommon_makeSvgSpan,
            makeLineSpan,
            makeAnchor: buildCommon_makeAnchor,
            makeFragment: buildCommon_makeFragment,
            wrapFragment: buildCommon_wrapFragment,
            makeVList: buildCommon_makeVList,
            makeOrd: buildCommon_makeOrd,
            makeGlue: buildCommon_makeGlue,
            staticSvg: buildCommon_staticSvg,
            svgData,
            tryCombineChars: buildCommon_tryCombineChars
          };
          var thinspace = {
            number: 3,
            unit: "mu"
          };
          var mediumspace = {
            number: 4,
            unit: "mu"
          };
          var thickspace = {
            number: 5,
            unit: "mu"
          };
          var spacings = {
            mord: {
              mop: thinspace,
              mbin: mediumspace,
              mrel: thickspace,
              minner: thinspace
            },
            mop: {
              mord: thinspace,
              mop: thinspace,
              mrel: thickspace,
              minner: thinspace
            },
            mbin: {
              mord: mediumspace,
              mop: mediumspace,
              mopen: mediumspace,
              minner: mediumspace
            },
            mrel: {
              mord: thickspace,
              mop: thickspace,
              mopen: thickspace,
              minner: thickspace
            },
            mopen: {},
            mclose: {
              mop: thinspace,
              mbin: mediumspace,
              mrel: thickspace,
              minner: thinspace
            },
            mpunct: {
              mord: thinspace,
              mop: thinspace,
              mrel: thickspace,
              mopen: thinspace,
              mclose: thinspace,
              mpunct: thinspace,
              minner: thinspace
            },
            minner: {
              mord: thinspace,
              mop: thinspace,
              mbin: mediumspace,
              mrel: thickspace,
              mopen: thinspace,
              mpunct: thinspace,
              minner: thinspace
            }
          };
          var tightSpacings = {
            mord: {
              mop: thinspace
            },
            mop: {
              mord: thinspace,
              mop: thinspace
            },
            mbin: {},
            mrel: {},
            mopen: {},
            mclose: {
              mop: thinspace
            },
            mpunct: {},
            minner: {
              mop: thinspace
            }
          };
          var _functions = {};
          var _htmlGroupBuilders = {};
          var _mathmlGroupBuilders = {};
          function defineFunction(_ref) {
            var type = _ref.type, names = _ref.names, props = _ref.props, handler = _ref.handler, htmlBuilder = _ref.htmlBuilder, mathmlBuilder = _ref.mathmlBuilder;
            var data2 = {
              type,
              numArgs: props.numArgs,
              argTypes: props.argTypes,
              greediness: props.greediness === void 0 ? 1 : props.greediness,
              allowedInText: !!props.allowedInText,
              allowedInMath: props.allowedInMath === void 0 ? true : props.allowedInMath,
              numOptionalArgs: props.numOptionalArgs || 0,
              infix: !!props.infix,
              handler
            };
            for (var i = 0; i < names.length; ++i) {
              _functions[names[i]] = data2;
            }
            if (type) {
              if (htmlBuilder) {
                _htmlGroupBuilders[type] = htmlBuilder;
              }
              if (mathmlBuilder) {
                _mathmlGroupBuilders[type] = mathmlBuilder;
              }
            }
          }
          function defineFunctionBuilders(_ref2) {
            var type = _ref2.type, htmlBuilder = _ref2.htmlBuilder, mathmlBuilder = _ref2.mathmlBuilder;
            defineFunction({
              type,
              names: [],
              props: {
                numArgs: 0
              },
              handler: function handler() {
                throw new Error("Should never be called.");
              },
              htmlBuilder,
              mathmlBuilder
            });
          }
          var ordargument = function ordargument2(arg) {
            return arg.type === "ordgroup" ? arg.body : [arg];
          };
          var buildHTML_makeSpan = buildCommon.makeSpan;
          var binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
          var binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
          var styleMap = {
            "display": src_Style.DISPLAY,
            "text": src_Style.TEXT,
            "script": src_Style.SCRIPT,
            "scriptscript": src_Style.SCRIPTSCRIPT
          };
          var DomEnum = {
            mord: "mord",
            mop: "mop",
            mbin: "mbin",
            mrel: "mrel",
            mopen: "mopen",
            mclose: "mclose",
            mpunct: "mpunct",
            minner: "minner"
          };
          var buildHTML_buildExpression = function buildExpression(expression, options, isRealGroup, surrounding) {
            if (surrounding === void 0) {
              surrounding = [null, null];
            }
            var groups = [];
            for (var i = 0; i < expression.length; i++) {
              var output = buildHTML_buildGroup(expression[i], options);
              if (output instanceof tree_DocumentFragment) {
                var children2 = output.children;
                groups.push.apply(groups, children2);
              } else {
                groups.push(output);
              }
            }
            if (!isRealGroup) {
              return groups;
            }
            var glueOptions = options;
            if (expression.length === 1) {
              var node = expression[0];
              if (node.type === "sizing") {
                glueOptions = options.havingSize(node.size);
              } else if (node.type === "styling") {
                glueOptions = options.havingStyle(styleMap[node.style]);
              }
            }
            var dummyPrev = buildHTML_makeSpan([surrounding[0] || "leftmost"], [], options);
            var dummyNext = buildHTML_makeSpan([surrounding[1] || "rightmost"], [], options);
            var isRoot = isRealGroup === "root";
            traverseNonSpaceNodes(groups, function(node2, prev2) {
              var prevType = prev2.classes[0];
              var type = node2.classes[0];
              if (prevType === "mbin" && utils.contains(binRightCanceller, type)) {
                prev2.classes[0] = "mord";
              } else if (type === "mbin" && utils.contains(binLeftCanceller, prevType)) {
                node2.classes[0] = "mord";
              }
            }, {
              node: dummyPrev
            }, dummyNext, isRoot);
            traverseNonSpaceNodes(groups, function(node2, prev2) {
              var prevType = getTypeOfDomTree(prev2);
              var type = getTypeOfDomTree(node2);
              var space = prevType && type ? node2.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;
              if (space) {
                return buildCommon.makeGlue(space, glueOptions);
              }
            }, {
              node: dummyPrev
            }, dummyNext, isRoot);
            return groups;
          };
          var traverseNonSpaceNodes = function traverseNonSpaceNodes2(nodes, callback, prev2, next2, isRoot) {
            if (next2) {
              nodes.push(next2);
            }
            var i = 0;
            for (; i < nodes.length; i++) {
              var node = nodes[i];
              var partialGroup = buildHTML_checkPartialGroup(node);
              if (partialGroup) {
                traverseNonSpaceNodes2(partialGroup.children, callback, prev2, null, isRoot);
                continue;
              }
              var nonspace = !node.hasClass("mspace");
              if (nonspace) {
                var result = callback(node, prev2.node);
                if (result) {
                  if (prev2.insertAfter) {
                    prev2.insertAfter(result);
                  } else {
                    nodes.unshift(result);
                    i++;
                  }
                }
              }
              if (nonspace) {
                prev2.node = node;
              } else if (isRoot && node.hasClass("newline")) {
                prev2.node = buildHTML_makeSpan(["leftmost"]);
              }
              prev2.insertAfter = function(index2) {
                return function(n) {
                  nodes.splice(index2 + 1, 0, n);
                  i++;
                };
              }(i);
            }
            if (next2) {
              nodes.pop();
            }
          };
          var buildHTML_checkPartialGroup = function checkPartialGroup(node) {
            if (node instanceof tree_DocumentFragment || node instanceof domTree_Anchor || node instanceof domTree_Span && node.hasClass("enclosing")) {
              return node;
            }
            return null;
          };
          var getOutermostNode = function getOutermostNode2(node, side) {
            var partialGroup = buildHTML_checkPartialGroup(node);
            if (partialGroup) {
              var children2 = partialGroup.children;
              if (children2.length) {
                if (side === "right") {
                  return getOutermostNode2(children2[children2.length - 1], "right");
                } else if (side === "left") {
                  return getOutermostNode2(children2[0], "left");
                }
              }
            }
            return node;
          };
          var getTypeOfDomTree = function getTypeOfDomTree2(node, side) {
            if (!node) {
              return null;
            }
            if (side) {
              node = getOutermostNode(node, side);
            }
            return DomEnum[node.classes[0]] || null;
          };
          var makeNullDelimiter = function makeNullDelimiter2(options, classes) {
            var moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
            return buildHTML_makeSpan(classes.concat(moreClasses));
          };
          var buildHTML_buildGroup = function buildGroup(group, options, baseOptions) {
            if (!group) {
              return buildHTML_makeSpan();
            }
            if (_htmlGroupBuilders[group.type]) {
              var groupNode = _htmlGroupBuilders[group.type](group, options);
              if (baseOptions && options.size !== baseOptions.size) {
                groupNode = buildHTML_makeSpan(options.sizingClasses(baseOptions), [groupNode], options);
                var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
                groupNode.height *= multiplier;
                groupNode.depth *= multiplier;
              }
              return groupNode;
            } else {
              throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
            }
          };
          function buildHTMLUnbreakable(children2, options) {
            var body = buildHTML_makeSpan(["base"], children2, options);
            var strut = buildHTML_makeSpan(["strut"]);
            strut.style.height = body.height + body.depth + "em";
            strut.style.verticalAlign = -body.depth + "em";
            body.children.unshift(strut);
            return body;
          }
          function buildHTML(tree, options) {
            var tag = null;
            if (tree.length === 1 && tree[0].type === "tag") {
              tag = tree[0].tag;
              tree = tree[0].body;
            }
            var expression = buildHTML_buildExpression(tree, options, "root");
            var children2 = [];
            var parts = [];
            for (var i = 0; i < expression.length; i++) {
              parts.push(expression[i]);
              if (expression[i].hasClass("mbin") || expression[i].hasClass("mrel") || expression[i].hasClass("allowbreak")) {
                var nobreak = false;
                while (i < expression.length - 1 && expression[i + 1].hasClass("mspace") && !expression[i + 1].hasClass("newline")) {
                  i++;
                  parts.push(expression[i]);
                  if (expression[i].hasClass("nobreak")) {
                    nobreak = true;
                  }
                }
                if (!nobreak) {
                  children2.push(buildHTMLUnbreakable(parts, options));
                  parts = [];
                }
              } else if (expression[i].hasClass("newline")) {
                parts.pop();
                if (parts.length > 0) {
                  children2.push(buildHTMLUnbreakable(parts, options));
                  parts = [];
                }
                children2.push(expression[i]);
              }
            }
            if (parts.length > 0) {
              children2.push(buildHTMLUnbreakable(parts, options));
            }
            var tagChild;
            if (tag) {
              tagChild = buildHTMLUnbreakable(buildHTML_buildExpression(tag, options, true));
              tagChild.classes = ["tag"];
              children2.push(tagChild);
            }
            var htmlNode = buildHTML_makeSpan(["katex-html"], children2);
            htmlNode.setAttribute("aria-hidden", "true");
            if (tagChild) {
              var strut = tagChild.children[0];
              strut.style.height = htmlNode.height + htmlNode.depth + "em";
              strut.style.verticalAlign = -htmlNode.depth + "em";
            }
            return htmlNode;
          }
          function newDocumentFragment(children2) {
            return new tree_DocumentFragment(children2);
          }
          var mathMLTree_MathNode = /* @__PURE__ */ function() {
            function MathNode(type, children2) {
              this.type = void 0;
              this.attributes = void 0;
              this.children = void 0;
              this.type = type;
              this.attributes = {};
              this.children = children2 || [];
            }
            var _proto = MathNode.prototype;
            _proto.setAttribute = function setAttribute(name2, value) {
              this.attributes[name2] = value;
            };
            _proto.getAttribute = function getAttribute(name2) {
              return this.attributes[name2];
            };
            _proto.toNode = function toNode() {
              var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
              for (var attr2 in this.attributes) {
                if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                  node.setAttribute(attr2, this.attributes[attr2]);
                }
              }
              for (var i = 0; i < this.children.length; i++) {
                node.appendChild(this.children[i].toNode());
              }
              return node;
            };
            _proto.toMarkup = function toMarkup() {
              var markup = "<" + this.type;
              for (var attr2 in this.attributes) {
                if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                  markup += " " + attr2 + '="';
                  markup += utils.escape(this.attributes[attr2]);
                  markup += '"';
                }
              }
              markup += ">";
              for (var i = 0; i < this.children.length; i++) {
                markup += this.children[i].toMarkup();
              }
              markup += "</" + this.type + ">";
              return markup;
            };
            _proto.toText = function toText() {
              return this.children.map(function(child) {
                return child.toText();
              }).join("");
            };
            return MathNode;
          }();
          var mathMLTree_TextNode = /* @__PURE__ */ function() {
            function TextNode(text4) {
              this.text = void 0;
              this.text = text4;
            }
            var _proto2 = TextNode.prototype;
            _proto2.toNode = function toNode() {
              return document.createTextNode(this.text);
            };
            _proto2.toMarkup = function toMarkup() {
              return utils.escape(this.toText());
            };
            _proto2.toText = function toText() {
              return this.text;
            };
            return TextNode;
          }();
          var SpaceNode = /* @__PURE__ */ function() {
            function SpaceNode2(width) {
              this.width = void 0;
              this.character = void 0;
              this.width = width;
              if (width >= 0.05555 && width <= 0.05556) {
                this.character = "\u200A";
              } else if (width >= 0.1666 && width <= 0.1667) {
                this.character = "\u2009";
              } else if (width >= 0.2222 && width <= 0.2223) {
                this.character = "\u2005";
              } else if (width >= 0.2777 && width <= 0.2778) {
                this.character = "\u2005\u200A";
              } else if (width >= -0.05556 && width <= -0.05555) {
                this.character = "\u200A\u2063";
              } else if (width >= -0.1667 && width <= -0.1666) {
                this.character = "\u2009\u2063";
              } else if (width >= -0.2223 && width <= -0.2222) {
                this.character = "\u205F\u2063";
              } else if (width >= -0.2778 && width <= -0.2777) {
                this.character = "\u2005\u2063";
              } else {
                this.character = null;
              }
            }
            var _proto3 = SpaceNode2.prototype;
            _proto3.toNode = function toNode() {
              if (this.character) {
                return document.createTextNode(this.character);
              } else {
                var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
                node.setAttribute("width", this.width + "em");
                return node;
              }
            };
            _proto3.toMarkup = function toMarkup() {
              if (this.character) {
                return "<mtext>" + this.character + "</mtext>";
              } else {
                return '<mspace width="' + this.width + 'em"/>';
              }
            };
            _proto3.toText = function toText() {
              if (this.character) {
                return this.character;
              } else {
                return " ";
              }
            };
            return SpaceNode2;
          }();
          var mathMLTree = {
            MathNode: mathMLTree_MathNode,
            TextNode: mathMLTree_TextNode,
            SpaceNode,
            newDocumentFragment
          };
          var buildMathML_makeText = function makeText(text4, mode, options) {
            if (src_symbols[mode][text4] && src_symbols[mode][text4].replace && text4.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(text4) && options && (options.fontFamily && options.fontFamily.substr(4, 2) === "tt" || options.font && options.font.substr(4, 2) === "tt"))) {
              text4 = src_symbols[mode][text4].replace;
            }
            return new mathMLTree.TextNode(text4);
          };
          var buildMathML_makeRow = function makeRow(body) {
            if (body.length === 1) {
              return body[0];
            } else {
              return new mathMLTree.MathNode("mrow", body);
            }
          };
          var buildMathML_getVariant = function getVariant(group, options) {
            if (options.fontFamily === "texttt") {
              return "monospace";
            } else if (options.fontFamily === "textsf") {
              if (options.fontShape === "textit" && options.fontWeight === "textbf") {
                return "sans-serif-bold-italic";
              } else if (options.fontShape === "textit") {
                return "sans-serif-italic";
              } else if (options.fontWeight === "textbf") {
                return "bold-sans-serif";
              } else {
                return "sans-serif";
              }
            } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
              return "bold-italic";
            } else if (options.fontShape === "textit") {
              return "italic";
            } else if (options.fontWeight === "textbf") {
              return "bold";
            }
            var font = options.font;
            if (!font || font === "mathnormal") {
              return null;
            }
            var mode = group.mode;
            if (font === "mathit") {
              return "italic";
            } else if (font === "boldsymbol") {
              return group.type === "textord" ? "bold" : "bold-italic";
            } else if (font === "mathbf") {
              return "bold";
            } else if (font === "mathbb") {
              return "double-struck";
            } else if (font === "mathfrak") {
              return "fraktur";
            } else if (font === "mathscr" || font === "mathcal") {
              return "script";
            } else if (font === "mathsf") {
              return "sans-serif";
            } else if (font === "mathtt") {
              return "monospace";
            }
            var text4 = group.text;
            if (utils.contains(["\\imath", "\\jmath"], text4)) {
              return null;
            }
            if (src_symbols[mode][text4] && src_symbols[mode][text4].replace) {
              text4 = src_symbols[mode][text4].replace;
            }
            var fontName = buildCommon.fontMap[font].fontName;
            if (getCharacterMetrics(text4, fontName, mode)) {
              return buildCommon.fontMap[font].variant;
            }
            return null;
          };
          var buildMathML_buildExpression = function buildExpression(expression, options, isOrdgroup) {
            if (expression.length === 1) {
              var group = buildMathML_buildGroup(expression[0], options);
              if (isOrdgroup && group instanceof mathMLTree_MathNode && group.type === "mo") {
                group.setAttribute("lspace", "0em");
                group.setAttribute("rspace", "0em");
              }
              return [group];
            }
            var groups = [];
            var lastGroup;
            for (var i = 0; i < expression.length; i++) {
              var _group = buildMathML_buildGroup(expression[i], options);
              if (_group instanceof mathMLTree_MathNode && lastGroup instanceof mathMLTree_MathNode) {
                if (_group.type === "mtext" && lastGroup.type === "mtext" && _group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
                  var _lastGroup$children;
                  (_lastGroup$children = lastGroup.children).push.apply(_lastGroup$children, _group.children);
                  continue;
                } else if (_group.type === "mn" && lastGroup.type === "mn") {
                  var _lastGroup$children2;
                  (_lastGroup$children2 = lastGroup.children).push.apply(_lastGroup$children2, _group.children);
                  continue;
                } else if (_group.type === "mi" && _group.children.length === 1 && lastGroup.type === "mn") {
                  var child = _group.children[0];
                  if (child instanceof mathMLTree_TextNode && child.text === ".") {
                    var _lastGroup$children3;
                    (_lastGroup$children3 = lastGroup.children).push.apply(_lastGroup$children3, _group.children);
                    continue;
                  }
                } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
                  var lastChild = lastGroup.children[0];
                  if (lastChild instanceof mathMLTree_TextNode && lastChild.text === "\u0338" && (_group.type === "mo" || _group.type === "mi" || _group.type === "mn")) {
                    var _child = _group.children[0];
                    if (_child instanceof mathMLTree_TextNode && _child.text.length > 0) {
                      _child.text = _child.text.slice(0, 1) + "\u0338" + _child.text.slice(1);
                      groups.pop();
                    }
                  }
                }
              }
              groups.push(_group);
              lastGroup = _group;
            }
            return groups;
          };
          var buildExpressionRow = function buildExpressionRow2(expression, options, isOrdgroup) {
            return buildMathML_makeRow(buildMathML_buildExpression(expression, options, isOrdgroup));
          };
          var buildMathML_buildGroup = function buildGroup(group, options) {
            if (!group) {
              return new mathMLTree.MathNode("mrow");
            }
            if (_mathmlGroupBuilders[group.type]) {
              var result = _mathmlGroupBuilders[group.type](group, options);
              return result;
            } else {
              throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
            }
          };
          function buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {
            var expression = buildMathML_buildExpression(tree, options);
            var wrapper;
            if (expression.length === 1 && expression[0] instanceof mathMLTree_MathNode && utils.contains(["mrow", "mtable"], expression[0].type)) {
              wrapper = expression[0];
            } else {
              wrapper = new mathMLTree.MathNode("mrow", expression);
            }
            var annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
            annotation.setAttribute("encoding", "application/x-tex");
            var semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
            var math = new mathMLTree.MathNode("math", [semantics]);
            math.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
            if (isDisplayMode) {
              math.setAttribute("display", "block");
            }
            var wrapperClass = forMathmlOnly ? "katex" : "katex-mathml";
            return buildCommon.makeSpan([wrapperClass], [math]);
          }
          var buildTree_optionsFromSettings = function optionsFromSettings(settings) {
            return new src_Options({
              style: settings.displayMode ? src_Style.DISPLAY : src_Style.TEXT,
              maxSize: settings.maxSize,
              minRuleThickness: settings.minRuleThickness
            });
          };
          var buildTree_displayWrap = function displayWrap(node, settings) {
            if (settings.displayMode) {
              var classes = ["katex-display"];
              if (settings.leqno) {
                classes.push("leqno");
              }
              if (settings.fleqn) {
                classes.push("fleqn");
              }
              node = buildCommon.makeSpan(classes, [node]);
            }
            return node;
          };
          var buildTree_buildTree = function buildTree2(tree, expression, settings) {
            var options = buildTree_optionsFromSettings(settings);
            var katexNode;
            if (settings.output === "mathml") {
              return buildMathML(tree, expression, options, settings.displayMode, true);
            } else if (settings.output === "html") {
              var htmlNode = buildHTML(tree, options);
              katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
            } else {
              var mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);
              var _htmlNode = buildHTML(tree, options);
              katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, _htmlNode]);
            }
            return buildTree_displayWrap(katexNode, settings);
          };
          var buildTree_buildHTMLTree = function buildHTMLTree(tree, expression, settings) {
            var options = buildTree_optionsFromSettings(settings);
            var htmlNode = buildHTML(tree, options);
            var katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
            return buildTree_displayWrap(katexNode, settings);
          };
          var src_buildTree = buildTree_buildTree;
          var stretchyCodePoint = {
            widehat: "^",
            widecheck: "\u02C7",
            widetilde: "~",
            utilde: "~",
            overleftarrow: "\u2190",
            underleftarrow: "\u2190",
            xleftarrow: "\u2190",
            overrightarrow: "\u2192",
            underrightarrow: "\u2192",
            xrightarrow: "\u2192",
            underbrace: "\u23DF",
            overbrace: "\u23DE",
            overgroup: "\u23E0",
            undergroup: "\u23E1",
            overleftrightarrow: "\u2194",
            underleftrightarrow: "\u2194",
            xleftrightarrow: "\u2194",
            Overrightarrow: "\u21D2",
            xRightarrow: "\u21D2",
            overleftharpoon: "\u21BC",
            xleftharpoonup: "\u21BC",
            overrightharpoon: "\u21C0",
            xrightharpoonup: "\u21C0",
            xLeftarrow: "\u21D0",
            xLeftrightarrow: "\u21D4",
            xhookleftarrow: "\u21A9",
            xhookrightarrow: "\u21AA",
            xmapsto: "\u21A6",
            xrightharpoondown: "\u21C1",
            xleftharpoondown: "\u21BD",
            xrightleftharpoons: "\u21CC",
            xleftrightharpoons: "\u21CB",
            xtwoheadleftarrow: "\u219E",
            xtwoheadrightarrow: "\u21A0",
            xlongequal: "=",
            xtofrom: "\u21C4",
            xrightleftarrows: "\u21C4",
            xrightequilibrium: "\u21CC",
            xleftequilibrium: "\u21CB"
          };
          var stretchy_mathMLnode = function mathMLnode(label) {
            var node = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.substr(1)])]);
            node.setAttribute("stretchy", "true");
            return node;
          };
          var katexImagesData = {
            overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
            overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
            underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
            underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
            xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
            xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
            Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
            xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
            xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
            overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
            xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
            xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
            overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
            xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
            xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
            xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
            xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
            xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
            overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
            overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
            underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
            underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
            xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
            xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
            xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
            xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
            xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
            xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
            overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
            underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
            overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
            undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
            xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
            xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
            xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
            xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
            xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
          };
          var groupLength = function groupLength2(arg) {
            if (arg.type === "ordgroup") {
              return arg.body.length;
            } else {
              return 1;
            }
          };
          var stretchy_svgSpan = function svgSpan(group, options) {
            function buildSvgSpan_() {
              var viewBoxWidth = 4e5;
              var label = group.label.substr(1);
              if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
                var grp = group;
                var numChars = groupLength(grp.base);
                var viewBoxHeight;
                var pathName;
                var _height;
                if (numChars > 5) {
                  if (label === "widehat" || label === "widecheck") {
                    viewBoxHeight = 420;
                    viewBoxWidth = 2364;
                    _height = 0.42;
                    pathName = label + "4";
                  } else {
                    viewBoxHeight = 312;
                    viewBoxWidth = 2340;
                    _height = 0.34;
                    pathName = "tilde4";
                  }
                } else {
                  var imgIndex = [1, 1, 2, 2, 3, 3][numChars];
                  if (label === "widehat" || label === "widecheck") {
                    viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
                    viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
                    _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
                    pathName = label + imgIndex;
                  } else {
                    viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
                    viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
                    _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
                    pathName = "tilde" + imgIndex;
                  }
                }
                var path = new domTree_PathNode(pathName);
                var svgNode = new SvgNode([path], {
                  "width": "100%",
                  "height": _height + "em",
                  "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
                  "preserveAspectRatio": "none"
                });
                return {
                  span: buildCommon.makeSvgSpan([], [svgNode], options),
                  minWidth: 0,
                  height: _height
                };
              } else {
                var spans = [];
                var data2 = katexImagesData[label];
                var paths = data2[0], _minWidth = data2[1], _viewBoxHeight = data2[2];
                var _height2 = _viewBoxHeight / 1e3;
                var numSvgChildren = paths.length;
                var widthClasses;
                var aligns;
                if (numSvgChildren === 1) {
                  var align1 = data2[3];
                  widthClasses = ["hide-tail"];
                  aligns = [align1];
                } else if (numSvgChildren === 2) {
                  widthClasses = ["halfarrow-left", "halfarrow-right"];
                  aligns = ["xMinYMin", "xMaxYMin"];
                } else if (numSvgChildren === 3) {
                  widthClasses = ["brace-left", "brace-center", "brace-right"];
                  aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
                } else {
                  throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
                }
                for (var i = 0; i < numSvgChildren; i++) {
                  var _path = new domTree_PathNode(paths[i]);
                  var _svgNode = new SvgNode([_path], {
                    "width": "400em",
                    "height": _height2 + "em",
                    "viewBox": "0 0 " + viewBoxWidth + " " + _viewBoxHeight,
                    "preserveAspectRatio": aligns[i] + " slice"
                  });
                  var _span = buildCommon.makeSvgSpan([widthClasses[i]], [_svgNode], options);
                  if (numSvgChildren === 1) {
                    return {
                      span: _span,
                      minWidth: _minWidth,
                      height: _height2
                    };
                  } else {
                    _span.style.height = _height2 + "em";
                    spans.push(_span);
                  }
                }
                return {
                  span: buildCommon.makeSpan(["stretchy"], spans, options),
                  minWidth: _minWidth,
                  height: _height2
                };
              }
            }
            var _buildSvgSpan_ = buildSvgSpan_(), span = _buildSvgSpan_.span, minWidth = _buildSvgSpan_.minWidth, height = _buildSvgSpan_.height;
            span.height = height;
            span.style.height = height + "em";
            if (minWidth > 0) {
              span.style.minWidth = minWidth + "em";
            }
            return span;
          };
          var stretchy_encloseSpan = function encloseSpan(inner, label, pad, options) {
            var img;
            var totalHeight = inner.height + inner.depth + 2 * pad;
            if (/fbox|color/.test(label)) {
              img = buildCommon.makeSpan(["stretchy", label], [], options);
              if (label === "fbox") {
                var color = options.color && options.getColor();
                if (color) {
                  img.style.borderColor = color;
                }
              }
            } else {
              var lines = [];
              if (/^[bx]cancel$/.test(label)) {
                lines.push(new LineNode({
                  "x1": "0",
                  "y1": "0",
                  "x2": "100%",
                  "y2": "100%",
                  "stroke-width": "0.046em"
                }));
              }
              if (/^x?cancel$/.test(label)) {
                lines.push(new LineNode({
                  "x1": "0",
                  "y1": "100%",
                  "x2": "100%",
                  "y2": "0",
                  "stroke-width": "0.046em"
                }));
              }
              var svgNode = new SvgNode(lines, {
                "width": "100%",
                "height": totalHeight + "em"
              });
              img = buildCommon.makeSvgSpan([], [svgNode], options);
            }
            img.height = totalHeight;
            img.style.height = totalHeight + "em";
            return img;
          };
          var stretchy = {
            encloseSpan: stretchy_encloseSpan,
            mathMLnode: stretchy_mathMLnode,
            svgSpan: stretchy_svgSpan
          };
          function assertNodeType(node, type) {
            if (!node || node.type !== type) {
              throw new Error("Expected node of type " + type + ", but got " + (node ? "node of type " + node.type : String(node)));
            }
            return node;
          }
          function assertSymbolNodeType(node) {
            var typedNode = checkSymbolNodeType(node);
            if (!typedNode) {
              throw new Error("Expected node of symbol group type, but got " + (node ? "node of type " + node.type : String(node)));
            }
            return typedNode;
          }
          function checkSymbolNodeType(node) {
            if (node && (node.type === "atom" || NON_ATOMS.hasOwnProperty(node.type))) {
              return node;
            }
            return null;
          }
          var accent_htmlBuilder = function htmlBuilder(grp, options) {
            var base2;
            var group;
            var supSubGroup;
            if (grp && grp.type === "supsub") {
              group = assertNodeType(grp.base, "accent");
              base2 = group.base;
              grp.base = base2;
              supSubGroup = assertSpan(buildHTML_buildGroup(grp, options));
              grp.base = group;
            } else {
              group = assertNodeType(grp, "accent");
              base2 = group.base;
            }
            var body = buildHTML_buildGroup(base2, options.havingCrampedStyle());
            var mustShift = group.isShifty && utils.isCharacterBox(base2);
            var skew2 = 0;
            if (mustShift) {
              var baseChar = utils.getBaseElem(base2);
              var baseGroup = buildHTML_buildGroup(baseChar, options.havingCrampedStyle());
              skew2 = assertSymbolDomNode(baseGroup).skew;
            }
            var clearance = Math.min(body.height, options.fontMetrics().xHeight);
            var accentBody;
            if (!group.isStretchy) {
              var accent;
              var width;
              if (group.label === "\\vec") {
                accent = buildCommon.staticSvg("vec", options);
                width = buildCommon.svgData.vec[1];
              } else {
                accent = buildCommon.makeOrd({
                  mode: group.mode,
                  text: group.label
                }, options, "textord");
                accent = assertSymbolDomNode(accent);
                accent.italic = 0;
                width = accent.width;
              }
              accentBody = buildCommon.makeSpan(["accent-body"], [accent]);
              var accentFull = group.label === "\\textcircled";
              if (accentFull) {
                accentBody.classes.push("accent-full");
                clearance = body.height;
              }
              var left = skew2;
              if (!accentFull) {
                left -= width / 2;
              }
              accentBody.style.left = left + "em";
              if (group.label === "\\textcircled") {
                accentBody.style.top = ".2em";
              }
              accentBody = buildCommon.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: body
                }, {
                  type: "kern",
                  size: -clearance
                }, {
                  type: "elem",
                  elem: accentBody
                }]
              }, options);
            } else {
              accentBody = stretchy.svgSpan(group, options);
              accentBody = buildCommon.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: body
                }, {
                  type: "elem",
                  elem: accentBody,
                  wrapperClasses: ["svg-align"],
                  wrapperStyle: skew2 > 0 ? {
                    width: "calc(100% - " + 2 * skew2 + "em)",
                    marginLeft: 2 * skew2 + "em"
                  } : void 0
                }]
              }, options);
            }
            var accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);
            if (supSubGroup) {
              supSubGroup.children[0] = accentWrap;
              supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
              supSubGroup.classes[0] = "mord";
              return supSubGroup;
            } else {
              return accentWrap;
            }
          };
          var accent_mathmlBuilder = function mathmlBuilder(group, options) {
            var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [buildMathML_makeText(group.label, group.mode)]);
            var node = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.base, options), accentNode]);
            node.setAttribute("accent", "true");
            return node;
          };
          var NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map(function(accent) {
            return "\\" + accent;
          }).join("|"));
          defineFunction({
            type: "accent",
            names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
            props: {
              numArgs: 1
            },
            handler: function handler(context, args) {
              var base2 = args[0];
              var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
              var isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
              return {
                type: "accent",
                mode: context.parser.mode,
                label: context.funcName,
                isStretchy,
                isShifty,
                base: base2
              };
            },
            htmlBuilder: accent_htmlBuilder,
            mathmlBuilder: accent_mathmlBuilder
          });
          defineFunction({
            type: "accent",
            names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\r", "\\H", "\\v", "\\textcircled"],
            props: {
              numArgs: 1,
              allowedInText: true,
              allowedInMath: false
            },
            handler: function handler(context, args) {
              var base2 = args[0];
              return {
                type: "accent",
                mode: context.parser.mode,
                label: context.funcName,
                isStretchy: false,
                isShifty: true,
                base: base2
              };
            },
            htmlBuilder: accent_htmlBuilder,
            mathmlBuilder: accent_mathmlBuilder
          });
          defineFunction({
            type: "accentUnder",
            names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
            props: {
              numArgs: 1
            },
            handler: function handler(_ref, args) {
              var parser = _ref.parser, funcName = _ref.funcName;
              var base2 = args[0];
              return {
                type: "accentUnder",
                mode: parser.mode,
                label: funcName,
                base: base2
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              var innerGroup = buildHTML_buildGroup(group.base, options);
              var accentBody = stretchy.svgSpan(group, options);
              var kern = group.label === "\\utilde" ? 0.12 : 0;
              var vlist = buildCommon.makeVList({
                positionType: "top",
                positionData: innerGroup.height,
                children: [{
                  type: "elem",
                  elem: accentBody,
                  wrapperClasses: ["svg-align"]
                }, {
                  type: "kern",
                  size: kern
                }, {
                  type: "elem",
                  elem: innerGroup
                }]
              }, options);
              return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var accentNode = stretchy.mathMLnode(group.label);
              var node = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.base, options), accentNode]);
              node.setAttribute("accentunder", "true");
              return node;
            }
          });
          var arrow_paddedNode = function paddedNode(group) {
            var node = new mathMLTree.MathNode("mpadded", group ? [group] : []);
            node.setAttribute("width", "+0.6em");
            node.setAttribute("lspace", "0.3em");
            return node;
          };
          defineFunction({
            type: "xArrow",
            names: [
              "\\xleftarrow",
              "\\xrightarrow",
              "\\xLeftarrow",
              "\\xRightarrow",
              "\\xleftrightarrow",
              "\\xLeftrightarrow",
              "\\xhookleftarrow",
              "\\xhookrightarrow",
              "\\xmapsto",
              "\\xrightharpoondown",
              "\\xrightharpoonup",
              "\\xleftharpoondown",
              "\\xleftharpoonup",
              "\\xrightleftharpoons",
              "\\xleftrightharpoons",
              "\\xlongequal",
              "\\xtwoheadrightarrow",
              "\\xtwoheadleftarrow",
              "\\xtofrom",
              "\\xrightleftarrows",
              "\\xrightequilibrium",
              "\\xleftequilibrium"
            ],
            props: {
              numArgs: 1,
              numOptionalArgs: 1
            },
            handler: function handler(_ref, args, optArgs) {
              var parser = _ref.parser, funcName = _ref.funcName;
              return {
                type: "xArrow",
                mode: parser.mode,
                label: funcName,
                body: args[0],
                below: optArgs[0]
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              var style = options.style;
              var newOptions = options.havingStyle(style.sup());
              var upperGroup = buildCommon.wrapFragment(buildHTML_buildGroup(group.body, newOptions, options), options);
              upperGroup.classes.push("x-arrow-pad");
              var lowerGroup;
              if (group.below) {
                newOptions = options.havingStyle(style.sub());
                lowerGroup = buildCommon.wrapFragment(buildHTML_buildGroup(group.below, newOptions, options), options);
                lowerGroup.classes.push("x-arrow-pad");
              }
              var arrowBody = stretchy.svgSpan(group, options);
              var arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height;
              var upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
              if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
                upperShift -= upperGroup.depth;
              }
              var vlist;
              if (lowerGroup) {
                var lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
                vlist = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: upperGroup,
                    shift: upperShift
                  }, {
                    type: "elem",
                    elem: arrowBody,
                    shift: arrowShift
                  }, {
                    type: "elem",
                    elem: lowerGroup,
                    shift: lowerShift
                  }]
                }, options);
              } else {
                vlist = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: upperGroup,
                    shift: upperShift
                  }, {
                    type: "elem",
                    elem: arrowBody,
                    shift: arrowShift
                  }]
                }, options);
              }
              vlist.children[0].children[0].children[1].classes.push("svg-align");
              return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var arrowNode = stretchy.mathMLnode(group.label);
              var node;
              if (group.body) {
                var upperNode = arrow_paddedNode(buildMathML_buildGroup(group.body, options));
                if (group.below) {
                  var lowerNode = arrow_paddedNode(buildMathML_buildGroup(group.below, options));
                  node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
                } else {
                  node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
                }
              } else if (group.below) {
                var _lowerNode = arrow_paddedNode(buildMathML_buildGroup(group.below, options));
                node = new mathMLTree.MathNode("munder", [arrowNode, _lowerNode]);
              } else {
                node = arrow_paddedNode();
                node = new mathMLTree.MathNode("mover", [arrowNode, node]);
              }
              return node;
            }
          });
          defineFunction({
            type: "textord",
            names: ["\\@char"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: function handler(_ref, args) {
              var parser = _ref.parser;
              var arg = assertNodeType(args[0], "ordgroup");
              var group = arg.body;
              var number = "";
              for (var i = 0; i < group.length; i++) {
                var node = assertNodeType(group[i], "textord");
                number += node.text;
              }
              var code2 = parseInt(number);
              if (isNaN(code2)) {
                throw new src_ParseError("\\@char has non-numeric argument " + number);
              }
              return {
                type: "textord",
                mode: parser.mode,
                text: String.fromCharCode(code2)
              };
            }
          });
          var color_htmlBuilder = function htmlBuilder(group, options) {
            var elements = buildHTML_buildExpression(group.body, options.withColor(group.color), false);
            return buildCommon.makeFragment(elements);
          };
          var color_mathmlBuilder = function mathmlBuilder(group, options) {
            var inner = buildMathML_buildExpression(group.body, options.withColor(group.color));
            var node = new mathMLTree.MathNode("mstyle", inner);
            node.setAttribute("mathcolor", group.color);
            return node;
          };
          defineFunction({
            type: "color",
            names: ["\\textcolor"],
            props: {
              numArgs: 2,
              allowedInText: true,
              greediness: 3,
              argTypes: ["color", "original"]
            },
            handler: function handler(_ref, args) {
              var parser = _ref.parser;
              var color = assertNodeType(args[0], "color-token").color;
              var body = args[1];
              return {
                type: "color",
                mode: parser.mode,
                color,
                body: ordargument(body)
              };
            },
            htmlBuilder: color_htmlBuilder,
            mathmlBuilder: color_mathmlBuilder
          });
          defineFunction({
            type: "color",
            names: ["\\color"],
            props: {
              numArgs: 1,
              allowedInText: true,
              greediness: 3,
              argTypes: ["color"]
            },
            handler: function handler(_ref2, args) {
              var parser = _ref2.parser, breakOnTokenText = _ref2.breakOnTokenText;
              var color = assertNodeType(args[0], "color-token").color;
              parser.gullet.macros.set("\\current@color", color);
              var body = parser.parseExpression(true, breakOnTokenText);
              return {
                type: "color",
                mode: parser.mode,
                color,
                body
              };
            },
            htmlBuilder: color_htmlBuilder,
            mathmlBuilder: color_mathmlBuilder
          });
          defineFunction({
            type: "cr",
            names: ["\\cr", "\\newline"],
            props: {
              numArgs: 0,
              numOptionalArgs: 1,
              argTypes: ["size"],
              allowedInText: true
            },
            handler: function handler(_ref, args, optArgs) {
              var parser = _ref.parser, funcName = _ref.funcName;
              var size = optArgs[0];
              var newRow = funcName === "\\cr";
              var newLine = false;
              if (!newRow) {
                if (parser.settings.displayMode && parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode")) {
                  newLine = false;
                } else {
                  newLine = true;
                }
              }
              return {
                type: "cr",
                mode: parser.mode,
                newLine,
                newRow,
                size: size && assertNodeType(size, "size").value
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              if (group.newRow) {
                throw new src_ParseError("\\cr valid only within a tabular/array environment");
              }
              var span = buildCommon.makeSpan(["mspace"], [], options);
              if (group.newLine) {
                span.classes.push("newline");
                if (group.size) {
                  span.style.marginTop = units_calculateSize(group.size, options) + "em";
                }
              }
              return span;
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var node = new mathMLTree.MathNode("mspace");
              if (group.newLine) {
                node.setAttribute("linebreak", "newline");
                if (group.size) {
                  node.setAttribute("height", units_calculateSize(group.size, options) + "em");
                }
              }
              return node;
            }
          });
          var globalMap = {
            "\\global": "\\global",
            "\\long": "\\\\globallong",
            "\\\\globallong": "\\\\globallong",
            "\\def": "\\gdef",
            "\\gdef": "\\gdef",
            "\\edef": "\\xdef",
            "\\xdef": "\\xdef",
            "\\let": "\\\\globallet",
            "\\futurelet": "\\\\globalfuture"
          };
          var def_checkControlSequence = function checkControlSequence(tok) {
            var name2 = tok.text;
            if (/^(?:[\\{}$&#^_]|EOF)$/.test(name2)) {
              throw new src_ParseError("Expected a control sequence", tok);
            }
            return name2;
          };
          var getRHS = function getRHS2(parser) {
            var tok = parser.gullet.popToken();
            if (tok.text === "=") {
              tok = parser.gullet.popToken();
              if (tok.text === " ") {
                tok = parser.gullet.popToken();
              }
            }
            return tok;
          };
          var letCommand = function letCommand2(parser, name2, tok, global2) {
            var macro = parser.gullet.macros.get(tok.text);
            if (macro == null) {
              tok.noexpand = true;
              macro = {
                tokens: [tok],
                numArgs: 0,
                unexpandable: !parser.gullet.isExpandable(tok.text)
              };
            }
            parser.gullet.macros.set(name2, macro, global2);
          };
          defineFunction({
            type: "internal",
            names: ["\\global", "\\long", "\\\\globallong"],
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler: function handler(_ref) {
              var parser = _ref.parser, funcName = _ref.funcName;
              parser.consumeSpaces();
              var token = parser.fetch();
              if (globalMap[token.text]) {
                if (funcName === "\\global" || funcName === "\\\\globallong") {
                  token.text = globalMap[token.text];
                }
                return assertNodeType(parser.parseFunction(), "internal");
              }
              throw new src_ParseError("Invalid token after macro prefix", token);
            }
          });
          defineFunction({
            type: "internal",
            names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler: function handler(_ref2) {
              var parser = _ref2.parser, funcName = _ref2.funcName;
              var arg = parser.gullet.consumeArgs(1)[0];
              if (arg.length !== 1) {
                throw new src_ParseError("\\gdef's first argument must be a macro name");
              }
              var name2 = arg[0].text;
              var numArgs = 0;
              arg = parser.gullet.consumeArgs(1)[0];
              while (arg.length === 1 && arg[0].text === "#") {
                arg = parser.gullet.consumeArgs(1)[0];
                if (arg.length !== 1) {
                  throw new src_ParseError('Invalid argument number length "' + arg.length + '"');
                }
                if (!/^[1-9]$/.test(arg[0].text)) {
                  throw new src_ParseError('Invalid argument number "' + arg[0].text + '"');
                }
                numArgs++;
                if (parseInt(arg[0].text) !== numArgs) {
                  throw new src_ParseError('Argument number "' + arg[0].text + '" out of order');
                }
                arg = parser.gullet.consumeArgs(1)[0];
              }
              if (funcName === "\\edef" || funcName === "\\xdef") {
                arg = parser.gullet.expandTokens(arg);
                arg.reverse();
              }
              parser.gullet.macros.set(name2, {
                tokens: arg,
                numArgs
              }, funcName === globalMap[funcName]);
              return {
                type: "internal",
                mode: parser.mode
              };
            }
          });
          defineFunction({
            type: "internal",
            names: ["\\let", "\\\\globallet"],
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler: function handler(_ref3) {
              var parser = _ref3.parser, funcName = _ref3.funcName;
              var name2 = def_checkControlSequence(parser.gullet.popToken());
              parser.gullet.consumeSpaces();
              var tok = getRHS(parser);
              letCommand(parser, name2, tok, funcName === "\\\\globallet");
              return {
                type: "internal",
                mode: parser.mode
              };
            }
          });
          defineFunction({
            type: "internal",
            names: ["\\futurelet", "\\\\globalfuture"],
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler: function handler(_ref4) {
              var parser = _ref4.parser, funcName = _ref4.funcName;
              var name2 = def_checkControlSequence(parser.gullet.popToken());
              var middle = parser.gullet.popToken();
              var tok = parser.gullet.popToken();
              letCommand(parser, name2, tok, funcName === "\\\\globalfuture");
              parser.gullet.pushToken(tok);
              parser.gullet.pushToken(middle);
              return {
                type: "internal",
                mode: parser.mode
              };
            }
          });
          var delimiter_getMetrics = function getMetrics(symbol, font, mode) {
            var replace2 = src_symbols.math[symbol] && src_symbols.math[symbol].replace;
            var metrics = getCharacterMetrics(replace2 || symbol, font, mode);
            if (!metrics) {
              throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
            }
            return metrics;
          };
          var delimiter_styleWrap = function styleWrap(delim, toStyle, options, classes) {
            var newOptions = options.havingBaseStyle(toStyle);
            var span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
            var delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
            span.height *= delimSizeMultiplier;
            span.depth *= delimSizeMultiplier;
            span.maxFontSize = newOptions.sizeMultiplier;
            return span;
          };
          var centerSpan = function centerSpan2(span, options, style) {
            var newOptions = options.havingBaseStyle(style);
            var shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
            span.classes.push("delimcenter");
            span.style.top = shift + "em";
            span.height -= shift;
            span.depth += shift;
          };
          var delimiter_makeSmallDelim = function makeSmallDelim(delim, style, center, options, mode, classes) {
            var text4 = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
            var span = delimiter_styleWrap(text4, style, options, classes);
            if (center) {
              centerSpan(span, options, style);
            }
            return span;
          };
          var delimiter_mathrmSize = function mathrmSize(value, size, mode, options) {
            return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode, options);
          };
          var delimiter_makeLargeDelim = function makeLargeDelim(delim, size, center, options, mode, classes) {
            var inner = delimiter_mathrmSize(delim, size, mode, options);
            var span = delimiter_styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner], options), src_Style.TEXT, options, classes);
            if (center) {
              centerSpan(span, options, src_Style.TEXT);
            }
            return span;
          };
          var delimiter_makeInner = function makeInner(symbol, font, mode) {
            var sizeClass;
            if (font === "Size1-Regular") {
              sizeClass = "delim-size1";
            } else {
              sizeClass = "delim-size4";
            }
            var inner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);
            return {
              type: "elem",
              elem: inner
            };
          };
          var lap = {
            type: "kern",
            size: -5e-3
          };
          var delimiter_makeStackedDelim = function makeStackedDelim(delim, heightTotal, center, options, mode, classes) {
            var top;
            var middle;
            var repeat;
            var bottom;
            top = repeat = bottom = delim;
            middle = null;
            var font = "Size1-Regular";
            if (delim === "\\uparrow") {
              repeat = bottom = "\u23D0";
            } else if (delim === "\\Uparrow") {
              repeat = bottom = "\u2016";
            } else if (delim === "\\downarrow") {
              top = repeat = "\u23D0";
            } else if (delim === "\\Downarrow") {
              top = repeat = "\u2016";
            } else if (delim === "\\updownarrow") {
              top = "\\uparrow";
              repeat = "\u23D0";
              bottom = "\\downarrow";
            } else if (delim === "\\Updownarrow") {
              top = "\\Uparrow";
              repeat = "\u2016";
              bottom = "\\Downarrow";
            } else if (delim === "[" || delim === "\\lbrack") {
              top = "\u23A1";
              repeat = "\u23A2";
              bottom = "\u23A3";
              font = "Size4-Regular";
            } else if (delim === "]" || delim === "\\rbrack") {
              top = "\u23A4";
              repeat = "\u23A5";
              bottom = "\u23A6";
              font = "Size4-Regular";
            } else if (delim === "\\lfloor" || delim === "\u230A") {
              repeat = top = "\u23A2";
              bottom = "\u23A3";
              font = "Size4-Regular";
            } else if (delim === "\\lceil" || delim === "\u2308") {
              top = "\u23A1";
              repeat = bottom = "\u23A2";
              font = "Size4-Regular";
            } else if (delim === "\\rfloor" || delim === "\u230B") {
              repeat = top = "\u23A5";
              bottom = "\u23A6";
              font = "Size4-Regular";
            } else if (delim === "\\rceil" || delim === "\u2309") {
              top = "\u23A4";
              repeat = bottom = "\u23A5";
              font = "Size4-Regular";
            } else if (delim === "(" || delim === "\\lparen") {
              top = "\u239B";
              repeat = "\u239C";
              bottom = "\u239D";
              font = "Size4-Regular";
            } else if (delim === ")" || delim === "\\rparen") {
              top = "\u239E";
              repeat = "\u239F";
              bottom = "\u23A0";
              font = "Size4-Regular";
            } else if (delim === "\\{" || delim === "\\lbrace") {
              top = "\u23A7";
              middle = "\u23A8";
              bottom = "\u23A9";
              repeat = "\u23AA";
              font = "Size4-Regular";
            } else if (delim === "\\}" || delim === "\\rbrace") {
              top = "\u23AB";
              middle = "\u23AC";
              bottom = "\u23AD";
              repeat = "\u23AA";
              font = "Size4-Regular";
            } else if (delim === "\\lgroup" || delim === "\u27EE") {
              top = "\u23A7";
              bottom = "\u23A9";
              repeat = "\u23AA";
              font = "Size4-Regular";
            } else if (delim === "\\rgroup" || delim === "\u27EF") {
              top = "\u23AB";
              bottom = "\u23AD";
              repeat = "\u23AA";
              font = "Size4-Regular";
            } else if (delim === "\\lmoustache" || delim === "\u23B0") {
              top = "\u23A7";
              bottom = "\u23AD";
              repeat = "\u23AA";
              font = "Size4-Regular";
            } else if (delim === "\\rmoustache" || delim === "\u23B1") {
              top = "\u23AB";
              bottom = "\u23A9";
              repeat = "\u23AA";
              font = "Size4-Regular";
            }
            var topMetrics = delimiter_getMetrics(top, font, mode);
            var topHeightTotal = topMetrics.height + topMetrics.depth;
            var repeatMetrics = delimiter_getMetrics(repeat, font, mode);
            var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
            var bottomMetrics = delimiter_getMetrics(bottom, font, mode);
            var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
            var middleHeightTotal = 0;
            var middleFactor = 1;
            if (middle !== null) {
              var middleMetrics = delimiter_getMetrics(middle, font, mode);
              middleHeightTotal = middleMetrics.height + middleMetrics.depth;
              middleFactor = 2;
            }
            var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
            var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
            var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
            var axisHeight = options.fontMetrics().axisHeight;
            if (center) {
              axisHeight *= options.sizeMultiplier;
            }
            var depth = realHeightTotal / 2 - axisHeight;
            var shiftOfExtraElement = (repeatCount + 1) * 5e-3 - repeatHeightTotal;
            var inners = [];
            inners.push(delimiter_makeInner(bottom, font, mode));
            if (middle === null) {
              for (var i = 0; i < repeatCount; i++) {
                inners.push(lap);
                inners.push(delimiter_makeInner(repeat, font, mode));
              }
            } else {
              for (var _i = 0; _i < repeatCount; _i++) {
                inners.push(lap);
                inners.push(delimiter_makeInner(repeat, font, mode));
              }
              inners.push({
                type: "kern",
                size: shiftOfExtraElement
              });
              inners.push(delimiter_makeInner(repeat, font, mode));
              inners.push(lap);
              inners.push(delimiter_makeInner(middle, font, mode));
              for (var _i2 = 0; _i2 < repeatCount; _i2++) {
                inners.push(lap);
                inners.push(delimiter_makeInner(repeat, font, mode));
              }
            }
            if ((repeat === "\u239C" || repeat === "\u239F") && repeatCount === 0) {
              var overlap = buildCommon.svgData.leftParenInner[2] / 2;
              inners.push({
                type: "kern",
                size: -overlap
              });
              var pathName = repeat === "\u239C" ? "leftParenInner" : "rightParenInner";
              var innerSpan = buildCommon.staticSvg(pathName, options);
              inners.push({
                type: "elem",
                elem: innerSpan
              });
              inners.push({
                type: "kern",
                size: -overlap
              });
            } else {
              inners.push({
                type: "kern",
                size: shiftOfExtraElement
              });
              inners.push(delimiter_makeInner(repeat, font, mode));
              inners.push(lap);
            }
            inners.push(delimiter_makeInner(top, font, mode));
            var newOptions = options.havingBaseStyle(src_Style.TEXT);
            var inner = buildCommon.makeVList({
              positionType: "bottom",
              positionData: depth,
              children: inners
            }, newOptions);
            return delimiter_styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner], newOptions), src_Style.TEXT, options, classes);
          };
          var vbPad = 80;
          var emPad = 0.08;
          var delimiter_sqrtSvg = function sqrtSvg(sqrtName, height, viewBoxHeight, extraViniculum, options) {
            var path = sqrtPath(sqrtName, extraViniculum, viewBoxHeight);
            var pathNode = new domTree_PathNode(sqrtName, path);
            var svg = new SvgNode([pathNode], {
              "width": "400em",
              "height": height + "em",
              "viewBox": "0 0 400000 " + viewBoxHeight,
              "preserveAspectRatio": "xMinYMin slice"
            });
            return buildCommon.makeSvgSpan(["hide-tail"], [svg], options);
          };
          var makeSqrtImage = function makeSqrtImage2(height, options) {
            var newOptions = options.havingBaseSizing();
            var delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
            var sizeMultiplier = newOptions.sizeMultiplier;
            var extraViniculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness);
            var span;
            var spanHeight = 0;
            var texHeight = 0;
            var viewBoxHeight = 0;
            var advanceWidth;
            if (delim.type === "small") {
              viewBoxHeight = 1e3 + 1e3 * extraViniculum + vbPad;
              if (height < 1) {
                sizeMultiplier = 1;
              } else if (height < 1.4) {
                sizeMultiplier = 0.7;
              }
              spanHeight = (1 + extraViniculum + emPad) / sizeMultiplier;
              texHeight = (1 + extraViniculum) / sizeMultiplier;
              span = delimiter_sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraViniculum, options);
              span.style.minWidth = "0.853em";
              advanceWidth = 0.833 / sizeMultiplier;
            } else if (delim.type === "large") {
              viewBoxHeight = (1e3 + vbPad) * sizeToMaxHeight[delim.size];
              texHeight = (sizeToMaxHeight[delim.size] + extraViniculum) / sizeMultiplier;
              spanHeight = (sizeToMaxHeight[delim.size] + extraViniculum + emPad) / sizeMultiplier;
              span = delimiter_sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraViniculum, options);
              span.style.minWidth = "1.02em";
              advanceWidth = 1 / sizeMultiplier;
            } else {
              spanHeight = height + extraViniculum + emPad;
              texHeight = height + extraViniculum;
              viewBoxHeight = Math.floor(1e3 * height + extraViniculum) + vbPad;
              span = delimiter_sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraViniculum, options);
              span.style.minWidth = "0.742em";
              advanceWidth = 1.056;
            }
            span.height = texHeight;
            span.style.height = spanHeight + "em";
            return {
              span,
              advanceWidth,
              ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraViniculum) * sizeMultiplier
            };
          };
          var stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"];
          var stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1"];
          var stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
          var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
          var delimiter_makeSizedDelim = function makeSizedDelim(delim, size, options, mode, classes) {
            if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
              delim = "\\langle";
            } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
              delim = "\\rangle";
            }
            if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
              return delimiter_makeLargeDelim(delim, size, false, options, mode, classes);
            } else if (utils.contains(stackAlwaysDelimiters, delim)) {
              return delimiter_makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);
            } else {
              throw new src_ParseError("Illegal delimiter: '" + delim + "'");
            }
          };
          var stackNeverDelimiterSequence = [{
            type: "small",
            style: src_Style.SCRIPTSCRIPT
          }, {
            type: "small",
            style: src_Style.SCRIPT
          }, {
            type: "small",
            style: src_Style.TEXT
          }, {
            type: "large",
            size: 1
          }, {
            type: "large",
            size: 2
          }, {
            type: "large",
            size: 3
          }, {
            type: "large",
            size: 4
          }];
          var stackAlwaysDelimiterSequence = [{
            type: "small",
            style: src_Style.SCRIPTSCRIPT
          }, {
            type: "small",
            style: src_Style.SCRIPT
          }, {
            type: "small",
            style: src_Style.TEXT
          }, {
            type: "stack"
          }];
          var stackLargeDelimiterSequence = [{
            type: "small",
            style: src_Style.SCRIPTSCRIPT
          }, {
            type: "small",
            style: src_Style.SCRIPT
          }, {
            type: "small",
            style: src_Style.TEXT
          }, {
            type: "large",
            size: 1
          }, {
            type: "large",
            size: 2
          }, {
            type: "large",
            size: 3
          }, {
            type: "large",
            size: 4
          }, {
            type: "stack"
          }];
          var delimTypeToFont = function delimTypeToFont2(type) {
            if (type.type === "small") {
              return "Main-Regular";
            } else if (type.type === "large") {
              return "Size" + type.size + "-Regular";
            } else if (type.type === "stack") {
              return "Size4-Regular";
            } else {
              throw new Error("Add support for delim type '" + type.type + "' here.");
            }
          };
          var traverseSequence = function traverseSequence2(delim, height, sequence, options) {
            var start = Math.min(2, 3 - options.style.size);
            for (var i = start; i < sequence.length; i++) {
              if (sequence[i].type === "stack") {
                break;
              }
              var metrics = delimiter_getMetrics(delim, delimTypeToFont(sequence[i]), "math");
              var heightDepth = metrics.height + metrics.depth;
              if (sequence[i].type === "small") {
                var newOptions = options.havingBaseStyle(sequence[i].style);
                heightDepth *= newOptions.sizeMultiplier;
              }
              if (heightDepth > height) {
                return sequence[i];
              }
            }
            return sequence[sequence.length - 1];
          };
          var delimiter_makeCustomSizedDelim = function makeCustomSizedDelim(delim, height, center, options, mode, classes) {
            if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
              delim = "\\langle";
            } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
              delim = "\\rangle";
            }
            var sequence;
            if (utils.contains(stackNeverDelimiters, delim)) {
              sequence = stackNeverDelimiterSequence;
            } else if (utils.contains(stackLargeDelimiters, delim)) {
              sequence = stackLargeDelimiterSequence;
            } else {
              sequence = stackAlwaysDelimiterSequence;
            }
            var delimType = traverseSequence(delim, height, sequence, options);
            if (delimType.type === "small") {
              return delimiter_makeSmallDelim(delim, delimType.style, center, options, mode, classes);
            } else if (delimType.type === "large") {
              return delimiter_makeLargeDelim(delim, delimType.size, center, options, mode, classes);
            } else {
              return delimiter_makeStackedDelim(delim, height, center, options, mode, classes);
            }
          };
          var makeLeftRightDelim = function makeLeftRightDelim2(delim, height, depth, options, mode, classes) {
            var axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier;
            var delimiterFactor = 901;
            var delimiterExtend = 5 / options.fontMetrics().ptPerEm;
            var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
            var totalHeight = Math.max(
              maxDistFromAxis / 500 * delimiterFactor,
              2 * maxDistFromAxis - delimiterExtend
            );
            return delimiter_makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);
          };
          var delimiter2 = {
            sqrtImage: makeSqrtImage,
            sizedDelim: delimiter_makeSizedDelim,
            customSizedDelim: delimiter_makeCustomSizedDelim,
            leftRightDelim: makeLeftRightDelim
          };
          var delimiterSizes = {
            "\\bigl": {
              mclass: "mopen",
              size: 1
            },
            "\\Bigl": {
              mclass: "mopen",
              size: 2
            },
            "\\biggl": {
              mclass: "mopen",
              size: 3
            },
            "\\Biggl": {
              mclass: "mopen",
              size: 4
            },
            "\\bigr": {
              mclass: "mclose",
              size: 1
            },
            "\\Bigr": {
              mclass: "mclose",
              size: 2
            },
            "\\biggr": {
              mclass: "mclose",
              size: 3
            },
            "\\Biggr": {
              mclass: "mclose",
              size: 4
            },
            "\\bigm": {
              mclass: "mrel",
              size: 1
            },
            "\\Bigm": {
              mclass: "mrel",
              size: 2
            },
            "\\biggm": {
              mclass: "mrel",
              size: 3
            },
            "\\Biggm": {
              mclass: "mrel",
              size: 4
            },
            "\\big": {
              mclass: "mord",
              size: 1
            },
            "\\Big": {
              mclass: "mord",
              size: 2
            },
            "\\bigg": {
              mclass: "mord",
              size: 3
            },
            "\\Bigg": {
              mclass: "mord",
              size: 4
            }
          };
          var delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27E8", "\\rangle", "\u27E9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
          function checkDelimiter(delim, context) {
            var symDelim = checkSymbolNodeType(delim);
            if (symDelim && utils.contains(delimiters, symDelim.text)) {
              return symDelim;
            } else if (symDelim) {
              throw new src_ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
            } else {
              throw new src_ParseError("Invalid delimiter type '" + delim.type + "'", delim);
            }
          }
          defineFunction({
            type: "delimsizing",
            names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
            props: {
              numArgs: 1
            },
            handler: function handler(context, args) {
              var delim = checkDelimiter(args[0], context);
              return {
                type: "delimsizing",
                mode: context.parser.mode,
                size: delimiterSizes[context.funcName].size,
                mclass: delimiterSizes[context.funcName].mclass,
                delim: delim.text
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              if (group.delim === ".") {
                return buildCommon.makeSpan([group.mclass]);
              }
              return delimiter2.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
            },
            mathmlBuilder: function mathmlBuilder(group) {
              var children2 = [];
              if (group.delim !== ".") {
                children2.push(buildMathML_makeText(group.delim, group.mode));
              }
              var node = new mathMLTree.MathNode("mo", children2);
              if (group.mclass === "mopen" || group.mclass === "mclose") {
                node.setAttribute("fence", "true");
              } else {
                node.setAttribute("fence", "false");
              }
              return node;
            }
          });
          function assertParsed(group) {
            if (!group.body) {
              throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
            }
          }
          defineFunction({
            type: "leftright-right",
            names: ["\\right"],
            props: {
              numArgs: 1
            },
            handler: function handler(context, args) {
              var color = context.parser.gullet.macros.get("\\current@color");
              if (color && typeof color !== "string") {
                throw new src_ParseError("\\current@color set to non-string in \\right");
              }
              return {
                type: "leftright-right",
                mode: context.parser.mode,
                delim: checkDelimiter(args[0], context).text,
                color
              };
            }
          });
          defineFunction({
            type: "leftright",
            names: ["\\left"],
            props: {
              numArgs: 1
            },
            handler: function handler(context, args) {
              var delim = checkDelimiter(args[0], context);
              var parser = context.parser;
              ++parser.leftrightDepth;
              var body = parser.parseExpression(false);
              --parser.leftrightDepth;
              parser.expect("\\right", false);
              var right = assertNodeType(parser.parseFunction(), "leftright-right");
              return {
                type: "leftright",
                mode: parser.mode,
                body,
                left: delim.text,
                right: right.delim,
                rightColor: right.color
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              assertParsed(group);
              var inner = buildHTML_buildExpression(group.body, options, true, ["mopen", "mclose"]);
              var innerHeight = 0;
              var innerDepth = 0;
              var hadMiddle = false;
              for (var i = 0; i < inner.length; i++) {
                if (inner[i].isMiddle) {
                  hadMiddle = true;
                } else {
                  innerHeight = Math.max(inner[i].height, innerHeight);
                  innerDepth = Math.max(inner[i].depth, innerDepth);
                }
              }
              innerHeight *= options.sizeMultiplier;
              innerDepth *= options.sizeMultiplier;
              var leftDelim;
              if (group.left === ".") {
                leftDelim = makeNullDelimiter(options, ["mopen"]);
              } else {
                leftDelim = delimiter2.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
              }
              inner.unshift(leftDelim);
              if (hadMiddle) {
                for (var _i = 1; _i < inner.length; _i++) {
                  var middleDelim = inner[_i];
                  var isMiddle = middleDelim.isMiddle;
                  if (isMiddle) {
                    inner[_i] = delimiter2.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
                  }
                }
              }
              var rightDelim;
              if (group.right === ".") {
                rightDelim = makeNullDelimiter(options, ["mclose"]);
              } else {
                var colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;
                rightDelim = delimiter2.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
              }
              inner.push(rightDelim);
              return buildCommon.makeSpan(["minner"], inner, options);
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              assertParsed(group);
              var inner = buildMathML_buildExpression(group.body, options);
              if (group.left !== ".") {
                var leftNode = new mathMLTree.MathNode("mo", [buildMathML_makeText(group.left, group.mode)]);
                leftNode.setAttribute("fence", "true");
                inner.unshift(leftNode);
              }
              if (group.right !== ".") {
                var rightNode = new mathMLTree.MathNode("mo", [buildMathML_makeText(group.right, group.mode)]);
                rightNode.setAttribute("fence", "true");
                if (group.rightColor) {
                  rightNode.setAttribute("mathcolor", group.rightColor);
                }
                inner.push(rightNode);
              }
              return buildMathML_makeRow(inner);
            }
          });
          defineFunction({
            type: "middle",
            names: ["\\middle"],
            props: {
              numArgs: 1
            },
            handler: function handler(context, args) {
              var delim = checkDelimiter(args[0], context);
              if (!context.parser.leftrightDepth) {
                throw new src_ParseError("\\middle without preceding \\left", delim);
              }
              return {
                type: "middle",
                mode: context.parser.mode,
                delim: delim.text
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              var middleDelim;
              if (group.delim === ".") {
                middleDelim = makeNullDelimiter(options, []);
              } else {
                middleDelim = delimiter2.sizedDelim(group.delim, 1, options, group.mode, []);
                var isMiddle = {
                  delim: group.delim,
                  options
                };
                middleDelim.isMiddle = isMiddle;
              }
              return middleDelim;
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var textNode = group.delim === "\\vert" || group.delim === "|" ? buildMathML_makeText("|", "text") : buildMathML_makeText(group.delim, group.mode);
              var middleNode = new mathMLTree.MathNode("mo", [textNode]);
              middleNode.setAttribute("fence", "true");
              middleNode.setAttribute("lspace", "0.05em");
              middleNode.setAttribute("rspace", "0.05em");
              return middleNode;
            }
          });
          var enclose_htmlBuilder = function htmlBuilder(group, options) {
            var inner = buildCommon.wrapFragment(buildHTML_buildGroup(group.body, options), options);
            var label = group.label.substr(1);
            var scale = options.sizeMultiplier;
            var img;
            var imgShift = 0;
            var isSingleChar = utils.isCharacterBox(group.body);
            if (label === "sout") {
              img = buildCommon.makeSpan(["stretchy", "sout"]);
              img.height = options.fontMetrics().defaultRuleThickness / scale;
              imgShift = -0.5 * options.fontMetrics().xHeight;
            } else {
              if (/cancel/.test(label)) {
                if (!isSingleChar) {
                  inner.classes.push("cancel-pad");
                }
              } else {
                inner.classes.push("boxpad");
              }
              var vertPad = 0;
              var ruleThickness = 0;
              if (/box/.test(label)) {
                ruleThickness = Math.max(
                  options.fontMetrics().fboxrule,
                  options.minRuleThickness
                );
                vertPad = options.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
              } else {
                vertPad = isSingleChar ? 0.2 : 0;
              }
              img = stretchy.encloseSpan(inner, label, vertPad, options);
              if (/fbox|boxed|fcolorbox/.test(label)) {
                img.style.borderStyle = "solid";
                img.style.borderWidth = ruleThickness + "em";
              }
              imgShift = inner.depth + vertPad;
              if (group.backgroundColor) {
                img.style.backgroundColor = group.backgroundColor;
                if (group.borderColor) {
                  img.style.borderColor = group.borderColor;
                }
              }
            }
            var vlist;
            if (group.backgroundColor) {
              vlist = buildCommon.makeVList({
                positionType: "individualShift",
                children: [
                  {
                    type: "elem",
                    elem: img,
                    shift: imgShift
                  },
                  {
                    type: "elem",
                    elem: inner,
                    shift: 0
                  }
                ]
              }, options);
            } else {
              vlist = buildCommon.makeVList({
                positionType: "individualShift",
                children: [
                  {
                    type: "elem",
                    elem: inner,
                    shift: 0
                  },
                  {
                    type: "elem",
                    elem: img,
                    shift: imgShift,
                    wrapperClasses: /cancel/.test(label) ? ["svg-align"] : []
                  }
                ]
              }, options);
            }
            if (/cancel/.test(label)) {
              vlist.height = inner.height;
              vlist.depth = inner.depth;
            }
            if (/cancel/.test(label) && !isSingleChar) {
              return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
            } else {
              return buildCommon.makeSpan(["mord"], [vlist], options);
            }
          };
          var enclose_mathmlBuilder = function mathmlBuilder(group, options) {
            var fboxsep = 0;
            var node = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildMathML_buildGroup(group.body, options)]);
            switch (group.label) {
              case "\\cancel":
                node.setAttribute("notation", "updiagonalstrike");
                break;
              case "\\bcancel":
                node.setAttribute("notation", "downdiagonalstrike");
                break;
              case "\\sout":
                node.setAttribute("notation", "horizontalstrike");
                break;
              case "\\fbox":
                node.setAttribute("notation", "box");
                break;
              case "\\fcolorbox":
              case "\\colorbox":
                fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
                node.setAttribute("width", "+" + 2 * fboxsep + "pt");
                node.setAttribute("height", "+" + 2 * fboxsep + "pt");
                node.setAttribute("lspace", fboxsep + "pt");
                node.setAttribute("voffset", fboxsep + "pt");
                if (group.label === "\\fcolorbox") {
                  var thk = Math.max(
                    options.fontMetrics().fboxrule,
                    options.minRuleThickness
                  );
                  node.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
                }
                break;
              case "\\xcancel":
                node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
                break;
            }
            if (group.backgroundColor) {
              node.setAttribute("mathbackground", group.backgroundColor);
            }
            return node;
          };
          defineFunction({
            type: "enclose",
            names: ["\\colorbox"],
            props: {
              numArgs: 2,
              allowedInText: true,
              greediness: 3,
              argTypes: ["color", "text"]
            },
            handler: function handler(_ref, args, optArgs) {
              var parser = _ref.parser, funcName = _ref.funcName;
              var color = assertNodeType(args[0], "color-token").color;
              var body = args[1];
              return {
                type: "enclose",
                mode: parser.mode,
                label: funcName,
                backgroundColor: color,
                body
              };
            },
            htmlBuilder: enclose_htmlBuilder,
            mathmlBuilder: enclose_mathmlBuilder
          });
          defineFunction({
            type: "enclose",
            names: ["\\fcolorbox"],
            props: {
              numArgs: 3,
              allowedInText: true,
              greediness: 3,
              argTypes: ["color", "color", "text"]
            },
            handler: function handler(_ref2, args, optArgs) {
              var parser = _ref2.parser, funcName = _ref2.funcName;
              var borderColor = assertNodeType(args[0], "color-token").color;
              var backgroundColor = assertNodeType(args[1], "color-token").color;
              var body = args[2];
              return {
                type: "enclose",
                mode: parser.mode,
                label: funcName,
                backgroundColor,
                borderColor,
                body
              };
            },
            htmlBuilder: enclose_htmlBuilder,
            mathmlBuilder: enclose_mathmlBuilder
          });
          defineFunction({
            type: "enclose",
            names: ["\\fbox"],
            props: {
              numArgs: 1,
              argTypes: ["hbox"],
              allowedInText: true
            },
            handler: function handler(_ref3, args) {
              var parser = _ref3.parser;
              return {
                type: "enclose",
                mode: parser.mode,
                label: "\\fbox",
                body: args[0]
              };
            }
          });
          defineFunction({
            type: "enclose",
            names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout"],
            props: {
              numArgs: 1
            },
            handler: function handler(_ref4, args, optArgs) {
              var parser = _ref4.parser, funcName = _ref4.funcName;
              var body = args[0];
              return {
                type: "enclose",
                mode: parser.mode,
                label: funcName,
                body
              };
            },
            htmlBuilder: enclose_htmlBuilder,
            mathmlBuilder: enclose_mathmlBuilder
          });
          var _environments = {};
          function defineEnvironment(_ref) {
            var type = _ref.type, names = _ref.names, props = _ref.props, handler = _ref.handler, htmlBuilder = _ref.htmlBuilder, mathmlBuilder = _ref.mathmlBuilder;
            var data2 = {
              type,
              numArgs: props.numArgs || 0,
              greediness: 1,
              allowedInText: false,
              numOptionalArgs: 0,
              handler
            };
            for (var i = 0; i < names.length; ++i) {
              _environments[names[i]] = data2;
            }
            if (htmlBuilder) {
              _htmlGroupBuilders[type] = htmlBuilder;
            }
            if (mathmlBuilder) {
              _mathmlGroupBuilders[type] = mathmlBuilder;
            }
          }
          function getHLines(parser) {
            var hlineInfo = [];
            parser.consumeSpaces();
            var nxt = parser.fetch().text;
            while (nxt === "\\hline" || nxt === "\\hdashline") {
              parser.consume();
              hlineInfo.push(nxt === "\\hdashline");
              parser.consumeSpaces();
              nxt = parser.fetch().text;
            }
            return hlineInfo;
          }
          function parseArray(parser, _ref, style) {
            var hskipBeforeAndAfter = _ref.hskipBeforeAndAfter, addJot = _ref.addJot, cols = _ref.cols, arraystretch = _ref.arraystretch, colSeparationType = _ref.colSeparationType;
            parser.gullet.beginGroup();
            parser.gullet.macros.set("\\\\", "\\cr");
            if (!arraystretch) {
              var stretch = parser.gullet.expandMacroAsText("\\arraystretch");
              if (stretch == null) {
                arraystretch = 1;
              } else {
                arraystretch = parseFloat(stretch);
                if (!arraystretch || arraystretch < 0) {
                  throw new src_ParseError("Invalid \\arraystretch: " + stretch);
                }
              }
            }
            parser.gullet.beginGroup();
            var row = [];
            var body = [row];
            var rowGaps = [];
            var hLinesBeforeRow = [];
            hLinesBeforeRow.push(getHLines(parser));
            while (true) {
              var cell = parser.parseExpression(false, "\\cr");
              parser.gullet.endGroup();
              parser.gullet.beginGroup();
              cell = {
                type: "ordgroup",
                mode: parser.mode,
                body: cell
              };
              if (style) {
                cell = {
                  type: "styling",
                  mode: parser.mode,
                  style,
                  body: [cell]
                };
              }
              row.push(cell);
              var next2 = parser.fetch().text;
              if (next2 === "&") {
                parser.consume();
              } else if (next2 === "\\end") {
                if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0) {
                  body.pop();
                }
                if (hLinesBeforeRow.length < body.length + 1) {
                  hLinesBeforeRow.push([]);
                }
                break;
              } else if (next2 === "\\cr") {
                var cr = assertNodeType(parser.parseFunction(), "cr");
                rowGaps.push(cr.size);
                hLinesBeforeRow.push(getHLines(parser));
                row = [];
                body.push(row);
              } else {
                throw new src_ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
              }
            }
            parser.gullet.endGroup();
            parser.gullet.endGroup();
            return {
              type: "array",
              mode: parser.mode,
              addJot,
              arraystretch,
              body,
              cols,
              rowGaps,
              hskipBeforeAndAfter,
              hLinesBeforeRow,
              colSeparationType
            };
          }
          function dCellStyle(envName) {
            if (envName.substr(0, 1) === "d") {
              return "display";
            } else {
              return "text";
            }
          }
          var array_htmlBuilder = function htmlBuilder(group, options) {
            var r;
            var c;
            var nr = group.body.length;
            var hLinesBeforeRow = group.hLinesBeforeRow;
            var nc = 0;
            var body = new Array(nr);
            var hlines = [];
            var ruleThickness = Math.max(
              options.fontMetrics().arrayRuleWidth,
              options.minRuleThickness
            );
            var pt = 1 / options.fontMetrics().ptPerEm;
            var arraycolsep = 5 * pt;
            if (group.colSeparationType && group.colSeparationType === "small") {
              var localMultiplier = options.havingStyle(src_Style.SCRIPT).sizeMultiplier;
              arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);
            }
            var baselineskip = 12 * pt;
            var jot = 3 * pt;
            var arrayskip = group.arraystretch * baselineskip;
            var arstrutHeight = 0.7 * arrayskip;
            var arstrutDepth = 0.3 * arrayskip;
            var totalHeight = 0;
            function setHLinePos(hlinesInGap) {
              for (var i = 0; i < hlinesInGap.length; ++i) {
                if (i > 0) {
                  totalHeight += 0.25;
                }
                hlines.push({
                  pos: totalHeight,
                  isDashed: hlinesInGap[i]
                });
              }
            }
            setHLinePos(hLinesBeforeRow[0]);
            for (r = 0; r < group.body.length; ++r) {
              var inrow = group.body[r];
              var height = arstrutHeight;
              var depth = arstrutDepth;
              if (nc < inrow.length) {
                nc = inrow.length;
              }
              var outrow = new Array(inrow.length);
              for (c = 0; c < inrow.length; ++c) {
                var elt = buildHTML_buildGroup(inrow[c], options);
                if (depth < elt.depth) {
                  depth = elt.depth;
                }
                if (height < elt.height) {
                  height = elt.height;
                }
                outrow[c] = elt;
              }
              var rowGap = group.rowGaps[r];
              var gap = 0;
              if (rowGap) {
                gap = units_calculateSize(rowGap, options);
                if (gap > 0) {
                  gap += arstrutDepth;
                  if (depth < gap) {
                    depth = gap;
                  }
                  gap = 0;
                }
              }
              if (group.addJot) {
                depth += jot;
              }
              outrow.height = height;
              outrow.depth = depth;
              totalHeight += height;
              outrow.pos = totalHeight;
              totalHeight += depth + gap;
              body[r] = outrow;
              setHLinePos(hLinesBeforeRow[r + 1]);
            }
            var offset = totalHeight / 2 + options.fontMetrics().axisHeight;
            var colDescriptions = group.cols || [];
            var cols = [];
            var colSep;
            var colDescrNum;
            for (c = 0, colDescrNum = 0; c < nc || colDescrNum < colDescriptions.length; ++c, ++colDescrNum) {
              var colDescr = colDescriptions[colDescrNum] || {};
              var firstSeparator = true;
              while (colDescr.type === "separator") {
                if (!firstSeparator) {
                  colSep = buildCommon.makeSpan(["arraycolsep"], []);
                  colSep.style.width = options.fontMetrics().doubleRuleSep + "em";
                  cols.push(colSep);
                }
                if (colDescr.separator === "|" || colDescr.separator === ":") {
                  var lineType = colDescr.separator === "|" ? "solid" : "dashed";
                  var separator = buildCommon.makeSpan(["vertical-separator"], [], options);
                  separator.style.height = totalHeight + "em";
                  separator.style.borderRightWidth = ruleThickness + "em";
                  separator.style.borderRightStyle = lineType;
                  separator.style.margin = "0 -" + ruleThickness / 2 + "em";
                  separator.style.verticalAlign = -(totalHeight - offset) + "em";
                  cols.push(separator);
                } else {
                  throw new src_ParseError("Invalid separator type: " + colDescr.separator);
                }
                colDescrNum++;
                colDescr = colDescriptions[colDescrNum] || {};
                firstSeparator = false;
              }
              if (c >= nc) {
                continue;
              }
              var sepwidth = void 0;
              if (c > 0 || group.hskipBeforeAndAfter) {
                sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
                if (sepwidth !== 0) {
                  colSep = buildCommon.makeSpan(["arraycolsep"], []);
                  colSep.style.width = sepwidth + "em";
                  cols.push(colSep);
                }
              }
              var col = [];
              for (r = 0; r < nr; ++r) {
                var row = body[r];
                var elem = row[c];
                if (!elem) {
                  continue;
                }
                var shift = row.pos - offset;
                elem.depth = row.depth;
                elem.height = row.height;
                col.push({
                  type: "elem",
                  elem,
                  shift
                });
              }
              col = buildCommon.makeVList({
                positionType: "individualShift",
                children: col
              }, options);
              col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
              cols.push(col);
              if (c < nc - 1 || group.hskipBeforeAndAfter) {
                sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
                if (sepwidth !== 0) {
                  colSep = buildCommon.makeSpan(["arraycolsep"], []);
                  colSep.style.width = sepwidth + "em";
                  cols.push(colSep);
                }
              }
            }
            body = buildCommon.makeSpan(["mtable"], cols);
            if (hlines.length > 0) {
              var line = buildCommon.makeLineSpan("hline", options, ruleThickness);
              var dashes = buildCommon.makeLineSpan("hdashline", options, ruleThickness);
              var vListElems = [{
                type: "elem",
                elem: body,
                shift: 0
              }];
              while (hlines.length > 0) {
                var hline = hlines.pop();
                var lineShift = hline.pos - offset;
                if (hline.isDashed) {
                  vListElems.push({
                    type: "elem",
                    elem: dashes,
                    shift: lineShift
                  });
                } else {
                  vListElems.push({
                    type: "elem",
                    elem: line,
                    shift: lineShift
                  });
                }
              }
              body = buildCommon.makeVList({
                positionType: "individualShift",
                children: vListElems
              }, options);
            }
            return buildCommon.makeSpan(["mord"], [body], options);
          };
          var alignMap = {
            c: "center ",
            l: "left ",
            r: "right "
          };
          var array_mathmlBuilder = function mathmlBuilder(group, options) {
            var table2 = new mathMLTree.MathNode("mtable", group.body.map(function(row) {
              return new mathMLTree.MathNode("mtr", row.map(function(cell) {
                return new mathMLTree.MathNode("mtd", [buildMathML_buildGroup(cell, options)]);
              }));
            }));
            var gap = group.arraystretch === 0.5 ? 0.1 : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
            table2.setAttribute("rowspacing", gap + "em");
            var menclose = "";
            var align = "";
            if (group.cols && group.cols.length > 0) {
              var cols = group.cols;
              var columnLines = "";
              var prevTypeWasAlign = false;
              var iStart = 0;
              var iEnd = cols.length;
              if (cols[0].type === "separator") {
                menclose += "top ";
                iStart = 1;
              }
              if (cols[cols.length - 1].type === "separator") {
                menclose += "bottom ";
                iEnd -= 1;
              }
              for (var i = iStart; i < iEnd; i++) {
                if (cols[i].type === "align") {
                  align += alignMap[cols[i].align];
                  if (prevTypeWasAlign) {
                    columnLines += "none ";
                  }
                  prevTypeWasAlign = true;
                } else if (cols[i].type === "separator") {
                  if (prevTypeWasAlign) {
                    columnLines += cols[i].separator === "|" ? "solid " : "dashed ";
                    prevTypeWasAlign = false;
                  }
                }
              }
              table2.setAttribute("columnalign", align.trim());
              if (/[sd]/.test(columnLines)) {
                table2.setAttribute("columnlines", columnLines.trim());
              }
            }
            if (group.colSeparationType === "align") {
              var _cols = group.cols || [];
              var spacing = "";
              for (var _i = 1; _i < _cols.length; _i++) {
                spacing += _i % 2 ? "0em " : "1em ";
              }
              table2.setAttribute("columnspacing", spacing.trim());
            } else if (group.colSeparationType === "alignat") {
              table2.setAttribute("columnspacing", "0em");
            } else if (group.colSeparationType === "small") {
              table2.setAttribute("columnspacing", "0.2778em");
            } else {
              table2.setAttribute("columnspacing", "1em");
            }
            var rowLines = "";
            var hlines = group.hLinesBeforeRow;
            menclose += hlines[0].length > 0 ? "left " : "";
            menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
            for (var _i2 = 1; _i2 < hlines.length - 1; _i2++) {
              rowLines += hlines[_i2].length === 0 ? "none " : hlines[_i2][0] ? "dashed " : "solid ";
            }
            if (/[sd]/.test(rowLines)) {
              table2.setAttribute("rowlines", rowLines.trim());
            }
            if (menclose !== "") {
              table2 = new mathMLTree.MathNode("menclose", [table2]);
              table2.setAttribute("notation", menclose.trim());
            }
            if (group.arraystretch && group.arraystretch < 1) {
              table2 = new mathMLTree.MathNode("mstyle", [table2]);
              table2.setAttribute("scriptlevel", "1");
            }
            return table2;
          };
          var array_alignedHandler = function alignedHandler(context, args) {
            var cols = [];
            var res = parseArray(context.parser, {
              cols,
              addJot: true
            }, "display");
            var numMaths;
            var numCols = 0;
            var emptyGroup = {
              type: "ordgroup",
              mode: context.mode,
              body: []
            };
            if (args[0] && args[0].type === "ordgroup") {
              var arg0 = "";
              for (var i = 0; i < args[0].body.length; i++) {
                var textord = assertNodeType(args[0].body[i], "textord");
                arg0 += textord.text;
              }
              numMaths = Number(arg0);
              numCols = numMaths * 2;
            }
            var isAligned = !numCols;
            res.body.forEach(function(row) {
              for (var _i3 = 1; _i3 < row.length; _i3 += 2) {
                var styling = assertNodeType(row[_i3], "styling");
                var ordgroup = assertNodeType(styling.body[0], "ordgroup");
                ordgroup.body.unshift(emptyGroup);
              }
              if (!isAligned) {
                var curMaths = row.length / 2;
                if (numMaths < curMaths) {
                  throw new src_ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
                }
              } else if (numCols < row.length) {
                numCols = row.length;
              }
            });
            for (var _i4 = 0; _i4 < numCols; ++_i4) {
              var align = "r";
              var pregap = 0;
              if (_i4 % 2 === 1) {
                align = "l";
              } else if (_i4 > 0 && isAligned) {
                pregap = 1;
              }
              cols[_i4] = {
                type: "align",
                align,
                pregap,
                postgap: 0
              };
            }
            res.colSeparationType = isAligned ? "align" : "alignat";
            return res;
          };
          defineEnvironment({
            type: "array",
            names: ["array", "darray"],
            props: {
              numArgs: 1
            },
            handler: function handler(context, args) {
              var symNode = checkSymbolNodeType(args[0]);
              var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
              var cols = colalign.map(function(nde) {
                var node = assertSymbolNodeType(nde);
                var ca = node.text;
                if ("lcr".indexOf(ca) !== -1) {
                  return {
                    type: "align",
                    align: ca
                  };
                } else if (ca === "|") {
                  return {
                    type: "separator",
                    separator: "|"
                  };
                } else if (ca === ":") {
                  return {
                    type: "separator",
                    separator: ":"
                  };
                }
                throw new src_ParseError("Unknown column alignment: " + ca, nde);
              });
              var res = {
                cols,
                hskipBeforeAndAfter: true
              };
              return parseArray(context.parser, res, dCellStyle(context.envName));
            },
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment({
            type: "array",
            names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix"],
            props: {
              numArgs: 0
            },
            handler: function handler(context) {
              var delimiters2 = {
                "matrix": null,
                "pmatrix": ["(", ")"],
                "bmatrix": ["[", "]"],
                "Bmatrix": ["\\{", "\\}"],
                "vmatrix": ["|", "|"],
                "Vmatrix": ["\\Vert", "\\Vert"]
              }[context.envName];
              var payload = {
                hskipBeforeAndAfter: false
              };
              var res = parseArray(context.parser, payload, dCellStyle(context.envName));
              return delimiters2 ? {
                type: "leftright",
                mode: context.mode,
                body: [res],
                left: delimiters2[0],
                right: delimiters2[1],
                rightColor: void 0
              } : res;
            },
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment({
            type: "array",
            names: ["smallmatrix"],
            props: {
              numArgs: 0
            },
            handler: function handler(context) {
              var payload = {
                arraystretch: 0.5
              };
              var res = parseArray(context.parser, payload, "script");
              res.colSeparationType = "small";
              return res;
            },
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment({
            type: "array",
            names: ["subarray"],
            props: {
              numArgs: 1
            },
            handler: function handler(context, args) {
              var symNode = checkSymbolNodeType(args[0]);
              var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
              var cols = colalign.map(function(nde) {
                var node = assertSymbolNodeType(nde);
                var ca = node.text;
                if ("lc".indexOf(ca) !== -1) {
                  return {
                    type: "align",
                    align: ca
                  };
                }
                throw new src_ParseError("Unknown column alignment: " + ca, nde);
              });
              if (cols.length > 1) {
                throw new src_ParseError("{subarray} can contain only one column");
              }
              var res = {
                cols,
                hskipBeforeAndAfter: false,
                arraystretch: 0.5
              };
              res = parseArray(context.parser, res, "script");
              if (res.body.length > 0 && res.body[0].length > 1) {
                throw new src_ParseError("{subarray} can contain only one column");
              }
              return res;
            },
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment({
            type: "array",
            names: ["cases", "dcases", "rcases", "drcases"],
            props: {
              numArgs: 0
            },
            handler: function handler(context) {
              var payload = {
                arraystretch: 1.2,
                cols: [{
                  type: "align",
                  align: "l",
                  pregap: 0,
                  postgap: 1
                }, {
                  type: "align",
                  align: "l",
                  pregap: 0,
                  postgap: 0
                }]
              };
              var res = parseArray(context.parser, payload, dCellStyle(context.envName));
              return {
                type: "leftright",
                mode: context.mode,
                body: [res],
                left: context.envName.indexOf("r") > -1 ? "." : "\\{",
                right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
                rightColor: void 0
              };
            },
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment({
            type: "array",
            names: ["aligned"],
            props: {
              numArgs: 0
            },
            handler: array_alignedHandler,
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment({
            type: "array",
            names: ["gathered"],
            props: {
              numArgs: 0
            },
            handler: function handler(context) {
              var res = {
                cols: [{
                  type: "align",
                  align: "c"
                }],
                addJot: true
              };
              return parseArray(context.parser, res, "display");
            },
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment({
            type: "array",
            names: ["alignedat"],
            props: {
              numArgs: 1
            },
            handler: array_alignedHandler,
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineFunction({
            type: "text",
            names: ["\\hline", "\\hdashline"],
            props: {
              numArgs: 0,
              allowedInText: true,
              allowedInMath: true
            },
            handler: function handler(context, args) {
              throw new src_ParseError(context.funcName + " valid only within array environment");
            }
          });
          var environments = _environments;
          var src_environments = environments;
          defineFunction({
            type: "environment",
            names: ["\\begin", "\\end"],
            props: {
              numArgs: 1,
              argTypes: ["text"]
            },
            handler: function handler(_ref, args) {
              var parser = _ref.parser, funcName = _ref.funcName;
              var nameGroup = args[0];
              if (nameGroup.type !== "ordgroup") {
                throw new src_ParseError("Invalid environment name", nameGroup);
              }
              var envName = "";
              for (var i = 0; i < nameGroup.body.length; ++i) {
                envName += assertNodeType(nameGroup.body[i], "textord").text;
              }
              if (funcName === "\\begin") {
                if (!src_environments.hasOwnProperty(envName)) {
                  throw new src_ParseError("No such environment: " + envName, nameGroup);
                }
                var env = src_environments[envName];
                var _parser$parseArgument = parser.parseArguments("\\begin{" + envName + "}", env), _args = _parser$parseArgument.args, optArgs = _parser$parseArgument.optArgs;
                var context = {
                  mode: parser.mode,
                  envName,
                  parser
                };
                var result = env.handler(context, _args, optArgs);
                parser.expect("\\end", false);
                var endNameToken = parser.nextToken;
                var end2 = assertNodeType(parser.parseFunction(), "environment");
                if (end2.name !== envName) {
                  throw new src_ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end2.name + "}", endNameToken);
                }
                return result;
              }
              return {
                type: "environment",
                mode: parser.mode,
                name: envName,
                nameGroup
              };
            }
          });
          var mclass_makeSpan = buildCommon.makeSpan;
          function mclass_htmlBuilder(group, options) {
            var elements = buildHTML_buildExpression(group.body, options, true);
            return mclass_makeSpan([group.mclass], elements, options);
          }
          function mclass_mathmlBuilder(group, options) {
            var node;
            var inner = buildMathML_buildExpression(group.body, options);
            if (group.mclass === "minner") {
              return mathMLTree.newDocumentFragment(inner);
            } else if (group.mclass === "mord") {
              if (group.isCharacterBox) {
                node = inner[0];
                node.type = "mi";
              } else {
                node = new mathMLTree.MathNode("mi", inner);
              }
            } else {
              if (group.isCharacterBox) {
                node = inner[0];
                node.type = "mo";
              } else {
                node = new mathMLTree.MathNode("mo", inner);
              }
              if (group.mclass === "mbin") {
                node.attributes.lspace = "0.22em";
                node.attributes.rspace = "0.22em";
              } else if (group.mclass === "mpunct") {
                node.attributes.lspace = "0em";
                node.attributes.rspace = "0.17em";
              } else if (group.mclass === "mopen" || group.mclass === "mclose") {
                node.attributes.lspace = "0em";
                node.attributes.rspace = "0em";
              }
            }
            return node;
          }
          defineFunction({
            type: "mclass",
            names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
            props: {
              numArgs: 1
            },
            handler: function handler(_ref, args) {
              var parser = _ref.parser, funcName = _ref.funcName;
              var body = args[0];
              return {
                type: "mclass",
                mode: parser.mode,
                mclass: "m" + funcName.substr(5),
                body: ordargument(body),
                isCharacterBox: utils.isCharacterBox(body)
              };
            },
            htmlBuilder: mclass_htmlBuilder,
            mathmlBuilder: mclass_mathmlBuilder
          });
          var binrelClass = function binrelClass2(arg) {
            var atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
            if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
              return "m" + atom.family;
            } else {
              return "mord";
            }
          };
          defineFunction({
            type: "mclass",
            names: ["\\@binrel"],
            props: {
              numArgs: 2
            },
            handler: function handler(_ref2, args) {
              var parser = _ref2.parser;
              return {
                type: "mclass",
                mode: parser.mode,
                mclass: binrelClass(args[0]),
                body: [args[1]],
                isCharacterBox: utils.isCharacterBox(args[1])
              };
            }
          });
          defineFunction({
            type: "mclass",
            names: ["\\stackrel", "\\overset", "\\underset"],
            props: {
              numArgs: 2
            },
            handler: function handler(_ref3, args) {
              var parser = _ref3.parser, funcName = _ref3.funcName;
              var baseArg = args[1];
              var shiftedArg = args[0];
              var mclass;
              if (funcName !== "\\stackrel") {
                mclass = binrelClass(baseArg);
              } else {
                mclass = "mrel";
              }
              var baseOp = {
                type: "op",
                mode: baseArg.mode,
                limits: true,
                alwaysHandleSupSub: true,
                parentIsSupSub: false,
                symbol: false,
                suppressBaseShift: funcName !== "\\stackrel",
                body: ordargument(baseArg)
              };
              var supsub = {
                type: "supsub",
                mode: shiftedArg.mode,
                base: baseOp,
                sup: funcName === "\\underset" ? null : shiftedArg,
                sub: funcName === "\\underset" ? shiftedArg : null
              };
              return {
                type: "mclass",
                mode: parser.mode,
                mclass,
                body: [supsub],
                isCharacterBox: utils.isCharacterBox(supsub)
              };
            },
            htmlBuilder: mclass_htmlBuilder,
            mathmlBuilder: mclass_mathmlBuilder
          });
          var font_htmlBuilder = function htmlBuilder(group, options) {
            var font = group.font;
            var newOptions = options.withFont(font);
            return buildHTML_buildGroup(group.body, newOptions);
          };
          var font_mathmlBuilder = function mathmlBuilder(group, options) {
            var font = group.font;
            var newOptions = options.withFont(font);
            return buildMathML_buildGroup(group.body, newOptions);
          };
          var fontAliases = {
            "\\Bbb": "\\mathbb",
            "\\bold": "\\mathbf",
            "\\frak": "\\mathfrak",
            "\\bm": "\\boldsymbol"
          };
          defineFunction({
            type: "font",
            names: [
              "\\mathrm",
              "\\mathit",
              "\\mathbf",
              "\\mathnormal",
              "\\mathbb",
              "\\mathcal",
              "\\mathfrak",
              "\\mathscr",
              "\\mathsf",
              "\\mathtt",
              "\\Bbb",
              "\\bold",
              "\\frak"
            ],
            props: {
              numArgs: 1,
              greediness: 2
            },
            handler: function handler(_ref, args) {
              var parser = _ref.parser, funcName = _ref.funcName;
              var body = args[0];
              var func = funcName;
              if (func in fontAliases) {
                func = fontAliases[func];
              }
              return {
                type: "font",
                mode: parser.mode,
                font: func.slice(1),
                body
              };
            },
            htmlBuilder: font_htmlBuilder,
            mathmlBuilder: font_mathmlBuilder
          });
          defineFunction({
            type: "mclass",
            names: ["\\boldsymbol", "\\bm"],
            props: {
              numArgs: 1,
              greediness: 2
            },
            handler: function handler(_ref2, args) {
              var parser = _ref2.parser;
              var body = args[0];
              var isCharacterBox = utils.isCharacterBox(body);
              return {
                type: "mclass",
                mode: parser.mode,
                mclass: binrelClass(body),
                body: [{
                  type: "font",
                  mode: parser.mode,
                  font: "boldsymbol",
                  body
                }],
                isCharacterBox
              };
            }
          });
          defineFunction({
            type: "font",
            names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler: function handler(_ref3, args) {
              var parser = _ref3.parser, funcName = _ref3.funcName, breakOnTokenText = _ref3.breakOnTokenText;
              var mode = parser.mode;
              var body = parser.parseExpression(true, breakOnTokenText);
              var style = "math" + funcName.slice(1);
              return {
                type: "font",
                mode,
                font: style,
                body: {
                  type: "ordgroup",
                  mode: parser.mode,
                  body
                }
              };
            },
            htmlBuilder: font_htmlBuilder,
            mathmlBuilder: font_mathmlBuilder
          });
          var genfrac_adjustStyle = function adjustStyle(size, originalStyle) {
            var style = originalStyle;
            if (size === "display") {
              style = style.id >= src_Style.SCRIPT.id ? style.text() : src_Style.DISPLAY;
            } else if (size === "text" && style.size === src_Style.DISPLAY.size) {
              style = src_Style.TEXT;
            } else if (size === "script") {
              style = src_Style.SCRIPT;
            } else if (size === "scriptscript") {
              style = src_Style.SCRIPTSCRIPT;
            }
            return style;
          };
          var genfrac_htmlBuilder = function htmlBuilder(group, options) {
            var style = genfrac_adjustStyle(group.size, options.style);
            var nstyle = style.fracNum();
            var dstyle = style.fracDen();
            var newOptions;
            newOptions = options.havingStyle(nstyle);
            var numerm = buildHTML_buildGroup(group.numer, newOptions, options);
            if (group.continued) {
              var hStrut = 8.5 / options.fontMetrics().ptPerEm;
              var dStrut = 3.5 / options.fontMetrics().ptPerEm;
              numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
              numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
            }
            newOptions = options.havingStyle(dstyle);
            var denomm = buildHTML_buildGroup(group.denom, newOptions, options);
            var rule;
            var ruleWidth;
            var ruleSpacing;
            if (group.hasBarLine) {
              if (group.barSize) {
                ruleWidth = units_calculateSize(group.barSize, options);
                rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
              } else {
                rule = buildCommon.makeLineSpan("frac-line", options);
              }
              ruleWidth = rule.height;
              ruleSpacing = rule.height;
            } else {
              rule = null;
              ruleWidth = 0;
              ruleSpacing = options.fontMetrics().defaultRuleThickness;
            }
            var numShift;
            var clearance;
            var denomShift;
            if (style.size === src_Style.DISPLAY.size || group.size === "display") {
              numShift = options.fontMetrics().num1;
              if (ruleWidth > 0) {
                clearance = 3 * ruleSpacing;
              } else {
                clearance = 7 * ruleSpacing;
              }
              denomShift = options.fontMetrics().denom1;
            } else {
              if (ruleWidth > 0) {
                numShift = options.fontMetrics().num2;
                clearance = ruleSpacing;
              } else {
                numShift = options.fontMetrics().num3;
                clearance = 3 * ruleSpacing;
              }
              denomShift = options.fontMetrics().denom2;
            }
            var frac;
            if (!rule) {
              var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
              if (candidateClearance < clearance) {
                numShift += 0.5 * (clearance - candidateClearance);
                denomShift += 0.5 * (clearance - candidateClearance);
              }
              frac = buildCommon.makeVList({
                positionType: "individualShift",
                children: [{
                  type: "elem",
                  elem: denomm,
                  shift: denomShift
                }, {
                  type: "elem",
                  elem: numerm,
                  shift: -numShift
                }]
              }, options);
            } else {
              var axisHeight = options.fontMetrics().axisHeight;
              if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
                numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
              }
              if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
                denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
              }
              var midShift = -(axisHeight - 0.5 * ruleWidth);
              frac = buildCommon.makeVList({
                positionType: "individualShift",
                children: [{
                  type: "elem",
                  elem: denomm,
                  shift: denomShift
                }, {
                  type: "elem",
                  elem: rule,
                  shift: midShift
                }, {
                  type: "elem",
                  elem: numerm,
                  shift: -numShift
                }]
              }, options);
            }
            newOptions = options.havingStyle(style);
            frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
            frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier;
            var delimSize;
            if (style.size === src_Style.DISPLAY.size) {
              delimSize = options.fontMetrics().delim1;
            } else {
              delimSize = options.fontMetrics().delim2;
            }
            var leftDelim;
            var rightDelim;
            if (group.leftDelim == null) {
              leftDelim = makeNullDelimiter(options, ["mopen"]);
            } else {
              leftDelim = delimiter2.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, ["mopen"]);
            }
            if (group.continued) {
              rightDelim = buildCommon.makeSpan([]);
            } else if (group.rightDelim == null) {
              rightDelim = makeNullDelimiter(options, ["mclose"]);
            } else {
              rightDelim = delimiter2.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, ["mclose"]);
            }
            return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
          };
          var genfrac_mathmlBuilder = function mathmlBuilder(group, options) {
            var node = new mathMLTree.MathNode("mfrac", [buildMathML_buildGroup(group.numer, options), buildMathML_buildGroup(group.denom, options)]);
            if (!group.hasBarLine) {
              node.setAttribute("linethickness", "0px");
            } else if (group.barSize) {
              var ruleWidth = units_calculateSize(group.barSize, options);
              node.setAttribute("linethickness", ruleWidth + "em");
            }
            var style = genfrac_adjustStyle(group.size, options.style);
            if (style.size !== options.style.size) {
              node = new mathMLTree.MathNode("mstyle", [node]);
              var isDisplay = style.size === src_Style.DISPLAY.size ? "true" : "false";
              node.setAttribute("displaystyle", isDisplay);
              node.setAttribute("scriptlevel", "0");
            }
            if (group.leftDelim != null || group.rightDelim != null) {
              var withDelims = [];
              if (group.leftDelim != null) {
                var leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
                leftOp.setAttribute("fence", "true");
                withDelims.push(leftOp);
              }
              withDelims.push(node);
              if (group.rightDelim != null) {
                var rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
                rightOp.setAttribute("fence", "true");
                withDelims.push(rightOp);
              }
              return buildMathML_makeRow(withDelims);
            }
            return node;
          };
          defineFunction({
            type: "genfrac",
            names: [
              "\\cfrac",
              "\\dfrac",
              "\\frac",
              "\\tfrac",
              "\\dbinom",
              "\\binom",
              "\\tbinom",
              "\\\\atopfrac",
              "\\\\bracefrac",
              "\\\\brackfrac"
            ],
            props: {
              numArgs: 2,
              greediness: 2
            },
            handler: function handler(_ref, args) {
              var parser = _ref.parser, funcName = _ref.funcName;
              var numer = args[0];
              var denom = args[1];
              var hasBarLine;
              var leftDelim = null;
              var rightDelim = null;
              var size = "auto";
              switch (funcName) {
                case "\\cfrac":
                case "\\dfrac":
                case "\\frac":
                case "\\tfrac":
                  hasBarLine = true;
                  break;
                case "\\\\atopfrac":
                  hasBarLine = false;
                  break;
                case "\\dbinom":
                case "\\binom":
                case "\\tbinom":
                  hasBarLine = false;
                  leftDelim = "(";
                  rightDelim = ")";
                  break;
                case "\\\\bracefrac":
                  hasBarLine = false;
                  leftDelim = "\\{";
                  rightDelim = "\\}";
                  break;
                case "\\\\brackfrac":
                  hasBarLine = false;
                  leftDelim = "[";
                  rightDelim = "]";
                  break;
                default:
                  throw new Error("Unrecognized genfrac command");
              }
              switch (funcName) {
                case "\\cfrac":
                case "\\dfrac":
                case "\\dbinom":
                  size = "display";
                  break;
                case "\\tfrac":
                case "\\tbinom":
                  size = "text";
                  break;
              }
              return {
                type: "genfrac",
                mode: parser.mode,
                continued: funcName === "\\cfrac",
                numer,
                denom,
                hasBarLine,
                leftDelim,
                rightDelim,
                size,
                barSize: null
              };
            },
            htmlBuilder: genfrac_htmlBuilder,
            mathmlBuilder: genfrac_mathmlBuilder
          });
          defineFunction({
            type: "infix",
            names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
            props: {
              numArgs: 0,
              infix: true
            },
            handler: function handler(_ref2) {
              var parser = _ref2.parser, funcName = _ref2.funcName, token = _ref2.token;
              var replaceWith2;
              switch (funcName) {
                case "\\over":
                  replaceWith2 = "\\frac";
                  break;
                case "\\choose":
                  replaceWith2 = "\\binom";
                  break;
                case "\\atop":
                  replaceWith2 = "\\\\atopfrac";
                  break;
                case "\\brace":
                  replaceWith2 = "\\\\bracefrac";
                  break;
                case "\\brack":
                  replaceWith2 = "\\\\brackfrac";
                  break;
                default:
                  throw new Error("Unrecognized infix genfrac command");
              }
              return {
                type: "infix",
                mode: parser.mode,
                replaceWith: replaceWith2,
                token
              };
            }
          });
          var stylArray = ["display", "text", "script", "scriptscript"];
          var delimFromValue = function delimFromValue2(delimString) {
            var delim = null;
            if (delimString.length > 0) {
              delim = delimString;
              delim = delim === "." ? null : delim;
            }
            return delim;
          };
          defineFunction({
            type: "genfrac",
            names: ["\\genfrac"],
            props: {
              numArgs: 6,
              greediness: 6,
              argTypes: ["math", "math", "size", "text", "math", "math"]
            },
            handler: function handler(_ref3, args) {
              var parser = _ref3.parser;
              var numer = args[4];
              var denom = args[5];
              var leftDelim = args[0].type === "atom" && args[0].family === "open" ? delimFromValue(args[0].text) : null;
              var rightDelim = args[1].type === "atom" && args[1].family === "close" ? delimFromValue(args[1].text) : null;
              var barNode = assertNodeType(args[2], "size");
              var hasBarLine;
              var barSize = null;
              if (barNode.isBlank) {
                hasBarLine = true;
              } else {
                barSize = barNode.value;
                hasBarLine = barSize.number > 0;
              }
              var size = "auto";
              var styl = args[3];
              if (styl.type === "ordgroup") {
                if (styl.body.length > 0) {
                  var textOrd = assertNodeType(styl.body[0], "textord");
                  size = stylArray[Number(textOrd.text)];
                }
              } else {
                styl = assertNodeType(styl, "textord");
                size = stylArray[Number(styl.text)];
              }
              return {
                type: "genfrac",
                mode: parser.mode,
                numer,
                denom,
                continued: false,
                hasBarLine,
                barSize,
                leftDelim,
                rightDelim,
                size
              };
            },
            htmlBuilder: genfrac_htmlBuilder,
            mathmlBuilder: genfrac_mathmlBuilder
          });
          defineFunction({
            type: "infix",
            names: ["\\above"],
            props: {
              numArgs: 1,
              argTypes: ["size"],
              infix: true
            },
            handler: function handler(_ref4, args) {
              var parser = _ref4.parser, funcName = _ref4.funcName, token = _ref4.token;
              return {
                type: "infix",
                mode: parser.mode,
                replaceWith: "\\\\abovefrac",
                size: assertNodeType(args[0], "size").value,
                token
              };
            }
          });
          defineFunction({
            type: "genfrac",
            names: ["\\\\abovefrac"],
            props: {
              numArgs: 3,
              argTypes: ["math", "size", "math"]
            },
            handler: function handler(_ref5, args) {
              var parser = _ref5.parser, funcName = _ref5.funcName;
              var numer = args[0];
              var barSize = assert(assertNodeType(args[1], "infix").size);
              var denom = args[2];
              var hasBarLine = barSize.number > 0;
              return {
                type: "genfrac",
                mode: parser.mode,
                numer,
                denom,
                continued: false,
                hasBarLine,
                barSize,
                leftDelim: null,
                rightDelim: null,
                size: "auto"
              };
            },
            htmlBuilder: genfrac_htmlBuilder,
            mathmlBuilder: genfrac_mathmlBuilder
          });
          var horizBrace_htmlBuilder = function htmlBuilder(grp, options) {
            var style = options.style;
            var supSubGroup;
            var group;
            if (grp.type === "supsub") {
              supSubGroup = grp.sup ? buildHTML_buildGroup(grp.sup, options.havingStyle(style.sup()), options) : buildHTML_buildGroup(grp.sub, options.havingStyle(style.sub()), options);
              group = assertNodeType(grp.base, "horizBrace");
            } else {
              group = assertNodeType(grp, "horizBrace");
            }
            var body = buildHTML_buildGroup(group.base, options.havingBaseStyle(src_Style.DISPLAY));
            var braceBody = stretchy.svgSpan(group, options);
            var vlist;
            if (group.isOver) {
              vlist = buildCommon.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: body
                }, {
                  type: "kern",
                  size: 0.1
                }, {
                  type: "elem",
                  elem: braceBody
                }]
              }, options);
              vlist.children[0].children[0].children[1].classes.push("svg-align");
            } else {
              vlist = buildCommon.makeVList({
                positionType: "bottom",
                positionData: body.depth + 0.1 + braceBody.height,
                children: [{
                  type: "elem",
                  elem: braceBody
                }, {
                  type: "kern",
                  size: 0.1
                }, {
                  type: "elem",
                  elem: body
                }]
              }, options);
              vlist.children[0].children[0].children[0].classes.push("svg-align");
            }
            if (supSubGroup) {
              var vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
              if (group.isOver) {
                vlist = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: vSpan
                  }, {
                    type: "kern",
                    size: 0.2
                  }, {
                    type: "elem",
                    elem: supSubGroup
                  }]
                }, options);
              } else {
                vlist = buildCommon.makeVList({
                  positionType: "bottom",
                  positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
                  children: [{
                    type: "elem",
                    elem: supSubGroup
                  }, {
                    type: "kern",
                    size: 0.2
                  }, {
                    type: "elem",
                    elem: vSpan
                  }]
                }, options);
              }
            }
            return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
          };
          var horizBrace_mathmlBuilder = function mathmlBuilder(group, options) {
            var accentNode = stretchy.mathMLnode(group.label);
            return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildMathML_buildGroup(group.base, options), accentNode]);
          };
          defineFunction({
            type: "horizBrace",
            names: ["\\overbrace", "\\underbrace"],
            props: {
              numArgs: 1
            },
            handler: function handler(_ref, args) {
              var parser = _ref.parser, funcName = _ref.funcName;
              return {
                type: "horizBrace",
                mode: parser.mode,
                label: funcName,
                isOver: /^\\over/.test(funcName),
                base: args[0]
              };
            },
            htmlBuilder: horizBrace_htmlBuilder,
            mathmlBuilder: horizBrace_mathmlBuilder
          });
          defineFunction({
            type: "href",
            names: ["\\href"],
            props: {
              numArgs: 2,
              argTypes: ["url", "original"],
              allowedInText: true
            },
            handler: function handler(_ref, args) {
              var parser = _ref.parser;
              var body = args[1];
              var href = assertNodeType(args[0], "url").url;
              if (!parser.settings.isTrusted({
                command: "\\href",
                url: href
              })) {
                return parser.formatUnsupportedCmd("\\href");
              }
              return {
                type: "href",
                mode: parser.mode,
                href,
                body: ordargument(body)
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              var elements = buildHTML_buildExpression(group.body, options, false);
              return buildCommon.makeAnchor(group.href, [], elements, options);
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var math = buildExpressionRow(group.body, options);
              if (!(math instanceof mathMLTree_MathNode)) {
                math = new mathMLTree_MathNode("mrow", [math]);
              }
              math.setAttribute("href", group.href);
              return math;
            }
          });
          defineFunction({
            type: "href",
            names: ["\\url"],
            props: {
              numArgs: 1,
              argTypes: ["url"],
              allowedInText: true
            },
            handler: function handler(_ref2, args) {
              var parser = _ref2.parser;
              var href = assertNodeType(args[0], "url").url;
              if (!parser.settings.isTrusted({
                command: "\\url",
                url: href
              })) {
                return parser.formatUnsupportedCmd("\\url");
              }
              var chars = [];
              for (var i = 0; i < href.length; i++) {
                var c = href[i];
                if (c === "~") {
                  c = "\\textasciitilde";
                }
                chars.push({
                  type: "textord",
                  mode: "text",
                  text: c
                });
              }
              var body = {
                type: "text",
                mode: parser.mode,
                font: "\\texttt",
                body: chars
              };
              return {
                type: "href",
                mode: parser.mode,
                href,
                body: ordargument(body)
              };
            }
          });
          defineFunction({
            type: "html",
            names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
            props: {
              numArgs: 2,
              argTypes: ["raw", "original"],
              allowedInText: true
            },
            handler: function handler(_ref, args) {
              var parser = _ref.parser, funcName = _ref.funcName, token = _ref.token;
              var value = assertNodeType(args[0], "raw").string;
              var body = args[1];
              if (parser.settings.strict) {
                parser.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
              }
              var trustContext;
              var attributes2 = {};
              switch (funcName) {
                case "\\htmlClass":
                  attributes2.class = value;
                  trustContext = {
                    command: "\\htmlClass",
                    class: value
                  };
                  break;
                case "\\htmlId":
                  attributes2.id = value;
                  trustContext = {
                    command: "\\htmlId",
                    id: value
                  };
                  break;
                case "\\htmlStyle":
                  attributes2.style = value;
                  trustContext = {
                    command: "\\htmlStyle",
                    style: value
                  };
                  break;
                case "\\htmlData": {
                  var data2 = value.split(",");
                  for (var i = 0; i < data2.length; i++) {
                    var keyVal = data2[i].split("=");
                    if (keyVal.length !== 2) {
                      throw new src_ParseError("Error parsing key-value for \\htmlData");
                    }
                    attributes2["data-" + keyVal[0].trim()] = keyVal[1].trim();
                  }
                  trustContext = {
                    command: "\\htmlData",
                    attributes: attributes2
                  };
                  break;
                }
                default:
                  throw new Error("Unrecognized html command");
              }
              if (!parser.settings.isTrusted(trustContext)) {
                return parser.formatUnsupportedCmd(funcName);
              }
              return {
                type: "html",
                mode: parser.mode,
                attributes: attributes2,
                body: ordargument(body)
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              var elements = buildHTML_buildExpression(group.body, options, false);
              var classes = ["enclosing"];
              if (group.attributes.class) {
                classes.push.apply(classes, group.attributes.class.trim().split(/\s+/));
              }
              var span = buildCommon.makeSpan(classes, elements, options);
              for (var attr2 in group.attributes) {
                if (attr2 !== "class" && group.attributes.hasOwnProperty(attr2)) {
                  span.setAttribute(attr2, group.attributes[attr2]);
                }
              }
              return span;
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              return buildExpressionRow(group.body, options);
            }
          });
          defineFunction({
            type: "htmlmathml",
            names: ["\\html@mathml"],
            props: {
              numArgs: 2,
              allowedInText: true
            },
            handler: function handler(_ref, args) {
              var parser = _ref.parser;
              return {
                type: "htmlmathml",
                mode: parser.mode,
                html: ordargument(args[0]),
                mathml: ordargument(args[1])
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              var elements = buildHTML_buildExpression(group.html, options, false);
              return buildCommon.makeFragment(elements);
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              return buildExpressionRow(group.mathml, options);
            }
          });
          var includegraphics_sizeData = function sizeData(str) {
            if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
              return {
                number: +str,
                unit: "bp"
              };
            } else {
              var match2 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
              if (!match2) {
                throw new src_ParseError("Invalid size: '" + str + "' in \\includegraphics");
              }
              var data2 = {
                number: +(match2[1] + match2[2]),
                unit: match2[3]
              };
              if (!validUnit(data2)) {
                throw new src_ParseError("Invalid unit: '" + data2.unit + "' in \\includegraphics.");
              }
              return data2;
            }
          };
          defineFunction({
            type: "includegraphics",
            names: ["\\includegraphics"],
            props: {
              numArgs: 1,
              numOptionalArgs: 1,
              argTypes: ["raw", "url"],
              allowedInText: false
            },
            handler: function handler(_ref, args, optArgs) {
              var parser = _ref.parser;
              var width = {
                number: 0,
                unit: "em"
              };
              var height = {
                number: 0.9,
                unit: "em"
              };
              var totalheight = {
                number: 0,
                unit: "em"
              };
              var alt = "";
              if (optArgs[0]) {
                var attributeStr = assertNodeType(optArgs[0], "raw").string;
                var attributes2 = attributeStr.split(",");
                for (var i = 0; i < attributes2.length; i++) {
                  var keyVal = attributes2[i].split("=");
                  if (keyVal.length === 2) {
                    var str = keyVal[1].trim();
                    switch (keyVal[0].trim()) {
                      case "alt":
                        alt = str;
                        break;
                      case "width":
                        width = includegraphics_sizeData(str);
                        break;
                      case "height":
                        height = includegraphics_sizeData(str);
                        break;
                      case "totalheight":
                        totalheight = includegraphics_sizeData(str);
                        break;
                      default:
                        throw new src_ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
                    }
                  }
                }
              }
              var src = assertNodeType(args[0], "url").url;
              if (alt === "") {
                alt = src;
                alt = alt.replace(/^.*[\\/]/, "");
                alt = alt.substring(0, alt.lastIndexOf("."));
              }
              if (!parser.settings.isTrusted({
                command: "\\includegraphics",
                url: src
              })) {
                return parser.formatUnsupportedCmd("\\includegraphics");
              }
              return {
                type: "includegraphics",
                mode: parser.mode,
                alt,
                width,
                height,
                totalheight,
                src
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              var height = units_calculateSize(group.height, options);
              var depth = 0;
              if (group.totalheight.number > 0) {
                depth = units_calculateSize(group.totalheight, options) - height;
                depth = Number(depth.toFixed(2));
              }
              var width = 0;
              if (group.width.number > 0) {
                width = units_calculateSize(group.width, options);
              }
              var style = {
                height: height + depth + "em"
              };
              if (width > 0) {
                style.width = width + "em";
              }
              if (depth > 0) {
                style.verticalAlign = -depth + "em";
              }
              var node = new domTree_Img(group.src, group.alt, style);
              node.height = height;
              node.depth = depth;
              return node;
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var node = new mathMLTree.MathNode("mglyph", []);
              node.setAttribute("alt", group.alt);
              var height = units_calculateSize(group.height, options);
              var depth = 0;
              if (group.totalheight.number > 0) {
                depth = units_calculateSize(group.totalheight, options) - height;
                depth = depth.toFixed(2);
                node.setAttribute("valign", "-" + depth + "em");
              }
              node.setAttribute("height", height + depth + "em");
              if (group.width.number > 0) {
                var width = units_calculateSize(group.width, options);
                node.setAttribute("width", width + "em");
              }
              node.setAttribute("src", group.src);
              return node;
            }
          });
          defineFunction({
            type: "kern",
            names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
            props: {
              numArgs: 1,
              argTypes: ["size"],
              allowedInText: true
            },
            handler: function handler(_ref, args) {
              var parser = _ref.parser, funcName = _ref.funcName;
              var size = assertNodeType(args[0], "size");
              if (parser.settings.strict) {
                var mathFunction = funcName[1] === "m";
                var muUnit = size.value.unit === "mu";
                if (mathFunction) {
                  if (!muUnit) {
                    parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
                  }
                  if (parser.mode !== "math") {
                    parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
                  }
                } else {
                  if (muUnit) {
                    parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
                  }
                }
              }
              return {
                type: "kern",
                mode: parser.mode,
                dimension: size.value
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              return buildCommon.makeGlue(group.dimension, options);
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var dimension = units_calculateSize(group.dimension, options);
              return new mathMLTree.SpaceNode(dimension);
            }
          });
          defineFunction({
            type: "lap",
            names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: function handler(_ref, args) {
              var parser = _ref.parser, funcName = _ref.funcName;
              var body = args[0];
              return {
                type: "lap",
                mode: parser.mode,
                alignment: funcName.slice(5),
                body
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              var inner;
              if (group.alignment === "clap") {
                inner = buildCommon.makeSpan([], [buildHTML_buildGroup(group.body, options)]);
                inner = buildCommon.makeSpan(["inner"], [inner], options);
              } else {
                inner = buildCommon.makeSpan(["inner"], [buildHTML_buildGroup(group.body, options)]);
              }
              var fix = buildCommon.makeSpan(["fix"], []);
              var node = buildCommon.makeSpan([group.alignment], [inner, fix], options);
              var strut = buildCommon.makeSpan(["strut"]);
              strut.style.height = node.height + node.depth + "em";
              strut.style.verticalAlign = -node.depth + "em";
              node.children.unshift(strut);
              node = buildCommon.makeSpan(["thinbox"], [node], options);
              return buildCommon.makeSpan(["mord", "vbox"], [node], options);
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
              if (group.alignment !== "rlap") {
                var offset = group.alignment === "llap" ? "-1" : "-0.5";
                node.setAttribute("lspace", offset + "width");
              }
              node.setAttribute("width", "0px");
              return node;
            }
          });
          defineFunction({
            type: "styling",
            names: ["\\(", "$"],
            props: {
              numArgs: 0,
              allowedInText: true,
              allowedInMath: false
            },
            handler: function handler(_ref, args) {
              var funcName = _ref.funcName, parser = _ref.parser;
              var outerMode = parser.mode;
              parser.switchMode("math");
              var close = funcName === "\\(" ? "\\)" : "$";
              var body = parser.parseExpression(false, close);
              parser.expect(close);
              parser.switchMode(outerMode);
              return {
                type: "styling",
                mode: parser.mode,
                style: "text",
                body
              };
            }
          });
          defineFunction({
            type: "text",
            names: ["\\)", "\\]"],
            props: {
              numArgs: 0,
              allowedInText: true,
              allowedInMath: false
            },
            handler: function handler(context, args) {
              throw new src_ParseError("Mismatched " + context.funcName);
            }
          });
          var mathchoice_chooseMathStyle = function chooseMathStyle(group, options) {
            switch (options.style.size) {
              case src_Style.DISPLAY.size:
                return group.display;
              case src_Style.TEXT.size:
                return group.text;
              case src_Style.SCRIPT.size:
                return group.script;
              case src_Style.SCRIPTSCRIPT.size:
                return group.scriptscript;
              default:
                return group.text;
            }
          };
          defineFunction({
            type: "mathchoice",
            names: ["\\mathchoice"],
            props: {
              numArgs: 4
            },
            handler: function handler(_ref, args) {
              var parser = _ref.parser;
              return {
                type: "mathchoice",
                mode: parser.mode,
                display: ordargument(args[0]),
                text: ordargument(args[1]),
                script: ordargument(args[2]),
                scriptscript: ordargument(args[3])
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              var body = mathchoice_chooseMathStyle(group, options);
              var elements = buildHTML_buildExpression(body, options, false);
              return buildCommon.makeFragment(elements);
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var body = mathchoice_chooseMathStyle(group, options);
              return buildExpressionRow(body, options);
            }
          });
          var assembleSupSub_assembleSupSub = function assembleSupSub(base2, supGroup, subGroup, options, style, slant, baseShift) {
            base2 = buildCommon.makeSpan([], [base2]);
            var sub;
            var sup;
            if (supGroup) {
              var elem = buildHTML_buildGroup(supGroup, options.havingStyle(style.sup()), options);
              sup = {
                elem,
                kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
              };
            }
            if (subGroup) {
              var _elem = buildHTML_buildGroup(subGroup, options.havingStyle(style.sub()), options);
              sub = {
                elem: _elem,
                kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - _elem.height)
              };
            }
            var finalGroup;
            if (sup && sub) {
              var bottom = options.fontMetrics().bigOpSpacing5 + sub.elem.height + sub.elem.depth + sub.kern + base2.depth + baseShift;
              finalGroup = buildCommon.makeVList({
                positionType: "bottom",
                positionData: bottom,
                children: [{
                  type: "kern",
                  size: options.fontMetrics().bigOpSpacing5
                }, {
                  type: "elem",
                  elem: sub.elem,
                  marginLeft: -slant + "em"
                }, {
                  type: "kern",
                  size: sub.kern
                }, {
                  type: "elem",
                  elem: base2
                }, {
                  type: "kern",
                  size: sup.kern
                }, {
                  type: "elem",
                  elem: sup.elem,
                  marginLeft: slant + "em"
                }, {
                  type: "kern",
                  size: options.fontMetrics().bigOpSpacing5
                }]
              }, options);
            } else if (sub) {
              var top = base2.height - baseShift;
              finalGroup = buildCommon.makeVList({
                positionType: "top",
                positionData: top,
                children: [{
                  type: "kern",
                  size: options.fontMetrics().bigOpSpacing5
                }, {
                  type: "elem",
                  elem: sub.elem,
                  marginLeft: -slant + "em"
                }, {
                  type: "kern",
                  size: sub.kern
                }, {
                  type: "elem",
                  elem: base2
                }]
              }, options);
            } else if (sup) {
              var _bottom = base2.depth + baseShift;
              finalGroup = buildCommon.makeVList({
                positionType: "bottom",
                positionData: _bottom,
                children: [{
                  type: "elem",
                  elem: base2
                }, {
                  type: "kern",
                  size: sup.kern
                }, {
                  type: "elem",
                  elem: sup.elem,
                  marginLeft: slant + "em"
                }, {
                  type: "kern",
                  size: options.fontMetrics().bigOpSpacing5
                }]
              }, options);
            } else {
              return base2;
            }
            return buildCommon.makeSpan(["mop", "op-limits"], [finalGroup], options);
          };
          var noSuccessor = ["\\smallint"];
          var op_htmlBuilder = function htmlBuilder(grp, options) {
            var supGroup;
            var subGroup;
            var hasLimits = false;
            var group;
            if (grp.type === "supsub") {
              supGroup = grp.sup;
              subGroup = grp.sub;
              group = assertNodeType(grp.base, "op");
              hasLimits = true;
            } else {
              group = assertNodeType(grp, "op");
            }
            var style = options.style;
            var large = false;
            if (style.size === src_Style.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {
              large = true;
            }
            var base2;
            if (group.symbol) {
              var fontName = large ? "Size2-Regular" : "Size1-Regular";
              var stash = "";
              if (group.name === "\\oiint" || group.name === "\\oiiint") {
                stash = group.name.substr(1);
                group.name = stash === "oiint" ? "\\iint" : "\\iiint";
              }
              base2 = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
              if (stash.length > 0) {
                var italic = base2.italic;
                var oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
                base2 = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: base2,
                    shift: 0
                  }, {
                    type: "elem",
                    elem: oval,
                    shift: large ? 0.08 : 0
                  }]
                }, options);
                group.name = "\\" + stash;
                base2.classes.unshift("mop");
                base2.italic = italic;
              }
            } else if (group.body) {
              var inner = buildHTML_buildExpression(group.body, options, true);
              if (inner.length === 1 && inner[0] instanceof domTree_SymbolNode) {
                base2 = inner[0];
                base2.classes[0] = "mop";
              } else {
                base2 = buildCommon.makeSpan(["mop"], buildCommon.tryCombineChars(inner), options);
              }
            } else {
              var output = [];
              for (var i = 1; i < group.name.length; i++) {
                output.push(buildCommon.mathsym(group.name[i], group.mode, options));
              }
              base2 = buildCommon.makeSpan(["mop"], output, options);
            }
            var baseShift = 0;
            var slant = 0;
            if ((base2 instanceof domTree_SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
              baseShift = (base2.height - base2.depth) / 2 - options.fontMetrics().axisHeight;
              slant = base2.italic;
            }
            if (hasLimits) {
              return assembleSupSub_assembleSupSub(base2, supGroup, subGroup, options, style, slant, baseShift);
            } else {
              if (baseShift) {
                base2.style.position = "relative";
                base2.style.top = baseShift + "em";
              }
              return base2;
            }
          };
          var op_mathmlBuilder = function mathmlBuilder(group, options) {
            var node;
            if (group.symbol) {
              node = new mathMLTree_MathNode("mo", [buildMathML_makeText(group.name, group.mode)]);
              if (utils.contains(noSuccessor, group.name)) {
                node.setAttribute("largeop", "false");
              }
            } else if (group.body) {
              node = new mathMLTree_MathNode("mo", buildMathML_buildExpression(group.body, options));
            } else {
              node = new mathMLTree_MathNode("mi", [new mathMLTree_TextNode(group.name.slice(1))]);
              var operator = new mathMLTree_MathNode("mo", [buildMathML_makeText("\u2061", "text")]);
              if (group.parentIsSupSub) {
                node = new mathMLTree_MathNode("mo", [node, operator]);
              } else {
                node = newDocumentFragment([node, operator]);
              }
            }
            return node;
          };
          var singleCharBigOps = {
            "\u220F": "\\prod",
            "\u2210": "\\coprod",
            "\u2211": "\\sum",
            "\u22C0": "\\bigwedge",
            "\u22C1": "\\bigvee",
            "\u22C2": "\\bigcap",
            "\u22C3": "\\bigcup",
            "\u2A00": "\\bigodot",
            "\u2A01": "\\bigoplus",
            "\u2A02": "\\bigotimes",
            "\u2A04": "\\biguplus",
            "\u2A06": "\\bigsqcup"
          };
          defineFunction({
            type: "op",
            names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22C0", "\u22C1", "\u22C2", "\u22C3", "\u2A00", "\u2A01", "\u2A02", "\u2A04", "\u2A06"],
            props: {
              numArgs: 0
            },
            handler: function handler(_ref, args) {
              var parser = _ref.parser, funcName = _ref.funcName;
              var fName = funcName;
              if (fName.length === 1) {
                fName = singleCharBigOps[fName];
              }
              return {
                type: "op",
                mode: parser.mode,
                limits: true,
                parentIsSupSub: false,
                symbol: true,
                name: fName
              };
            },
            htmlBuilder: op_htmlBuilder,
            mathmlBuilder: op_mathmlBuilder
          });
          defineFunction({
            type: "op",
            names: ["\\mathop"],
            props: {
              numArgs: 1
            },
            handler: function handler(_ref2, args) {
              var parser = _ref2.parser;
              var body = args[0];
              return {
                type: "op",
                mode: parser.mode,
                limits: false,
                parentIsSupSub: false,
                symbol: false,
                body: ordargument(body)
              };
            },
            htmlBuilder: op_htmlBuilder,
            mathmlBuilder: op_mathmlBuilder
          });
          var singleCharIntegrals = {
            "\u222B": "\\int",
            "\u222C": "\\iint",
            "\u222D": "\\iiint",
            "\u222E": "\\oint",
            "\u222F": "\\oiint",
            "\u2230": "\\oiiint"
          };
          defineFunction({
            type: "op",
            names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
            props: {
              numArgs: 0
            },
            handler: function handler(_ref3) {
              var parser = _ref3.parser, funcName = _ref3.funcName;
              return {
                type: "op",
                mode: parser.mode,
                limits: false,
                parentIsSupSub: false,
                symbol: false,
                name: funcName
              };
            },
            htmlBuilder: op_htmlBuilder,
            mathmlBuilder: op_mathmlBuilder
          });
          defineFunction({
            type: "op",
            names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
            props: {
              numArgs: 0
            },
            handler: function handler(_ref4) {
              var parser = _ref4.parser, funcName = _ref4.funcName;
              return {
                type: "op",
                mode: parser.mode,
                limits: true,
                parentIsSupSub: false,
                symbol: false,
                name: funcName
              };
            },
            htmlBuilder: op_htmlBuilder,
            mathmlBuilder: op_mathmlBuilder
          });
          defineFunction({
            type: "op",
            names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222B", "\u222C", "\u222D", "\u222E", "\u222F", "\u2230"],
            props: {
              numArgs: 0
            },
            handler: function handler(_ref5) {
              var parser = _ref5.parser, funcName = _ref5.funcName;
              var fName = funcName;
              if (fName.length === 1) {
                fName = singleCharIntegrals[fName];
              }
              return {
                type: "op",
                mode: parser.mode,
                limits: false,
                parentIsSupSub: false,
                symbol: true,
                name: fName
              };
            },
            htmlBuilder: op_htmlBuilder,
            mathmlBuilder: op_mathmlBuilder
          });
          var operatorname_htmlBuilder = function htmlBuilder(grp, options) {
            var supGroup;
            var subGroup;
            var hasLimits = false;
            var group;
            if (grp.type === "supsub") {
              supGroup = grp.sup;
              subGroup = grp.sub;
              group = assertNodeType(grp.base, "operatorname");
              hasLimits = true;
            } else {
              group = assertNodeType(grp, "operatorname");
            }
            var base2;
            if (group.body.length > 0) {
              var body = group.body.map(function(child2) {
                var childText = child2.text;
                if (typeof childText === "string") {
                  return {
                    type: "textord",
                    mode: child2.mode,
                    text: childText
                  };
                } else {
                  return child2;
                }
              });
              var expression = buildHTML_buildExpression(body, options.withFont("mathrm"), true);
              for (var i = 0; i < expression.length; i++) {
                var child = expression[i];
                if (child instanceof domTree_SymbolNode) {
                  child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                }
              }
              base2 = buildCommon.makeSpan(["mop"], expression, options);
            } else {
              base2 = buildCommon.makeSpan(["mop"], [], options);
            }
            if (hasLimits) {
              return assembleSupSub_assembleSupSub(base2, supGroup, subGroup, options, options.style, 0, 0);
            } else {
              return base2;
            }
          };
          var operatorname_mathmlBuilder = function mathmlBuilder(group, options) {
            var expression = buildMathML_buildExpression(group.body, options.withFont("mathrm"));
            var isAllString = true;
            for (var i = 0; i < expression.length; i++) {
              var node = expression[i];
              if (node instanceof mathMLTree.SpaceNode) {
              } else if (node instanceof mathMLTree.MathNode) {
                switch (node.type) {
                  case "mi":
                  case "mn":
                  case "ms":
                  case "mspace":
                  case "mtext":
                    break;
                  case "mo": {
                    var child = node.children[0];
                    if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
                      child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                    } else {
                      isAllString = false;
                    }
                    break;
                  }
                  default:
                    isAllString = false;
                }
              } else {
                isAllString = false;
              }
            }
            if (isAllString) {
              var word = expression.map(function(node2) {
                return node2.toText();
              }).join("");
              expression = [new mathMLTree.TextNode(word)];
            }
            var identifier = new mathMLTree.MathNode("mi", expression);
            identifier.setAttribute("mathvariant", "normal");
            var operator = new mathMLTree.MathNode("mo", [buildMathML_makeText("\u2061", "text")]);
            if (group.parentIsSupSub) {
              return new mathMLTree.MathNode("mo", [identifier, operator]);
            } else {
              return mathMLTree.newDocumentFragment([identifier, operator]);
            }
          };
          defineFunction({
            type: "operatorname",
            names: ["\\operatorname", "\\operatorname*"],
            props: {
              numArgs: 1
            },
            handler: function handler(_ref, args) {
              var parser = _ref.parser, funcName = _ref.funcName;
              var body = args[0];
              return {
                type: "operatorname",
                mode: parser.mode,
                body: ordargument(body),
                alwaysHandleSupSub: funcName === "\\operatorname*",
                limits: false,
                parentIsSupSub: false
              };
            },
            htmlBuilder: operatorname_htmlBuilder,
            mathmlBuilder: operatorname_mathmlBuilder
          });
          defineFunctionBuilders({
            type: "ordgroup",
            htmlBuilder: function htmlBuilder(group, options) {
              if (group.semisimple) {
                return buildCommon.makeFragment(buildHTML_buildExpression(group.body, options, false));
              }
              return buildCommon.makeSpan(["mord"], buildHTML_buildExpression(group.body, options, true), options);
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              return buildExpressionRow(group.body, options, true);
            }
          });
          defineFunction({
            type: "overline",
            names: ["\\overline"],
            props: {
              numArgs: 1
            },
            handler: function handler(_ref, args) {
              var parser = _ref.parser;
              var body = args[0];
              return {
                type: "overline",
                mode: parser.mode,
                body
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              var innerGroup = buildHTML_buildGroup(group.body, options.havingCrampedStyle());
              var line = buildCommon.makeLineSpan("overline-line", options);
              var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
              var vlist = buildCommon.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: innerGroup
                }, {
                  type: "kern",
                  size: 3 * defaultRuleThickness
                }, {
                  type: "elem",
                  elem: line
                }, {
                  type: "kern",
                  size: defaultRuleThickness
                }]
              }, options);
              return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
              operator.setAttribute("stretchy", "true");
              var node = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.body, options), operator]);
              node.setAttribute("accent", "true");
              return node;
            }
          });
          defineFunction({
            type: "phantom",
            names: ["\\phantom"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: function handler(_ref, args) {
              var parser = _ref.parser;
              var body = args[0];
              return {
                type: "phantom",
                mode: parser.mode,
                body: ordargument(body)
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              var elements = buildHTML_buildExpression(group.body, options.withPhantom(), false);
              return buildCommon.makeFragment(elements);
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var inner = buildMathML_buildExpression(group.body, options);
              return new mathMLTree.MathNode("mphantom", inner);
            }
          });
          defineFunction({
            type: "hphantom",
            names: ["\\hphantom"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: function handler(_ref2, args) {
              var parser = _ref2.parser;
              var body = args[0];
              return {
                type: "hphantom",
                mode: parser.mode,
                body
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              var node = buildCommon.makeSpan([], [buildHTML_buildGroup(group.body, options.withPhantom())]);
              node.height = 0;
              node.depth = 0;
              if (node.children) {
                for (var i = 0; i < node.children.length; i++) {
                  node.children[i].height = 0;
                  node.children[i].depth = 0;
                }
              }
              node = buildCommon.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: node
                }]
              }, options);
              return buildCommon.makeSpan(["mord"], [node], options);
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var inner = buildMathML_buildExpression(ordargument(group.body), options);
              var phantom = new mathMLTree.MathNode("mphantom", inner);
              var node = new mathMLTree.MathNode("mpadded", [phantom]);
              node.setAttribute("height", "0px");
              node.setAttribute("depth", "0px");
              return node;
            }
          });
          defineFunction({
            type: "vphantom",
            names: ["\\vphantom"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: function handler(_ref3, args) {
              var parser = _ref3.parser;
              var body = args[0];
              return {
                type: "vphantom",
                mode: parser.mode,
                body
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              var inner = buildCommon.makeSpan(["inner"], [buildHTML_buildGroup(group.body, options.withPhantom())]);
              var fix = buildCommon.makeSpan(["fix"], []);
              return buildCommon.makeSpan(["mord", "rlap"], [inner, fix], options);
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var inner = buildMathML_buildExpression(ordargument(group.body), options);
              var phantom = new mathMLTree.MathNode("mphantom", inner);
              var node = new mathMLTree.MathNode("mpadded", [phantom]);
              node.setAttribute("width", "0px");
              return node;
            }
          });
          defineFunction({
            type: "raisebox",
            names: ["\\raisebox"],
            props: {
              numArgs: 2,
              argTypes: ["size", "hbox"],
              allowedInText: true
            },
            handler: function handler(_ref, args) {
              var parser = _ref.parser;
              var amount = assertNodeType(args[0], "size").value;
              var body = args[1];
              return {
                type: "raisebox",
                mode: parser.mode,
                dy: amount,
                body
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              var body = buildHTML_buildGroup(group.body, options);
              var dy = units_calculateSize(group.dy, options);
              return buildCommon.makeVList({
                positionType: "shift",
                positionData: -dy,
                children: [{
                  type: "elem",
                  elem: body
                }]
              }, options);
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
              var dy = group.dy.number + group.dy.unit;
              node.setAttribute("voffset", dy);
              return node;
            }
          });
          defineFunction({
            type: "rule",
            names: ["\\rule"],
            props: {
              numArgs: 2,
              numOptionalArgs: 1,
              argTypes: ["size", "size", "size"]
            },
            handler: function handler(_ref, args, optArgs) {
              var parser = _ref.parser;
              var shift = optArgs[0];
              var width = assertNodeType(args[0], "size");
              var height = assertNodeType(args[1], "size");
              return {
                type: "rule",
                mode: parser.mode,
                shift: shift && assertNodeType(shift, "size").value,
                width: width.value,
                height: height.value
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              var rule = buildCommon.makeSpan(["mord", "rule"], [], options);
              var width = units_calculateSize(group.width, options);
              var height = units_calculateSize(group.height, options);
              var shift = group.shift ? units_calculateSize(group.shift, options) : 0;
              rule.style.borderRightWidth = width + "em";
              rule.style.borderTopWidth = height + "em";
              rule.style.bottom = shift + "em";
              rule.width = width;
              rule.height = height + shift;
              rule.depth = -shift;
              rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
              return rule;
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var width = units_calculateSize(group.width, options);
              var height = units_calculateSize(group.height, options);
              var shift = group.shift ? units_calculateSize(group.shift, options) : 0;
              var color = options.color && options.getColor() || "black";
              var rule = new mathMLTree.MathNode("mspace");
              rule.setAttribute("mathbackground", color);
              rule.setAttribute("width", width + "em");
              rule.setAttribute("height", height + "em");
              var wrapper = new mathMLTree.MathNode("mpadded", [rule]);
              if (shift >= 0) {
                wrapper.setAttribute("height", "+" + shift + "em");
              } else {
                wrapper.setAttribute("height", shift + "em");
                wrapper.setAttribute("depth", "+" + -shift + "em");
              }
              wrapper.setAttribute("voffset", shift + "em");
              return wrapper;
            }
          });
          function sizingGroup(value, options, baseOptions) {
            var inner = buildHTML_buildExpression(value, options, false);
            var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
            for (var i = 0; i < inner.length; i++) {
              var pos = inner[i].classes.indexOf("sizing");
              if (pos < 0) {
                Array.prototype.push.apply(inner[i].classes, options.sizingClasses(baseOptions));
              } else if (inner[i].classes[pos + 1] === "reset-size" + options.size) {
                inner[i].classes[pos + 1] = "reset-size" + baseOptions.size;
              }
              inner[i].height *= multiplier;
              inner[i].depth *= multiplier;
            }
            return buildCommon.makeFragment(inner);
          }
          var sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
          var sizing_htmlBuilder = function htmlBuilder(group, options) {
            var newOptions = options.havingSize(group.size);
            return sizingGroup(group.body, newOptions, options);
          };
          defineFunction({
            type: "sizing",
            names: sizeFuncs,
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler: function handler(_ref, args) {
              var breakOnTokenText = _ref.breakOnTokenText, funcName = _ref.funcName, parser = _ref.parser;
              var body = parser.parseExpression(false, breakOnTokenText);
              return {
                type: "sizing",
                mode: parser.mode,
                size: sizeFuncs.indexOf(funcName) + 1,
                body
              };
            },
            htmlBuilder: sizing_htmlBuilder,
            mathmlBuilder: function mathmlBuilder(group, options) {
              var newOptions = options.havingSize(group.size);
              var inner = buildMathML_buildExpression(group.body, newOptions);
              var node = new mathMLTree.MathNode("mstyle", inner);
              node.setAttribute("mathsize", newOptions.sizeMultiplier + "em");
              return node;
            }
          });
          defineFunction({
            type: "smash",
            names: ["\\smash"],
            props: {
              numArgs: 1,
              numOptionalArgs: 1,
              allowedInText: true
            },
            handler: function handler(_ref, args, optArgs) {
              var parser = _ref.parser;
              var smashHeight = false;
              var smashDepth = false;
              var tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
              if (tbArg) {
                var letter = "";
                for (var i = 0; i < tbArg.body.length; ++i) {
                  var node = tbArg.body[i];
                  letter = node.text;
                  if (letter === "t") {
                    smashHeight = true;
                  } else if (letter === "b") {
                    smashDepth = true;
                  } else {
                    smashHeight = false;
                    smashDepth = false;
                    break;
                  }
                }
              } else {
                smashHeight = true;
                smashDepth = true;
              }
              var body = args[0];
              return {
                type: "smash",
                mode: parser.mode,
                body,
                smashHeight,
                smashDepth
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              var node = buildCommon.makeSpan([], [buildHTML_buildGroup(group.body, options)]);
              if (!group.smashHeight && !group.smashDepth) {
                return node;
              }
              if (group.smashHeight) {
                node.height = 0;
                if (node.children) {
                  for (var i = 0; i < node.children.length; i++) {
                    node.children[i].height = 0;
                  }
                }
              }
              if (group.smashDepth) {
                node.depth = 0;
                if (node.children) {
                  for (var _i = 0; _i < node.children.length; _i++) {
                    node.children[_i].depth = 0;
                  }
                }
              }
              var smashedNode = buildCommon.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: node
                }]
              }, options);
              return buildCommon.makeSpan(["mord"], [smashedNode], options);
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
              if (group.smashHeight) {
                node.setAttribute("height", "0px");
              }
              if (group.smashDepth) {
                node.setAttribute("depth", "0px");
              }
              return node;
            }
          });
          defineFunction({
            type: "sqrt",
            names: ["\\sqrt"],
            props: {
              numArgs: 1,
              numOptionalArgs: 1
            },
            handler: function handler(_ref, args, optArgs) {
              var parser = _ref.parser;
              var index2 = optArgs[0];
              var body = args[0];
              return {
                type: "sqrt",
                mode: parser.mode,
                body,
                index: index2
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              var inner = buildHTML_buildGroup(group.body, options.havingCrampedStyle());
              if (inner.height === 0) {
                inner.height = options.fontMetrics().xHeight;
              }
              inner = buildCommon.wrapFragment(inner, options);
              var metrics = options.fontMetrics();
              var theta = metrics.defaultRuleThickness;
              var phi = theta;
              if (options.style.id < src_Style.TEXT.id) {
                phi = options.fontMetrics().xHeight;
              }
              var lineClearance = theta + phi / 4;
              var minDelimiterHeight = inner.height + inner.depth + lineClearance + theta;
              var _delimiter$sqrtImage = delimiter2.sqrtImage(minDelimiterHeight, options), img = _delimiter$sqrtImage.span, ruleWidth = _delimiter$sqrtImage.ruleWidth, advanceWidth = _delimiter$sqrtImage.advanceWidth;
              var delimDepth = img.height - ruleWidth;
              if (delimDepth > inner.height + inner.depth + lineClearance) {
                lineClearance = (lineClearance + delimDepth - inner.height - inner.depth) / 2;
              }
              var imgShift = img.height - inner.height - lineClearance - ruleWidth;
              inner.style.paddingLeft = advanceWidth + "em";
              var body = buildCommon.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: inner,
                  wrapperClasses: ["svg-align"]
                }, {
                  type: "kern",
                  size: -(inner.height + imgShift)
                }, {
                  type: "elem",
                  elem: img
                }, {
                  type: "kern",
                  size: ruleWidth
                }]
              }, options);
              if (!group.index) {
                return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
              } else {
                var newOptions = options.havingStyle(src_Style.SCRIPTSCRIPT);
                var rootm = buildHTML_buildGroup(group.index, newOptions, options);
                var toShift = 0.6 * (body.height - body.depth);
                var rootVList = buildCommon.makeVList({
                  positionType: "shift",
                  positionData: -toShift,
                  children: [{
                    type: "elem",
                    elem: rootm
                  }]
                }, options);
                var rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
                return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
              }
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var body = group.body, index2 = group.index;
              return index2 ? new mathMLTree.MathNode("mroot", [buildMathML_buildGroup(body, options), buildMathML_buildGroup(index2, options)]) : new mathMLTree.MathNode("msqrt", [buildMathML_buildGroup(body, options)]);
            }
          });
          var styling_styleMap = {
            "display": src_Style.DISPLAY,
            "text": src_Style.TEXT,
            "script": src_Style.SCRIPT,
            "scriptscript": src_Style.SCRIPTSCRIPT
          };
          defineFunction({
            type: "styling",
            names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler: function handler(_ref, args) {
              var breakOnTokenText = _ref.breakOnTokenText, funcName = _ref.funcName, parser = _ref.parser;
              var body = parser.parseExpression(true, breakOnTokenText);
              var style = funcName.slice(1, funcName.length - 5);
              return {
                type: "styling",
                mode: parser.mode,
                style,
                body
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              var newStyle = styling_styleMap[group.style];
              var newOptions = options.havingStyle(newStyle).withFont("");
              return sizingGroup(group.body, newOptions, options);
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var newStyle = styling_styleMap[group.style];
              var newOptions = options.havingStyle(newStyle);
              var inner = buildMathML_buildExpression(group.body, newOptions);
              var node = new mathMLTree.MathNode("mstyle", inner);
              var styleAttributes = {
                "display": ["0", "true"],
                "text": ["0", "false"],
                "script": ["1", "false"],
                "scriptscript": ["2", "false"]
              };
              var attr2 = styleAttributes[group.style];
              node.setAttribute("scriptlevel", attr2[0]);
              node.setAttribute("displaystyle", attr2[1]);
              return node;
            }
          });
          var supsub_htmlBuilderDelegate = function htmlBuilderDelegate(group, options) {
            var base2 = group.base;
            if (!base2) {
              return null;
            } else if (base2.type === "op") {
              var delegate = base2.limits && (options.style.size === src_Style.DISPLAY.size || base2.alwaysHandleSupSub);
              return delegate ? op_htmlBuilder : null;
            } else if (base2.type === "operatorname") {
              var _delegate = base2.alwaysHandleSupSub && (options.style.size === src_Style.DISPLAY.size || base2.limits);
              return _delegate ? operatorname_htmlBuilder : null;
            } else if (base2.type === "accent") {
              return utils.isCharacterBox(base2.base) ? accent_htmlBuilder : null;
            } else if (base2.type === "horizBrace") {
              var isSup = !group.sub;
              return isSup === base2.isOver ? horizBrace_htmlBuilder : null;
            } else {
              return null;
            }
          };
          defineFunctionBuilders({
            type: "supsub",
            htmlBuilder: function htmlBuilder(group, options) {
              var builderDelegate = supsub_htmlBuilderDelegate(group, options);
              if (builderDelegate) {
                return builderDelegate(group, options);
              }
              var valueBase = group.base, valueSup = group.sup, valueSub = group.sub;
              var base2 = buildHTML_buildGroup(valueBase, options);
              var supm;
              var subm;
              var metrics = options.fontMetrics();
              var supShift = 0;
              var subShift = 0;
              var isCharacterBox = valueBase && utils.isCharacterBox(valueBase);
              if (valueSup) {
                var newOptions = options.havingStyle(options.style.sup());
                supm = buildHTML_buildGroup(valueSup, newOptions, options);
                if (!isCharacterBox) {
                  supShift = base2.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
                }
              }
              if (valueSub) {
                var _newOptions = options.havingStyle(options.style.sub());
                subm = buildHTML_buildGroup(valueSub, _newOptions, options);
                if (!isCharacterBox) {
                  subShift = base2.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options.sizeMultiplier;
                }
              }
              var minSupShift;
              if (options.style === src_Style.DISPLAY) {
                minSupShift = metrics.sup1;
              } else if (options.style.cramped) {
                minSupShift = metrics.sup3;
              } else {
                minSupShift = metrics.sup2;
              }
              var multiplier = options.sizeMultiplier;
              var marginRight = 0.5 / metrics.ptPerEm / multiplier + "em";
              var marginLeft = null;
              if (subm) {
                var isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
                if (base2 instanceof domTree_SymbolNode || isOiint) {
                  marginLeft = -base2.italic + "em";
                }
              }
              var supsub;
              if (supm && subm) {
                supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
                subShift = Math.max(subShift, metrics.sub2);
                var ruleWidth = metrics.defaultRuleThickness;
                var maxWidth = 4 * ruleWidth;
                if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
                  subShift = maxWidth - (supShift - supm.depth) + subm.height;
                  var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
                  if (psi > 0) {
                    supShift += psi;
                    subShift -= psi;
                  }
                }
                var vlistElem = [{
                  type: "elem",
                  elem: subm,
                  shift: subShift,
                  marginRight,
                  marginLeft
                }, {
                  type: "elem",
                  elem: supm,
                  shift: -supShift,
                  marginRight
                }];
                supsub = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: vlistElem
                }, options);
              } else if (subm) {
                subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
                var _vlistElem = [{
                  type: "elem",
                  elem: subm,
                  marginLeft,
                  marginRight
                }];
                supsub = buildCommon.makeVList({
                  positionType: "shift",
                  positionData: subShift,
                  children: _vlistElem
                }, options);
              } else if (supm) {
                supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
                supsub = buildCommon.makeVList({
                  positionType: "shift",
                  positionData: -supShift,
                  children: [{
                    type: "elem",
                    elem: supm,
                    marginRight
                  }]
                }, options);
              } else {
                throw new Error("supsub must have either sup or sub.");
              }
              var mclass = getTypeOfDomTree(base2, "right") || "mord";
              return buildCommon.makeSpan([mclass], [base2, buildCommon.makeSpan(["msupsub"], [supsub])], options);
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var isBrace = false;
              var isOver;
              var isSup;
              if (group.base && group.base.type === "horizBrace") {
                isSup = !!group.sup;
                if (isSup === group.base.isOver) {
                  isBrace = true;
                  isOver = group.base.isOver;
                }
              }
              if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
                group.base.parentIsSupSub = true;
              }
              var children2 = [buildMathML_buildGroup(group.base, options)];
              if (group.sub) {
                children2.push(buildMathML_buildGroup(group.sub, options));
              }
              if (group.sup) {
                children2.push(buildMathML_buildGroup(group.sup, options));
              }
              var nodeType;
              if (isBrace) {
                nodeType = isOver ? "mover" : "munder";
              } else if (!group.sub) {
                var base2 = group.base;
                if (base2 && base2.type === "op" && base2.limits && (options.style === src_Style.DISPLAY || base2.alwaysHandleSupSub)) {
                  nodeType = "mover";
                } else if (base2 && base2.type === "operatorname" && base2.alwaysHandleSupSub && (base2.limits || options.style === src_Style.DISPLAY)) {
                  nodeType = "mover";
                } else {
                  nodeType = "msup";
                }
              } else if (!group.sup) {
                var _base = group.base;
                if (_base && _base.type === "op" && _base.limits && (options.style === src_Style.DISPLAY || _base.alwaysHandleSupSub)) {
                  nodeType = "munder";
                } else if (_base && _base.type === "operatorname" && _base.alwaysHandleSupSub && (_base.limits || options.style === src_Style.DISPLAY)) {
                  nodeType = "munder";
                } else {
                  nodeType = "msub";
                }
              } else {
                var _base2 = group.base;
                if (_base2 && _base2.type === "op" && _base2.limits && options.style === src_Style.DISPLAY) {
                  nodeType = "munderover";
                } else if (_base2 && _base2.type === "operatorname" && _base2.alwaysHandleSupSub && (options.style === src_Style.DISPLAY || _base2.limits)) {
                  nodeType = "munderover";
                } else {
                  nodeType = "msubsup";
                }
              }
              var node = new mathMLTree.MathNode(nodeType, children2);
              return node;
            }
          });
          defineFunctionBuilders({
            type: "atom",
            htmlBuilder: function htmlBuilder(group, options) {
              return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var node = new mathMLTree.MathNode("mo", [buildMathML_makeText(group.text, group.mode)]);
              if (group.family === "bin") {
                var variant = buildMathML_getVariant(group, options);
                if (variant === "bold-italic") {
                  node.setAttribute("mathvariant", variant);
                }
              } else if (group.family === "punct") {
                node.setAttribute("separator", "true");
              } else if (group.family === "open" || group.family === "close") {
                node.setAttribute("stretchy", "false");
              }
              return node;
            }
          });
          var defaultVariant = {
            "mi": "italic",
            "mn": "normal",
            "mtext": "normal"
          };
          defineFunctionBuilders({
            type: "mathord",
            htmlBuilder: function htmlBuilder(group, options) {
              return buildCommon.makeOrd(group, options, "mathord");
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var node = new mathMLTree.MathNode("mi", [buildMathML_makeText(group.text, group.mode, options)]);
              var variant = buildMathML_getVariant(group, options) || "italic";
              if (variant !== defaultVariant[node.type]) {
                node.setAttribute("mathvariant", variant);
              }
              return node;
            }
          });
          defineFunctionBuilders({
            type: "textord",
            htmlBuilder: function htmlBuilder(group, options) {
              return buildCommon.makeOrd(group, options, "textord");
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var text4 = buildMathML_makeText(group.text, group.mode, options);
              var variant = buildMathML_getVariant(group, options) || "normal";
              var node;
              if (group.mode === "text") {
                node = new mathMLTree.MathNode("mtext", [text4]);
              } else if (/[0-9]/.test(group.text)) {
                node = new mathMLTree.MathNode("mn", [text4]);
              } else if (group.text === "\\prime") {
                node = new mathMLTree.MathNode("mo", [text4]);
              } else {
                node = new mathMLTree.MathNode("mi", [text4]);
              }
              if (variant !== defaultVariant[node.type]) {
                node.setAttribute("mathvariant", variant);
              }
              return node;
            }
          });
          var cssSpace = {
            "\\nobreak": "nobreak",
            "\\allowbreak": "allowbreak"
          };
          var regularSpace = {
            " ": {},
            "\\ ": {},
            "~": {
              className: "nobreak"
            },
            "\\space": {},
            "\\nobreakspace": {
              className: "nobreak"
            }
          };
          defineFunctionBuilders({
            type: "spacing",
            htmlBuilder: function htmlBuilder(group, options) {
              if (regularSpace.hasOwnProperty(group.text)) {
                var className = regularSpace[group.text].className || "";
                if (group.mode === "text") {
                  var ord = buildCommon.makeOrd(group, options, "textord");
                  ord.classes.push(className);
                  return ord;
                } else {
                  return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
                }
              } else if (cssSpace.hasOwnProperty(group.text)) {
                return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
              } else {
                throw new src_ParseError('Unknown type of space "' + group.text + '"');
              }
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var node;
              if (regularSpace.hasOwnProperty(group.text)) {
                node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\xA0")]);
              } else if (cssSpace.hasOwnProperty(group.text)) {
                return new mathMLTree.MathNode("mspace");
              } else {
                throw new src_ParseError('Unknown type of space "' + group.text + '"');
              }
              return node;
            }
          });
          var tag_pad = function pad() {
            var padNode = new mathMLTree.MathNode("mtd", []);
            padNode.setAttribute("width", "50%");
            return padNode;
          };
          defineFunctionBuilders({
            type: "tag",
            mathmlBuilder: function mathmlBuilder(group, options) {
              var table2 = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [tag_pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), tag_pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
              table2.setAttribute("width", "100%");
              return table2;
            }
          });
          var textFontFamilies = {
            "\\text": void 0,
            "\\textrm": "textrm",
            "\\textsf": "textsf",
            "\\texttt": "texttt",
            "\\textnormal": "textrm"
          };
          var textFontWeights = {
            "\\textbf": "textbf",
            "\\textmd": "textmd"
          };
          var textFontShapes = {
            "\\textit": "textit",
            "\\textup": "textup"
          };
          var optionsWithFont = function optionsWithFont2(group, options) {
            var font = group.font;
            if (!font) {
              return options;
            } else if (textFontFamilies[font]) {
              return options.withTextFontFamily(textFontFamilies[font]);
            } else if (textFontWeights[font]) {
              return options.withTextFontWeight(textFontWeights[font]);
            } else {
              return options.withTextFontShape(textFontShapes[font]);
            }
          };
          defineFunction({
            type: "text",
            names: [
              "\\text",
              "\\textrm",
              "\\textsf",
              "\\texttt",
              "\\textnormal",
              "\\textbf",
              "\\textmd",
              "\\textit",
              "\\textup"
            ],
            props: {
              numArgs: 1,
              argTypes: ["text"],
              greediness: 2,
              allowedInText: true
            },
            handler: function handler(_ref, args) {
              var parser = _ref.parser, funcName = _ref.funcName;
              var body = args[0];
              return {
                type: "text",
                mode: parser.mode,
                body: ordargument(body),
                font: funcName
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              var newOptions = optionsWithFont(group, options);
              var inner = buildHTML_buildExpression(group.body, newOptions, true);
              return buildCommon.makeSpan(["mord", "text"], buildCommon.tryCombineChars(inner), newOptions);
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var newOptions = optionsWithFont(group, options);
              return buildExpressionRow(group.body, newOptions);
            }
          });
          defineFunction({
            type: "underline",
            names: ["\\underline"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: function handler(_ref, args) {
              var parser = _ref.parser;
              return {
                type: "underline",
                mode: parser.mode,
                body: args[0]
              };
            },
            htmlBuilder: function htmlBuilder(group, options) {
              var innerGroup = buildHTML_buildGroup(group.body, options);
              var line = buildCommon.makeLineSpan("underline-line", options);
              var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
              var vlist = buildCommon.makeVList({
                positionType: "top",
                positionData: innerGroup.height,
                children: [{
                  type: "kern",
                  size: defaultRuleThickness
                }, {
                  type: "elem",
                  elem: line
                }, {
                  type: "kern",
                  size: 3 * defaultRuleThickness
                }, {
                  type: "elem",
                  elem: innerGroup
                }]
              }, options);
              return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
              operator.setAttribute("stretchy", "true");
              var node = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.body, options), operator]);
              node.setAttribute("accentunder", "true");
              return node;
            }
          });
          defineFunction({
            type: "verb",
            names: ["\\verb"],
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler: function handler(context, args, optArgs) {
              throw new src_ParseError("\\verb ended by end of line instead of matching delimiter");
            },
            htmlBuilder: function htmlBuilder(group, options) {
              var text4 = makeVerb(group);
              var body = [];
              var newOptions = options.havingStyle(options.style.text());
              for (var i = 0; i < text4.length; i++) {
                var c = text4[i];
                if (c === "~") {
                  c = "\\textasciitilde";
                }
                body.push(buildCommon.makeSymbol(c, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
              }
              return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
            },
            mathmlBuilder: function mathmlBuilder(group, options) {
              var text4 = new mathMLTree.TextNode(makeVerb(group));
              var node = new mathMLTree.MathNode("mtext", [text4]);
              node.setAttribute("mathvariant", "monospace");
              return node;
            }
          });
          var makeVerb = function makeVerb2(group) {
            return group.body.replace(/ /g, group.star ? "\u2423" : "\xA0");
          };
          var functions = _functions;
          var src_functions = functions;
          var spaceRegexString = "[ \r\n	]";
          var controlWordRegexString = "\\\\[a-zA-Z@]+";
          var controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
          var controlWordWhitespaceRegexString = "" + controlWordRegexString + spaceRegexString + "*";
          var controlWordWhitespaceRegex = new RegExp("^(" + controlWordRegexString + ")" + spaceRegexString + "*$");
          var combiningDiacriticalMarkString = "[\u0300-\u036F]";
          var combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
          var tokenRegexString = "(" + spaceRegexString + "+)|([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + (combiningDiacriticalMarkString + "*") + "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + (combiningDiacriticalMarkString + "*") + "|\\\\verb\\*([^]).*?\\3|\\\\verb([^*a-zA-Z]).*?\\4|\\\\operatorname\\*" + ("|" + controlWordWhitespaceRegexString) + ("|" + controlSymbolRegexString + ")");
          var Lexer_Lexer = /* @__PURE__ */ function() {
            function Lexer2(input, settings) {
              this.input = void 0;
              this.settings = void 0;
              this.tokenRegex = void 0;
              this.catcodes = void 0;
              this.input = input;
              this.settings = settings;
              this.tokenRegex = new RegExp(tokenRegexString, "g");
              this.catcodes = {
                "%": 14
              };
            }
            var _proto = Lexer2.prototype;
            _proto.setCatcode = function setCatcode(char, code2) {
              this.catcodes[char] = code2;
            };
            _proto.lex = function lex() {
              var input = this.input;
              var pos = this.tokenRegex.lastIndex;
              if (pos === input.length) {
                return new Token_Token("EOF", new SourceLocation(this, pos, pos));
              }
              var match2 = this.tokenRegex.exec(input);
              if (match2 === null || match2.index !== pos) {
                throw new src_ParseError("Unexpected character: '" + input[pos] + "'", new Token_Token(input[pos], new SourceLocation(this, pos, pos + 1)));
              }
              var text4 = match2[2] || " ";
              if (this.catcodes[text4] === 14) {
                var nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
                if (nlIndex === -1) {
                  this.tokenRegex.lastIndex = input.length;
                  this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)");
                } else {
                  this.tokenRegex.lastIndex = nlIndex + 1;
                }
                return this.lex();
              }
              var controlMatch = text4.match(controlWordWhitespaceRegex);
              if (controlMatch) {
                text4 = controlMatch[1];
              }
              return new Token_Token(text4, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
            };
            return Lexer2;
          }();
          var Namespace_Namespace = /* @__PURE__ */ function() {
            function Namespace(builtins, globalMacros) {
              if (builtins === void 0) {
                builtins = {};
              }
              if (globalMacros === void 0) {
                globalMacros = {};
              }
              this.current = void 0;
              this.builtins = void 0;
              this.undefStack = void 0;
              this.current = globalMacros;
              this.builtins = builtins;
              this.undefStack = [];
            }
            var _proto = Namespace.prototype;
            _proto.beginGroup = function beginGroup() {
              this.undefStack.push({});
            };
            _proto.endGroup = function endGroup() {
              if (this.undefStack.length === 0) {
                throw new src_ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
              }
              var undefs = this.undefStack.pop();
              for (var undef in undefs) {
                if (undefs.hasOwnProperty(undef)) {
                  if (undefs[undef] === void 0) {
                    delete this.current[undef];
                  } else {
                    this.current[undef] = undefs[undef];
                  }
                }
              }
            };
            _proto.has = function has3(name2) {
              return this.current.hasOwnProperty(name2) || this.builtins.hasOwnProperty(name2);
            };
            _proto.get = function get2(name2) {
              if (this.current.hasOwnProperty(name2)) {
                return this.current[name2];
              } else {
                return this.builtins[name2];
              }
            };
            _proto.set = function set3(name2, value, global2) {
              if (global2 === void 0) {
                global2 = false;
              }
              if (global2) {
                for (var i = 0; i < this.undefStack.length; i++) {
                  delete this.undefStack[i][name2];
                }
                if (this.undefStack.length > 0) {
                  this.undefStack[this.undefStack.length - 1][name2] = value;
                }
              } else {
                var top = this.undefStack[this.undefStack.length - 1];
                if (top && !top.hasOwnProperty(name2)) {
                  top[name2] = this.current[name2];
                }
              }
              this.current[name2] = value;
            };
            return Namespace;
          }();
          var builtinMacros = {};
          var macros = builtinMacros;
          function defineMacro(name2, body) {
            builtinMacros[name2] = body;
          }
          defineMacro("\\noexpand", function(context) {
            var t2 = context.popToken();
            if (context.isExpandable(t2.text)) {
              t2.noexpand = true;
              t2.treatAsRelax = true;
            }
            return {
              tokens: [t2],
              numArgs: 0
            };
          });
          defineMacro("\\expandafter", function(context) {
            var t2 = context.popToken();
            context.expandOnce(true);
            return {
              tokens: [t2],
              numArgs: 0
            };
          });
          defineMacro("\\@firstoftwo", function(context) {
            var args = context.consumeArgs(2);
            return {
              tokens: args[0],
              numArgs: 0
            };
          });
          defineMacro("\\@secondoftwo", function(context) {
            var args = context.consumeArgs(2);
            return {
              tokens: args[1],
              numArgs: 0
            };
          });
          defineMacro("\\@ifnextchar", function(context) {
            var args = context.consumeArgs(3);
            context.consumeSpaces();
            var nextToken = context.future();
            if (args[0].length === 1 && args[0][0].text === nextToken.text) {
              return {
                tokens: args[1],
                numArgs: 0
              };
            } else {
              return {
                tokens: args[2],
                numArgs: 0
              };
            }
          });
          defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
          defineMacro("\\TextOrMath", function(context) {
            var args = context.consumeArgs(2);
            if (context.mode === "text") {
              return {
                tokens: args[0],
                numArgs: 0
              };
            } else {
              return {
                tokens: args[1],
                numArgs: 0
              };
            }
          });
          var digitToNumber = {
            "0": 0,
            "1": 1,
            "2": 2,
            "3": 3,
            "4": 4,
            "5": 5,
            "6": 6,
            "7": 7,
            "8": 8,
            "9": 9,
            "a": 10,
            "A": 10,
            "b": 11,
            "B": 11,
            "c": 12,
            "C": 12,
            "d": 13,
            "D": 13,
            "e": 14,
            "E": 14,
            "f": 15,
            "F": 15
          };
          defineMacro("\\char", function(context) {
            var token = context.popToken();
            var base2;
            var number = "";
            if (token.text === "'") {
              base2 = 8;
              token = context.popToken();
            } else if (token.text === '"') {
              base2 = 16;
              token = context.popToken();
            } else if (token.text === "`") {
              token = context.popToken();
              if (token.text[0] === "\\") {
                number = token.text.charCodeAt(1);
              } else if (token.text === "EOF") {
                throw new src_ParseError("\\char` missing argument");
              } else {
                number = token.text.charCodeAt(0);
              }
            } else {
              base2 = 10;
            }
            if (base2) {
              number = digitToNumber[token.text];
              if (number == null || number >= base2) {
                throw new src_ParseError("Invalid base-" + base2 + " digit " + token.text);
              }
              var digit;
              while ((digit = digitToNumber[context.future().text]) != null && digit < base2) {
                number *= base2;
                number += digit;
                context.popToken();
              }
            }
            return "\\@char{" + number + "}";
          });
          var macros_newcommand = function newcommand(context, existsOK, nonexistsOK) {
            var arg = context.consumeArgs(1)[0];
            if (arg.length !== 1) {
              throw new src_ParseError("\\newcommand's first argument must be a macro name");
            }
            var name2 = arg[0].text;
            var exists = context.isDefined(name2);
            if (exists && !existsOK) {
              throw new src_ParseError("\\newcommand{" + name2 + "} attempting to redefine " + (name2 + "; use \\renewcommand"));
            }
            if (!exists && !nonexistsOK) {
              throw new src_ParseError("\\renewcommand{" + name2 + "} when command " + name2 + " does not yet exist; use \\newcommand");
            }
            var numArgs = 0;
            arg = context.consumeArgs(1)[0];
            if (arg.length === 1 && arg[0].text === "[") {
              var argText = "";
              var token = context.expandNextToken();
              while (token.text !== "]" && token.text !== "EOF") {
                argText += token.text;
                token = context.expandNextToken();
              }
              if (!argText.match(/^\s*[0-9]+\s*$/)) {
                throw new src_ParseError("Invalid number of arguments: " + argText);
              }
              numArgs = parseInt(argText);
              arg = context.consumeArgs(1)[0];
            }
            context.macros.set(name2, {
              tokens: arg,
              numArgs
            });
            return "";
          };
          defineMacro("\\newcommand", function(context) {
            return macros_newcommand(context, false, true);
          });
          defineMacro("\\renewcommand", function(context) {
            return macros_newcommand(context, true, false);
          });
          defineMacro("\\providecommand", function(context) {
            return macros_newcommand(context, true, true);
          });
          defineMacro("\\message", function(context) {
            var arg = context.consumeArgs(1)[0];
            console.log(arg.reverse().map(function(token) {
              return token.text;
            }).join(""));
            return "";
          });
          defineMacro("\\errmessage", function(context) {
            var arg = context.consumeArgs(1)[0];
            console.error(arg.reverse().map(function(token) {
              return token.text;
            }).join(""));
            return "";
          });
          defineMacro("\\show", function(context) {
            var tok = context.popToken();
            var name2 = tok.text;
            console.log(tok, context.macros.get(name2), src_functions[name2], src_symbols.math[name2], src_symbols.text[name2]);
            return "";
          });
          defineMacro("\\bgroup", "{");
          defineMacro("\\egroup", "}");
          defineMacro("\\lq", "`");
          defineMacro("\\rq", "'");
          defineMacro("\\aa", "\\r a");
          defineMacro("\\AA", "\\r A");
          defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`\xA9}");
          defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
          defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`\xAE}");
          defineMacro("\u212C", "\\mathscr{B}");
          defineMacro("\u2130", "\\mathscr{E}");
          defineMacro("\u2131", "\\mathscr{F}");
          defineMacro("\u210B", "\\mathscr{H}");
          defineMacro("\u2110", "\\mathscr{I}");
          defineMacro("\u2112", "\\mathscr{L}");
          defineMacro("\u2133", "\\mathscr{M}");
          defineMacro("\u211B", "\\mathscr{R}");
          defineMacro("\u212D", "\\mathfrak{C}");
          defineMacro("\u210C", "\\mathfrak{H}");
          defineMacro("\u2128", "\\mathfrak{Z}");
          defineMacro("\\Bbbk", "\\Bbb{k}");
          defineMacro("\xB7", "\\cdotp");
          defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
          defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
          defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
          defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
          defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`\u2260}}");
          defineMacro("\\ne", "\\neq");
          defineMacro("\u2260", "\\neq");
          defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`\u2209}}");
          defineMacro("\u2209", "\\notin");
          defineMacro("\u2258", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`\u2258}}");
          defineMacro("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");
          defineMacro("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");
          defineMacro("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`\u225B}}");
          defineMacro("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`\u225D}}");
          defineMacro("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`\u225E}}");
          defineMacro("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}");
          defineMacro("\u27C2", "\\perp");
          defineMacro("\u203C", "\\mathclose{!\\mkern-0.8mu!}");
          defineMacro("\u220C", "\\notni");
          defineMacro("\u231C", "\\ulcorner");
          defineMacro("\u231D", "\\urcorner");
          defineMacro("\u231E", "\\llcorner");
          defineMacro("\u231F", "\\lrcorner");
          defineMacro("\xA9", "\\copyright");
          defineMacro("\xAE", "\\textregistered");
          defineMacro("\uFE0F", "\\textregistered");
          defineMacro("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
          defineMacro("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
          defineMacro("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
          defineMacro("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
          defineMacro("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}");
          defineMacro("\u22EE", "\\vdots");
          defineMacro("\\varGamma", "\\mathit{\\Gamma}");
          defineMacro("\\varDelta", "\\mathit{\\Delta}");
          defineMacro("\\varTheta", "\\mathit{\\Theta}");
          defineMacro("\\varLambda", "\\mathit{\\Lambda}");
          defineMacro("\\varXi", "\\mathit{\\Xi}");
          defineMacro("\\varPi", "\\mathit{\\Pi}");
          defineMacro("\\varSigma", "\\mathit{\\Sigma}");
          defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
          defineMacro("\\varPhi", "\\mathit{\\Phi}");
          defineMacro("\\varPsi", "\\mathit{\\Psi}");
          defineMacro("\\varOmega", "\\mathit{\\Omega}");
          defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
          defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu");
          defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
          defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
          defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
          defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
          var dotsByToken = {
            ",": "\\dotsc",
            "\\not": "\\dotsb",
            "+": "\\dotsb",
            "=": "\\dotsb",
            "<": "\\dotsb",
            ">": "\\dotsb",
            "-": "\\dotsb",
            "*": "\\dotsb",
            ":": "\\dotsb",
            "\\DOTSB": "\\dotsb",
            "\\coprod": "\\dotsb",
            "\\bigvee": "\\dotsb",
            "\\bigwedge": "\\dotsb",
            "\\biguplus": "\\dotsb",
            "\\bigcap": "\\dotsb",
            "\\bigcup": "\\dotsb",
            "\\prod": "\\dotsb",
            "\\sum": "\\dotsb",
            "\\bigotimes": "\\dotsb",
            "\\bigoplus": "\\dotsb",
            "\\bigodot": "\\dotsb",
            "\\bigsqcup": "\\dotsb",
            "\\And": "\\dotsb",
            "\\longrightarrow": "\\dotsb",
            "\\Longrightarrow": "\\dotsb",
            "\\longleftarrow": "\\dotsb",
            "\\Longleftarrow": "\\dotsb",
            "\\longleftrightarrow": "\\dotsb",
            "\\Longleftrightarrow": "\\dotsb",
            "\\mapsto": "\\dotsb",
            "\\longmapsto": "\\dotsb",
            "\\hookrightarrow": "\\dotsb",
            "\\doteq": "\\dotsb",
            "\\mathbin": "\\dotsb",
            "\\mathrel": "\\dotsb",
            "\\relbar": "\\dotsb",
            "\\Relbar": "\\dotsb",
            "\\xrightarrow": "\\dotsb",
            "\\xleftarrow": "\\dotsb",
            "\\DOTSI": "\\dotsi",
            "\\int": "\\dotsi",
            "\\oint": "\\dotsi",
            "\\iint": "\\dotsi",
            "\\iiint": "\\dotsi",
            "\\iiiint": "\\dotsi",
            "\\idotsint": "\\dotsi",
            "\\DOTSX": "\\dotsx"
          };
          defineMacro("\\dots", function(context) {
            var thedots = "\\dotso";
            var next2 = context.expandAfterFuture().text;
            if (next2 in dotsByToken) {
              thedots = dotsByToken[next2];
            } else if (next2.substr(0, 4) === "\\not") {
              thedots = "\\dotsb";
            } else if (next2 in src_symbols.math) {
              if (utils.contains(["bin", "rel"], src_symbols.math[next2].group)) {
                thedots = "\\dotsb";
              }
            }
            return thedots;
          });
          var spaceAfterDots = {
            ")": true,
            "]": true,
            "\\rbrack": true,
            "\\}": true,
            "\\rbrace": true,
            "\\rangle": true,
            "\\rceil": true,
            "\\rfloor": true,
            "\\rgroup": true,
            "\\rmoustache": true,
            "\\right": true,
            "\\bigr": true,
            "\\biggr": true,
            "\\Bigr": true,
            "\\Biggr": true,
            "$": true,
            ";": true,
            ".": true,
            ",": true
          };
          defineMacro("\\dotso", function(context) {
            var next2 = context.future().text;
            if (next2 in spaceAfterDots) {
              return "\\ldots\\,";
            } else {
              return "\\ldots";
            }
          });
          defineMacro("\\dotsc", function(context) {
            var next2 = context.future().text;
            if (next2 in spaceAfterDots && next2 !== ",") {
              return "\\ldots\\,";
            } else {
              return "\\ldots";
            }
          });
          defineMacro("\\cdots", function(context) {
            var next2 = context.future().text;
            if (next2 in spaceAfterDots) {
              return "\\@cdots\\,";
            } else {
              return "\\@cdots";
            }
          });
          defineMacro("\\dotsb", "\\cdots");
          defineMacro("\\dotsm", "\\cdots");
          defineMacro("\\dotsi", "\\!\\cdots");
          defineMacro("\\dotsx", "\\ldots\\,");
          defineMacro("\\DOTSI", "\\relax");
          defineMacro("\\DOTSB", "\\relax");
          defineMacro("\\DOTSX", "\\relax");
          defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
          defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
          defineMacro("\\thinspace", "\\,");
          defineMacro("\\>", "\\mskip{4mu}");
          defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
          defineMacro("\\medspace", "\\:");
          defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
          defineMacro("\\thickspace", "\\;");
          defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
          defineMacro("\\negthinspace", "\\!");
          defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
          defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
          defineMacro("\\enspace", "\\kern.5em ");
          defineMacro("\\enskip", "\\hskip.5em\\relax");
          defineMacro("\\quad", "\\hskip1em\\relax");
          defineMacro("\\qquad", "\\hskip2em\\relax");
          defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
          defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
          defineMacro("\\tag@literal", function(context) {
            if (context.macros.get("\\df@tag")) {
              throw new src_ParseError("Multiple \\tag");
            }
            return "\\gdef\\df@tag{\\text{#1}}";
          });
          defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
          defineMacro("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
          defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
          defineMacro("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
          defineMacro("\\pmb", "\\html@mathml{\\@binrel{#1}{\\mathrlap{#1}\\kern0.5px#1}}{\\mathbf{#1}}");
          defineMacro("\\\\", "\\newline");
          defineMacro("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
          var latexRaiseA = fontMetricsData["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * fontMetricsData["Main-Regular"]["A".charCodeAt(0)][1] + "em";
          defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
          defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
          defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
          defineMacro("\\@hspace", "\\hskip #1\\relax");
          defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
          defineMacro("\\ordinarycolon", ":");
          defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
          defineMacro("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
          defineMacro("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
          defineMacro("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
          defineMacro("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
          defineMacro("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
          defineMacro("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
          defineMacro("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
          defineMacro("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
          defineMacro("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
          defineMacro("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
          defineMacro("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
          defineMacro("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
          defineMacro("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
          defineMacro("\u2237", "\\dblcolon");
          defineMacro("\u2239", "\\eqcolon");
          defineMacro("\u2254", "\\coloneqq");
          defineMacro("\u2255", "\\eqqcolon");
          defineMacro("\u2A74", "\\Coloneqq");
          defineMacro("\\ratio", "\\vcentcolon");
          defineMacro("\\coloncolon", "\\dblcolon");
          defineMacro("\\colonequals", "\\coloneqq");
          defineMacro("\\coloncolonequals", "\\Coloneqq");
          defineMacro("\\equalscolon", "\\eqqcolon");
          defineMacro("\\equalscoloncolon", "\\Eqqcolon");
          defineMacro("\\colonminus", "\\coloneq");
          defineMacro("\\coloncolonminus", "\\Coloneq");
          defineMacro("\\minuscolon", "\\eqcolon");
          defineMacro("\\minuscoloncolon", "\\Eqcolon");
          defineMacro("\\coloncolonapprox", "\\Colonapprox");
          defineMacro("\\coloncolonsim", "\\Colonsim");
          defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
          defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
          defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
          defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
          defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");
          defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
          defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
          defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}");
          defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}");
          defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}");
          defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}");
          defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}");
          defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}");
          defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{\u2224}");
          defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{\u2226}");
          defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}");
          defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}");
          defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{\u228A}");
          defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{\u2ACB}");
          defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{\u228B}");
          defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{\u2ACC}");
          defineMacro("\\imath", "\\html@mathml{\\@imath}{\u0131}");
          defineMacro("\\jmath", "\\html@mathml{\\@jmath}{\u0237}");
          defineMacro("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`\u27E6}}");
          defineMacro("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`\u27E7}}");
          defineMacro("\u27E6", "\\llbracket");
          defineMacro("\u27E7", "\\rrbracket");
          defineMacro("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`\u2983}}");
          defineMacro("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`\u2984}}");
          defineMacro("\u2983", "\\lBrace");
          defineMacro("\u2984", "\\rBrace");
          defineMacro("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`\u29B5}}");
          defineMacro("\u29B5", "\\minuso");
          defineMacro("\\darr", "\\downarrow");
          defineMacro("\\dArr", "\\Downarrow");
          defineMacro("\\Darr", "\\Downarrow");
          defineMacro("\\lang", "\\langle");
          defineMacro("\\rang", "\\rangle");
          defineMacro("\\uarr", "\\uparrow");
          defineMacro("\\uArr", "\\Uparrow");
          defineMacro("\\Uarr", "\\Uparrow");
          defineMacro("\\N", "\\mathbb{N}");
          defineMacro("\\R", "\\mathbb{R}");
          defineMacro("\\Z", "\\mathbb{Z}");
          defineMacro("\\alef", "\\aleph");
          defineMacro("\\alefsym", "\\aleph");
          defineMacro("\\Alpha", "\\mathrm{A}");
          defineMacro("\\Beta", "\\mathrm{B}");
          defineMacro("\\bull", "\\bullet");
          defineMacro("\\Chi", "\\mathrm{X}");
          defineMacro("\\clubs", "\\clubsuit");
          defineMacro("\\cnums", "\\mathbb{C}");
          defineMacro("\\Complex", "\\mathbb{C}");
          defineMacro("\\Dagger", "\\ddagger");
          defineMacro("\\diamonds", "\\diamondsuit");
          defineMacro("\\empty", "\\emptyset");
          defineMacro("\\Epsilon", "\\mathrm{E}");
          defineMacro("\\Eta", "\\mathrm{H}");
          defineMacro("\\exist", "\\exists");
          defineMacro("\\harr", "\\leftrightarrow");
          defineMacro("\\hArr", "\\Leftrightarrow");
          defineMacro("\\Harr", "\\Leftrightarrow");
          defineMacro("\\hearts", "\\heartsuit");
          defineMacro("\\image", "\\Im");
          defineMacro("\\infin", "\\infty");
          defineMacro("\\Iota", "\\mathrm{I}");
          defineMacro("\\isin", "\\in");
          defineMacro("\\Kappa", "\\mathrm{K}");
          defineMacro("\\larr", "\\leftarrow");
          defineMacro("\\lArr", "\\Leftarrow");
          defineMacro("\\Larr", "\\Leftarrow");
          defineMacro("\\lrarr", "\\leftrightarrow");
          defineMacro("\\lrArr", "\\Leftrightarrow");
          defineMacro("\\Lrarr", "\\Leftrightarrow");
          defineMacro("\\Mu", "\\mathrm{M}");
          defineMacro("\\natnums", "\\mathbb{N}");
          defineMacro("\\Nu", "\\mathrm{N}");
          defineMacro("\\Omicron", "\\mathrm{O}");
          defineMacro("\\plusmn", "\\pm");
          defineMacro("\\rarr", "\\rightarrow");
          defineMacro("\\rArr", "\\Rightarrow");
          defineMacro("\\Rarr", "\\Rightarrow");
          defineMacro("\\real", "\\Re");
          defineMacro("\\reals", "\\mathbb{R}");
          defineMacro("\\Reals", "\\mathbb{R}");
          defineMacro("\\Rho", "\\mathrm{P}");
          defineMacro("\\sdot", "\\cdot");
          defineMacro("\\sect", "\\S");
          defineMacro("\\spades", "\\spadesuit");
          defineMacro("\\sub", "\\subset");
          defineMacro("\\sube", "\\subseteq");
          defineMacro("\\supe", "\\supseteq");
          defineMacro("\\Tau", "\\mathrm{T}");
          defineMacro("\\thetasym", "\\vartheta");
          defineMacro("\\weierp", "\\wp");
          defineMacro("\\Zeta", "\\mathrm{Z}");
          defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
          defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
          defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
          defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
          defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
          defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
          defineMacro("\\Bra", "\\left\\langle#1\\right|");
          defineMacro("\\Ket", "\\left|#1\\right\\rangle");
          defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
          defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
          defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
          defineMacro("\\red", "\\textcolor{##df0030}{#1}");
          defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
          defineMacro("\\gray", "\\textcolor{gray}{#1}");
          defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
          defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
          defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
          defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
          defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
          defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
          defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
          defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
          defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
          defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
          defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
          defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
          defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
          defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
          defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
          defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
          defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
          defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
          defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
          defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
          defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
          defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
          defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
          defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
          defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
          defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
          defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
          defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
          defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
          defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
          defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
          defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
          defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
          defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
          defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
          defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
          defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
          defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
          defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
          defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
          defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
          defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
          defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
          defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
          defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
          defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
          defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
          defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
          defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
          defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
          var implicitCommands = {
            "\\relax": true,
            "^": true,
            "_": true,
            "\\limits": true,
            "\\nolimits": true
          };
          var MacroExpander_MacroExpander = /* @__PURE__ */ function() {
            function MacroExpander(input, settings, mode) {
              this.settings = void 0;
              this.expansionCount = void 0;
              this.lexer = void 0;
              this.macros = void 0;
              this.stack = void 0;
              this.mode = void 0;
              this.settings = settings;
              this.expansionCount = 0;
              this.feed(input);
              this.macros = new Namespace_Namespace(macros, settings.macros);
              this.mode = mode;
              this.stack = [];
            }
            var _proto = MacroExpander.prototype;
            _proto.feed = function feed(input) {
              this.lexer = new Lexer_Lexer(input, this.settings);
            };
            _proto.switchMode = function switchMode(newMode) {
              this.mode = newMode;
            };
            _proto.beginGroup = function beginGroup() {
              this.macros.beginGroup();
            };
            _proto.endGroup = function endGroup() {
              this.macros.endGroup();
            };
            _proto.future = function future() {
              if (this.stack.length === 0) {
                this.pushToken(this.lexer.lex());
              }
              return this.stack[this.stack.length - 1];
            };
            _proto.popToken = function popToken() {
              this.future();
              return this.stack.pop();
            };
            _proto.pushToken = function pushToken(token) {
              this.stack.push(token);
            };
            _proto.pushTokens = function pushTokens(tokens) {
              var _this$stack;
              (_this$stack = this.stack).push.apply(_this$stack, tokens);
            };
            _proto.consumeSpaces = function consumeSpaces() {
              for (; ; ) {
                var token = this.future();
                if (token.text === " ") {
                  this.stack.pop();
                } else {
                  break;
                }
              }
            };
            _proto.consumeArgs = function consumeArgs(numArgs) {
              var args = [];
              for (var i = 0; i < numArgs; ++i) {
                this.consumeSpaces();
                var startOfArg = this.popToken();
                if (startOfArg.text === "{") {
                  var arg = [];
                  var depth = 1;
                  while (depth !== 0) {
                    var tok = this.popToken();
                    arg.push(tok);
                    if (tok.text === "{") {
                      ++depth;
                    } else if (tok.text === "}") {
                      --depth;
                    } else if (tok.text === "EOF") {
                      throw new src_ParseError("End of input in macro argument", startOfArg);
                    }
                  }
                  arg.pop();
                  arg.reverse();
                  args[i] = arg;
                } else if (startOfArg.text === "EOF") {
                  throw new src_ParseError("End of input expecting macro argument");
                } else {
                  args[i] = [startOfArg];
                }
              }
              return args;
            };
            _proto.expandOnce = function expandOnce(expandableOnly) {
              var topToken = this.popToken();
              var name2 = topToken.text;
              var expansion = !topToken.noexpand ? this._getExpansion(name2) : null;
              if (expansion == null || expandableOnly && expansion.unexpandable) {
                if (expandableOnly && expansion == null && name2[0] === "\\" && !this.isDefined(name2)) {
                  throw new src_ParseError("Undefined control sequence: " + name2);
                }
                this.pushToken(topToken);
                return topToken;
              }
              this.expansionCount++;
              if (this.expansionCount > this.settings.maxExpand) {
                throw new src_ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
              }
              var tokens = expansion.tokens;
              if (expansion.numArgs) {
                var args = this.consumeArgs(expansion.numArgs);
                tokens = tokens.slice();
                for (var i = tokens.length - 1; i >= 0; --i) {
                  var tok = tokens[i];
                  if (tok.text === "#") {
                    if (i === 0) {
                      throw new src_ParseError("Incomplete placeholder at end of macro body", tok);
                    }
                    tok = tokens[--i];
                    if (tok.text === "#") {
                      tokens.splice(i + 1, 1);
                    } else if (/^[1-9]$/.test(tok.text)) {
                      var _tokens;
                      (_tokens = tokens).splice.apply(_tokens, [i, 2].concat(args[+tok.text - 1]));
                    } else {
                      throw new src_ParseError("Not a valid argument number", tok);
                    }
                  }
                }
              }
              this.pushTokens(tokens);
              return tokens;
            };
            _proto.expandAfterFuture = function expandAfterFuture() {
              this.expandOnce();
              return this.future();
            };
            _proto.expandNextToken = function expandNextToken() {
              for (; ; ) {
                var expanded = this.expandOnce();
                if (expanded instanceof Token_Token) {
                  if (expanded.text === "\\relax" || expanded.treatAsRelax) {
                    this.stack.pop();
                  } else {
                    return this.stack.pop();
                  }
                }
              }
              throw new Error();
            };
            _proto.expandMacro = function expandMacro(name2) {
              return this.macros.has(name2) ? this.expandTokens([new Token_Token(name2)]) : void 0;
            };
            _proto.expandTokens = function expandTokens(tokens) {
              var output = [];
              var oldStackLength = this.stack.length;
              this.pushTokens(tokens);
              while (this.stack.length > oldStackLength) {
                var expanded = this.expandOnce(true);
                if (expanded instanceof Token_Token) {
                  if (expanded.treatAsRelax) {
                    expanded.noexpand = false;
                    expanded.treatAsRelax = false;
                  }
                  output.push(this.stack.pop());
                }
              }
              return output;
            };
            _proto.expandMacroAsText = function expandMacroAsText(name2) {
              var tokens = this.expandMacro(name2);
              if (tokens) {
                return tokens.map(function(token) {
                  return token.text;
                }).join("");
              } else {
                return tokens;
              }
            };
            _proto._getExpansion = function _getExpansion(name2) {
              var definition = this.macros.get(name2);
              if (definition == null) {
                return definition;
              }
              var expansion = typeof definition === "function" ? definition(this) : definition;
              if (typeof expansion === "string") {
                var numArgs = 0;
                if (expansion.indexOf("#") !== -1) {
                  var stripped = expansion.replace(/##/g, "");
                  while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
                    ++numArgs;
                  }
                }
                var bodyLexer = new Lexer_Lexer(expansion, this.settings);
                var tokens = [];
                var tok = bodyLexer.lex();
                while (tok.text !== "EOF") {
                  tokens.push(tok);
                  tok = bodyLexer.lex();
                }
                tokens.reverse();
                var expanded = {
                  tokens,
                  numArgs
                };
                return expanded;
              }
              return expansion;
            };
            _proto.isDefined = function isDefined(name2) {
              return this.macros.has(name2) || src_functions.hasOwnProperty(name2) || src_symbols.math.hasOwnProperty(name2) || src_symbols.text.hasOwnProperty(name2) || implicitCommands.hasOwnProperty(name2);
            };
            _proto.isExpandable = function isExpandable(name2) {
              var macro = this.macros.get(name2);
              return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : src_functions.hasOwnProperty(name2);
            };
            return MacroExpander;
          }();
          var unicodeAccents = {
            "\u0301": {
              "text": "\\'",
              "math": "\\acute"
            },
            "\u0300": {
              "text": "\\`",
              "math": "\\grave"
            },
            "\u0308": {
              "text": '\\"',
              "math": "\\ddot"
            },
            "\u0303": {
              "text": "\\~",
              "math": "\\tilde"
            },
            "\u0304": {
              "text": "\\=",
              "math": "\\bar"
            },
            "\u0306": {
              "text": "\\u",
              "math": "\\breve"
            },
            "\u030C": {
              "text": "\\v",
              "math": "\\check"
            },
            "\u0302": {
              "text": "\\^",
              "math": "\\hat"
            },
            "\u0307": {
              "text": "\\.",
              "math": "\\dot"
            },
            "\u030A": {
              "text": "\\r",
              "math": "\\mathring"
            },
            "\u030B": {
              "text": "\\H"
            }
          };
          var unicodeSymbols = {
            "\xE1": "a\u0301",
            "\xE0": "a\u0300",
            "\xE4": "a\u0308",
            "\u01DF": "a\u0308\u0304",
            "\xE3": "a\u0303",
            "\u0101": "a\u0304",
            "\u0103": "a\u0306",
            "\u1EAF": "a\u0306\u0301",
            "\u1EB1": "a\u0306\u0300",
            "\u1EB5": "a\u0306\u0303",
            "\u01CE": "a\u030C",
            "\xE2": "a\u0302",
            "\u1EA5": "a\u0302\u0301",
            "\u1EA7": "a\u0302\u0300",
            "\u1EAB": "a\u0302\u0303",
            "\u0227": "a\u0307",
            "\u01E1": "a\u0307\u0304",
            "\xE5": "a\u030A",
            "\u01FB": "a\u030A\u0301",
            "\u1E03": "b\u0307",
            "\u0107": "c\u0301",
            "\u010D": "c\u030C",
            "\u0109": "c\u0302",
            "\u010B": "c\u0307",
            "\u010F": "d\u030C",
            "\u1E0B": "d\u0307",
            "\xE9": "e\u0301",
            "\xE8": "e\u0300",
            "\xEB": "e\u0308",
            "\u1EBD": "e\u0303",
            "\u0113": "e\u0304",
            "\u1E17": "e\u0304\u0301",
            "\u1E15": "e\u0304\u0300",
            "\u0115": "e\u0306",
            "\u011B": "e\u030C",
            "\xEA": "e\u0302",
            "\u1EBF": "e\u0302\u0301",
            "\u1EC1": "e\u0302\u0300",
            "\u1EC5": "e\u0302\u0303",
            "\u0117": "e\u0307",
            "\u1E1F": "f\u0307",
            "\u01F5": "g\u0301",
            "\u1E21": "g\u0304",
            "\u011F": "g\u0306",
            "\u01E7": "g\u030C",
            "\u011D": "g\u0302",
            "\u0121": "g\u0307",
            "\u1E27": "h\u0308",
            "\u021F": "h\u030C",
            "\u0125": "h\u0302",
            "\u1E23": "h\u0307",
            "\xED": "i\u0301",
            "\xEC": "i\u0300",
            "\xEF": "i\u0308",
            "\u1E2F": "i\u0308\u0301",
            "\u0129": "i\u0303",
            "\u012B": "i\u0304",
            "\u012D": "i\u0306",
            "\u01D0": "i\u030C",
            "\xEE": "i\u0302",
            "\u01F0": "j\u030C",
            "\u0135": "j\u0302",
            "\u1E31": "k\u0301",
            "\u01E9": "k\u030C",
            "\u013A": "l\u0301",
            "\u013E": "l\u030C",
            "\u1E3F": "m\u0301",
            "\u1E41": "m\u0307",
            "\u0144": "n\u0301",
            "\u01F9": "n\u0300",
            "\xF1": "n\u0303",
            "\u0148": "n\u030C",
            "\u1E45": "n\u0307",
            "\xF3": "o\u0301",
            "\xF2": "o\u0300",
            "\xF6": "o\u0308",
            "\u022B": "o\u0308\u0304",
            "\xF5": "o\u0303",
            "\u1E4D": "o\u0303\u0301",
            "\u1E4F": "o\u0303\u0308",
            "\u022D": "o\u0303\u0304",
            "\u014D": "o\u0304",
            "\u1E53": "o\u0304\u0301",
            "\u1E51": "o\u0304\u0300",
            "\u014F": "o\u0306",
            "\u01D2": "o\u030C",
            "\xF4": "o\u0302",
            "\u1ED1": "o\u0302\u0301",
            "\u1ED3": "o\u0302\u0300",
            "\u1ED7": "o\u0302\u0303",
            "\u022F": "o\u0307",
            "\u0231": "o\u0307\u0304",
            "\u0151": "o\u030B",
            "\u1E55": "p\u0301",
            "\u1E57": "p\u0307",
            "\u0155": "r\u0301",
            "\u0159": "r\u030C",
            "\u1E59": "r\u0307",
            "\u015B": "s\u0301",
            "\u1E65": "s\u0301\u0307",
            "\u0161": "s\u030C",
            "\u1E67": "s\u030C\u0307",
            "\u015D": "s\u0302",
            "\u1E61": "s\u0307",
            "\u1E97": "t\u0308",
            "\u0165": "t\u030C",
            "\u1E6B": "t\u0307",
            "\xFA": "u\u0301",
            "\xF9": "u\u0300",
            "\xFC": "u\u0308",
            "\u01D8": "u\u0308\u0301",
            "\u01DC": "u\u0308\u0300",
            "\u01D6": "u\u0308\u0304",
            "\u01DA": "u\u0308\u030C",
            "\u0169": "u\u0303",
            "\u1E79": "u\u0303\u0301",
            "\u016B": "u\u0304",
            "\u1E7B": "u\u0304\u0308",
            "\u016D": "u\u0306",
            "\u01D4": "u\u030C",
            "\xFB": "u\u0302",
            "\u016F": "u\u030A",
            "\u0171": "u\u030B",
            "\u1E7D": "v\u0303",
            "\u1E83": "w\u0301",
            "\u1E81": "w\u0300",
            "\u1E85": "w\u0308",
            "\u0175": "w\u0302",
            "\u1E87": "w\u0307",
            "\u1E98": "w\u030A",
            "\u1E8D": "x\u0308",
            "\u1E8B": "x\u0307",
            "\xFD": "y\u0301",
            "\u1EF3": "y\u0300",
            "\xFF": "y\u0308",
            "\u1EF9": "y\u0303",
            "\u0233": "y\u0304",
            "\u0177": "y\u0302",
            "\u1E8F": "y\u0307",
            "\u1E99": "y\u030A",
            "\u017A": "z\u0301",
            "\u017E": "z\u030C",
            "\u1E91": "z\u0302",
            "\u017C": "z\u0307",
            "\xC1": "A\u0301",
            "\xC0": "A\u0300",
            "\xC4": "A\u0308",
            "\u01DE": "A\u0308\u0304",
            "\xC3": "A\u0303",
            "\u0100": "A\u0304",
            "\u0102": "A\u0306",
            "\u1EAE": "A\u0306\u0301",
            "\u1EB0": "A\u0306\u0300",
            "\u1EB4": "A\u0306\u0303",
            "\u01CD": "A\u030C",
            "\xC2": "A\u0302",
            "\u1EA4": "A\u0302\u0301",
            "\u1EA6": "A\u0302\u0300",
            "\u1EAA": "A\u0302\u0303",
            "\u0226": "A\u0307",
            "\u01E0": "A\u0307\u0304",
            "\xC5": "A\u030A",
            "\u01FA": "A\u030A\u0301",
            "\u1E02": "B\u0307",
            "\u0106": "C\u0301",
            "\u010C": "C\u030C",
            "\u0108": "C\u0302",
            "\u010A": "C\u0307",
            "\u010E": "D\u030C",
            "\u1E0A": "D\u0307",
            "\xC9": "E\u0301",
            "\xC8": "E\u0300",
            "\xCB": "E\u0308",
            "\u1EBC": "E\u0303",
            "\u0112": "E\u0304",
            "\u1E16": "E\u0304\u0301",
            "\u1E14": "E\u0304\u0300",
            "\u0114": "E\u0306",
            "\u011A": "E\u030C",
            "\xCA": "E\u0302",
            "\u1EBE": "E\u0302\u0301",
            "\u1EC0": "E\u0302\u0300",
            "\u1EC4": "E\u0302\u0303",
            "\u0116": "E\u0307",
            "\u1E1E": "F\u0307",
            "\u01F4": "G\u0301",
            "\u1E20": "G\u0304",
            "\u011E": "G\u0306",
            "\u01E6": "G\u030C",
            "\u011C": "G\u0302",
            "\u0120": "G\u0307",
            "\u1E26": "H\u0308",
            "\u021E": "H\u030C",
            "\u0124": "H\u0302",
            "\u1E22": "H\u0307",
            "\xCD": "I\u0301",
            "\xCC": "I\u0300",
            "\xCF": "I\u0308",
            "\u1E2E": "I\u0308\u0301",
            "\u0128": "I\u0303",
            "\u012A": "I\u0304",
            "\u012C": "I\u0306",
            "\u01CF": "I\u030C",
            "\xCE": "I\u0302",
            "\u0130": "I\u0307",
            "\u0134": "J\u0302",
            "\u1E30": "K\u0301",
            "\u01E8": "K\u030C",
            "\u0139": "L\u0301",
            "\u013D": "L\u030C",
            "\u1E3E": "M\u0301",
            "\u1E40": "M\u0307",
            "\u0143": "N\u0301",
            "\u01F8": "N\u0300",
            "\xD1": "N\u0303",
            "\u0147": "N\u030C",
            "\u1E44": "N\u0307",
            "\xD3": "O\u0301",
            "\xD2": "O\u0300",
            "\xD6": "O\u0308",
            "\u022A": "O\u0308\u0304",
            "\xD5": "O\u0303",
            "\u1E4C": "O\u0303\u0301",
            "\u1E4E": "O\u0303\u0308",
            "\u022C": "O\u0303\u0304",
            "\u014C": "O\u0304",
            "\u1E52": "O\u0304\u0301",
            "\u1E50": "O\u0304\u0300",
            "\u014E": "O\u0306",
            "\u01D1": "O\u030C",
            "\xD4": "O\u0302",
            "\u1ED0": "O\u0302\u0301",
            "\u1ED2": "O\u0302\u0300",
            "\u1ED6": "O\u0302\u0303",
            "\u022E": "O\u0307",
            "\u0230": "O\u0307\u0304",
            "\u0150": "O\u030B",
            "\u1E54": "P\u0301",
            "\u1E56": "P\u0307",
            "\u0154": "R\u0301",
            "\u0158": "R\u030C",
            "\u1E58": "R\u0307",
            "\u015A": "S\u0301",
            "\u1E64": "S\u0301\u0307",
            "\u0160": "S\u030C",
            "\u1E66": "S\u030C\u0307",
            "\u015C": "S\u0302",
            "\u1E60": "S\u0307",
            "\u0164": "T\u030C",
            "\u1E6A": "T\u0307",
            "\xDA": "U\u0301",
            "\xD9": "U\u0300",
            "\xDC": "U\u0308",
            "\u01D7": "U\u0308\u0301",
            "\u01DB": "U\u0308\u0300",
            "\u01D5": "U\u0308\u0304",
            "\u01D9": "U\u0308\u030C",
            "\u0168": "U\u0303",
            "\u1E78": "U\u0303\u0301",
            "\u016A": "U\u0304",
            "\u1E7A": "U\u0304\u0308",
            "\u016C": "U\u0306",
            "\u01D3": "U\u030C",
            "\xDB": "U\u0302",
            "\u016E": "U\u030A",
            "\u0170": "U\u030B",
            "\u1E7C": "V\u0303",
            "\u1E82": "W\u0301",
            "\u1E80": "W\u0300",
            "\u1E84": "W\u0308",
            "\u0174": "W\u0302",
            "\u1E86": "W\u0307",
            "\u1E8C": "X\u0308",
            "\u1E8A": "X\u0307",
            "\xDD": "Y\u0301",
            "\u1EF2": "Y\u0300",
            "\u0178": "Y\u0308",
            "\u1EF8": "Y\u0303",
            "\u0232": "Y\u0304",
            "\u0176": "Y\u0302",
            "\u1E8E": "Y\u0307",
            "\u0179": "Z\u0301",
            "\u017D": "Z\u030C",
            "\u1E90": "Z\u0302",
            "\u017B": "Z\u0307",
            "\u03AC": "\u03B1\u0301",
            "\u1F70": "\u03B1\u0300",
            "\u1FB1": "\u03B1\u0304",
            "\u1FB0": "\u03B1\u0306",
            "\u03AD": "\u03B5\u0301",
            "\u1F72": "\u03B5\u0300",
            "\u03AE": "\u03B7\u0301",
            "\u1F74": "\u03B7\u0300",
            "\u03AF": "\u03B9\u0301",
            "\u1F76": "\u03B9\u0300",
            "\u03CA": "\u03B9\u0308",
            "\u0390": "\u03B9\u0308\u0301",
            "\u1FD2": "\u03B9\u0308\u0300",
            "\u1FD1": "\u03B9\u0304",
            "\u1FD0": "\u03B9\u0306",
            "\u03CC": "\u03BF\u0301",
            "\u1F78": "\u03BF\u0300",
            "\u03CD": "\u03C5\u0301",
            "\u1F7A": "\u03C5\u0300",
            "\u03CB": "\u03C5\u0308",
            "\u03B0": "\u03C5\u0308\u0301",
            "\u1FE2": "\u03C5\u0308\u0300",
            "\u1FE1": "\u03C5\u0304",
            "\u1FE0": "\u03C5\u0306",
            "\u03CE": "\u03C9\u0301",
            "\u1F7C": "\u03C9\u0300",
            "\u038E": "\u03A5\u0301",
            "\u1FEA": "\u03A5\u0300",
            "\u03AB": "\u03A5\u0308",
            "\u1FE9": "\u03A5\u0304",
            "\u1FE8": "\u03A5\u0306",
            "\u038F": "\u03A9\u0301",
            "\u1FFA": "\u03A9\u0300"
          };
          var Parser_Parser = /* @__PURE__ */ function() {
            function Parser4(input, settings) {
              this.mode = void 0;
              this.gullet = void 0;
              this.settings = void 0;
              this.leftrightDepth = void 0;
              this.nextToken = void 0;
              this.mode = "math";
              this.gullet = new MacroExpander_MacroExpander(input, settings, this.mode);
              this.settings = settings;
              this.leftrightDepth = 0;
            }
            var _proto = Parser4.prototype;
            _proto.expect = function expect(text4, consume) {
              if (consume === void 0) {
                consume = true;
              }
              if (this.fetch().text !== text4) {
                throw new src_ParseError("Expected '" + text4 + "', got '" + this.fetch().text + "'", this.fetch());
              }
              if (consume) {
                this.consume();
              }
            };
            _proto.consume = function consume() {
              this.nextToken = null;
            };
            _proto.fetch = function fetch3() {
              if (this.nextToken == null) {
                this.nextToken = this.gullet.expandNextToken();
              }
              return this.nextToken;
            };
            _proto.switchMode = function switchMode(newMode) {
              this.mode = newMode;
              this.gullet.switchMode(newMode);
            };
            _proto.parse = function parse7() {
              if (!this.settings.globalGroup) {
                this.gullet.beginGroup();
              }
              if (this.settings.colorIsTextColor) {
                this.gullet.macros.set("\\color", "\\textcolor");
              }
              var parse8 = this.parseExpression(false);
              this.expect("EOF");
              if (!this.settings.globalGroup) {
                this.gullet.endGroup();
              }
              return parse8;
            };
            _proto.parseExpression = function parseExpression(breakOnInfix, breakOnTokenText) {
              var body = [];
              while (true) {
                if (this.mode === "math") {
                  this.consumeSpaces();
                }
                var lex = this.fetch();
                if (Parser4.endOfExpression.indexOf(lex.text) !== -1) {
                  break;
                }
                if (breakOnTokenText && lex.text === breakOnTokenText) {
                  break;
                }
                if (breakOnInfix && src_functions[lex.text] && src_functions[lex.text].infix) {
                  break;
                }
                var atom = this.parseAtom(breakOnTokenText);
                if (!atom) {
                  break;
                } else if (atom.type === "internal") {
                  continue;
                }
                body.push(atom);
              }
              if (this.mode === "text") {
                this.formLigatures(body);
              }
              return this.handleInfixNodes(body);
            };
            _proto.handleInfixNodes = function handleInfixNodes(body) {
              var overIndex = -1;
              var funcName;
              for (var i = 0; i < body.length; i++) {
                if (body[i].type === "infix") {
                  if (overIndex !== -1) {
                    throw new src_ParseError("only one infix operator per group", body[i].token);
                  }
                  overIndex = i;
                  funcName = body[i].replaceWith;
                }
              }
              if (overIndex !== -1 && funcName) {
                var numerNode;
                var denomNode;
                var numerBody = body.slice(0, overIndex);
                var denomBody = body.slice(overIndex + 1);
                if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
                  numerNode = numerBody[0];
                } else {
                  numerNode = {
                    type: "ordgroup",
                    mode: this.mode,
                    body: numerBody
                  };
                }
                if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
                  denomNode = denomBody[0];
                } else {
                  denomNode = {
                    type: "ordgroup",
                    mode: this.mode,
                    body: denomBody
                  };
                }
                var node;
                if (funcName === "\\\\abovefrac") {
                  node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
                } else {
                  node = this.callFunction(funcName, [numerNode, denomNode], []);
                }
                return [node];
              } else {
                return body;
              }
            };
            _proto.handleSupSubscript = function handleSupSubscript(name2) {
              var symbolToken = this.fetch();
              var symbol = symbolToken.text;
              this.consume();
              var group = this.parseGroup(name2, false, Parser4.SUPSUB_GREEDINESS, void 0, void 0, true);
              if (!group) {
                throw new src_ParseError("Expected group after '" + symbol + "'", symbolToken);
              }
              return group;
            };
            _proto.formatUnsupportedCmd = function formatUnsupportedCmd(text4) {
              var textordArray = [];
              for (var i = 0; i < text4.length; i++) {
                textordArray.push({
                  type: "textord",
                  mode: "text",
                  text: text4[i]
                });
              }
              var textNode = {
                type: "text",
                mode: this.mode,
                body: textordArray
              };
              var colorNode = {
                type: "color",
                mode: this.mode,
                color: this.settings.errorColor,
                body: [textNode]
              };
              return colorNode;
            };
            _proto.parseAtom = function parseAtom(breakOnTokenText) {
              var base2 = this.parseGroup("atom", false, null, breakOnTokenText);
              if (this.mode === "text") {
                return base2;
              }
              var superscript2;
              var subscript2;
              while (true) {
                this.consumeSpaces();
                var lex = this.fetch();
                if (lex.text === "\\limits" || lex.text === "\\nolimits") {
                  if (base2 && base2.type === "op") {
                    var limits = lex.text === "\\limits";
                    base2.limits = limits;
                    base2.alwaysHandleSupSub = true;
                  } else if (base2 && base2.type === "operatorname" && base2.alwaysHandleSupSub) {
                    var _limits = lex.text === "\\limits";
                    base2.limits = _limits;
                  } else {
                    throw new src_ParseError("Limit controls must follow a math operator", lex);
                  }
                  this.consume();
                } else if (lex.text === "^") {
                  if (superscript2) {
                    throw new src_ParseError("Double superscript", lex);
                  }
                  superscript2 = this.handleSupSubscript("superscript");
                } else if (lex.text === "_") {
                  if (subscript2) {
                    throw new src_ParseError("Double subscript", lex);
                  }
                  subscript2 = this.handleSupSubscript("subscript");
                } else if (lex.text === "'") {
                  if (superscript2) {
                    throw new src_ParseError("Double superscript", lex);
                  }
                  var prime = {
                    type: "textord",
                    mode: this.mode,
                    text: "\\prime"
                  };
                  var primes = [prime];
                  this.consume();
                  while (this.fetch().text === "'") {
                    primes.push(prime);
                    this.consume();
                  }
                  if (this.fetch().text === "^") {
                    primes.push(this.handleSupSubscript("superscript"));
                  }
                  superscript2 = {
                    type: "ordgroup",
                    mode: this.mode,
                    body: primes
                  };
                } else {
                  break;
                }
              }
              if (superscript2 || subscript2) {
                return {
                  type: "supsub",
                  mode: this.mode,
                  base: base2,
                  sup: superscript2,
                  sub: subscript2
                };
              } else {
                return base2;
              }
            };
            _proto.parseFunction = function parseFunction(breakOnTokenText, name2, greediness) {
              var token = this.fetch();
              var func = token.text;
              var funcData = src_functions[func];
              if (!funcData) {
                return null;
              }
              this.consume();
              if (greediness != null && funcData.greediness <= greediness) {
                throw new src_ParseError("Got function '" + func + "' with no arguments" + (name2 ? " as " + name2 : ""), token);
              } else if (this.mode === "text" && !funcData.allowedInText) {
                throw new src_ParseError("Can't use function '" + func + "' in text mode", token);
              } else if (this.mode === "math" && funcData.allowedInMath === false) {
                throw new src_ParseError("Can't use function '" + func + "' in math mode", token);
              }
              var _this$parseArguments = this.parseArguments(func, funcData), args = _this$parseArguments.args, optArgs = _this$parseArguments.optArgs;
              return this.callFunction(func, args, optArgs, token, breakOnTokenText);
            };
            _proto.callFunction = function callFunction(name2, args, optArgs, token, breakOnTokenText) {
              var context = {
                funcName: name2,
                parser: this,
                token,
                breakOnTokenText
              };
              var func = src_functions[name2];
              if (func && func.handler) {
                return func.handler(context, args, optArgs);
              } else {
                throw new src_ParseError("No function handler for " + name2);
              }
            };
            _proto.parseArguments = function parseArguments(func, funcData) {
              var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
              if (totalArgs === 0) {
                return {
                  args: [],
                  optArgs: []
                };
              }
              var baseGreediness = funcData.greediness;
              var args = [];
              var optArgs = [];
              for (var i = 0; i < totalArgs; i++) {
                var argType = funcData.argTypes && funcData.argTypes[i];
                var isOptional = i < funcData.numOptionalArgs;
                var consumeSpaces = i > 0 && !isOptional || i === 0 && !isOptional && this.mode === "math";
                var arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional, baseGreediness, consumeSpaces);
                if (!arg) {
                  if (isOptional) {
                    optArgs.push(null);
                    continue;
                  }
                  throw new src_ParseError("Expected group after '" + func + "'", this.fetch());
                }
                (isOptional ? optArgs : args).push(arg);
              }
              return {
                args,
                optArgs
              };
            };
            _proto.parseGroupOfType = function parseGroupOfType(name2, type, optional, greediness, consumeSpaces) {
              switch (type) {
                case "color":
                  if (consumeSpaces) {
                    this.consumeSpaces();
                  }
                  return this.parseColorGroup(optional);
                case "size":
                  if (consumeSpaces) {
                    this.consumeSpaces();
                  }
                  return this.parseSizeGroup(optional);
                case "url":
                  return this.parseUrlGroup(optional, consumeSpaces);
                case "math":
                case "text":
                  return this.parseGroup(name2, optional, greediness, void 0, type, consumeSpaces);
                case "hbox": {
                  var group = this.parseGroup(name2, optional, greediness, void 0, "text", consumeSpaces);
                  if (!group) {
                    return group;
                  }
                  var styledGroup = {
                    type: "styling",
                    mode: group.mode,
                    body: [group],
                    style: "text"
                  };
                  return styledGroup;
                }
                case "raw": {
                  if (consumeSpaces) {
                    this.consumeSpaces();
                  }
                  if (optional && this.fetch().text === "{") {
                    return null;
                  }
                  var token = this.parseStringGroup("raw", optional, true);
                  if (token) {
                    return {
                      type: "raw",
                      mode: "text",
                      string: token.text
                    };
                  } else {
                    throw new src_ParseError("Expected raw group", this.fetch());
                  }
                }
                case "original":
                case null:
                case void 0:
                  return this.parseGroup(name2, optional, greediness, void 0, void 0, consumeSpaces);
                default:
                  throw new src_ParseError("Unknown group type as " + name2, this.fetch());
              }
            };
            _proto.consumeSpaces = function consumeSpaces() {
              while (this.fetch().text === " ") {
                this.consume();
              }
            };
            _proto.parseStringGroup = function parseStringGroup(modeName, optional, raw) {
              var groupBegin = optional ? "[" : "{";
              var groupEnd = optional ? "]" : "}";
              var beginToken = this.fetch();
              if (beginToken.text !== groupBegin) {
                if (optional) {
                  return null;
                } else if (raw && beginToken.text !== "EOF" && /[^{}[\]]/.test(beginToken.text)) {
                  this.consume();
                  return beginToken;
                }
              }
              var outerMode = this.mode;
              this.mode = "text";
              this.expect(groupBegin);
              var str = "";
              var firstToken = this.fetch();
              var nested = 0;
              var lastToken = firstToken;
              var nextToken;
              while ((nextToken = this.fetch()).text !== groupEnd || raw && nested > 0) {
                switch (nextToken.text) {
                  case "EOF":
                    throw new src_ParseError("Unexpected end of input in " + modeName, firstToken.range(lastToken, str));
                  case groupBegin:
                    nested++;
                    break;
                  case groupEnd:
                    nested--;
                    break;
                }
                lastToken = nextToken;
                str += lastToken.text;
                this.consume();
              }
              this.expect(groupEnd);
              this.mode = outerMode;
              return firstToken.range(lastToken, str);
            };
            _proto.parseRegexGroup = function parseRegexGroup(regex, modeName) {
              var outerMode = this.mode;
              this.mode = "text";
              var firstToken = this.fetch();
              var lastToken = firstToken;
              var str = "";
              var nextToken;
              while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str + nextToken.text)) {
                lastToken = nextToken;
                str += lastToken.text;
                this.consume();
              }
              if (str === "") {
                throw new src_ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
              }
              this.mode = outerMode;
              return firstToken.range(lastToken, str);
            };
            _proto.parseColorGroup = function parseColorGroup(optional) {
              var res = this.parseStringGroup("color", optional);
              if (!res) {
                return null;
              }
              var match2 = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
              if (!match2) {
                throw new src_ParseError("Invalid color: '" + res.text + "'", res);
              }
              var color = match2[0];
              if (/^[0-9a-f]{6}$/i.test(color)) {
                color = "#" + color;
              }
              return {
                type: "color-token",
                mode: this.mode,
                color
              };
            };
            _proto.parseSizeGroup = function parseSizeGroup(optional) {
              var res;
              var isBlank = false;
              if (!optional && this.fetch().text !== "{") {
                res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
              } else {
                res = this.parseStringGroup("size", optional);
              }
              if (!res) {
                return null;
              }
              if (!optional && res.text.length === 0) {
                res.text = "0pt";
                isBlank = true;
              }
              var match2 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
              if (!match2) {
                throw new src_ParseError("Invalid size: '" + res.text + "'", res);
              }
              var data2 = {
                number: +(match2[1] + match2[2]),
                unit: match2[3]
              };
              if (!validUnit(data2)) {
                throw new src_ParseError("Invalid unit: '" + data2.unit + "'", res);
              }
              return {
                type: "size",
                mode: this.mode,
                value: data2,
                isBlank
              };
            };
            _proto.parseUrlGroup = function parseUrlGroup(optional, consumeSpaces) {
              this.gullet.lexer.setCatcode("%", 13);
              var res = this.parseStringGroup("url", optional, true);
              this.gullet.lexer.setCatcode("%", 14);
              if (!res) {
                return null;
              }
              var url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
              return {
                type: "url",
                mode: this.mode,
                url
              };
            };
            _proto.parseGroup = function parseGroup(name2, optional, greediness, breakOnTokenText, mode, consumeSpaces) {
              var outerMode = this.mode;
              if (mode) {
                this.switchMode(mode);
              }
              if (consumeSpaces) {
                this.consumeSpaces();
              }
              var firstToken = this.fetch();
              var text4 = firstToken.text;
              var result;
              if (optional ? text4 === "[" : text4 === "{" || text4 === "\\begingroup") {
                this.consume();
                var groupEnd = Parser4.endOfGroup[text4];
                this.gullet.beginGroup();
                var expression = this.parseExpression(false, groupEnd);
                var lastToken = this.fetch();
                this.expect(groupEnd);
                this.gullet.endGroup();
                result = {
                  type: "ordgroup",
                  mode: this.mode,
                  loc: SourceLocation.range(firstToken, lastToken),
                  body: expression,
                  semisimple: text4 === "\\begingroup" || void 0
                };
              } else if (optional) {
                result = null;
              } else {
                result = this.parseFunction(breakOnTokenText, name2, greediness) || this.parseSymbol();
                if (result == null && text4[0] === "\\" && !implicitCommands.hasOwnProperty(text4)) {
                  if (this.settings.throwOnError) {
                    throw new src_ParseError("Undefined control sequence: " + text4, firstToken);
                  }
                  result = this.formatUnsupportedCmd(text4);
                  this.consume();
                }
              }
              if (mode) {
                this.switchMode(outerMode);
              }
              return result;
            };
            _proto.formLigatures = function formLigatures(group) {
              var n = group.length - 1;
              for (var i = 0; i < n; ++i) {
                var a = group[i];
                var v = a.text;
                if (v === "-" && group[i + 1].text === "-") {
                  if (i + 1 < n && group[i + 2].text === "-") {
                    group.splice(i, 3, {
                      type: "textord",
                      mode: "text",
                      loc: SourceLocation.range(a, group[i + 2]),
                      text: "---"
                    });
                    n -= 2;
                  } else {
                    group.splice(i, 2, {
                      type: "textord",
                      mode: "text",
                      loc: SourceLocation.range(a, group[i + 1]),
                      text: "--"
                    });
                    n -= 1;
                  }
                }
                if ((v === "'" || v === "`") && group[i + 1].text === v) {
                  group.splice(i, 2, {
                    type: "textord",
                    mode: "text",
                    loc: SourceLocation.range(a, group[i + 1]),
                    text: v + v
                  });
                  n -= 1;
                }
              }
            };
            _proto.parseSymbol = function parseSymbol() {
              var nucleus = this.fetch();
              var text4 = nucleus.text;
              if (/^\\verb[^a-zA-Z]/.test(text4)) {
                this.consume();
                var arg = text4.slice(5);
                var star = arg.charAt(0) === "*";
                if (star) {
                  arg = arg.slice(1);
                }
                if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
                  throw new src_ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
                }
                arg = arg.slice(1, -1);
                return {
                  type: "verb",
                  mode: "text",
                  body: arg,
                  star
                };
              }
              if (unicodeSymbols.hasOwnProperty(text4[0]) && !src_symbols[this.mode][text4[0]]) {
                if (this.settings.strict && this.mode === "math") {
                  this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text4[0] + '" used in math mode', nucleus);
                }
                text4 = unicodeSymbols[text4[0]] + text4.substr(1);
              }
              var match2 = combiningDiacriticalMarksEndRegex.exec(text4);
              if (match2) {
                text4 = text4.substring(0, match2.index);
                if (text4 === "i") {
                  text4 = "\u0131";
                } else if (text4 === "j") {
                  text4 = "\u0237";
                }
              }
              var symbol;
              if (src_symbols[this.mode][text4]) {
                if (this.settings.strict && this.mode === "math" && extraLatin.indexOf(text4) >= 0) {
                  this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text4[0] + '" used in math mode', nucleus);
                }
                var group = src_symbols[this.mode][text4].group;
                var loc = SourceLocation.range(nucleus);
                var s;
                if (ATOMS.hasOwnProperty(group)) {
                  var family = group;
                  s = {
                    type: "atom",
                    mode: this.mode,
                    family,
                    loc,
                    text: text4
                  };
                } else {
                  s = {
                    type: group,
                    mode: this.mode,
                    loc,
                    text: text4
                  };
                }
                symbol = s;
              } else if (text4.charCodeAt(0) >= 128) {
                if (this.settings.strict) {
                  if (!supportedCodepoint(text4.charCodeAt(0))) {
                    this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text4[0] + '"' + (" (" + text4.charCodeAt(0) + ")"), nucleus);
                  } else if (this.mode === "math") {
                    this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text4[0] + '" used in math mode', nucleus);
                  }
                }
                symbol = {
                  type: "textord",
                  mode: "text",
                  loc: SourceLocation.range(nucleus),
                  text: text4
                };
              } else {
                return null;
              }
              this.consume();
              if (match2) {
                for (var i = 0; i < match2[0].length; i++) {
                  var accent = match2[0][i];
                  if (!unicodeAccents[accent]) {
                    throw new src_ParseError("Unknown accent ' " + accent + "'", nucleus);
                  }
                  var command = unicodeAccents[accent][this.mode];
                  if (!command) {
                    throw new src_ParseError("Accent " + accent + " unsupported in " + this.mode + " mode", nucleus);
                  }
                  symbol = {
                    type: "accent",
                    mode: this.mode,
                    loc: SourceLocation.range(nucleus),
                    label: command,
                    isStretchy: false,
                    isShifty: true,
                    base: symbol
                  };
                }
              }
              return symbol;
            };
            return Parser4;
          }();
          Parser_Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
          Parser_Parser.endOfGroup = {
            "[": "]",
            "{": "}",
            "\\begingroup": "\\endgroup"
          };
          Parser_Parser.SUPSUB_GREEDINESS = 1;
          var parseTree_parseTree = function parseTree(toParse, settings) {
            if (!(typeof toParse === "string" || toParse instanceof String)) {
              throw new TypeError("KaTeX can only parse string typed expression");
            }
            var parser = new Parser_Parser(toParse, settings);
            delete parser.gullet.macros.current["\\df@tag"];
            var tree = parser.parse();
            if (parser.gullet.macros.get("\\df@tag")) {
              if (!settings.displayMode) {
                throw new src_ParseError("\\tag works only in display equations");
              }
              parser.gullet.feed("\\df@tag");
              tree = [{
                type: "tag",
                mode: "text",
                body: tree,
                tag: parser.parse()
              }];
            }
            return tree;
          };
          var src_parseTree = parseTree_parseTree;
          var katex_render = function render3(expression, baseNode, options) {
            baseNode.textContent = "";
            var node = katex_renderToDomTree(expression, options).toNode();
            baseNode.appendChild(node);
          };
          if (typeof document !== "undefined") {
            if (document.compatMode !== "CSS1Compat") {
              typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
              katex_render = function render3() {
                throw new src_ParseError("KaTeX doesn't work in quirks mode.");
              };
            }
          }
          var renderToString = function renderToString2(expression, options) {
            var markup = katex_renderToDomTree(expression, options).toMarkup();
            return markup;
          };
          var katex_generateParseTree = function generateParseTree(expression, options) {
            var settings = new Settings_Settings(options);
            return src_parseTree(expression, settings);
          };
          var katex_renderError = function renderError(error2, expression, options) {
            if (options.throwOnError || !(error2 instanceof src_ParseError)) {
              throw error2;
            }
            var node = buildCommon.makeSpan(["katex-error"], [new domTree_SymbolNode(expression)]);
            node.setAttribute("title", error2.toString());
            node.setAttribute("style", "color:" + options.errorColor);
            return node;
          };
          var katex_renderToDomTree = function renderToDomTree(expression, options) {
            var settings = new Settings_Settings(options);
            try {
              var tree = src_parseTree(expression, settings);
              return buildTree_buildTree(tree, expression, settings);
            } catch (error2) {
              return katex_renderError(error2, expression, settings);
            }
          };
          var katex_renderToHTMLTree = function renderToHTMLTree(expression, options) {
            var settings = new Settings_Settings(options);
            try {
              var tree = src_parseTree(expression, settings);
              return buildTree_buildHTMLTree(tree, expression, settings);
            } catch (error2) {
              return katex_renderError(error2, expression, settings);
            }
          };
          var katex_0 = {
            version: "0.12.0",
            render: katex_render,
            renderToString,
            ParseError: src_ParseError,
            __parse: katex_generateParseTree,
            __renderToDomTree: katex_renderToDomTree,
            __renderToHTMLTree: katex_renderToHTMLTree,
            __setFontMetrics: setFontMetrics,
            __defineSymbol: defineSymbol,
            __defineMacro: defineMacro,
            __domTree: {
              Span: domTree_Span,
              Anchor: domTree_Anchor,
              SymbolNode: domTree_SymbolNode,
              SvgNode,
              PathNode: domTree_PathNode,
              LineNode
            }
          };
          var katex_webpack = __webpack_exports__["default"] = katex_0;
        }
      ])["default"];
    });
  }
});

// ../../node_modules/.pnpm/@iktakahiro+markdown-it-katex@4.0.1/node_modules/@iktakahiro/markdown-it-katex/index.js
var require_markdown_it_katex = __commonJS({
  "../../node_modules/.pnpm/@iktakahiro+markdown-it-katex@4.0.1/node_modules/@iktakahiro/markdown-it-katex/index.js"(exports, module2) {
    "use strict";
    var katex = require_katex();
    function isValidDelim(state, pos) {
      var prevChar, nextChar, max = state.posMax, can_open = true, can_close = true;
      prevChar = pos > 0 ? state.src.charCodeAt(pos - 1) : -1;
      nextChar = pos + 1 <= max ? state.src.charCodeAt(pos + 1) : -1;
      if (prevChar === 32 || prevChar === 9 || nextChar >= 48 && nextChar <= 57) {
        can_close = false;
      }
      if (nextChar === 32 || nextChar === 9) {
        can_open = false;
      }
      return {
        can_open,
        can_close
      };
    }
    function math_inline(state, silent) {
      var start, match2, token, res, pos, esc_count;
      if (state.src[state.pos] !== "$") {
        return false;
      }
      res = isValidDelim(state, state.pos);
      if (!res.can_open) {
        if (!silent) {
          state.pending += "$";
        }
        state.pos += 1;
        return true;
      }
      start = state.pos + 1;
      match2 = start;
      while ((match2 = state.src.indexOf("$", match2)) !== -1) {
        pos = match2 - 1;
        while (state.src[pos] === "\\") {
          pos -= 1;
        }
        if ((match2 - pos) % 2 == 1) {
          break;
        }
        match2 += 1;
      }
      if (match2 === -1) {
        if (!silent) {
          state.pending += "$";
        }
        state.pos = start;
        return true;
      }
      if (match2 - start === 0) {
        if (!silent) {
          state.pending += "$$";
        }
        state.pos = start + 1;
        return true;
      }
      res = isValidDelim(state, match2);
      if (!res.can_close) {
        if (!silent) {
          state.pending += "$";
        }
        state.pos = start;
        return true;
      }
      if (!silent) {
        token = state.push("math_inline", "math", 0);
        token.markup = "$";
        token.content = state.src.slice(start, match2);
      }
      state.pos = match2 + 1;
      return true;
    }
    function math_block(state, start, end2, silent) {
      var firstLine, lastLine, next2, lastPos, found = false, token, pos = state.bMarks[start] + state.tShift[start], max = state.eMarks[start];
      if (pos + 2 > max) {
        return false;
      }
      if (state.src.slice(pos, pos + 2) !== "$$") {
        return false;
      }
      pos += 2;
      firstLine = state.src.slice(pos, max);
      if (silent) {
        return true;
      }
      if (firstLine.trim().slice(-2) === "$$") {
        firstLine = firstLine.trim().slice(0, -2);
        found = true;
      }
      for (next2 = start; !found; ) {
        next2++;
        if (next2 >= end2) {
          break;
        }
        pos = state.bMarks[next2] + state.tShift[next2];
        max = state.eMarks[next2];
        if (pos < max && state.tShift[next2] < state.blkIndent) {
          break;
        }
        if (state.src.slice(pos, max).trim().slice(-2) === "$$") {
          lastPos = state.src.slice(0, max).lastIndexOf("$$");
          lastLine = state.src.slice(pos, lastPos);
          found = true;
        }
      }
      state.line = next2 + 1;
      token = state.push("math_block", "math", 0);
      token.block = true;
      token.content = (firstLine && firstLine.trim() ? firstLine + "\n" : "") + state.getLines(start + 1, next2, state.tShift[start], true) + (lastLine && lastLine.trim() ? lastLine : "");
      token.map = [start, state.line];
      token.markup = "$$";
      return true;
    }
    function escapeHtml2(unsafe) {
      return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
    }
    module2.exports = function math_plugin(md, options) {
      options = options || {};
      var katexInline = function(latex) {
        options.displayMode = false;
        try {
          return katex.renderToString(latex, options);
        } catch (error2) {
          if (options.throwOnError) {
            console.log(error2);
          }
          return `<span class='katex-error' title='${escapeHtml2(error2.toString())}'>${escapeHtml2(latex)}</span>`;
        }
      };
      var inlineRenderer = function(tokens, idx) {
        return katexInline(tokens[idx].content);
      };
      var katexBlock = function(latex) {
        options.displayMode = true;
        try {
          return "<p class='katex-block'>" + katex.renderToString(latex, options) + "</p>";
        } catch (error2) {
          if (options.throwOnError) {
            console.log(error2);
          }
          return `<p class='katex-block katex-error' title='${escapeHtml2(error2.toString())}'>${escapeHtml2(latex)}</p>`;
        }
      };
      var blockRenderer = function(tokens, idx) {
        return katexBlock(tokens[idx].content) + "\n";
      };
      md.inline.ruler.after("escape", "math_inline", math_inline);
      md.block.ruler.after("blockquote", "math_block", math_block, {
        alt: ["paragraph", "reference", "blockquote", "list"]
      });
      md.renderer.rules.math_inline = inlineRenderer;
      md.renderer.rules.math_block = blockRenderer;
    };
  }
});

// ../../node_modules/.pnpm/html-to-md@0.8.8/node_modules/html-to-md/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/.pnpm/html-to-md@0.8.8/node_modules/html-to-md/dist/index.js"(exports, module2) {
    !function(t2, e) {
      "object" === typeof exports && "object" === typeof module2 ? module2.exports = e() : "function" === typeof define && define.amd ? define([], e) : "object" === typeof exports ? exports.html2md = e() : t2.html2md = e();
    }(exports, function() {
      return function(t2) {
        var e = {};
        function r(n) {
          if (e[n])
            return e[n].exports;
          var o = e[n] = { i: n, l: false, exports: {} };
          return t2[n].call(o.exports, o, o.exports, r), o.l = true, o.exports;
        }
        return r.m = t2, r.c = e, r.d = function(t3, e2, n) {
          r.o(t3, e2) || Object.defineProperty(t3, e2, { enumerable: true, get: n });
        }, r.r = function(t3) {
          "undefined" !== typeof Symbol && Symbol.toStringTag && Object.defineProperty(t3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t3, "__esModule", { value: true });
        }, r.t = function(t3, e2) {
          if (1 & e2 && (t3 = r(t3)), 8 & e2)
            return t3;
          if (4 & e2 && "object" === typeof t3 && t3 && t3.__esModule)
            return t3;
          var n = /* @__PURE__ */ Object.create(null);
          if (r.r(n), Object.defineProperty(n, "default", { enumerable: true, value: t3 }), 2 & e2 && "string" != typeof t3)
            for (var o in t3)
              r.d(n, o, function(e3) {
                return t3[e3];
              }.bind(null, o));
          return n;
        }, r.n = function(t3) {
          var e2 = t3 && t3.__esModule ? function() {
            return t3.default;
          } : function() {
            return t3;
          };
          return r.d(e2, "a", e2), e2;
        }, r.o = function(t3, e2) {
          return Object.prototype.hasOwnProperty.call(t3, e2);
        }, r.p = "", r(r.s = 46);
      }([function(t2, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var n = r(1), o = r(12), i = r(6), a = r(7), c = r(2), u = function() {
          function t3(t4, e2, r2) {
            var o2 = void 0 === r2 ? {} : r2, i2 = o2.keepSpace, a2 = void 0 !== i2 && i2, c2 = o2.prevTagName, u2 = void 0 === c2 ? "" : c2, s = o2.nextTagName, p = void 0 === s ? "" : s, l = o2.prevTagStr, f = void 0 === l ? "" : l, h2 = o2.nextTagStr, d = void 0 === h2 ? "" : h2, _ = o2.parentTag, y = void 0 === _ ? "" : _, v = o2.isFirstSubTag, g = void 0 === v || v, b = o2.calcLeading, m = void 0 !== b && b, O = o2.leadingSpace, S = void 0 === O ? "" : O, T = o2.layer, x = void 0 === T ? 1 : T, j = o2.noWrap, w = void 0 !== j && j, P = o2.prevHasEndSpace, M = void 0 !== P && P, E = o2.prevHasStartSpace, N = void 0 !== E && E, C = o2.match, L = void 0 === C ? null : C, k = o2.indentSpace, A = void 0 === k ? "" : k, H = o2.language, W = void 0 === H ? "" : H, V = o2.count, R = void 0 === V ? 1 : V, I = o2.tableColumnCount, q = void 0 === I ? 0 : I, D = o2.noExtraLine, U = void 0 !== D && D, B = o2.inTable, F = void 0 !== B && B;
            if (this.tagName = e2, this.rawStr = t4, this.parentTag = y, this.prevTagName = u2, this.nextTagName = p, this.prevTagStr = f, this.nextTagStr = d, this.isFirstSubTag = g, this.calcLeading = m, this.leadingSpace = S, this.layer = x, this.noWrap = w, this.match = L, this.indentSpace = A, this.language = W, this.count = R, this.inTable = F, this.tableColumnCount = q, this.noExtraLine = U, this.prevHasEndSpace = M, this.prevHasStartSpace = N, this.hasStartSpace = false, this.hasEndSpace = false, this.keepSpace = a2, !this.__detectStr__(t4, this.tagName))
              return this.attrs = {}, void (this.innerHTML = "");
            var G = this.__fetchTagAttrAndInnerHTML__(t4), $2 = G.attr, J = G.innerHTML;
            J.startsWith(" ") && (0, n.isSpacePassingTag)(e2) && (this.hasStartSpace = true), J.endsWith(" ") && (0, n.isSpacePassingTag)(e2) && (this.hasEndSpace = true), this.attrs = $2, this.innerHTML = J;
          }
          return t3.prototype.__detectStr__ = function(t4, e2) {
            if ("<" !== t4[0])
              return "Not a valid tag, current tag name: ".concat(this.tagName, ", tag content: ").concat(t4), false;
            for (var r2 = "", n2 = false, o2 = 1; o2 < t4.length && ">" !== t4[o2]; o2++)
              !n2 && /(\s|\/)/.test(t4[o2]) && (n2 = true), n2 || (r2 += t4[o2]);
            return r2 === e2;
          }, t3.prototype.__fetchTagAttrAndInnerHTML__ = function(t4) {
            for (var e2 = "", r2 = 1; r2 < t4.length && ">" !== t4[r2]; r2++)
              e2 += t4[r2];
            for (var o2 = t4.slice(r2 + 1), i2 = "", a2 = -1, c2 = o2.length - 1; c2 >= 0; c2--)
              if ((i2 = o2[c2] + i2).startsWith("</")) {
                i2.startsWith("</" + this.tagName + ">") && (a2 = c2);
                break;
              }
            -1 === a2 && (0, n.isSelfClosing)(this.tagName) && this.tagName;
            var u2 = (0, n.getTagAttributes)(e2);
            return this.tagName && delete u2[this.tagName], { attr: u2, innerHTML: o2.slice(0, a2) };
          }, t3.prototype.__onlyLeadingSpace__ = function(t4) {
            t4 = t4.trim();
            for (var e2 = 0; e2 < t4.length; e2++)
              if (t4[e2] !== i.SINGLE)
                return false;
            return true;
          }, t3.prototype.__isEmpty__ = function(t4) {
            return !this.keepSpace && ("" === t4 && "td" !== this.tagName || this.calcLeading && this.__onlyLeadingSpace__(t4));
          }, t3.prototype.getValidSubTagName = function(t4) {
            return t4;
          }, t3.prototype.beforeParse = function() {
            var t4 = c.default.get().tagListener;
            if (t4) {
              var e2 = t4(this.tagName, { parentTag: this.parentTag, prevTagName: this.prevTagName, nextTagName: this.nextTagName, isFirstSubTag: this.isFirstSubTag, attrs: this.attrs, innerHTML: this.innerHTML, language: this.language, match: this.match, isSelfClosing: false }), r2 = e2.attrs, n2 = e2.language, o2 = e2.match;
              this.attrs = r2, "string" === typeof n2 && (this.language = n2), "undefined" !== typeof o2 && (this.match = o2);
            }
            return "";
          }, t3.prototype.parseValidSubTag = function(t4, e2, r2) {
            var o2 = new ((0, n.getTagConstructor)(e2))(t4, e2, r2);
            return [o2.exec(), o2];
          }, t3.prototype.parseOnlyString = function(t4, e2, r2) {
            var n2 = new o.default(t4, e2, r2);
            return [n2.exec(), n2];
          }, t3.prototype.afterParsed = function(t4) {
            return t4;
          }, t3.prototype.slim = function(t4) {
            return this.keepSpace ? t4 : t4.trim();
          }, t3.prototype.beforeMergeSpace = function(t4) {
            return t4;
          }, t3.prototype.mergeSpace = function(t4, e2, r2) {
            return this.keepSpace && "pre" !== this.tagName ? t4.endsWith("\n") ? t4 : t4 + r2.replace(/\n+/g, "\n") : e2 + t4 + r2;
          }, t3.prototype.afterMergeSpace = function(t4) {
            return t4;
          }, t3.prototype.beforeReturn = function(t4) {
            return !((0, n.isSpacePassingTag)(this.prevTagName) && this.prevHasEndSpace || (0, n.isSpacePassingTag)(this.tagName) && this.hasStartSpace) || /^\s+/.test(t4) || /\s+$/.test(this.prevTagStr) ? t4 : " " + t4;
          }, t3.prototype.exec = function(t4, e2) {
            void 0 === t4 && (t4 = ""), void 0 === e2 && (e2 = "");
            for (var r2 = this.beforeParse(), o2 = (0, n.generateGetNextValidTag)(this.innerHTML), i2 = o2(), c2 = i2[0], u2 = i2[1], s = null, p = false, l = false; "" !== u2; ) {
              var f, h2 = o2(), d = h2[0], _ = h2[1], y = { parentTag: this.tagName, nextTagName: d, nextTagStr: _, prevTagName: s, prevTagStr: r2, prevHasEndSpace: l, prevHasStartSpace: p, leadingSpace: this.leadingSpace, layer: this.layer, keepSpace: this.keepSpace, inTable: this.inTable, calcLeading: ("li" === this.tagName || "ol" === this.tagName || "ul" === this.tagName) && this.calcLeading }, v = void 0, g = void 0;
              if (null != c2)
                v = (f = this.parseValidSubTag(u2, c2, y))[0], g = f[1];
              else
                v = (f = this.parseOnlyString(u2, c2, y))[0], g = f[1];
              l = (null === g || void 0 === g ? void 0 : g.hasEndSpace) || false, p = (null === g || void 0 === g ? void 0 : g.hasStartSpace) || false;
              var b = this.getValidSubTagName(c2);
              c2 = d, u2 = _, null == b && this.__isEmpty__(v) || (!this.keepSpace && (0, a.default)(s) && (0, a.default)(b) && (r2 = r2.replace(/\n+$/, "\n"), v = v.replace(/^\n+/, "\n")), s = b, this.isFirstSubTag = false, r2 += v);
            }
            return r2 = this.afterParsed(r2), r2 = this.slim(r2), this.__isEmpty__(r2) ? "" : (r2 = this.beforeMergeSpace(r2), !this.noExtraLine && (0, a.default)(this.tagName) && this.prevTagName && !r2.startsWith("\n") && !(0, a.default)(this.prevTagName) && this.parentTag && (t4 = "\n\n"), r2 = this.mergeSpace(r2, t4, e2), this.noWrap && !this.keepSpace && (r2 = r2.replace(/\s+/g, " ")), r2 = this.afterMergeSpace(r2), r2 = this.beforeReturn(r2));
          }, t3;
        }();
        e.default = u;
      }, function(t2, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.isSpacePassingTag = e.isIndependentTag = e.clearComment = e.getLanguage = e.getTableAlign = e.getTagAttributes = e.isSelfClosing = e.generateGetNextValidTag = e.getTagConstructor = e.getRealTagName = e.unescapeStr = e.extraEscape = void 0;
        var n = r(18);
        Object.defineProperty(e, "extraEscape", { enumerable: true, get: function() {
          return n.extraEscape;
        } }), Object.defineProperty(e, "unescapeStr", { enumerable: true, get: function() {
          return n.unescapeStr;
        } });
        var o = r(47);
        e.generateGetNextValidTag = o.default;
        var i = r(48);
        e.getTagConstructor = i.default;
        var a = r(11);
        e.isSelfClosing = a.default;
        var c = r(51);
        e.getTagAttributes = c.default;
        var u = r(52);
        e.getLanguage = u.default;
        var s = r(53);
        e.clearComment = s.default;
        var p = r(13);
        e.getRealTagName = p.default;
        var l = r(7);
        e.isIndependentTag = l.default;
        var f = r(54);
        e.isSpacePassingTag = f.default;
        var h2 = r(55);
        e.getTableAlign = h2.default;
      }, function(t2, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var n = function() {
          function t3(t4) {
            var e2 = void 0 === t4 ? {} : t4, r2 = e2.skipTags, n2 = void 0 === r2 ? [] : r2, o2 = e2.emptyTags, i2 = void 0 === o2 ? [] : o2, a = e2.ignoreTags, c = void 0 === a ? [] : a, u = e2.aliasTags, s = void 0 === u ? {} : u, p = e2.renderCustomTags, l = void 0 === p || p, f = e2.tagListener, h2 = void 0 === f ? function(t5, e3) {
              return e3;
            } : f;
            this.options = { skipTags: n2, emptyTags: i2, ignoreTags: c, aliasTags: s, renderCustomTags: l, tagListener: h2 };
          }
          return t3.prototype.get = function() {
            return this.options;
          }, t3.prototype.clear = function() {
            this.options = {};
          }, t3.prototype.set = function(t4, e2) {
            var r2 = this;
            t4 && "[object Object]" === Object.prototype.toString.call(t4) && Object.keys(t4).forEach(function(n2) {
              e2 ? r2.options[n2] = t4[n2] : function(t5, e3, r3) {
                if (!(r3 in t5))
                  return void (t5[r3] = e3[r3]);
                var n3 = Array.isArray(t5[r3]), o2 = "[object Object]" === Object.prototype.toString.call(t5[r3]);
                t5[r3] = n3 ? t5[r3].concat(e3[r3]) : o2 ? Object.assign(t5[r3], e3[r3]) : e3[r3];
              }(r2.options, t4, n2);
            });
          }, t3.prototype.reset = function() {
            this.options = JSON.parse(JSON.stringify(o)), this.options.tagListener = function(t4, e2) {
              return e2;
            };
          }, t3;
        }();
        var o = { ignoreTags: ["", "style", "head", "!doctype", "form", "svg", "noscript", "script", "meta"], skipTags: ["div", "html", "body", "nav", "section", "footer", "main", "aside", "article", "header"], emptyTags: [], aliasTags: { figure: "p", dl: "p", dd: "p", dt: "p", figcaption: "p" }, renderCustomTags: true }, i = new n();
        i.reset(), e.default = i;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = function(t3) {
          function e2(e3, r2) {
            void 0 === r2 && (r2 = "h1");
            var n2 = t3.call(this, e3, r2) || this;
            return n2.match = "#", n2;
          }
          return n(e2, t3), e2.prototype.beforeMergeSpace = function(t4) {
            return this.match + " " + t4;
          }, e2.prototype.exec = function(e3, r2) {
            return e3 || (e3 = "\n"), r2 || (r2 = "\n"), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(r(0).default);
        e.default = o;
      }, function(t2, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var n = r(1), o = r(2), i = function() {
          function t3(t4, e2, r2) {
            var n2 = void 0 === r2 ? {} : r2, o2 = n2.parentTag, i2 = void 0 === o2 ? "" : o2, a = n2.leadingSpace, c = void 0 === a ? "" : a, u = n2.layer, s = void 0 === u ? 1 : u, p = n2.isFirstSubTag, l = void 0 !== p && p, f = n2.inTable, h2 = void 0 !== f && f, d = n2.match, _ = void 0 === d ? null : d, y = n2.prevTagName, v = void 0 === y ? "" : y, g = n2.nextTagName, b = void 0 === g ? "" : g;
            if (this.tagName = e2, this.rawStr = t4, this.parentTag = i2, this.isFirstSubTag = l, this.prevTagName = v, this.nextTagName = b, this.leadingSpace = c, this.layer = s, this.innerHTML = "", this.match = _, this.inTable = h2, this.__detectStr__(t4, this.tagName)) {
              var m = this.__fetchTagAttr__(t4).attr;
              this.attrs = m;
            } else
              this.attrs = {};
          }
          return t3.prototype.__detectStr__ = function(t4, e2) {
            if ("<" !== t4[0])
              return "Not a valid tag, current tag name: ".concat(this.tagName, ", tag content: ").concat(t4), false;
            for (var r2 = "", n2 = false, o2 = 1; o2 < t4.length && ">" !== t4[o2]; o2++)
              !n2 && /(\s|\/)/.test(t4[o2]) && (n2 = true), n2 || (r2 += t4[o2]);
            return r2 === e2;
          }, t3.prototype.__fetchTagAttr__ = function(t4) {
            for (var e2 = "", r2 = 1; r2 < t4.length && ">" !== t4[r2]; r2++)
              e2 += t4[r2];
            return { attr: (0, n.getTagAttributes)(e2) };
          }, t3.prototype.beforeParse = function() {
            var t4 = o.default.get().tagListener;
            if (t4) {
              var e2 = t4(this.tagName, { parentTag: this.parentTag, prevTagName: this.prevTagName, nextTagName: this.nextTagName, isFirstSubTag: this.isFirstSubTag, attrs: this.attrs, innerHTML: this.innerHTML, match: this.match, isSelfClosing: true }), r2 = e2.attrs, n2 = e2.match;
              this.attrs = r2, this.match = n2;
            }
            return "";
          }, t3.prototype.beforeMergeSpace = function(t4) {
            return t4;
          }, t3.prototype.afterMergeSpace = function(t4) {
            return t4;
          }, t3.prototype.beforeReturn = function(t4) {
            return t4;
          }, t3.prototype.exec = function(t4, e2) {
            void 0 === t4 && (t4 = ""), void 0 === e2 && (e2 = "");
            var r2 = this.beforeParse();
            return r2 = t4 + (r2 = this.beforeMergeSpace(r2)) + e2, r2 = this.afterMergeSpace(r2), r2 = this.beforeReturn(r2);
          }, t3;
        }();
        e.default = i;
      }, function(t2, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var n = function() {
          function t3() {
          }
          return t3.prototype.exec = function() {
            return "";
          }, t3;
        }();
        e.default = n;
      }, function(t2, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.TRIPLE = e.DOUBLE = e.SINGLE = void 0;
        e.SINGLE = "\u2608";
        e.DOUBLE = "\u2608\u2608";
        e.TRIPLE = "\u2608\u2608\u2608";
      }, function(t2, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var n = r(13), o = { html: true, body: true, p: true, div: true, pre: true, section: true, blockquote: true, aside: true, li: true, ul: true, ol: true, form: true, hr: true, h1: true, h2: true, h3: true, h4: true, h5: true, h6: true, dl: true, dd: true, dt: true, br: true, table: true };
        e.default = function(t3) {
          if (!t3)
            return false;
          var e2 = (0, n.default)(t3);
          return !!e2 && !!o[e2];
        };
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }(), o = this && this.__assign || function() {
          return (o = Object.assign || function(t3) {
            for (var e2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
              for (var o2 in e2 = arguments[r2])
                Object.prototype.hasOwnProperty.call(e2, o2) && (t3[o2] = e2[o2]);
            return t3;
          }).apply(this, arguments);
        };
        Object.defineProperty(e, "__esModule", { value: true }), e.__EmptySelfClose__ = e.__Empty__ = void 0;
        var i = r(0), a = r(4), c = function(t3) {
          function e2(e3, r2, n2) {
            return void 0 === r2 && (r2 = "__empty__"), t3.call(this, e3, r2, n2) || this;
          }
          return n(e2, t3), e2.prototype.slim = function(t4) {
            return t4;
          }, e2.prototype.parseValidSubTag = function(r2, n2, i2) {
            if ("__skip__" === this.tagName)
              return t3.prototype.parseValidSubTag.call(this, r2, n2, i2);
            var a2 = new e2(r2, n2, o({}, i2));
            return [a2.exec(), a2];
          }, e2.prototype.parseOnlyString = function(e3, r2, n2) {
            return "__skip__" === this.tagName ? t3.prototype.parseOnlyString.call(this, e3, r2, n2) : [e3, null];
          }, e2.prototype.exec = function() {
            return t3.prototype.exec.call(this, "", "");
          }, e2;
        }(i.default);
        e.__Empty__ = c;
        var u = function(t3) {
          function e2(e3, r2) {
            void 0 === r2 && (r2 = "__emptyselfclose__");
            var n2 = t3.call(this, e3, r2) || this;
            return n2.tagName = r2, n2;
          }
          return n(e2, t3), e2.prototype.exec = function() {
            return t3.prototype.exec.call(this, "", "");
          }, e2;
        }(a.default);
        e.__EmptySelfClose__ = u;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true }), e.__SkipSelfClose__ = e.__Skip__ = void 0;
        var o = r(0), i = r(4), a = r(1), c = function(t3) {
          function e2(e3, r2, n2) {
            void 0 === r2 && (r2 = "__skip__");
            var o2 = t3.call(this, e3, r2, n2) || this;
            return o2.noNeedWrap = ["td", "th"], o2;
          }
          return n(e2, t3), e2.prototype.exec = function() {
            var e3 = (0, a.isIndependentTag)((0, a.getRealTagName)(this.tagName)) && (!this.parentTag || !this.noNeedWrap.includes(this.parentTag)), r2 = e3 ? "\n" : "", n2 = e3 ? "\n" : "";
            return t3.prototype.exec.call(this, r2, n2);
          }, e2;
        }(o.default);
        e.__Skip__ = c;
        var u = function(t3) {
          function e2(e3, r2, n2) {
            return void 0 === r2 && (r2 = "__skipselfclose__"), t3.call(this, e3, r2, n2) || this;
          }
          return n(e2, t3), e2.prototype.exec = function() {
            return "";
          }, e2;
        }(i.default);
        e.__SkipSelfClose__ = u;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true }), e.__NoMatchSelfClose__ = e.__NoMatch__ = void 0;
        var o = r(0), i = r(4), a = function(t3) {
          function e2(e3, r2) {
            return void 0 === r2 && (r2 = "__nomatch__"), t3.call(this, e3, r2) || this;
          }
          return n(e2, t3), e2.prototype.beforeMergeSpace = function(t4) {
            return "<".concat(this.tagName, ">").concat(t4, "</").concat(this.tagName, ">");
          }, e2.prototype.exec = function() {
            return t3.prototype.exec.call(this, "", "");
          }, e2;
        }(o.default);
        e.__NoMatch__ = a;
        var c = function(t3) {
          function e2(e3, r2) {
            return void 0 === r2 && (r2 = "__nomatchselfclose__"), t3.call(this, e3, r2) || this;
          }
          return n(e2, t3), e2.prototype.exec = function() {
            return "<".concat(this.tagName, " />");
          }, e2;
        }(i.default);
        e.__NoMatchSelfClose__ = c;
      }, function(t2, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var n = { img: true, hr: true, input: true, br: true, meta: true, link: true, "!doctype": true, base: true, col: true, area: true, param: true, object: true, embed: true, keygen: true, source: true };
        e.default = function(t3) {
          return null != t3 && !!n[t3.toLowerCase()];
        };
      }, function(t2, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var n = r(1), o = r(7), i = function() {
          function t3(t4, e2, r2) {
            void 0 === e2 && (e2 = "__nomatch__");
            var n2 = void 0 === r2 ? {} : r2, o2 = n2.keepSpace, i2 = void 0 !== o2 && o2, a = n2.prevTagName, c = void 0 === a ? "" : a, u = n2.nextTagName, s = void 0 === u ? "" : u, p = n2.prevTagStr, l = void 0 === p ? "" : p, f = n2.prevHasEndSpace, h2 = void 0 !== f && f, d = n2.prevHasStartSpace, _ = void 0 !== d && d, y = n2.parentTag, v = void 0 === y ? "" : y, g = n2.calcLeading, b = void 0 !== g && g, m = n2.layer, O = void 0 === m ? 1 : m, S = n2.leadingSpace, T = void 0 === S ? "" : S, x = n2.inTable, j = void 0 !== x && x;
            this.tagName = e2, this.nextTagName = s, this.prevTagName = c, this.parentTag = v, this.prevTagStr = l, this.keepSpace = i2, this.calcLeading = b, this.leadingSpace = T, this.layer = O, this.rawStr = t4, this.inTable = j, this.prevHasEndSpace = h2, this.prevHasStartSpace = _, this.hasEndSpace = false, this.hasStartSpace = false, t4.startsWith(" ") && (this.hasStartSpace = true), t4.endsWith(" ") && (this.hasEndSpace = true);
          }
          return t3.prototype.slim = function(t4) {
            if (this.keepSpace)
              return t4;
            var e2 = t4.replace(/\s+/g, " ");
            return (0, o.default)(this.prevTagName) && (e2 = e2.trimLeft()), (0, o.default)(this.nextTagName) && (e2 = e2.trimRight()), e2;
          }, t3.prototype.beforeReturn = function(t4) {
            if (this.keepSpace)
              return t4;
            if (this.calcLeading)
              return this.leadingSpace + (0, n.extraEscape)(t4);
            var e2 = (0, n.extraEscape)(t4);
            return this.inTable && (e2 = e2.replace(/\|/g, "\\|")), this.prevTagName, this.prevHasEndSpace, this.prevTagStr, (0, n.isSpacePassingTag)(this.prevTagName) && this.prevHasEndSpace && !/^\s+/.test(t4) && !/\s+$/.test(this.prevTagStr) ? " " + t4 : e2;
          }, t3.prototype.exec = function() {
            var t4 = this.rawStr;
            return t4 = this.slim(t4), t4 = this.beforeReturn(t4);
          }, t3;
        }();
        e.default = i;
      }, function(t2, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var n = r(2);
        e.default = function(t3) {
          if (!t3)
            return t3;
          var e2 = n.default.get().aliasTags;
          return null != (null === e2 || void 0 === e2 ? void 0 : e2[t3]) ? e2[t3] : t3;
        };
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = function(t3) {
          function e2(e3, r2, n2) {
            void 0 === r2 && (r2 = "strong");
            var o2 = t3.call(this, e3, r2, n2) || this;
            return o2.layer = 1, o2.match = o2.match || "**", o2;
          }
          return n(e2, t3), e2.prototype.beforeMergeSpace = function(t4) {
            return this.match + t4 + this.match;
          }, e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), null != this.match && this.prevTagStr && !this.prevTagStr.endsWith("\\" + this.match[0]) && this.prevTagStr.endsWith(this.match[0]) && (e3 = " "), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(r(0).default);
        e.default = o;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = function(t3) {
          function e2(e3, r2) {
            void 0 === r2 && (r2 = "del");
            var n2 = t3.call(this, e3, r2) || this;
            return n2.match = n2.match || "~~", n2;
          }
          return n(e2, t3), e2.prototype.beforeMergeSpace = function(t4) {
            return this.match + t4 + this.match;
          }, e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(r(0).default);
        e.default = o;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = function(t3) {
          function e2(e3, r2, n2) {
            void 0 === r2 && (r2 = "em");
            var o2 = t3.call(this, e3, r2, n2) || this;
            return o2.match = o2.match || "*", o2;
          }
          return n(e2, t3), e2.prototype.beforeMergeSpace = function(t4) {
            return this.match + t4 + this.match;
          }, e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), "strong" === this.parentTag && this.nextTagStr && (r2 = " "), null != this.match && this.prevTagStr && !this.prevTagStr.endsWith("\\" + this.match) && this.prevTagStr.endsWith(this.match) && (e3 = " "), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(r(0).default);
        e.default = o;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = function(t3) {
          function e2(e3, r2, n2) {
            void 0 === r2 && (r2 = "th");
            var o2 = t3.call(this, e3, r2, n2) || this;
            return o2.tagName = r2, o2;
          }
          return n(e2, t3), e2.prototype.beforeMergeSpace = function(t4) {
            return t4 + "|";
          }, e2.prototype.parseValidSubTag = function(e3, r2, n2) {
            return "ul" === r2 || "ol" === r2 || "table" === r2 || "pre" === r2 ? [e3.replace(/([\n\r])/g, ""), null] : t3.prototype.parseValidSubTag.call(this, e3, r2, n2);
          }, e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(r(0).default);
        e.default = o;
      }, function(t2, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.unescapeStr = e.extraEscape = e.escapeStr = void 0;
        var n = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'", "&apos;": "'", "&#x60;": "`", "&ldquo;": "\u201C", "&rdquo;": "\u201D" }, o = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;", "`": "&#x60;", "\u201C": "&ldquo;", "\u201D": "&rdquo;" }, i = /[&<>"'`\u201c\u201d]/g, a = RegExp(i.source), c = /&(?:amp|lt|gt|quot|#39|apos|#x60|ldquo|rdquo);/g, u = RegExp(c.source), s = [[/\\/g, "\\\\"], [/\*/g, "\\*"], [/^-/g, "\\-"], [/^\+ /g, "\\+ "], [/^(=+)/g, "\\$1"], [/^(#{1,6}) /g, "\\$1 "], [/`/g, "\\`"], [/^~~~/g, "\\~~~"], [/\[/g, "\\["], [/\]/g, "\\]"], [/^>/g, "\\>"], [/_/g, "\\_"], [/^(\d+)\. /g, "$1\\. "]];
        e.escapeStr = function(t3) {
          return t3 && a.test(t3) ? t3.replace(i, function(t4) {
            return o[t4];
          }) : t3;
        }, e.unescapeStr = function(t3) {
          return t3 = t3 && u.test(t3) ? t3.replace(c, function(t4) {
            return n[t4];
          }) : t3;
        }, e.extraEscape = function(t3) {
          return s.reduce(function(t4, e2) {
            return t4.replace(e2[0], e2[1]);
          }, t3);
        };
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = function(t3) {
          function e2(e3, r2, n2) {
            return void 0 === r2 && (r2 = "a"), t3.call(this, e3, r2, n2) || this;
          }
          return n(e2, t3), e2.prototype.beforeMergeSpace = function(t4) {
            var e3 = this.attrs, r2 = e3.href, n2 = e3.title, o2 = r2 || "";
            return n2 ? "[".concat(t4, "](").concat(o2, ' "').concat(n2, '")') : "[".concat(t4, "](").concat(o2, ")");
          }, e2.prototype.parseOnlyString = function(e3, r2, n2) {
            return "tbody" === this.parentTag || "thead" === this.parentTag ? [e3, null] : t3.prototype.parseOnlyString.call(this, e3, r2, n2);
          }, e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(r(0).default);
        e.default = o;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = function(t3) {
          function e2(e3, r2, n2) {
            return void 0 === r2 && (r2 = "b"), t3.call(this, e3, r2, n2) || this;
          }
          return n(e2, t3), e2.prototype.exec = function(e3, r2) {
            return t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(r(14).default);
        e.default = o;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }(), o = this && this.__assign || function() {
          return (o = Object.assign || function(t3) {
            for (var e2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
              for (var o2 in e2 = arguments[r2])
                Object.prototype.hasOwnProperty.call(e2, o2) && (t3[o2] = e2[o2]);
            return t3;
          }).apply(this, arguments);
        };
        Object.defineProperty(e, "__esModule", { value: true });
        var i = r(7), a = r(0), c = r(1), u = function(t3) {
          function e2(e3, r2, n2) {
            void 0 === r2 && (r2 = "blockquote");
            var o2 = t3.call(this, e3, r2, n2) || this;
            return o2.match = o2.match || ">", o2.fillPerLine = o2.fillPerLine.bind(o2), o2;
          }
          return n(e2, t3), e2.prototype.beforeMergeSpace = function(t4) {
            if ("" === t4.trim())
              return "";
            var e3 = this.match + " " + t4;
            return this.calcLeading ? this.leadingSpace + e3 : e3;
          }, e2.prototype.afterMergeSpace = function(t4) {
            for (var e3 = this, r2 = t4.split("\n"), n2 = r2.length - 1; n2 >= 0; n2--)
              n2 < r2.length - 1 && ">" === r2[n2].trim() && ">" === r2[n2 + 1].trim() && r2.splice(n2, 1);
            return (r2 = r2.map(function(t5) {
              return "" === t5 ? "" : e3.fillPerLine(t5);
            })).join("\n");
          }, e2.prototype.beforeReturn = function(t4) {
            return t4.replace("\n\n", "\n");
          }, e2.prototype.fillPerLine = function(t4) {
            var e3 = ">";
            if (this.calcLeading && (e3 = this.leadingSpace + ">"), !t4.startsWith(e3)) {
              var r2 = this.match + " " + t4;
              return this.calcLeading ? this.leadingSpace + r2 : r2;
            }
            return t4;
          }, e2.prototype.parseValidSubTag = function(t4, e3, r2) {
            var n2;
            "blockquote" === e3 ? n2 = new ((0, c.getTagConstructor)(e3))(t4, e3, o(o({}, r2), { calcLeading: this.calcLeading, match: this.match + ">", noExtraLine: true })) : n2 = new ((0, c.getTagConstructor)(e3))(t4, e3, o(o({}, r2), { noExtraLine: true }));
            var a2 = n2.exec(), u2 = "";
            this.calcLeading && (u2 = this.leadingSpace);
            var s = (0, i.default)(r2.prevTagName) && "br" !== r2.prevTagName, p = (0, i.default)(r2.nextTagName) && "br" !== r2.nextTagName, l = (0, i.default)(e3) && "br" !== e3;
            return this.isFirstSubTag ? [a2.trimLeft().replace(u2, ""), n2] : l ? (a2 = u2 + this.match + a2, s || (a2 = "\n" + a2), !p && r2.nextTagStr && r2.nextTagStr.trim() && (a2 += this.match + "\n"), [a2, n2]) : s ? [u2 + this.match + "\n" + a2, n2] : [a2, n2];
          }, e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(a.default);
        e.default = u;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = r(4), i = r(18), a = function(t3) {
          function e2(e3, r2, n2) {
            return void 0 === r2 && (r2 = "b"), t3.call(this, e3, r2, n2) || this;
          }
          return n(e2, t3), e2.prototype.exec = function(t4, e3) {
            return void 0 === e3 && (e3 = "\n"), this.inTable ? (0, i.escapeStr)("<br />") : "  " + e3;
          }, e2;
        }(o.default);
        e.default = a;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }(), o = this && this.__assign || function() {
          return (o = Object.assign || function(t3) {
            for (var e2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
              for (var o2 in e2 = arguments[r2])
                Object.prototype.hasOwnProperty.call(e2, o2) && (t3[o2] = e2[o2]);
            return t3;
          }).apply(this, arguments);
        };
        Object.defineProperty(e, "__esModule", { value: true });
        var i = r(0), a = r(1), c = function(t3) {
          function e2(e3, r2, n2) {
            void 0 === r2 && (r2 = "code");
            var o2 = t3.call(this, e3, r2, n2) || this;
            return o2.match = null == o2.match ? "`" : o2.match, o2.noWrap = "`" === o2.match, o2.layer = 1, o2;
          }
          return n(e2, t3), e2.prototype.beforeMergeSpace = function(t4) {
            var e3, r2;
            return "" !== this.match && "`" !== this.match ? (e3 = this.match + " ", r2 = " " + this.match) : (e3 = this.match, r2 = this.match), e3 + t4 + r2;
          }, e2.prototype.parseValidSubTag = function(t4, e3, r2) {
            var n2;
            return "pre" === e3 ? [(n2 = new ((0, a.getTagConstructor)(e3))(t4, e3, o(o({}, r2), { language: "", match: "" }))).exec("", "\n"), n2] : [(n2 = new ((0, a.getTagConstructor)(e3))(t4, e3, o(o({}, r2), { keepSpace: this.keepSpace, noWrap: this.noWrap }))).exec("", ""), n2];
          }, e2.prototype.parseOnlyString = function(t4) {
            if ("" !== this.match && t4) {
              var e3 = 1;
              (t4.startsWith("`") || t4.endsWith("`")) && (e3 = 2, (t4.startsWith("``") || t4.endsWith("``")) && (e3 = 3)), this.match = "`".repeat(e3);
            }
            return [(0, a.unescapeStr)(t4), null];
          }, e2.prototype.slim = function(t4) {
            return this.keepSpace ? t4 : t4.trim();
          }, e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(i.default);
        e.default = c;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = function(t3) {
          function e2(e3, r2) {
            void 0 === r2 && (r2 = "h1");
            var n2 = t3.call(this, e3, r2) || this;
            return n2.match = "#", n2;
          }
          return n(e2, t3), e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(r(3).default);
        e.default = o;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = function(t3) {
          function e2(e3, r2) {
            void 0 === r2 && (r2 = "h2");
            var n2 = t3.call(this, e3, r2) || this;
            return n2.match = "##", n2;
          }
          return n(e2, t3), e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(r(3).default);
        e.default = o;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = function(t3) {
          function e2(e3, r2) {
            void 0 === r2 && (r2 = "h3");
            var n2 = t3.call(this, e3, r2) || this;
            return n2.match = "###", n2;
          }
          return n(e2, t3), e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(r(3).default);
        e.default = o;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = function(t3) {
          function e2(e3, r2) {
            void 0 === r2 && (r2 = "h4");
            var n2 = t3.call(this, e3, r2) || this;
            return n2.match = "####", n2;
          }
          return n(e2, t3), e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(r(3).default);
        e.default = o;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = function(t3) {
          function e2(e3, r2) {
            void 0 === r2 && (r2 = "h5");
            var n2 = t3.call(this, e3, r2) || this;
            return n2.match = "#####", n2;
          }
          return n(e2, t3), e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(r(3).default);
        e.default = o;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = function(t3) {
          function e2(e3, r2) {
            void 0 === r2 && (r2 = "h6");
            var n2 = t3.call(this, e3, r2) || this;
            return n2.match = "######", n2;
          }
          return n(e2, t3), e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(r(3).default);
        e.default = o;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = function(t3) {
          function e2(e3, r2, n2) {
            void 0 === r2 && (r2 = "hr");
            var o2 = t3.call(this, e3, r2, n2) || this;
            return o2.match = "---", o2;
          }
          return n(e2, t3), e2.prototype.beforeMergeSpace = function() {
            return this.leadingSpace + this.match;
          }, e2.prototype.beforeReturn = function(t4) {
            return t4.replace(/^(?:\n\s*)/, "\n\n").replace(/(?:\n\s*)$/, "\n\n"), t4;
          }, e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(r(4).default);
        e.default = o;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = function(t3) {
          function e2(e3, r2, n2) {
            return void 0 === r2 && (r2 = "i"), t3.call(this, e3, r2, n2) || this;
          }
          return n(e2, t3), e2.prototype.exec = function(e3, r2) {
            return t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(r(16).default);
        e.default = o;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = function(t3) {
          function e2(e3, r2, n2) {
            return void 0 === r2 && (r2 = "img"), t3.call(this, e3, r2, n2) || this;
          }
          return n(e2, t3), e2.prototype.beforeMergeSpace = function() {
            var t4 = this.attrs, e3 = t4.src, r2 = t4.alt;
            return r2 || (r2 = ""), e3 || (e3 = ""), "![".concat(r2, "](").concat(e3, ")");
          }, e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(r(4).default);
        e.default = o;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = function(t3) {
          function e2(e3, r2, n2) {
            return void 0 === r2 && (r2 = "input"), t3.call(this, e3, r2, n2) || this;
          }
          return n(e2, t3), e2.prototype.beforeMergeSpace = function() {
            var t4 = this.attrs, e3 = t4.type, r2 = t4.checked;
            return "li" === this.parentTag && "checkbox" === e3 ? null != r2 ? "[x] " : "[ ] " : "";
          }, e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(r(4).default);
        e.default = o;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }(), o = this && this.__assign || function() {
          return (o = Object.assign || function(t3) {
            for (var e2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
              for (var o2 in e2 = arguments[r2])
                Object.prototype.hasOwnProperty.call(e2, o2) && (t3[o2] = e2[o2]);
            return t3;
          }).apply(this, arguments);
        };
        Object.defineProperty(e, "__esModule", { value: true });
        var i = r(0), a = r(1), c = r(7), u = r(6), s = function(t3) {
          function e2(e3, r2, n2) {
            void 0 === r2 && (r2 = "li");
            var o2 = t3.call(this, e3, r2, n2) || this;
            return o2.match = o2.match || "*", o2.extraGap = "", o2;
          }
          return n(e2, t3), e2.prototype.beforeMergeSpace = function(t4) {
            return this.extraGap + this.leadingSpace + this.match + " " + t4;
          }, e2.prototype.__calcNextLeading__ = function() {
            var t4, e3, r2;
            return 1 === (null === (t4 = this.match) || void 0 === t4 ? void 0 : t4.length) ? u.DOUBLE : 2 === (null === (e3 = this.match) || void 0 === e3 ? void 0 : e3.length) ? u.TRIPLE : 3 === (null === (r2 = this.match) || void 0 === r2 ? void 0 : r2.length) ? u.DOUBLE : u.TRIPLE + u.DOUBLE;
          }, e2.prototype.parseValidSubTag = function(t4, e3, r2) {
            var n2 = (0, a.getTagConstructor)(e3), i2 = this.__calcNextLeading__(), c2 = new n2(t4, e3, o(o({}, r2), { calcLeading: true, leadingSpace: this.leadingSpace + i2, layer: this.layer + 1 })), u2 = c2.exec();
            return "p" === e3 && (this.extraGap = "\n"), this.isFirstSubTag ? [u2.trimLeft().replace(this.leadingSpace + i2, ""), c2] : [u2, c2];
          }, e2.prototype.parseOnlyString = function(e3, r2, n2) {
            var i2 = false;
            (0, c.default)(n2.prevTagName) && (i2 = true);
            var a2 = this.__calcNextLeading__(), u2 = t3.prototype.parseOnlyString.call(this, e3, r2, o(o({}, n2), { calcLeading: i2, leadingSpace: this.leadingSpace + a2, layer: this.layer + 1 })), s2 = u2[0], p = u2[1];
            return this.isFirstSubTag ? [s2.replace(this.leadingSpace + a2, ""), p] : [s2, p];
          }, e2.prototype.beforeReturn = function(e3) {
            return t3.prototype.beforeReturn.call(this, e3);
          }, e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(i.default);
        e.default = s;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }(), o = this && this.__assign || function() {
          return (o = Object.assign || function(t3) {
            for (var e2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
              for (var o2 in e2 = arguments[r2])
                Object.prototype.hasOwnProperty.call(e2, o2) && (t3[o2] = e2[o2]);
            return t3;
          }).apply(this, arguments);
        };
        Object.defineProperty(e, "__esModule", { value: true });
        var i = r(0), a = r(5), c = r(1), u = r(2), s = function(t3) {
          function e2(e3, r2, n2) {
            void 0 === r2 && (r2 = "ol");
            var o2, i2 = this;
            i2 = t3.call(this, e3, r2, n2) || this;
            var a2 = parseInt(null === (o2 = null === i2 || void 0 === i2 ? void 0 : i2.attrs) || void 0 === o2 ? void 0 : o2.start, 10);
            return i2.count = isNaN(a2) ? 1 : a2, i2;
          }
          return n(e2, t3), e2.prototype.__isValidSubTag__ = function(t4) {
            if (!t4)
              return false;
            var e3 = u.default.get().aliasTags, r2 = (0, c.getTagConstructor)(t4);
            return "li" === t4 || "li" == (null === e3 || void 0 === e3 ? void 0 : e3[t4]) || r2 === a.default;
          }, e2.prototype.getValidSubTagName = function(t4) {
            return t4 && this.__isValidSubTag__(t4) ? t4 : null;
          }, e2.prototype.parseValidSubTag = function(t4, e3, r2) {
            var n2 = (0, c.getTagConstructor)(e3);
            if (this.__isValidSubTag__(e3)) {
              var i2 = this.count + ".", a2 = new n2(t4, e3, o(o({}, r2), { calcLeading: true, leadingSpace: this.leadingSpace, layer: this.layer, match: i2 }));
              return this.count++, [a2.exec("", "\n"), a2];
            }
            return ["", null];
          }, e2.prototype.parseOnlyString = function() {
            return ["", null];
          }, e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(i.default);
        e.default = s;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = function(t3) {
          function e2(e3, r2, n2) {
            return void 0 === r2 && (r2 = "p"), t3.call(this, e3, r2, n2) || this;
          }
          return n(e2, t3), e2.prototype.beforeMergeSpace = function(t4) {
            return this.calcLeading ? this.leadingSpace + t4 : t4;
          }, e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), this.prevTagName || !this.prevTagStr || this.prevTagStr.endsWith("\n") || (e3 = "\n\n"), this.nextTagName || !this.nextTagStr || this.nextTagStr.startsWith("\n") || (r2 = "\n\n"), this.inTable && (e3 = "", r2 = ""), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(r(0).default);
        e.default = o;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }(), o = this && this.__assign || function() {
          return (o = Object.assign || function(t3) {
            for (var e2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
              for (var o2 in e2 = arguments[r2])
                Object.prototype.hasOwnProperty.call(e2, o2) && (t3[o2] = e2[o2]);
            return t3;
          }).apply(this, arguments);
        };
        Object.defineProperty(e, "__esModule", { value: true });
        var i = r(0), a = r(8), c = r(1), u = r(6), s = function(t3) {
          function e2(e3, r2, n2) {
            void 0 === r2 && (r2 = "pre");
            var o2 = t3.call(this, e3, r2, n2) || this;
            return o2.indentSpace = u.DOUBLE + u.DOUBLE, o2.isIndent = o2.innerHTML.includes("```"), o2.match = o2.isIndent ? "" : "```", o2.language = o2.language || (0, c.getLanguage)(e3), o2.keepSpace = true, o2;
          }
          return n(e2, t3), e2.prototype.beforeMergeSpace = function(t4) {
            var e3 = this.isIndent || "code" === this.parentTag ? "" : this.match + this.language + "\n", r2 = "";
            return t4.endsWith("\n") || (r2 = "\n"), e3 + t4 + (this.isIndent || "code" === this.parentTag ? "" : r2 + this.match);
          }, e2.prototype.fillPerLine = function(t4) {
            var e3 = "";
            return this.calcLeading && (e3 = this.leadingSpace), this.isIndent ? e3 + this.indentSpace + t4 : e3 + t4;
          }, e2.prototype.afterMergeSpace = function(t4) {
            var e3 = this, r2 = t4.split("\n");
            return (r2 = r2.map(function(t5) {
              return "" === t5 ? "" : e3.fillPerLine(t5);
            })).join("\n");
          }, e2.prototype.parseValidSubTag = function(t4, e3, r2) {
            if ("code" === e3) {
              var n2 = new ((0, c.getTagConstructor)(e3))(t4, e3, o(o({}, r2), { match: "", language: this.language, keepSpace: true }));
              return [n2.exec("", ""), n2];
            }
            var i2 = void 0;
            return [(i2 = (0, c.isSelfClosing)(e3) ? new a.__EmptySelfClose__(t4, e3) : new a.__Empty__(t4, e3, o(o({}, r2), { keepSpace: true }))).exec(), i2];
          }, e2.prototype.parseOnlyString = function(t4) {
            return [t4, null];
          }, e2.prototype.slim = function(t4) {
            return t4;
          }, e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(i.default);
        e.default = s;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = function(t3) {
          function e2(e3, r2) {
            return void 0 === r2 && (r2 = "s"), t3.call(this, e3, r2) || this;
          }
          return n(e2, t3), e2.prototype.exec = function(e3, r2) {
            return t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(r(15).default);
        e.default = o;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = function(t3) {
          function e2(e3, r2, n2) {
            return void 0 === r2 && (r2 = "span"), t3.call(this, e3, r2, n2) || this;
          }
          return n(e2, t3), e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(r(0).default);
        e.default = o;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }(), o = this && this.__assign || function() {
          return (o = Object.assign || function(t3) {
            for (var e2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
              for (var o2 in e2 = arguments[r2])
                Object.prototype.hasOwnProperty.call(e2, o2) && (t3[o2] = e2[o2]);
            return t3;
          }).apply(this, arguments);
        };
        Object.defineProperty(e, "__esModule", { value: true });
        var i = r(0), a = r(1);
        var c = function(t3) {
          function e2(e3, r2, n2) {
            void 0 === r2 && (r2 = "table");
            var o2 = t3.call(this, e3, r2, n2) || this;
            return o2.exist_thead = false, o2.exist_tbody = false, o2.empty_tbody = true, o2.tableColumnCount = function(t4) {
              for (var e4 = "", r3 = 0; r3 < t4.length && !e4.endsWith("</tr>"); r3++)
                e4 += t4[r3];
              return Math.max(e4.split("</td>").length - 1, e4.split("</th>").length - 1);
            }(o2.innerHTML), o2;
          }
          return n(e2, t3), e2.prototype.parseValidSubTag = function(t4, e3, r2) {
            "thead" === e3 && (this.exist_thead = true), "tbody" === e3 && (this.exist_tbody = true, this.empty_tbody = false), "tr" === e3 && (this.empty_tbody = false);
            var n2 = new ((0, a.getTagConstructor)(e3))(t4, e3, o(o({}, r2), { tableColumnCount: this.tableColumnCount, inTable: true }));
            return [n2.exec("", "\n"), n2];
          }, e2.prototype.parseOnlyString = function() {
            return ["", null];
          }, e2.prototype.beforeReturn = function(t4) {
            if (!this.exist_thead && !this.exist_tbody && this.empty_tbody)
              return "";
            if (0 === this.tableColumnCount)
              return "";
            if (!this.exist_tbody) {
              for (var e3 = (0, a.getTableAlign)(this.innerHTML, this.tableColumnCount), r2 = this.leadingSpace + "|", n2 = 0; n2 < e3.length; n2++)
                r2 += e3[n2];
              t4 = this.empty_tbody ? t4 + r2 + "\n" : r2 + "" + t4;
            }
            return this.exist_thead || (t4 = "\n" + this.leadingSpace + "|".repeat(this.tableColumnCount + 1) + (t4.startsWith("\n") ? "" : "\n") + t4), t4;
          }, e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(i.default);
        e.default = c;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = r(0), i = r(1), a = function(t3) {
          function e2(e3, r2, n2) {
            return void 0 === r2 && (r2 = "tbody"), t3.call(this, e3, r2, n2) || this;
          }
          return n(e2, t3), e2.prototype.beforeMergeSpace = function(t4) {
            for (var e3 = (0, i.getTableAlign)(this.innerHTML, this.tableColumnCount), r2 = this.leadingSpace + "|", n2 = 0; n2 < e3.length; n2++)
              r2 += e3[n2];
            return r2 + "\n" + t4;
          }, e2.prototype.parseOnlyString = function() {
            return ["", null];
          }, e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(o.default);
        e.default = a;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = function(t3) {
          function e2(e3, r2, n2) {
            return void 0 === r2 && (r2 = "td"), t3.call(this, e3, r2, n2) || this;
          }
          return n(e2, t3), e2.prototype.parseValidSubTag = function(e3, r2, n2) {
            return "ul" === r2 || "ol" === r2 || "table" === r2 || "pre" === r2 ? [e3.replace(/([\n\r])/g, ""), null] : t3.prototype.parseValidSubTag.call(this, e3, r2, n2);
          }, e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(r(17).default);
        e.default = o;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = function(t3) {
          function e2(e3, r2, n2) {
            return void 0 === r2 && (r2 = "thead"), t3.call(this, e3, r2, n2) || this;
          }
          return n(e2, t3), e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = ""), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(r(0).default);
        e.default = o;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }();
        Object.defineProperty(e, "__esModule", { value: true });
        var o = r(0), i = r(5), a = r(1), c = r(2), u = function(t3) {
          function e2(e3, r2, n2) {
            return void 0 === r2 && (r2 = "tr"), t3.call(this, e3, r2, n2) || this;
          }
          return n(e2, t3), e2.prototype.beforeMergeSpace = function(t4) {
            return this.leadingSpace + "|" + t4;
          }, e2.prototype.parseValidSubTag = function(t4, e3, r2) {
            var n2 = c.default.get().aliasTags, o2 = (0, a.getTagConstructor)(e3);
            if ("td" !== e3 && "th" !== e3 && "td" !== (null === n2 || void 0 === n2 ? void 0 : n2[e3]) && "th" !== (null === n2 || void 0 === n2 ? void 0 : n2[e3]) && o2 !== i.default)
              return "Should not have tags except <td> or <th> inside <tr>, current tag is ".concat(e3, " have been ignore."), ["", null];
            var u2 = new o2(t4, e3, r2);
            return [u2.exec("", ""), u2];
          }, e2.prototype.parseOnlyString = function() {
            return ["", null];
          }, e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = ""), void 0 === r2 && (r2 = "\n"), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(o.default);
        e.default = u;
      }, function(t2, e, r) {
        "use strict";
        var n = this && this.__extends || function() {
          var t3 = function(e2, r2) {
            return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
              t4.__proto__ = e3;
            } || function(t4, e3) {
              for (var r3 in e3)
                Object.prototype.hasOwnProperty.call(e3, r3) && (t4[r3] = e3[r3]);
            })(e2, r2);
          };
          return function(e2, r2) {
            if ("function" !== typeof r2 && null !== r2)
              throw new TypeError("Class extends value " + String(r2) + " is not a constructor or null");
            function n2() {
              this.constructor = e2;
            }
            t3(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
          };
        }(), o = this && this.__assign || function() {
          return (o = Object.assign || function(t3) {
            for (var e2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
              for (var o2 in e2 = arguments[r2])
                Object.prototype.hasOwnProperty.call(e2, o2) && (t3[o2] = e2[o2]);
            return t3;
          }).apply(this, arguments);
        };
        Object.defineProperty(e, "__esModule", { value: true });
        var i = r(0), a = r(5), c = r(1), u = r(2).default.get().aliasTags, s = function(t3) {
          function e2(e3, r2, n2) {
            return void 0 === r2 && (r2 = "ul"), t3.call(this, e3, r2, n2) || this;
          }
          return n(e2, t3), e2.prototype.__isValidSubTag__ = function(t4) {
            if (!t4)
              return false;
            var e3 = (0, c.getTagConstructor)(t4);
            return "li" === t4 || "li" == (null === u || void 0 === u ? void 0 : u[t4]) || e3 === a.default;
          }, e2.prototype.getValidSubTagName = function(t4) {
            return t4 && this.__isValidSubTag__(t4) ? t4 : null;
          }, e2.prototype.parseValidSubTag = function(t4, e3, r2) {
            var n2 = (0, c.getTagConstructor)(e3);
            if (this.__isValidSubTag__(e3)) {
              var i2 = new n2(t4, e3, o(o({}, r2), { calcLeading: true, leadingSpace: this.leadingSpace, layer: this.layer, match: "*" }));
              return [i2.exec("", "\n"), i2];
            }
            return ["", null];
          }, e2.prototype.parseOnlyString = function() {
            return ["", null];
          }, e2.prototype.exec = function(e3, r2) {
            return void 0 === e3 && (e3 = "\n"), void 0 === r2 && (r2 = "\n"), t3.prototype.exec.call(this, e3, r2);
          }, e2;
        }(i.default);
        e.default = s;
      }, function(t2, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var n = r(1), o = r(2), i = r(6);
        e.default = function(t3, e2, r2) {
          void 0 === r2 && (r2 = false), o.default.reset(), o.default.set(e2, r2), t3 = (t3 = (t3 = (0, n.clearComment)(t3)).trim()).replace(/(\r\n)/g, "").replace(/&nbsp;/g, " "), t3 = "<".concat(i.DOUBLE, "skip").concat(i.DOUBLE, ">").concat(t3, "</").concat(i.DOUBLE, "skip").concat(i.DOUBLE, ">");
          var a = "", c = "".concat(i.DOUBLE, "skip").concat(i.DOUBLE), u = t3;
          return a += new ((0, n.getTagConstructor)(c))(u, c, { parentTag: null, prevTagName: null, prevTagStr: a }).exec(), function(t4) {
            return t4 = (t4 = (t4 = t4.replace(/^\s+/, "")).replace(/\s+$/, "")).replace(/\u2608/g, " ");
          }((0, n.unescapeStr)(a));
        };
      }, function(t2, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var n = r(11);
        function o(t3, e2) {
          for (var r2 = ""; e2 < t3.length && /[a-zA-Z0-9!\-_]/.test(t3[e2]); )
            r2 += t3[e2++];
          return r2.toLowerCase();
        }
        e.default = function(t3) {
          var e2 = 0;
          return function() {
            var r2 = "", i = null, a = 0, c = null, u = false;
            if (e2 >= t3.length)
              return [i, r2];
            for (var s = e2; s < t3.length; s++) {
              if ("<" === t3[s] && "/" !== t3[s + 1]) {
                if ("" !== r2 && null == i && !u)
                  return e2 = s, [i, r2];
                var p = o(t3, s + 1);
                null == i && (i = p), i === p && a++, (0, n.default)(i) && (0 === --a && (u = true), a < 0 && "Tag ".concat(i, " is abnormal"));
              } else if ("<" === t3[s] && "/" === t3[s + 1]) {
                if (null == i) {
                  "Tag is not integrity, current tagStr is ".concat(t3.slice(e2));
                  for (var l = s; l < t3.length && ">" !== t3[l]; )
                    l++;
                  s = l;
                  continue;
                }
                i === (c = o(t3, s + 2)) && a--, a <= 0 && (u = true);
              }
              if (r2 += t3[s], ">" === t3[s] && u)
                return e2 = s + 1, [i, r2];
              s === t3.length - 1 && i !== c && (null != c && null != i && (r2 = r2.replace("<".concat(i, ">"), "").replace("</".concat(c, ">"), "")), i = null);
            }
            return e2 = t3.length, [i, r2];
          };
        };
      }, function(t2, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var n = r(2), o = r(6), i = r(11), a = r(49);
        e.default = function t3(e2) {
          var c, u = n.default.get(), s = u.skipTags, p = u.emptyTags, l = u.ignoreTags, f = u.aliasTags, h2 = u.renderCustomTags, d = (0, i.default)(e2);
          if ((null === s || void 0 === s ? void 0 : s.includes(e2)) || e2 === "".concat(o.DOUBLE, "skip").concat(o.DOUBLE)) {
            var _ = r(9);
            return d ? _.__SkipSelfClose__ : _.__Skip__;
          }
          if (null === p || void 0 === p ? void 0 : p.includes(e2)) {
            var y = r(8);
            return d ? y.__EmptySelfClose__ : y.__Empty__;
          }
          if (null === l || void 0 === l ? void 0 : l.includes(e2))
            return r(5).default;
          if (null != (null === f || void 0 === f ? void 0 : f[e2]))
            return t3(f[e2]);
          var v = e2.toLowerCase();
          if (true !== h2 && !(0, a.default)(v)) {
            if (false === h2 || "SKIP" === h2)
              return _ = r(9), d ? _.__SkipSelfClose__ : _.__Skip__;
            if ("EMPTY" === h2)
              return y = r(8), d ? y.__EmptySelfClose__ : y.__Empty__;
            if ("IGNORE" === h2)
              return r(5).default;
          }
          try {
            c = r(50)("./".concat(e2)).default;
          } catch (g) {
            c = d ? r(10).__NoMatchSelfClose__ : r(10).__NoMatch__;
          }
          return c;
        };
      }, function(t2, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var n = ["!doctype", "a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "circle", "cite", "clipPath", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "defs", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "ellipse", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "foreignObject", "form", "frame", "frameset", "g", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "line", "linearGradient", "link", "listing", "main", "map", "mark", "marquee", "mask", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "path", "pattern", "picture", "plaintext", "polygon", "polyline", "pre", "progress", "q", "radialGradient", "rb", "rbc", "rect", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "stop", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "text", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tspan", "tt", "u", "ul", "var", "video", "wbr", "xmp"];
        e.default = function(t3) {
          return "string" === typeof t3 && n.includes(t3.toLowerCase());
        };
      }, function(t2, e, r) {
        var n = { "./__Heading__": 3, "./__Heading__.ts": 3, "./__empty__": 8, "./__empty__.ts": 8, "./__ignore__": 5, "./__ignore__.ts": 5, "./__nomatch__": 10, "./__nomatch__.ts": 10, "./__rawString__": 12, "./__rawString__.ts": 12, "./__skip__": 9, "./__skip__.ts": 9, "./a": 19, "./a.ts": 19, "./b": 20, "./b.ts": 20, "./blockquote": 21, "./blockquote.ts": 21, "./br": 22, "./br.ts": 22, "./code": 23, "./code.ts": 23, "./del": 15, "./del.ts": 15, "./em": 16, "./em.ts": 16, "./h1": 24, "./h1.ts": 24, "./h2": 25, "./h2.ts": 25, "./h3": 26, "./h3.ts": 26, "./h4": 27, "./h4.ts": 27, "./h5": 28, "./h5.ts": 28, "./h6": 29, "./h6.ts": 29, "./hr": 30, "./hr.ts": 30, "./i": 31, "./i.ts": 31, "./img": 32, "./img.ts": 32, "./input": 33, "./input.ts": 33, "./li": 34, "./li.ts": 34, "./ol": 35, "./ol.ts": 35, "./p": 36, "./p.ts": 36, "./pre": 37, "./pre.ts": 37, "./s": 38, "./s.ts": 38, "./span": 39, "./span.ts": 39, "./strong": 14, "./strong.ts": 14, "./table": 40, "./table.ts": 40, "./tbody": 41, "./tbody.ts": 41, "./td": 42, "./td.ts": 42, "./th": 17, "./th.ts": 17, "./thead": 43, "./thead.ts": 43, "./tr": 44, "./tr.ts": 44, "./ul": 45, "./ul.ts": 45 };
        function o(t3) {
          var e2 = i(t3);
          return r(e2);
        }
        function i(t3) {
          if (!r.o(n, t3)) {
            var e2 = new Error("Cannot find module '" + t3 + "'");
            throw e2.code = "MODULE_NOT_FOUND", e2;
          }
          return n[t3];
        }
        o.keys = function() {
          return Object.keys(n);
        }, o.resolve = i, t2.exports = o, o.id = 50;
      }, function(t2, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.default = function(t3) {
          for (var e2 = {}, r2 = false, n = "", o = "", i = null, a = 0; a <= t3.length; a++) {
            if (a === t3.length || /\s/.test(t3[a])) {
              if (a === t3.length || !r2) {
                var c = n.trim();
                "/" === c[c.length - 1] && (c = c.slice(0, c.length - 1)), c && (e2[c] = o.trim()), n = "", o = "";
              }
            } else {
              if (/['"]/.test(t3[a]) && (!i || t3[a] === i)) {
                (r2 = !r2) && (i = t3[a]);
                continue;
              }
              if ("=" === t3[a] && !r2)
                continue;
            }
            if (a === t3.length)
              break;
            r2 ? o += t3[a] : n += t3[a];
          }
          return e2;
        };
      }, function(t2, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var n = "javascript";
        e.default = function(t3) {
          var e2 = t3.match(/<.*?class=".*?language-([^\s"]*)?.*".*>/);
          return e2 ? e2[1] || "" : t3.match(/<span.*?hljs-(comment|keyword|number|string|literal|built_in|function|title|bullet).*?<\/span>/) ? n : "";
        };
      }, function(t2, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.default = function(t3) {
          return t3.replace(/<!--(?:[\s\S]*?)-->/g, "");
        };
      }, function(t2, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true });
        var n = r(13), o = { b: true, a: true, del: true, em: true, i: true, s: true, span: true, strong: true };
        e.default = function(t3) {
          if (null === t3)
            return true;
          if (!t3)
            return false;
          var e2 = (0, n.default)(t3);
          return !!e2 && !!o[e2];
        };
      }, function(t2, e, r) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: true }), e.default = function(t3, e2) {
          var r2 = { _default_: "---|", center: ":---:|", left: ":---|", right: "---:|", start: ":---|", end: "---:|" }, n = Array(e2).fill(r2._default_), o = t3.match(/<(td|th)(.*?)>/g);
          return o ? n = (n = o.slice(0, e2)).map(function(t4) {
            var e3 = t4.match(/align\s*=\s*['"]\s*(center|left|right|start|end)/), n2 = t4.match(/text-align\s*:\s*(center|left|right|start|end)/);
            return e3 || n2 ? e3 && !n2 ? r2[e3[1]] || r2._default_ : n2 ? r2[n2[1]] || r2._default_ : void 0 : r2._default_;
          }) : n;
        };
      }]).default;
    });
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AnyBlockPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// ../ABConverter/converter/ABConvert.ts
var ABConvert = class {
  constructor(process) {
    this.is_disable = false;
    this.register_from = "\u5185\u7F6E";
    this.is_enable = false;
    if ("process" in process) {
      this.constructor_simp(process);
    } else {
      this.constructor_user(process);
    }
  }
  static factory(process) {
    let ret = new ABConvert(process);
    ABConvertManager.getInstance().list_abConvert.push(ret);
    return ret;
  }
  constructor_simp(sim) {
    var _a3, _b, _c, _d, _e, _f;
    this.id = sim.id;
    this.name = sim.name;
    this.match = (_a3 = sim.match) != null ? _a3 : sim.id;
    this.default = ((_b = sim.default) != null ? _b : !sim.match || typeof sim.match == "string") ? sim.id : null;
    this.detail = (_c = sim.detail) != null ? _c : "";
    this.process_alias = (_d = sim.process_alias) != null ? _d : "";
    this.process_param = (_e = sim.process_param) != null ? _e : null;
    this.process_return = (_f = sim.process_return) != null ? _f : null;
    this.process = sim.process;
    this.is_disable = false;
    this.register_from = "\u5185\u7F6E";
  }
  constructor_user(sim) {
    this.id = sim.id;
    this.name = sim.name;
    this.match = /^\//.test(sim.match) ? RegExp(sim.match) : sim.match;
    this.default = null;
    this.detail = "";
    this.process_alias = sim.process_alias;
    this.process_param = null;
    this.process_return = null;
    this.process = () => {
    };
    this.is_disable = false;
    this.register_from = "\u7528\u6237";
  }
  destructor() {
    const index2 = ABConvertManager.getInstance().list_abConvert.indexOf(this);
    if (index2 > -1) {
      ABConvertManager.getInstance().list_abConvert.splice(index2, 1);
    }
  }
};

// ../ABConverter/ABReg.ts
var ABReg = {
  reg_header: /^((\s|>\s|-\s|\*\s|\+\s)*)(%%)?(\[((?!toc|TOC|\!|< )[\|\!#:;\(\)\s0-9a-zA-Z\u4e00-\u9fa5].*)\]):?(%%)?\s*$/,
  reg_header_up: /^((\s|>\s|-\s|\*\s|\+\s)*)(%%)?(\[((?!toc|TOC|\!)< [\|\!#:;\(\)\s0-9a-zA-Z\u4e00-\u9fa5].*)\]):?(%%)?\s*$/,
  reg_mdit_head: /^((\s|>\s|-\s|\*\s|\+\s)*)(::::*)\s?(.*)/,
  reg_mdit_tail: /^((\s|>\s|-\s|\*\s|\+\s)*)(::::*)/,
  reg_list: /^((\s|>\s|-\s|\*\s|\+\s)*)(-\s|\*\s|\+\s)(.*)/,
  reg_code: /^((\s|>\s|-\s|\*\s|\+\s)*)(````*|~~~~*)(.*)/,
  reg_quote: /^((\s|>\s|-\s|\*\s|\+\s)*)(>\s)(.*)/,
  reg_heading: /^((\s|>\s|-\s|\*\s|\+\s)*)(\#+\s)(.*)/,
  reg_table: /^((\s|>\s|-\s|\*\s|\+\s)*)(\|(.*)\|)/,
  reg_header_noprefix: /^((\s)*)(%%)?(\[((?!toc|TOC|\!|< )[\|\!#:;\(\)\s0-9a-zA-Z\u4e00-\u9fa5].*)\]):?(%%)?\s*$/,
  reg_header_up_noprefix: /^((\s)*)(%%)?(\[((?!toc|TOC|\!)< [\|\!#:;\(\)\s0-9a-zA-Z\u4e00-\u9fa5].*)\]):?(%%)?\s*$/,
  reg_mdit_head_noprefix: /^((\s)*)(::::*)\s?(.*)/,
  reg_mdit_tail_noprefix: /^((\s)*)(::::*)/,
  reg_list_noprefix: /^((\s)*)(-\s|\*\s|\+\s)(.*)/,
  reg_code_noprefix: /^((\s)*)(````*|~~~~*)(.*)/,
  reg_quote_noprefix: /^((\s)*)(>\s)(.*)/,
  reg_heading_noprefix: /^((\s)*)(\#+\s)(.*)/,
  reg_table_noprefix: /^((\s)*)(\|(.*)\|)/,
  reg_emptyline_noprefix: /^\s*$/,
  reg_indentline_noprefix: /^\s+?\S/,
  inline_split: /\| |,  |， |\.  |。 |:  |： /
};
var ABCSetting = {
  is_debug: false,
  env: "obsidian",
  global_ctx: null,
  mermaid: void 0
};

// ../ABConverter/ABAlias.ts
function autoABAlias(header, selectorName, content) {
  if (!header.trimEnd().endsWith("|"))
    header = header + "|";
  if (!header.trimStart().startsWith("|"))
    header = "|" + header;
  if (selectorName == "mdit") {
    header = "|:::_140lne" + header.trimStart();
  } else if (selectorName == "list" || ABReg.reg_list_noprefix.test(content.trimStart())) {
    header = "|list_140lne" + header;
  } else if (selectorName == "heading" || ABReg.reg_heading_noprefix.test(content.trimStart())) {
    header = "|heading_140lne" + header;
  } else if (selectorName == "code" || ABReg.reg_code_noprefix.test(content.trimStart())) {
    header = "|code_140lne" + header;
  } else if (selectorName == "quote" || ABReg.reg_quote_noprefix.test(content.trimStart())) {
    header = "|quote_140lne" + header;
  } else if (selectorName == "table" || ABReg.reg_table_noprefix.test(content.trimStart())) {
    header = "|table_140lne" + header;
  }
  for (const item of ABAlias_json) {
    header = header.replace(item.regex, item.replacement);
  }
  for (const item of ABAlias_json_withSub) {
    header = header.replace(item.regex, (match2, ...groups) => {
      return item.replacement.replace(/\$(\d+)/g, (_, number) => {
        var _a3;
        return (_a3 = groups[number - 1]) != null ? _a3 : "";
      });
    });
  }
  for (const item of ABAlias_json_end) {
    header = header.replace(item.regex, item.replacement);
  }
  return header;
}
var ABAlias_json_withSub = [
  { regex: /\|(note|warning|caution|attention|error|info|danger|tip|hint|example|abstract|summary|tldr|quote|cite|todo|success|check|done|important|question|help|faq|failure|fail|missing|bug)([+-]?)(\s.*)?\|/, replacement: "|add([!$1]$2$3)|addQuote|" },
  { regex: /\|(callout|alert) ([^+-\s]+)([+-]?)\s?(.*)\|/, replacement: "|add([!$2]$3 $4)|addQuote|" }
];
var ABAlias_json_mdit = [
  { regex: /\|:::_140lne\|(2?tabs?|标签页?)\|/, replacement: "|mditTabs|" },
  { regex: "|:::_140lne|demo|", replacement: "|mditDemo|" },
  { regex: "|:::_140lne|abDemo|", replacement: "|mditABDemo|" },
  { regex: /\|:::_140lne\|(2?col|分栏)\|/, replacement: "|mditCol|" },
  { regex: /\|:::_140lne\|(2?card|卡片)\|/, replacement: "|mditCard|" },
  { regex: /\|:::_140lne\|(2?chat|聊天)\|/, replacement: "|mditChat|code(chat)|" }
];
var ABAlias_json_title = [
  { regex: "|title2list|", replacement: "|title2listdata|listdata2strict|listdata2list|" },
  { regex: /\|heading_140lne\|2?(timeline|时间线)\|/, replacement: "|title2timeline|" },
  { regex: /\|heading_140lne\|2?(tabs?|标签页?)\||\|title2tabs?\|/, replacement: "|title2c2listdata|c2listdata2tab|" },
  { regex: /\|heading_140lne\|2?(col|分栏)\||\|title2col\|/, replacement: "|title2c2listdata|c2listdata2items|addClass(ab-col)|" },
  { regex: /\|heading_140lne\|2?(card|卡片)\||\|title2card\|/, replacement: "|title2c2listdata|c2listdata2items|addClass(ab-card)|addClass(ab-lay-vfall)|" },
  { regex: /\|heading_140lne\|2?(nodes?|节点)\||\|(title2node|title2abMindmap)\|/, replacement: "|title2listdata|listdata2strict|listdata2nodes|" },
  { regex: /\|heading_140lne\|2?(mermaid|flow|流程图)\|/, replacement: "|title2list|list2mermaid|" },
  { regex: /\|heading_140lne\|2?(mehrmaid|mdmermaid)\|/, replacement: "|title2list|list2mehrmaidText|code(mehrmaid)|" },
  { regex: /\|heading_140lne\|2?(puml)?(plantuml|mindmap|脑图|思维导图)\|/, replacement: "|title2list|list2pumlMindmap|" },
  { regex: /\|heading_140lne\|2?(markmap|mdMindmap|md脑图|md思维导图)\|/, replacement: "|title2list|list2markmap|" },
  { regex: /\|heading_140lne\|2?(wbs|(工作)?分解(图|结构))\|/, replacement: "|title2list|list2pumlWBS|" },
  { regex: /\|heading_140lne\|2?(table|multiWayTable|multiCrossTable|表格?|多叉表格?|跨行表格?)\|/, replacement: "|title2list|list2table|" },
  { regex: /\|heading_140lne\|2?(lt|listTable|treeTable|listGrid|treeGrid|列表格|树形表格?)\|/, replacement: "|title2list|list2lt|" },
  { regex: /\|heading_140lne\|2?(list|列表)\|/, replacement: "|title2list|list2lt|addClass(ab-listtable-likelist)|" },
  { regex: /\|heading_140lne\|2?(dir|dirTree|目录树?|目录结构)\|/, replacement: "|title2list|list2dt|" },
  { regex: /\|heading_140lne\|(fakeList|仿列表)\|/, replacement: "|title2list|list2table|addClass(ab-table-fc)|addClass(ab-table-likelist)|" }
];
var ABAlias_json_list = [
  { regex: "|listXinline|", replacement: "|list2listdata|listdata2list|" },
  { regex: /\|list_140lne\|2?(timeline|时间线)\|/, replacement: "|list2timeline|" },
  { regex: /\|list_140lne\|2?(tabs?|标签页?)\||\|list2tabs?\|/, replacement: "|list2c2listdata|c2listdata2tab|" },
  { regex: /\|list_140lne\|2?(col|分栏)\||\|list2col\|/, replacement: "|list2c2listdata|c2listdata2items|addClass(ab-col)|" },
  { regex: /\|list_140lne\|2?(card|卡片)\||\|list2card\|/, replacement: "|list2c2listdata|c2listdata2items|addClass(ab-card)|addClass(ab-lay-vfall)|" },
  { regex: /\|list_140lne\|2?(nodes?|节点)\||\|(list2node|list2abMindmap)\|/, replacement: "|list2listdata|listdata2strict|listdata2nodes|" },
  { regex: /\|list_140lne\|2?(mermaid|flow|流程图)\|/, replacement: "|list2mermaid|" },
  { regex: /\|list_140lne\|2?(mehrmaid|mdmermaid)\|/, replacement: "|list2mehrmaidText|code(mehrmaid)|" },
  { regex: /\|list_140lne\|2?(puml)?(plantuml|mindmap|脑图|思维导图)\|/, replacement: "|list2pumlMindmap|" },
  { regex: /\|list_140lne\|2?(markmap|mdMindmap|md脑图|md思维导图)\|/, replacement: "|list2markmap|" },
  { regex: /\|list_140lne\|2?(wbs|(工作)?分解(图|结构))\|/, replacement: "|list2pumlWBS|" },
  { regex: /\|list_140lne\|2?(table|multiWayTable|multiCrossTable|表格?|多叉表格?|跨行表格?)\|/, replacement: "|list2table|" },
  { regex: /\|list_140lne\|2?(lt|listTable|treeTable|listGrid|treeGrid|列表格|树形表格?)\|/, replacement: "|list2lt|" },
  { regex: /\|list_140lne\|2?(list|列表)\|/, replacement: "|list2lt|addClass(ab-listtable-likelist)|" },
  { regex: /\|list_140lne\|2?(dir|dirTree|目录树?|目录结构)\|/, replacement: "|list2dt|" },
  { regex: /\|list_140lne\|(fakeList|仿列表)\|/, replacement: "|list2table|addClass(ab-table-fc)|addClass(ab-table-likelist)|" }
];
var ABAlias_json_code = [
  { regex: "|code_140lne|X|", replacement: "|xCode|" },
  { regex: "|code_140lne|x|", replacement: "|xCode|" },
  { regex: "|code2list|", replacement: "|xCode|region2indent|addList|" },
  { regex: "|list2code|", replacement: "|xList|code(js)|" }
];
var ABAlias_json_quote = [];
var ABAlias_json_table = [];
var ABAlias_json_general = [
  { regex: "|\u9ED1\u5E55|", replacement: "|addClass(ab-deco-heimu)|" },
  { regex: "|\u6298\u53E0|", replacement: "|fold|" },
  { regex: "|\u6EDA\u52A8|", replacement: "|scroll|" },
  { regex: "|\u8D85\u51FA\u6298\u53E0|", replacement: "|overfold|" },
  { regex: "|\u8F6C\u7F6E|", replacement: "|transpose|" },
  { regex: "|T|", replacement: "|transpose|" },
  { regex: "|\u7EA2\u5B57|", replacement: "|addClass(ab-custom-text-red)|" },
  { regex: "|\u6A59\u5B57|", replacement: "|addClass(ab-custom-text-orange)|" },
  { regex: "|\u9EC4\u5B57|", replacement: "|addClass(ab-custom-text-yellow)|" },
  { regex: "|\u7EFF\u5B57|", replacement: "|addClass(ab-custom-text-green)|" },
  { regex: "|\u9752\u5B57|", replacement: "|addClass(ab-custom-text-cyan)|" },
  { regex: "|\u84DD\u5B57|", replacement: "|addClass(ab-custom-text-blue)|" },
  { regex: "|\u7D2B\u5B57|", replacement: "|addClass(ab-custom-text-purple)|" },
  { regex: "|\u767D\u5B57|", replacement: "|addClass(ab-custom-text-white)|" },
  { regex: "|\u9ED1\u5B57|", replacement: "|addClass(ab-custom-text-black)|" },
  { regex: "|\u7EA2\u5E95|", replacement: "|addClass(ab-custom-bg-red)|" },
  { regex: "|\u6A59\u5E95|", replacement: "|addClass(ab-custom-bg-orange)|" },
  { regex: "|\u9EC4\u5E95|", replacement: "|addClass(ab-custom-bg-yellow)|" },
  { regex: "|\u7EFF\u5E95|", replacement: "|addClass(ab-custom-bg-green)|" },
  { regex: "|\u9752\u5E95|", replacement: "|addClass(ab-custom-bg-cyan)|" },
  { regex: "|\u84DD\u5E95|", replacement: "|addClass(ab-custom-bg-blue)|" },
  { regex: "|\u7D2B\u5E95|", replacement: "|addClass(ab-custom-bg-purple)|" },
  { regex: "|\u767D\u5E95|", replacement: "|addClass(ab-custom-bg-white)|" },
  { regex: "|\u9ED1\u5E95|", replacement: "|addClass(ab-custom-bg-black)|" },
  { regex: "|\u9760\u4E0A|", replacement: "|addClass(ab-custom-dire-top)|" },
  { regex: "|\u9760\u4E0B|", replacement: "|addClass(ab-custom-dire-down)|" },
  { regex: "|\u9760\u5DE6|", replacement: "|addClass(ab-custom-dire-left)|" },
  { regex: "|\u9760\u53F3|", replacement: "|addClass(ab-custom-dire-right)|" },
  { regex: "|\u5C45\u4E2D|", replacement: "|addClass(ab-custom-dire-center)|" },
  { regex: "|\u6C34\u5E73\u5C45\u4E2D|", replacement: "|addClass(ab-custom-dire-hcenter)|" },
  { regex: "|\u5782\u76F4\u5C45\u4E2D|", replacement: "|addClass(ab-custom-dire-vcenter)|" },
  { regex: "|\u4E24\u7AEF\u5BF9\u9F50|", replacement: "|addClass(ab-custom-dire-justify)|" },
  { regex: "|\u5927\u5B57|", replacement: "|addClass(ab-custom-font-large)|" },
  { regex: "|\u8D85\u5927\u5B57|", replacement: "|addClass(ab-custom-font-largex)|" },
  { regex: "|\u8D85\u8D85\u5927\u5B57|", replacement: "|addClass(ab-custom-font-largexx)|" },
  { regex: "|\u5C0F\u5B57|", replacement: "|addClass(ab-custom-font-small)|" },
  { regex: "|\u8D85\u5C0F\u5B57|", replacement: "|addClass(ab-custom-font-smallx)|" },
  { regex: "|\u8D85\u8D85\u5C0F\u5B57|", replacement: "|addClass(ab-custom-font-smallxx)|" },
  { regex: "|\u52A0\u7C97|", replacement: "|addClass(ab-custom-font-bold)|" }
];
var ABAlias_json_default = [
  ...ABAlias_json_mdit,
  ...ABAlias_json_title,
  ...ABAlias_json_list,
  ...ABAlias_json_code,
  ...ABAlias_json_quote,
  ...ABAlias_json_table,
  ...ABAlias_json_general
];
var ABAlias_json = [
  ...ABAlias_json_default
];
var ABAlias_json_end = [
  { regex: "|:::_140lne", replacement: "" },
  { regex: "|heading_140lne", replacement: "" },
  { regex: "|list_140lne", replacement: "" },
  { regex: "|code_140lne", replacement: "" },
  { regex: "|qutoe_140lne", replacement: "" },
  { regex: "|table_140lne", replacement: "" }
];

// ../ABConverter/ABConvertManager.ts
var ABConvertManager = class {
  constructor() {
    this.list_abConvert = [];
    this.m_renderMarkdownFn = (markdown, el) => {
      el.classList.add("markdown-rendered");
      console.error("Please use renderMarkdownFn redefine render function");
    };
    if (typeof obsidian == "undefined" && typeof app == "undefined") {
      console.log("[environment]: markdown-it, without obsidian");
    } else {
      console.log("[environment]: obsidian");
    }
  }
  static getInstance() {
    if (!ABConvertManager.m_instance) {
      ABConvertManager.m_instance = new ABConvertManager();
    }
    return ABConvertManager.m_instance;
  }
  getConvertOptions() {
    return this.list_abConvert.filter((item) => {
      return item.default;
    }).map((item) => {
      return { id: item.default, name: item.name };
    });
  }
  redefine_renderMarkdown(callback) {
    this.m_renderMarkdownFn = callback;
  }
  static autoABConvert(el, header, content, selectorName = "") {
    let prev_result = content;
    let prev_type = "string";
    let prev_type2 = "string" /* text */;
    let prev_processor;
    let prev2 = {
      prev_result,
      prev_type,
      prev_type2,
      prev_processor
    };
    if (false)
      ABConvertManager.startTime = performance.now();
    {
      header = autoABAlias(header, selectorName, prev_result);
      let list_header = header.split("|");
      prev_result = this.autoABConvert_runConvert(el, list_header, prev2);
      this.autoABConvert_last(el, header, selectorName, prev2);
    }
    if (false) {
      const endTime = performance.now();
      console.log(`Takes ${(endTime - ABConvertManager.startTime).toFixed(2)} ms when selector "${selectorName}" header "${header}"`);
    }
  }
  static autoABConvert_runConvert(el, list_header, prev2) {
    for (let item_header of list_header) {
      for (let abReplaceProcessor of ABConvertManager.getInstance().list_abConvert) {
        if (typeof abReplaceProcessor.match == "string") {
          if (abReplaceProcessor.match != item_header)
            continue;
        } else {
          if (!abReplaceProcessor.match.test(item_header))
            continue;
        }
        if (abReplaceProcessor.process_alias) {
          let alias = abReplaceProcessor.process_alias;
          (() => {
            if (abReplaceProcessor.process_alias.indexOf("%") < 0)
              return;
            if (typeof abReplaceProcessor.match == "string")
              return;
            const matchs = item_header.match(abReplaceProcessor.match);
            if (!matchs)
              return;
            const len = matchs.length;
            if (len == 1)
              return;
            for (let i = 1; i < len; i++) {
              if (!matchs[i])
                continue;
              alias = alias.replace(RegExp(`%${i}`), matchs[i]);
            }
          })();
          prev2.prev_result = this.autoABConvert_runConvert(el, alias.split("|"), prev2);
        } else if (abReplaceProcessor.process) {
          if (abReplaceProcessor.process_param != prev2.prev_type2) {
            if (abReplaceProcessor.process_param == "HTMLElement" /* el */ && prev2.prev_type2 == "string" /* text */) {
              const subEl = document.createElement("div");
              el.appendChild(subEl);
              ABConvertManager.getInstance().m_renderMarkdownFn(prev2.prev_result, subEl);
              prev2.prev_result = el;
              prev2.prev_type = typeof prev2.prev_result;
              prev2.prev_type2 = "HTMLElement" /* el */;
              prev2.prev_processor = "md";
            } else if (abReplaceProcessor.process_param == "string" /* text */ && (prev2.prev_type2 == "array" /* list_stream */ || prev2.prev_type2 == "array2" /* c2list_stream */)) {
              prev2.prev_result = JSON.stringify(prev2.prev_result, null, 2);
              prev2.prev_type = typeof prev2.prev_result;
              prev2.prev_type2 = "string" /* text */;
              prev2.prev_processor = "stream to text";
            } else if (abReplaceProcessor.process_param == "string" /* text */ && prev2.prev_type2 == "json_string" /* json */) {
              prev2.prev_type2 = "string" /* text */;
              prev2.prev_processor = "json to text";
            } else {
              console.warn(`\u5904\u7406\u5668\u8F93\u5165\u7C7B\u578B\u9519\u8BEF, id:${abReplaceProcessor.id}, virtualParam:${abReplaceProcessor.process_param}, realParam:${prev2.prev_type2}`);
              break;
            }
          }
          prev2.prev_result = abReplaceProcessor.process(el, item_header, prev2.prev_result);
          prev2.prev_type = typeof prev2.prev_result;
          prev2.prev_type2 = abReplaceProcessor.process_return;
          prev2.prev_processor = abReplaceProcessor.process;
        } else {
          console.warn("\u5904\u7406\u5668\u5FC5\u987B\u5B9E\u73B0process\u6216process_alias\u65B9\u6CD5");
        }
      }
    }
    return prev2;
  }
  static autoABConvert_last(el, header, selectorName, prev2) {
    if (prev2.prev_type == "string" && prev2.prev_type2 == "string" /* text */) {
      const subEl = document.createElement("div");
      el.appendChild(subEl);
      ABConvertManager.getInstance().m_renderMarkdownFn(prev2.prev_result, subEl);
      prev2.prev_result = el;
      prev2.prev_type = "object";
      prev2.prev_type2 = "HTMLElement" /* el */;
      prev2.process = "md";
    } else if (prev2.prev_type == "string" && prev2.prev_type2 == "json_string" /* json */) {
      const code_str = "```json\n" + prev2.prev_result + "\n```\n";
      const subEl = document.createElement("div");
      el.appendChild(subEl);
      ABConvertManager.getInstance().m_renderMarkdownFn(code_str, subEl);
      prev2.prev_result = el;
      prev2.prev_type = "object";
      prev2.prev_type2 = "HTMLElement" /* el */;
      prev2.process = "show_json";
    } else if (prev2.prev_type == "object" && (prev2.prev_type2 == "array" /* list_stream */ || prev2.prev_type2 == "array2" /* c2list_stream */ || prev2.prev_type2 == "json_string" /* json */)) {
      const code_str = "```json\n" + JSON.stringify(prev2.prev_result, null, 2) + "\n```\n";
      const subEl = document.createElement("div");
      el.appendChild(subEl);
      ABConvertManager.getInstance().m_renderMarkdownFn(code_str, subEl);
      prev2.prev_result = el;
      prev2.prev_type = "object";
      prev2.prev_type2 = "HTMLElement" /* el */;
      prev2.process = "show_listStream";
    } else if (prev2.prev_type == "object" && prev2.prev_type2 == "HTMLElement" /* el */) {
      return prev2;
    } else {
      console.warn("other type in tail, can not tail processor:", prev2.prev_type, prev2.prev_type2, prev2.prev_result);
    }
    return prev2;
  }
};

// ../ABConverter/converter/abc_text.ts
var abc_addQuote = ABConvert.factory({
  id: "addQuote",
  name: "\u589E\u52A0\u5F15\u7528\u5757",
  match: "addQuote",
  detail: "\u5728\u6587\u672C\u7684\u6BCF\u884C\u524D\u9762\u52A0\u4E0A `> `",
  process_param: "string" /* text */,
  process_return: "string" /* text */,
  process: (el, header, content) => {
    return content.split("\n").map((line) => {
      return "> " + line;
    }).join("\n");
  }
});
var abc_addCode = ABConvert.factory({
  id: "addCode",
  name: "\u589E\u52A0\u4EE3\u7801\u5757",
  match: /^(addCode|code)(\((.*)\))?$/,
  default: "code()",
  detail: "\u5728\u6587\u672C\u7684\u524D\u540E\u5747\u52A0\u4E0A\u4E00\u884C\u4EE3\u7801\u5757\u56F4\u680F\u3002\u4E0D\u52A0`()`\u8868\u793A\u7528\u539F\u6587\u672C\u7684\u7B2C\u4E00\u884C\u4F5C\u4E3A\u4EE3\u7801\u7C7B\u578B\uFF0C\u62EC\u53F7\u7C7B\u578B\u4E3A\u7A7A\u8868\u793A\u4EE3\u7801\u7C7B\u578B\u4E3A\u7A7A",
  process_param: "string" /* text */,
  process_return: "string" /* text */,
  process: (el, header, content) => {
    let matchs = header.match(/^(addCode|code)(\((.*)\))?$/);
    if (!matchs)
      return content;
    if (matchs[2])
      content = matchs[3] + "\n" + content;
    return "``````" + content + "\n``````";
  }
});
var abc_xQuote = ABConvert.factory({
  id: "xQuote",
  name: "\u53BB\u9664\u5F15\u7528\u5757",
  match: /^(xQuote|Xquote)$/,
  detail: "\u5728\u6587\u672C\u7684\u6BCF\u884C\u524D\u9762\u5220\u9664 `> `",
  process_param: "string" /* text */,
  process_return: "string" /* text */,
  process: (el, header, content) => {
    return content.split("\n").map((line) => {
      return line.replace(/^>\s/, "");
    }).join("\n");
  }
});
var abc_xCode = ABConvert.factory({
  id: "xCode",
  name: "\u53BB\u9664\u4EE3\u7801\u5757",
  match: /^(xCode|Xcode)(\((true|false|)\))?$/,
  default: "xCode(true)",
  detail: "\u53C2\u6570\u4E3A\u662F\u5426\u79FB\u9664\u4EE3\u7801\u7C7B\u578B, Xcode\u9ED8\u8BA4\u4E3Afalse, Xcode\u9ED8\u8BA4\u4E3Atrue\u3002\u8BB0\u6CD5: code|Xcode \u6216 code()|Xcode()\u5185\u5BB9\u4E0D\u53D8",
  process_param: "string" /* text */,
  process_return: "string" /* text */,
  process: (el, header, content) => {
    let matchs = header.match(/^(xCode|Xcode)(\((true|false|)\))?$/);
    if (!matchs)
      return content;
    let remove_flag;
    if (matchs[2] == "")
      remove_flag = false;
    else
      remove_flag = matchs[3] != "false";
    let list_content = content.split("\n");
    let code_flag = "";
    let line_start = -1;
    let line_end = -1;
    for (let i = 0; i < list_content.length; i++) {
      if (code_flag == "") {
        const match_tmp = list_content[i].match(ABReg.reg_code);
        if (match_tmp) {
          code_flag = match_tmp[3];
          line_start = i;
        }
      } else {
        if (list_content[i].indexOf(code_flag) >= 0) {
          line_end = i;
          break;
        }
      }
    }
    if (line_start >= 0 && line_end > 0) {
      if (remove_flag)
        list_content[line_start] = list_content[line_start].replace(/^```(.*)$|^~~~(.*)$/, "");
      else
        list_content[line_start] = list_content[line_start].replace(/^```|^~~~/, "");
      list_content[line_end] = list_content[line_end].replace(/^```|^~~~/, "");
      content = list_content.join("\n");
    }
    return content;
  }
});
var abc_x = ABConvert.factory({
  id: "x",
  name: "\u53BB\u9664\u4EE3\u7801\u6216\u5F15\u7528\u5757",
  match: /^(x|X)$/,
  process_param: "string" /* text */,
  process_return: "string" /* text */,
  process: (el, header, content) => {
    let flag = "";
    for (let line of content.split("\n")) {
      if (ABReg.reg_code.test(line)) {
        flag = "code";
        break;
      } else if (ABReg.reg_quote.test(line)) {
        flag = "quote";
        break;
      }
    }
    if (flag == "code")
      return abc_xCode.process(el, header, content);
    else if (flag == "quote")
      return abc_xQuote.process(el, header, content);
    return content;
  }
});
var abc_slice = ABConvert.factory({
  id: "slice",
  name: "\u5207\u7247",
  match: /^slice\((\s*\d+\s*)(,\s*-?\d+\s*)?\)$/,
  detail: "\u548Cjs\u7684slice\u65B9\u6CD5\u662F\u4E00\u6837\u7684\u3002\u4F8B\u5982 `[slice(1, -1)]`",
  process_param: "string" /* text */,
  process_return: "string" /* text */,
  process: (el, header, content) => {
    const list_match = header.match(/^slice\((\s*\d+\s*)(,\s*-?\d+\s*)?\)$/);
    if (!list_match)
      return content;
    const arg1 = Number(list_match[1].trim());
    if (isNaN(arg1))
      return content;
    if (!list_match[2])
      return content.split("\n").slice(arg1).join("\n");
    const arg2 = Number(list_match[2].replace(",", "").trim());
    if (isNaN(arg2))
      return content.split("\n").slice(arg1).join("\n");
    else
      return content.split("\n").slice(arg1, arg2).join("\n");
  }
});
var abc_add = ABConvert.factory({
  id: "add",
  name: "\u589E\u6DFB\u5185\u5BB9",
  match: /^add\((.*?)(,\s*-?\d+\s*)?\)$/,
  detail: "\u589E\u6DFB. \u53C2\u65702\u4E3A\u884C\u5E8F, \u9ED8\u8BA40, \u884C\u5C3E-1\u3002\u4F1A\u63D2\u884C\u589E\u6DFB",
  process_param: "string" /* text */,
  process_return: "string" /* text */,
  process: (el, header, content) => {
    const list_match = header.match(/^add\((.*?)(,\s*-?\d+\s*)?\)$/);
    if (!list_match)
      return content;
    if (!list_match[1])
      return content;
    const arg1 = list_match[1].trim();
    if (!arg1)
      return content;
    let arg2;
    if (!list_match[2])
      arg2 = 0;
    else {
      arg2 = Number(list_match[2].replace(",", "").trim());
      if (isNaN(arg2)) {
        arg2 = 0;
      }
    }
    const list_content = content.split("\n");
    if (arg2 >= 0 && arg2 < list_content.length)
      list_content[arg2] = arg1 + "\n" + list_content[arg2];
    else if (arg2 < 0 && arg2 * -1 <= list_content.length) {
      arg2 = list_content.length + arg2;
      list_content[arg2] = arg1 + "\n" + list_content[arg2];
    }
    return list_content.join("\n");
  }
});
var abc_listroot = ABConvert.factory({
  id: "listroot",
  name: "\u589E\u52A0\u5217\u8868\u6839",
  match: /^listroot\((.*)\)$/,
  default: "listroot(root)",
  detail: "\u6BCF\u884C\u524D\u9762\u52A0\u4E24\u7A7A\u683C\uFF0C\u5E76\u5728\u9996\u884C\u63D2\u5165 `- ` \u5F00\u5934\u7684\u6839\u5217\u8868\u9879",
  process_param: "string" /* text */,
  process_return: "string" /* text */,
  process: (el, header, content) => {
    const list_match = header.match(/^listroot\((.*)\)$/);
    if (!list_match)
      return content;
    const arg1 = list_match[1].trim();
    content = content.split("\n").map((line) => {
      return "  " + line;
    }).join("\n");
    content = "- " + arg1 + "\n" + content;
    return content;
  }
});
var abc_addList = ABConvert.factory({
  id: "addList",
  name: "\u7F29\u8FDB\u8F6C\u5217\u8868",
  detail: "\u7F29\u8FDB\u8F6C\u5217\u8868",
  default: "\u7F29\u8FDB\u8F6C\u5217\u8868\u3002\u5BF9\u4E8E\u7A7A\u884C\u7684\u5904\u7406\u6709\u4E24\u79CD\u7B56\u7565\uFF1A\u4E00\u662F\u7A7A\u884C\u8868\u793A\u4E0B\u4E00\u4E2A\u5217\u8868\uFF0C\u5355\u6362\u884C\u8868\u793A\u540C\u4E00\u5217\u8868\u9879\u3002\u4E8C\u662F\u5FFD\u7565\u7A7A\u884C\u3002\u6682\u65F6\u4EC5\u4E3A\u7B56\u7565\u4E8C",
  process_param: "string" /* text */,
  process_return: "string" /* text */,
  process: (el, header, content) => {
    const lists = content.trimEnd().split("\n");
    let newContent = "";
    for (const item of lists) {
      if (item.trim() == "")
        continue;
      const match2 = item.match(/^(\s*)(.*)/);
      if (match2) {
        newContent += "\n" + match2[1] + "- " + match2[2];
      } else {
      }
    }
    return newContent;
  }
});
var abc_xList = ABConvert.factory({
  id: "xList",
  name: "\u5217\u8868\u8F6C\u7F29\u8FDB",
  match: /^(xList|Xlist)$/,
  detail: "\u5217\u8868\u8F6C\u7F29\u8FDB\u3002\u5BF9\u4E8E\u591A\u884C\u5185\u5BB9\u7684\u5217\u8868\u9879\uFF0C\u9ED8\u8BA4\u6362\u884C\u9879\u5220\u9664\u524D\u7F6E\u7A7A\u683C\u5E76\u4F7F\u7528 `; ` \u62FC\u63A5\uFF0C\u62FC\u63A5\u7B26\u6682\u4E0D\u652F\u6301\u81EA\u5B9A\u4E49",
  process_param: "string" /* text */,
  process_return: "string" /* text */,
  process: (el, header, content) => {
    const lists = content.trimEnd().split("\n");
    let newContent = "";
    for (const item of lists) {
      const match2 = item.match(ABReg.reg_list_noprefix);
      if (match2) {
        newContent += "\n" + match2[1] + match2[4];
      } else if (newContent != "") {
        newContent += "; " + item.trimStart();
      } else {
      }
    }
    return newContent.slice(1);
  }
});

// ../ABConverter/converter/abc_code.ts
var abc_region2indent = ABConvert.factory({
  id: "region2indent",
  name: "\u4EE3\u7801\u6CE8\u91CA\u8F6C\u7F29\u8FDB",
  detail: "\u4EE3\u7801\u5757\u6CE8\u91CA\u8F6C\u7F29\u8FDB (\u8BC6\u522B `//` \u548C `#` \u7684region\u6CE8\u91CA\u5BF9)\uFF0C\u901A\u5E38\u914D\u5408code2list\u4F7F\u7528\u3002\u9ED8\u8BA4\u8865\u5145\u4E24\u7F29\u8FDB",
  process_param: "string" /* text */,
  process_return: "string" /* text */,
  process: (el, header, content) => {
    const lists = content.trimEnd().split("\n");
    let newContent = "";
    let startFlagNumber = 0;
    const regionReg = /^([ \t]*)(#|\/\/)\s*#?(region|endregion)(.*)/;
    for (let i = 0; i < lists.length; i++) {
      const item = lists[i];
      const match2 = item.match(regionReg);
      if (!match2) {
        newContent += "\n" + "  ".repeat(startFlagNumber) + item;
        continue;
      } else {
        if (match2[3] == "region") {
          newContent += "\n" + "  ".repeat(startFlagNumber) + match2[4].trimStart();
          startFlagNumber++;
        } else {
          startFlagNumber--;
        }
      }
    }
    return newContent.slice(1);
  }
});
var abc_mdit2code = ABConvert.factory({
  id: "mdit2code",
  name: "mdit\u8F6C\u4EE3\u7801\u5757",
  detail: "mdit\u8F6C\u4EE3\u7801\u5757 (\u5141\u8BB8\u5D4C\u5957)\u3002\u6CE8\u610F `:*n` \u4F1A\u8F6C\u5316\u4E3A `~*(n+3)`, `@aaa bbb` \u4F1A\u8F6C\u6362\u4E3A `# bbb` (h1\u6807\u9898)",
  process_param: "string" /* text */,
  process_return: "string" /* text */,
  process: (el, header, content) => {
    const lists = content.trimEnd().split("\n");
    let newContent = "";
    for (let i = 0; i < lists.length; i++) {
      const item = lists[i];
      const match2 = item.match(ABReg.reg_mdit_head);
      const match22 = item.trim().match(/^@(\S*?)\s(.*?)$/);
      if (match22) {
        newContent += "\n# " + match22[2];
      } else if (match2) {
        const flag = "~".repeat(match2[3].length + 3);
        if (match2[4].trim() !== "")
          newContent += "\n" + flag + "anyblock\n[" + match2[4].trimStart() + "]";
        else
          newContent += "\n" + flag;
        continue;
      } else {
        newContent += "\n" + item;
        continue;
      }
    }
    return newContent.slice(1);
  }
});

// ../ABConverter/converter/abc_list.ts
var ListProcess = class {
  static list2data(text4, modeG = true) {
    let list_inline_comp = [];
    function update_inline_comp(level, inline_comp) {
      if (list_inline_comp.length == 0 && inline_comp == 0)
        return 0;
      while (list_inline_comp.length && list_inline_comp[list_inline_comp.length - 1].level >= level) {
        list_inline_comp.pop();
      }
      if (list_inline_comp.length == 0 && inline_comp == 0)
        return 0;
      let total_comp;
      if (list_inline_comp.length == 0)
        total_comp = 0;
      else
        total_comp = list_inline_comp[list_inline_comp.length - 1].inline_comp;
      if (inline_comp > 0)
        list_inline_comp.push({
          level,
          inline_comp: inline_comp + total_comp
        });
      return total_comp;
    }
    let list_itemInfo = [];
    const list_text = text4.split("\n");
    for (let line of list_text) {
      const m_line = line.match(ABReg.reg_list_noprefix);
      if (m_line) {
        let list_inline = m_line[4].split(ABReg.inline_split);
        let level_inline = m_line[1].length;
        let inline_comp = update_inline_comp(level_inline, list_inline.length - 1);
        for (let index2 = 0; index2 < list_inline.length; index2++) {
          list_itemInfo.push({
            content: list_inline[index2],
            level: level_inline + index2 + inline_comp
          });
        }
      } else {
        let itemInfo = list_itemInfo.pop();
        if (itemInfo) {
          list_itemInfo.push({
            content: itemInfo.content + "\n" + line.trim(),
            level: itemInfo.level
          });
        }
      }
    }
    return list_itemInfo;
  }
  static list2listnode(text4) {
    let data2 = ListProcess.list2data(text4, false);
    data2 = ListProcess.data2strict(data2);
    let nodes = [];
    let prev_nodes = [];
    let current_data;
    for (let index2 = 0; index2 < data2.length; index2++) {
      const item = data2[index2];
      current_data = {
        content: item.content,
        children: []
      };
      prev_nodes[item.level] = current_data;
      if (item.level >= 1 && prev_nodes.hasOwnProperty(item.level - 1)) {
        prev_nodes[item.level - 1].children.push(current_data);
      } else if (item.level == 0) {
        nodes.push(current_data);
      } else {
        console.error(`list\u6570\u636E\u4E0D\u5408\u89C4\uFF0C\u6CA1\u6709\u6B63\u89C4\u5316. level:${item.level}, prev_nodes:${prev_nodes}`);
        return nodes;
      }
    }
    return nodes;
  }
  static list2json(text4) {
    let data2 = ListProcess.list2data(text4, false);
    data2 = ListProcess.data2strict(data2);
    let nodes = {};
    let prev_nodes = [];
    for (let index2 = 0; index2 < data2.length; index2++) {
      const item = data2[index2];
      const current_key = item.content;
      const current_value = {};
      prev_nodes[item.level] = current_value;
      if (item.level >= 1 && prev_nodes.hasOwnProperty(item.level - 1)) {
        let lastItem = prev_nodes[item.level - 1];
        if (typeof lastItem != "object" || Array.isArray(lastItem)) {
          console.error(`list\u6570\u636E\u4E0D\u5408\u89C4\uFF0C\u7236\u8282\u70B9\u7684value\u503C\u4E0D\u662F{}\u7C7B\u578B`);
          return nodes;
        }
        lastItem[current_key] = current_value;
      } else if (item.level == 0) {
        nodes[current_key] = current_value;
      } else {
        console.error(`list\u6570\u636E\u4E0D\u5408\u89C4\uFF0C\u6CA1\u6709\u6B63\u89C4\u5316. level:${item.level}, prev_nodes:${prev_nodes}`);
        return nodes;
      }
    }
    let nodes2 = nodes;
    traverse(nodes2);
    return nodes2;
    function traverse(obj, objSource, objSource2) {
      if (Array.isArray(obj))
        return;
      const keys = Object.keys(obj);
      let count_null = 0;
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (!obj.hasOwnProperty(key))
          continue;
        const value = obj[key];
        if (typeof value === "object" && !Array.isArray(value)) {
          if (Object.keys(value).length === 0) {
            let index2 = key.indexOf(": ");
            if (index2 > 0) {
              delete obj[key];
              i--;
              obj[key.slice(0, index2)] = key.slice(index2 + 1);
            } else {
              obj[key] = "";
              count_null++;
            }
          } else {
            traverse(value, obj, key);
          }
        } else {
        }
      }
      if (objSource && objSource2) {
        let newObj = [];
        if (count_null == keys.length) {
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            if (!obj.hasOwnProperty(key))
              continue;
            newObj.push(key);
          }
          objSource[objSource2] = newObj;
        }
      }
    }
  }
  static title2data(text4) {
    let list_itemInfo = [];
    const list_text = text4.split("\n");
    let mul_mode = "";
    let codeBlockFlag = "";
    for (let line of list_text) {
      if (codeBlockFlag == "") {
        const match2 = line.match(ABReg.reg_code);
        if (match2 && match2[3]) {
          codeBlockFlag = match2[1] + match2[3];
          list_itemInfo[list_itemInfo.length - 1].content = list_itemInfo[list_itemInfo.length - 1].content + "\n" + line;
          continue;
        }
      } else {
        if (line.indexOf(codeBlockFlag) == 0)
          codeBlockFlag = "";
        list_itemInfo[list_itemInfo.length - 1].content = list_itemInfo[list_itemInfo.length - 1].content + "\n" + line;
        continue;
      }
      const match_heading = line.match(ABReg.reg_heading_noprefix);
      const match_list = line.match(ABReg.reg_list_noprefix);
      if (match_heading && !match_heading[1]) {
        removeTailBlank();
        list_itemInfo.push({
          content: match_heading[4],
          level: match_heading[3].length - 1 - 10
        });
        mul_mode = "heading";
      } else if (match_list) {
        removeTailBlank();
        list_itemInfo.push({
          content: match_list[4],
          level: match_list[1].length + 1
        });
        mul_mode = "list";
      } else if (/^\S/.test(line) && mul_mode == "list") {
        list_itemInfo[list_itemInfo.length - 1].content = list_itemInfo[list_itemInfo.length - 1].content + "\n" + line;
      } else {
        if (mul_mode == "para") {
          list_itemInfo[list_itemInfo.length - 1].content = list_itemInfo[list_itemInfo.length - 1].content + "\n" + line;
        } else if (/^\s*$/.test(line)) {
          continue;
        } else {
          list_itemInfo.push({
            content: line,
            level: 0
          });
          mul_mode = "para";
        }
      }
    }
    removeTailBlank();
    return list_itemInfo;
    function removeTailBlank() {
      if (mul_mode == "para" || mul_mode == "list") {
        list_itemInfo[list_itemInfo.length - 1].content = list_itemInfo[list_itemInfo.length - 1].content.replace(/\s*$/, "");
      }
    }
  }
  static old_ulist2data(text4) {
    let list_itemInfo = [];
    let level1 = -1;
    let level2 = -1;
    const list_text = text4.split("\n");
    for (let line of list_text) {
      const m_line = line.match(ABReg.reg_list_noprefix);
      if (m_line) {
        let level_inline = m_line[1].length;
        let this_level;
        if (level1 < 0) {
          level1 = level_inline;
          this_level = 1;
        } else if (level1 >= level_inline)
          this_level = 1;
        else if (level2 < 0) {
          level2 = level_inline;
          this_level = 2;
        } else if (level2 >= level_inline)
          this_level = 2;
        else {
          let itemInfo = list_itemInfo.pop();
          if (itemInfo) {
            list_itemInfo.push({
              content: itemInfo.content + "\n" + line.trim(),
              level: itemInfo.level
            });
          }
          continue;
        }
        list_itemInfo.push({
          content: m_line[4],
          level: this_level
        });
      } else {
        let itemInfo = list_itemInfo.pop();
        if (itemInfo) {
          list_itemInfo.push({
            content: itemInfo.content + "\n" + line.trim(),
            level: itemInfo.level
          });
        }
      }
    }
    let count_level_2 = 0;
    for (let item of list_itemInfo) {
      if (item.level == 2) {
        item.level += count_level_2;
        count_level_2++;
      } else {
        count_level_2 = 0;
      }
    }
    return list_itemInfo;
  }
  static data2strict(list_itemInfo) {
    let list_prev_level = [-999];
    let list_itemInfo2 = [];
    for (let itemInfo of list_itemInfo) {
      let new_level = 0;
      for (let i = 0; i < list_prev_level.length; i++) {
        if (list_prev_level[i] < itemInfo.level)
          continue;
        else if (list_prev_level[i] == itemInfo.level) {
          list_prev_level = list_prev_level.slice(0, i + 1);
          new_level = i;
          break;
        } else {
          list_prev_level = list_prev_level.slice(0, i);
          list_prev_level.push(itemInfo.level);
          new_level = i;
          break;
        }
      }
      if (new_level == 0) {
        list_prev_level.push(itemInfo.level);
        new_level = list_prev_level.length - 1;
      }
      list_itemInfo2.push({
        content: itemInfo.content,
        level: new_level - 1
      });
    }
    return list_itemInfo2;
  }
  static data_2L_2_mL1B(list_itemInfo) {
    let list_itemInfo2 = [];
    let count_level_2 = 0;
    for (let item of list_itemInfo) {
      if (item.level != 0) {
        list_itemInfo2.push({
          content: item.content,
          level: item.level + count_level_2
        });
        count_level_2++;
      } else {
        list_itemInfo2.push({
          content: item.content,
          level: item.level
        });
        count_level_2 = 0;
      }
    }
    return list_itemInfo2;
  }
  static data2list(list_itemInfo) {
    let list_newcontent = [];
    for (let item of list_itemInfo) {
      const str_indent = " ".repeat(item.level);
      let list_content = item.content.split("\n");
      for (let i = 0; i < list_content.length; i++) {
        if (i == 0)
          list_newcontent.push(str_indent + "- " + list_content[i]);
        else
          list_newcontent.push(str_indent + "  " + list_content[i]);
      }
    }
    const newcontent = list_newcontent.join("\n");
    return newcontent;
  }
  static data2nodes(listdata, el) {
    const el_root = document.createElement("div");
    el.appendChild(el_root);
    el_root.classList.add("ab-nodes");
    const el_root2 = document.createElement("div");
    el_root.appendChild(el_root2);
    el_root2.classList.add("ab-nodes-children");
    let cache_els = [];
    for (let item of listdata) {
      const el_node = document.createElement("div");
      el_node.classList.add("ab-nodes-node");
      el_node.setAttribute("has_children", "false");
      const el_node_content = document.createElement("div");
      el_node.appendChild(el_node_content);
      el_node_content.classList.add("ab-nodes-content");
      ABConvertManager.getInstance().m_renderMarkdownFn(item.content, el_node_content);
      const el_node_children = document.createElement("div");
      el_node.appendChild(el_node_children);
      el_node_children.classList.add("ab-nodes-children");
      const el_node_barcket = document.createElement("div");
      el_node_children.appendChild(el_node_barcket);
      el_node_barcket.classList.add("ab-nodes-bracket");
      const el_node_barcket2 = document.createElement("div");
      el_node_children.appendChild(el_node_barcket2);
      el_node_barcket2.classList.add("ab-nodes-bracket2");
      cache_els[item.level] = { node: el_node, content: el_node_content, children: el_node_children };
      if (item.level == 0) {
        el_root2.appendChild(el_node);
      } else if (item.level >= 1 && cache_els.hasOwnProperty(item.level - 1)) {
        cache_els[item.level - 1].children.appendChild(el_node);
        cache_els[item.level - 1].node.setAttribute("has_children", "true");
      } else {
        console.error("\u8282\u70B9\u9519\u8BEF");
        return el;
      }
    }
    return el;
  }
};
var abc_list2listdata = ABConvert.factory({
  id: "list2listdata",
  name: "\u5217\u8868\u5230listdata",
  process_param: "string" /* text */,
  process_return: "array" /* list_stream */,
  detail: "\u5217\u8868\u5230listdata",
  process: (el, header, content) => {
    return ListProcess.list2data(content);
  }
});
var abc_title2listdata = ABConvert.factory({
  id: "title2listdata",
  name: "\u6807\u9898\u5230listdata",
  process_param: "string" /* text */,
  process_return: "array" /* list_stream */,
  detail: "\u6807\u9898\u5230listdata",
  process: (el, header, content) => {
    return ListProcess.title2data(content);
  }
});
var abc_listdata2list = ABConvert.factory({
  id: "listdata2list",
  name: "listdata\u5230\u5217\u8868",
  process_param: "array" /* list_stream */,
  process_return: "string" /* text */,
  detail: "listdata\u5230\u5217\u8868",
  process: (el, header, content) => {
    return ListProcess.data2list(content);
  }
});
var abc_listdata2nodes = ABConvert.factory({
  id: "listdata2nodes",
  name: "listdata\u5230\u8282\u70B9\u56FE",
  process_param: "array" /* list_stream */,
  process_return: "HTMLElement" /* el */,
  detail: "listdata\u5230\u8282\u70B9\u56FE",
  process: (el, header, content) => {
    return ListProcess.data2nodes(content, el);
  }
});
var abc_listdata2strict = ABConvert.factory({
  id: "listdata2strict",
  name: "listdata\u4E25\u683C\u5316",
  process_param: "array" /* list_stream */,
  process_return: "array" /* list_stream */,
  detail: "\u5C06\u5217\u8868\u6570\u636E\u8F6C\u5316\u4E3A\u66F4\u89C4\u8303\u7684\u5217\u8868\u6570\u636E\u3002\u7EDF\u4E00\u7F29\u8FDB\u7B26(2\u7A7A\u683C 4\u7A7A\u683C tab\u6DF7\u7528)\u3001\u7981\u6B62\u8DF3\u7B49\u7EA7(h1\u76F4\u63A5\u5C31\u5230h3)",
  process: (el, header, content) => {
    return ListProcess.data2strict(content);
  }
});
var abc_list2listnode = ABConvert.factory({
  id: "list2listnode",
  name: "\u5217\u8868\u5230listnode (beta)",
  process_param: "string" /* text */,
  process_return: "json_string" /* json */,
  detail: "\u5217\u8868\u5230listnode",
  process: (el, header, content) => {
    const data2 = ListProcess.list2listnode(content);
    return JSON.stringify(data2, null, 2);
  }
});
var abc_list2json = ABConvert.factory({
  id: "list2json",
  name: "\u5217\u8868\u5230json (beta)",
  process_param: "string" /* text */,
  process_return: "json_string" /* json */,
  detail: "\u5217\u8868\u5230json",
  process: (el, header, content) => {
    const data2 = ListProcess.list2json(content);
    return JSON.stringify(data2, null, 2);
  }
});

// ../ABConverter/converter/abc_c2list.ts
var C2ListProcess = class {
  static data_mL_2_2L1B(list_itemInfo) {
    const list_itemInfo2 = [];
    const level1 = 0;
    const level2 = 1;
    let flag_leve2 = false;
    for (const itemInfo of list_itemInfo) {
      if (level1 >= itemInfo.level) {
        list_itemInfo2.push({
          content: itemInfo.content.trim(),
          level: level1
        });
        flag_leve2 = false;
        continue;
      }
      if (true) {
        if (!flag_leve2) {
          list_itemInfo2.push({
            content: itemInfo.content.trim(),
            level: level2
          });
          flag_leve2 = true;
          continue;
        } else {
          const old_itemInfo = list_itemInfo2.pop();
          if (old_itemInfo) {
            let new_content = itemInfo.content.trim();
            if (itemInfo.level > level2)
              new_content = "- " + new_content;
            for (let i = 0; i < itemInfo.level - level2; i++)
              new_content = " " + new_content;
            new_content = old_itemInfo.content + "\n" + new_content;
            list_itemInfo2.push({
              content: new_content,
              level: level2
            });
          }
        }
      }
    }
    return list_itemInfo2;
  }
  static data_mL_2_2L(list_itemInfo) {
    const list_itemInfo2 = [];
    const level1 = 0;
    const level2 = 1;
    for (const itemInfo of list_itemInfo) {
      if (level1 >= itemInfo.level) {
        list_itemInfo2.push({
          content: itemInfo.content.trim(),
          level: level1
        });
        continue;
      }
      if (level2 >= itemInfo.level) {
        list_itemInfo2.push({
          content: itemInfo.content.trim(),
          level: level2
        });
        continue;
      } else {
        const old_itemInfo = list_itemInfo2.pop();
        if (old_itemInfo) {
          let new_content = itemInfo.content.trim();
          if (itemInfo.level > level2)
            new_content = "- " + new_content;
          for (let i = 0; i < itemInfo.level - level2; i++)
            new_content = " " + new_content;
          new_content = old_itemInfo.content + "\n" + new_content;
          list_itemInfo2.push({
            content: new_content,
            level: level2
          });
        }
      }
    }
    return list_itemInfo2;
  }
  static list2c2data(text4, modeG = true) {
    const list_itemInfo = [];
    const list_text = text4.trimStart().split("\n");
    const first_match = list_text[0].match(ABReg.reg_list_noprefix);
    if (!first_match || first_match[1]) {
      console.error("\u4E0D\u662F\u5217\u8868\u5185\u5BB9:", list_text[0]);
      return list_itemInfo;
    }
    const root_list_level = first_match[1].length;
    let current_content = "";
    let current_content_prefix = "";
    for (let line of list_text) {
      const match_list = line.match(ABReg.reg_list_noprefix);
      if (match_list && !match_list[1] && match_list[1].length <= root_list_level) {
        add_current_content();
        let content = match_list[4];
        if (modeG) {
          const inlines = match_list[4].split(ABReg.inline_split);
          if (inlines.length > 1) {
            const second_part = content.indexOf(inlines[1]);
            current_content += content.slice(second_part) + "\n";
            current_content_prefix = "  ";
            content = inlines[0];
          }
        }
        list_itemInfo.push({
          content,
          level: 0
        });
      } else {
        if (current_content.trim() == "") {
          if (match_list && match_list[1])
            current_content_prefix = match_list[1];
          else
            current_content_prefix = "  ";
        }
        if (line.startsWith("	"))
          line = line.substring(1);
        else if (line.startsWith(current_content_prefix)) {
          line = line.substring(current_content_prefix.length);
        }
        current_content += line + "\n";
      }
    }
    add_current_content();
    return list_itemInfo;
    function add_current_content() {
      if (current_content.trim() == "")
        return;
      list_itemInfo.push({
        content: current_content,
        level: 1
      });
      current_content = "";
    }
  }
  static title2c2data(text4) {
    const list_itemInfo = [];
    const list_text = text4.trimStart().split("\n");
    const first_match = list_text[0].match(ABReg.reg_heading_noprefix);
    if (!first_match || first_match[1]) {
      console.error("\u4E0D\u662F\u6807\u9898\u5185\u5BB9:", list_text[0]);
      return list_itemInfo;
    }
    const root_title_level = first_match[3].length - 1;
    let current_content = "";
    let codeBlockFlag = "";
    for (const line of list_text) {
      if (codeBlockFlag == "") {
        const match2 = line.match(ABReg.reg_code);
        if (match2 && match2[3]) {
          codeBlockFlag = match2[1] + match2[3];
          current_content += line + "\n";
          continue;
        }
      } else {
        if (line.indexOf(codeBlockFlag) == 0)
          codeBlockFlag = "";
        current_content += line + "\n";
        continue;
      }
      const match_heading = line.match(ABReg.reg_heading_noprefix);
      if (match_heading && !match_heading[1] && match_heading[3].length - 1 <= root_title_level) {
        add_current_content();
        list_itemInfo.push({
          content: match_heading[4],
          level: 0
        });
      } else {
        current_content += line + "\n";
      }
    }
    add_current_content();
    return list_itemInfo;
    function add_current_content() {
      if (current_content.trim() == "")
        return;
      list_itemInfo.push({
        content: current_content,
        level: 1
      });
      current_content = "";
    }
  }
  static c2data2tab(list_itemInfo, div, modeT) {
    {
      const tab = document.createElement("div");
      div.appendChild(tab);
      tab.classList.add("ab-tab-root");
      if (modeT)
        tab.setAttribute("modeT", "true");
      const nav = document.createElement("div");
      tab.appendChild(nav);
      nav.classList.add("ab-tab-nav");
      const content = document.createElement("div");
      tab.appendChild(content);
      content.classList.add("ab-tab-content");
      let current_dom = null;
      for (let i = 0; i < list_itemInfo.length; i++) {
        const itemInfo = list_itemInfo[i];
        if (!current_dom) {
          if (itemInfo.level == 0) {
            const nav_item = document.createElement("button");
            nav.appendChild(nav_item);
            nav_item.classList.add("ab-tab-nav-item");
            nav_item.textContent = itemInfo.content.slice(0, 20);
            nav_item.setAttribute("is_activate", i == 0 ? "true" : "false");
            current_dom = document.createElement("div");
            content.appendChild(current_dom);
            current_dom.classList.add("ab-tab-content-item");
            current_dom.setAttribute("style", i == 0 ? "display:block" : "display:none");
            current_dom.setAttribute("is_activate", i == 0 ? "true" : "false");
          }
        } else {
          ABConvertManager.getInstance().m_renderMarkdownFn(itemInfo.content, current_dom);
          current_dom = null;
        }
      }
      const lis = tab.querySelectorAll(":scope>.ab-tab-nav>.ab-tab-nav-item");
      const contents2 = tab.querySelectorAll(":scope>.ab-tab-content>.ab-tab-content-item");
      if (lis.length != contents2.length)
        console.warn("ab-tab-nav-item\u548Cab-tab-content-item\u7684\u6570\u91CF\u4E0D\u4E00\u81F4");
      for (let i = 0; i < lis.length; i++) {
        if (ABCSetting.env == "obsidian" || ABCSetting.env == "obsidian-min") {
          lis[i].onclick = () => {
            for (let j = 0; j < contents2.length; j++) {
              lis[j].setAttribute("is_activate", "false");
              contents2[j].setAttribute("is_activate", "false");
              contents2[j].setAttribute("style", "display:none");
            }
            lis[i].setAttribute("is_activate", "true");
            contents2[i].setAttribute("is_activate", "true");
            contents2[i].setAttribute("style", "display:block");
          };
        } else {
          lis[i].setAttribute("onclick", `
            const i = ${i}
            const tab_current = this
            const tab_nav = this.parentNode
            const tab_root = tab_nav.parentNode
            const tab_content = tab_root.querySelector(":scope>.ab-tab-content")
            const tab_nav_items = tab_nav.querySelectorAll(":scope>.ab-tab-nav-item")
            const tab_content_items = tab_content.querySelectorAll(":scope>.ab-tab-content-item")
            for (let j=0; j<tab_content_items.length; j++){
              tab_nav_items[j].setAttribute("is_activate", "false")
              tab_content_items[j].setAttribute("is_activate", "false")
              tab_content_items[j].setAttribute("style", "display:none")
            }
            tab_current.setAttribute("is_activate", "true")
            tab_content_items[i].setAttribute("is_activate", "true")
            tab_content_items[i].setAttribute("style", "display:block")
          `);
        }
      }
    }
    return div;
  }
  static c2data2items(c2listdata, el) {
    const el_items = document.createElement("div");
    el.appendChild(el_items);
    el_items.classList.add("ab-items");
    let el_item = null;
    for (const item of c2listdata) {
      if (item.level == 0) {
        el_item = document.createElement("div");
        el_items.appendChild(el_item);
        el_item.classList.add("ab-items-item");
        const el_title = document.createElement("div");
        el_item.appendChild(el_title);
        el_title.classList.add("ab-items-title");
        ABConvertManager.getInstance().m_renderMarkdownFn(item.content, el_title);
      } else {
        if (!el_item)
          continue;
        const el_content = document.createElement("div");
        el_item.appendChild(el_content);
        el_content.classList.add("ab-items-content");
        ABConvertManager.getInstance().m_renderMarkdownFn(item.content, el_content);
      }
    }
    return el;
  }
};
var abc_list2c2listdata = ABConvert.factory({
  id: "list2c2listdata",
  name: "\u5217\u8868\u8F6Cc2listdata",
  match: "list2c2listdata",
  default: "list2c2listdata",
  process_param: "string" /* text */,
  process_return: "array2" /* c2list_stream */,
  process: (el, header, content) => {
    return C2ListProcess.list2c2data(content);
  }
});
var abc_title2c2listdata = ABConvert.factory({
  id: "title2c2listdata",
  name: "\u6807\u9898\u8F6Cc2listdata",
  match: "title2c2listdata",
  default: "title2c2listdata",
  process_param: "string" /* text */,
  process_return: "array2" /* c2list_stream */,
  process: (el, header, content) => {
    return C2ListProcess.title2c2data(content);
  }
});
var abc_c2listdata2tab = ABConvert.factory({
  id: "c2listdata2tab",
  name: "c2listdata\u8F6C\u6807\u7B7E",
  match: "c2listdata2tab",
  default: "c2listdata2tab",
  process_param: "array2" /* c2list_stream */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    return C2ListProcess.c2data2tab(content, el, false);
  }
});
var abc_c2listdata2items = ABConvert.factory({
  id: "c2listdata2items",
  name: "c2listdata\u8F6C\u5BB9\u5668\u7ED3\u6784",
  match: "c2listdata2items",
  default: "c2listdata2items",
  process_param: "array2" /* c2list_stream */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    return C2ListProcess.c2data2items(content, el);
  }
});
var abc_c2listdata2easytimeline = ABConvert.factory({
  id: "c2listdata2easytimeline",
  name: "\u9002\u914D\u5230easy_timeline",
  match: "c2listdata2easytimeline",
  detail: "\u9002\u914D\u5230easy_timeline\u683C\u5F0F\uFF0C\u9700\u8981\u5B89\u88C5easy timeline\u63D2\u4EF6",
  process_param: "array2" /* c2list_stream */,
  process_return: "string" /* text */,
  process: (el, header, content) => {
    let all_line = "";
    let line = "";
    for (const item of content) {
      if (item.level == 0) {
        if (line != "")
          all_line += line + "\n\n";
        line = item.content + ". ";
      } else {
        if (line == "")
          line = " . ";
        line += item.content;
      }
    }
    if (line != "")
      all_line += line;
    return "````timeline\n" + all_line + "\n````";
  }
});

// ../ABConverter/converter/abc_table.ts
var TableProcess = class {
  static list2ut(text4, div, modeT = false) {
    let data2 = ListProcess.list2data(text4);
    data2 = ListProcess.data2strict(data2);
    data2 = C2ListProcess.data_mL_2_2L(data2);
    data2 = ListProcess.data_2L_2_mL1B(data2);
    return TableProcess.data2table(data2, div, modeT);
  }
  static list2timeline(text4, div, modeT = false) {
    let data2 = C2ListProcess.list2c2data(text4);
    div = TableProcess.data2table(data2, div, modeT);
    const table2 = div.querySelector("table");
    if (table2)
      table2.classList.add("ab-table-timeline", "ab-table-fc");
    return div;
  }
  static title2timeline(text4, div, modeT = false) {
    let data2 = C2ListProcess.title2c2data(text4);
    div = TableProcess.data2table(data2, div, modeT);
    const table2 = div.querySelector("table");
    if (table2)
      table2.classList.add("ab-table-timeline", "ab-table-fc");
    return div;
  }
  static data2table(list_itemInfo, div, modeT) {
    let list_tableInfo = [];
    let prev_line = -1;
    let prev_level = 999;
    for (let i = 0; i < list_itemInfo.length; i++) {
      let item = list_itemInfo[i];
      let tableRow = 1;
      let row_level = list_itemInfo[i].level;
      for (let j = i + 1; j < list_itemInfo.length; j++) {
        if (list_itemInfo[j].level > row_level) {
          row_level = list_itemInfo[j].level;
        } else if (list_itemInfo[j].level > list_itemInfo[i].level) {
          row_level = list_itemInfo[j].level;
          tableRow++;
        } else
          break;
      }
      if (item.level <= prev_level) {
        prev_line++;
      }
      prev_level = item.level;
      list_tableInfo.push({
        content: item.content,
        level: item.level,
        tableRowSpan: tableRow,
        tableRow: prev_line
      });
    }
    {
      const table2 = document.createElement("table");
      div.appendChild(table2);
      table2.classList.add("ab-table", "ab-branch-table");
      if (modeT)
        table2.setAttribute("modeT", "true");
      let thead;
      if (list_tableInfo[0].content.indexOf("< ") == 0) {
        thead = document.createElement("thead");
        table2.appendChild(thead);
        list_tableInfo[0].content = list_tableInfo[0].content.replace(/^\<\s/, "");
      }
      const tbody = document.createElement("tbody");
      table2.appendChild(tbody);
      for (let index_line = 0; index_line < prev_line + 1; index_line++) {
        let is_head;
        let tr;
        if (index_line == 0 && thead) {
          tr = document.createElement("tr");
          thead.appendChild(tr);
          is_head = true;
        } else {
          is_head = false;
          tr = document.createElement("tr");
          tbody.appendChild(tr);
        }
        for (let item of list_tableInfo) {
          if (item.tableRow != index_line)
            continue;
          let td = document.createElement(is_head ? "th" : "td");
          tr.appendChild(td);
          td.setAttribute("rowspan", item.tableRowSpan.toString());
          td.setAttribute("col_index", item.level.toString());
          ABConvertManager.getInstance().m_renderMarkdownFn(item.content, td);
        }
      }
    }
    return div;
  }
};
var abc_title2table = ABConvert.factory({
  id: "title2table",
  name: "\u6807\u9898\u5230\u8868\u683C",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const data2 = abc_title2listdata.process(el, header, content);
    return el = TableProcess.data2table(data2, el, false);
  }
});
var abc_list2table = ABConvert.factory({
  id: "list2table",
  name: "\u5217\u8868\u8F6C\u8868\u683C",
  match: /list2(md)?table(T)?/,
  default: "list2table",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const matchs = header.match(/list2(md)?table(T)?/);
    if (!matchs)
      return el;
    const data2 = abc_list2listdata.process(el, header, content);
    return el = TableProcess.data2table(data2, el, matchs[2] == "T");
  }
});
var abc_list2c2table = ABConvert.factory({
  id: "list2c2t",
  name: "\u5217\u8868\u8F6C\u4E8C\u5217\u8868\u683C",
  match: "list2c2t",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    let data2 = C2ListProcess.list2c2data(content);
    TableProcess.data2table(data2, el, false);
    return el;
  }
});
var abc_list2ut = ABConvert.factory({
  id: "list2ut",
  name: "\u5217\u8868\u8F6C\u4E8C\u7EF4\u8868\u683C",
  match: /list2(md)?ut(T)?/,
  default: "list2ut",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const matchs = header.match(/list2(md)?ut(T)?/);
    if (!matchs)
      return el;
    TableProcess.list2ut(content, el, matchs[2] == "T");
    return el;
  }
});
var abc_list2timeline = ABConvert.factory({
  id: "list2timeline",
  name: "\u5217\u8868\u8F6C\u65F6\u95F4\u7EBF",
  match: /list2(md)?timeline(T)?/,
  default: "list2mdtimeline",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const matchs = header.match(/list2(md)?timeline(T)?/);
    if (!matchs)
      return el;
    TableProcess.list2timeline(content, el, matchs[2] == "T");
    return el;
  }
});
var abc_title2timeline = ABConvert.factory({
  id: "title2timeline",
  name: "\u6807\u9898\u8F6C\u65F6\u95F4\u7EBF",
  match: /title2(md)?timeline(T)?/,
  default: "title2mdtimeline",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const matchs = header.match(/title2(md)?timeline(T)?/);
    if (!matchs)
      return el;
    TableProcess.title2timeline(content, el, matchs[2] == "T");
    return el;
  }
});

// ../ABConverter/converter/abc_dir_tree.ts
var DirProcess = class {
  static list2lt(text4, div, modeT = false) {
    let list_itemInfo = DirProcess.list2dtdata(text4);
    list_itemInfo = ListProcess.data2strict(list_itemInfo).map((item, index2) => {
      return {
        content: list_itemInfo[index2].content,
        level: item.level,
        tableRow: list_itemInfo[index2].tableRow,
        tableColumn: list_itemInfo[index2].tableColumn,
        tableRowSpan: list_itemInfo[index2].tableRowSpan,
        type: list_itemInfo[index2].type
      };
    });
    return DirProcess.dtdata2dt(list_itemInfo, div, modeT);
  }
  static list2dt(text4, div, modeT = false) {
    let list_itemInfo = DirProcess.list2dtdata(text4);
    list_itemInfo = ListProcess.data2strict(list_itemInfo).map((item, index2) => {
      return {
        content: list_itemInfo[index2].content,
        level: item.level,
        tableRow: list_itemInfo[index2].tableRow,
        tableColumn: list_itemInfo[index2].tableColumn,
        tableRowSpan: list_itemInfo[index2].tableRowSpan,
        type: list_itemInfo[index2].type
      };
    });
    return DirProcess.dtdata2dt(list_itemInfo, div, modeT, true);
  }
  static list2dtdata(text4) {
    const list_itemInfo = [];
    const list_text = text4.split("\n");
    let row_index = -1;
    for (const line of list_text) {
      const m_line = line.match(ABReg.reg_list_noprefix);
      if (m_line) {
        row_index++;
        const content = m_line[4];
        const level_inline = m_line[1].length;
        list_itemInfo.push({
          content: content.trimStart(),
          level: level_inline,
          tableRow: row_index,
          tableColumn: 0,
          type: "",
          tableRowSpan: 1
        });
      } else {
        const itemInfo = list_itemInfo.pop();
        if (itemInfo) {
          list_itemInfo.push({
            content: itemInfo.content + "\n" + line.trim(),
            level: itemInfo.level,
            tableRow: itemInfo.tableRow,
            tableColumn: itemInfo.tableColumn,
            type: itemInfo.type,
            tableRowSpan: itemInfo.tableRowSpan
          });
        }
      }
    }
    const list_itemInfo2 = [];
    for (const row_item of list_itemInfo) {
      const list_column_item = row_item.content.split(ABReg.inline_split);
      for (let column_index = 0; column_index < list_column_item.length; column_index++) {
        let type = "";
        if (column_index == 0) {
          if (list_column_item[column_index].trimEnd().endsWith("/")) {
            type = "folder";
          } else {
            const parts = list_column_item[column_index].split(".");
            if (parts.length === 0 || parts[parts.length - 1] === "")
              type = "";
            else
              type = parts[parts.length - 1];
          }
        }
        list_itemInfo2.push({
          content: list_column_item[column_index].trimEnd(),
          level: row_item.level,
          tableRow: row_index,
          tableColumn: column_index,
          type,
          tableRowSpan: row_item.tableRowSpan
        });
      }
    }
    return list_itemInfo2;
  }
  static dtdata2dt(list_tableInfo, div, modeT, is_folder = false) {
    var _a3;
    const div2 = document.createElement("div");
    div.appendChild(div2);
    div2.classList.add("ab-list-table-parent");
    let table2, thead, tbody;
    {
      table2 = document.createElement("table");
      div2.appendChild(table2);
      table2.classList.add("ab-table", "ab-list-table");
      if (is_folder)
        table2.classList.add("ab-table-folder");
      if (modeT)
        table2.setAttribute("modeT", "true");
      {
        if (list_tableInfo[0].content.indexOf("< ") == 0) {
          thead = document.createElement("thead");
          table2.appendChild(thead);
          list_tableInfo[0].content = list_tableInfo[0].content.replace(/^\<\s/, "");
        }
        tbody = document.createElement("tbody");
        table2.appendChild(tbody);
      }
      let tr;
      let is_head = false;
      let prev_tr = null;
      for (let cell_index = 0; cell_index < list_tableInfo.length; cell_index++) {
        const cell_item = list_tableInfo[cell_index];
        if (cell_item.tableColumn == 0) {
          if (cell_index == 0 && thead) {
            is_head = true;
            tr = document.createElement("tr");
            thead.appendChild(tr);
          } else {
            is_head = false;
            tr = document.createElement("tr");
            tbody.appendChild(tr);
            tr.classList.add("ab-foldable-tr");
            tr.setAttribute("tr_level", cell_item.level.toString());
            tr.setAttribute("is_fold", "false");
            tr.setAttribute("able_fold", "false");
            tr.setAttribute("type", cell_item.type);
          }
          if (prev_tr && !isNaN(Number(prev_tr.getAttribute("tr_level"))) && Number(prev_tr.getAttribute("tr_level")) < cell_item.level) {
            prev_tr.setAttribute("able_fold", "true");
          }
          prev_tr = tr;
        }
        const td = document.createElement(is_head ? "th" : "td");
        tr.appendChild(td);
        td.setAttribute("rowspan", cell_item.tableRowSpan.toString());
        if (cell_item.tableColumn == 0 && is_folder) {
          const td_svg = document.createElement("div");
          td.appendChild(td_svg);
          td_svg.classList.add("ab-list-table-svg");
          if (!is_head) {
            if (cell_item.type == "folder") {
              td_svg.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M64 480H448c35.3 0 64-28.7 64-64V160c0-35.3-28.7-64-64-64H288c-10.1 0-19.6-4.7-25.6-12.8L243.2 57.6C231.1 41.5 212.1 32 192 32H64C28.7 32 0 60.7 0 96V416c0 35.3 28.7 64 64 64z"/></svg>`;
              cell_item.content = cell_item.content.trimEnd().slice(0, -1);
            } else {
              td_svg.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--!Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M320 464c8.8 0 16-7.2 16-16l0-288-80 0c-17.7 0-32-14.3-32-32l0-80L64 48c-8.8 0-16 7.2-16 16l0 384c0 8.8 7.2 16 16 16l256 0zM0 64C0 28.7 28.7 0 64 0L229.5 0c17 0 33.3 6.7 45.3 18.7l90.5 90.5c12 12 18.7 28.3 18.7 45.3L384 448c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64L0 64z"/></svg>`;
            }
          }
        }
        const td_cell = document.createElement("div");
        td.appendChild(td_cell);
        td_cell.classList.add("ab-list-table-witharrow");
        if (cell_item.tableColumn == 0 && is_folder) {
          td_cell.innerHTML = cell_item.content;
        } else {
          ABConvertManager.getInstance().m_renderMarkdownFn(cell_item.content, td_cell);
        }
      }
    }
    {
      const l_tr = tbody.querySelectorAll("tr");
      for (let i = 0; i < l_tr.length; i++) {
        const tr = l_tr[i];
        const targetEl = (_a3 = tr.querySelector(":scope>td:first-child")) != null ? _a3 : tr;
        if (ABCSetting.env == "obsidian" || ABCSetting.env == "obsidian-min") {
          targetEl.onclick = () => {
            const tr_level = Number(tr.getAttribute("tr_level"));
            if (isNaN(tr_level))
              return;
            const tr_isfold = tr.getAttribute("is_fold");
            if (!tr_isfold)
              return;
            let flag_do_fold = false;
            for (let j = i + 1; j < l_tr.length; j++) {
              const tr2 = l_tr[j];
              const tr_level2 = Number(tr2.getAttribute("tr_level"));
              if (isNaN(tr_level2))
                break;
              if (tr_level2 <= tr_level)
                break;
              tr_isfold == "true" ? tr2.style.display = "" : tr2.style.display = "none";
              flag_do_fold = true;
            }
            if (flag_do_fold)
              tr.setAttribute("is_fold", tr_isfold == "true" ? "false" : "true");
          };
        } else {
          targetEl.setAttribute("onclick", `            const tr = (this.tagName == "TD") ? this.parentNode : this
            const l_tr = tr.parentNode.querySelectorAll("tr")
            const i = ${i}
            
            const tr_level = Number(tr.getAttribute("tr_level"))
            if (isNaN(tr_level)) return
            const tr_isfold = tr.getAttribute("is_fold")
            if (!tr_isfold) return
            let flag_do_fold = false  // \u9632\u6B62\u6298\u53E0\u6700\u5C0F\u5C42
            for (let j=i+1; j<l_tr.length; j++){
              const tr2 = l_tr[j]
              const tr_level2 = Number(tr2.getAttribute("tr_level"))
              if (isNaN(tr_level2)) break
              if (tr_level2<=tr_level) break
              (tr_isfold == "true") ? tr2.style.display = "" : tr2.style.display = "none"
              flag_do_fold = true
            }
            if (flag_do_fold) tr.setAttribute("is_fold", tr_isfold=="true"?"false":"true")
          `);
        }
      }
    }
    {
      const btn = document.createElement("button");
      div2.appendChild(btn);
      btn.classList.add("ab-table-fold");
      const svgStr_fold = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-fold-vertical-icon lucide-fold-vertical"><path d="M12 22v-6"/><path d="M12 8V2"/><path d="M4 12H2"/><path d="M10 12H8"/><path d="M16 12h-2"/><path d="M22 12h-2"/><path d="m15 19-3-3-3 3"/><path d="m15 5-3 3-3-3"/></svg>`;
      const svgStr_unfold = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-unfold-vertical-icon lucide-unfold-vertical"><path d="M12 22v-6"/><path d="M12 8V2"/><path d="M4 12H2"/><path d="M10 12H8"/><path d="M16 12h-2"/><path d="M22 12h-2"/><path d="m15 19-3 3-3-3"/><path d="m15 5-3-3-3 3"/></svg>`;
      btn.setAttribute("is_fold", "false");
      btn.innerHTML = svgStr_fold;
      if (ABCSetting.env == "obsidian" || ABCSetting.env == "obsidian-min") {
        btn.onclick = () => {
          const l_tr = table2.querySelectorAll("tr");
          for (let i = 0; i < l_tr.length; i++) {
            const tr = l_tr[i];
            (() => {
              const tr_level = Number(tr.getAttribute("tr_level"));
              if (isNaN(tr_level))
                return;
              const tr_isfold = btn.getAttribute("is_fold");
              if (!tr_isfold)
                return;
              let flag_do_fold = false;
              for (let j = i + 1; j < l_tr.length; j++) {
                const tr2 = l_tr[j];
                const tr_level2 = Number(tr2.getAttribute("tr_level"));
                if (isNaN(tr_level2))
                  break;
                if (tr_level2 <= tr_level)
                  break;
                tr_isfold == "true" ? tr2.style.display = "" : tr2.style.display = "none";
                flag_do_fold = true;
              }
              if (flag_do_fold)
                tr.setAttribute("is_fold", tr_isfold == "true" ? "false" : "true");
            })();
          }
          const is_all_fold = btn.getAttribute("is_fold");
          if (is_all_fold == "true") {
            btn.setAttribute("is_fold", "false");
            btn.innerHTML = svgStr_fold;
          } else {
            btn.setAttribute("is_fold", "true");
            btn.innerHTML = svgStr_unfold;
          }
        };
      } else {
        btn.setAttribute(
          "onclick",
          `          const btn = this;
          const svgStr_fold = \`${svgStr_fold}\`;
          const svgStr_unfold = \`${svgStr_unfold}\`;
          const table = btn.parentNode?.querySelector("table");
          if (!table) return;
          
          const l_tr = table.querySelectorAll("tr");
          for (let i=0; i<l_tr.length; i++) {
            const tr = l_tr[i]
            ;(()=>{
              const tr_level = Number(tr.getAttribute("tr_level"))
              if (isNaN(tr_level)) return
              const tr_isfold = btn.getAttribute("is_fold"); // [!code] tr->btn
              if (!tr_isfold) return
              let flag_do_fold = false  // \u9632\u6B62\u6298\u53E0\u6700\u5C0F\u5C42
              for (let j=i+1; j<l_tr.length; j++){
                const tr2 = l_tr[j]
                const tr_level2 = Number(tr2.getAttribute("tr_level"))
                if (isNaN(tr_level2)) break
                if (tr_level2<=tr_level) break
                (tr_isfold == "true") ? tr2.style.display = "" : tr2.style.display = "none"
                flag_do_fold = true
              }
              if (flag_do_fold) tr.setAttribute("is_fold", tr_isfold=="true"?"false":"true")
            })()
          }
          const is_all_fold = btn.getAttribute("is_fold")
          if (is_all_fold=="true") {
            btn.setAttribute("is_fold", "false"); btn.innerHTML = svgStr_fold;
          }
          else {
            btn.setAttribute("is_fold", "true"); btn.innerHTML = svgStr_unfold;
          }
          `
        );
      }
    }
    return div;
  }
};
var abc_list2lt = ABConvert.factory({
  id: "list2lt",
  name: "\u5217\u8868\u8F6C\u5217\u8868\u8868\u683C",
  match: /list2(md)?lt(T)?/,
  default: "list2lt",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const matchs = header.match(/list2(md)?lt(T)?/);
    if (!matchs)
      return el;
    DirProcess.list2lt(content, el, matchs[2] == "T");
    return el;
  }
});
var abc_list2dt = ABConvert.factory({
  id: "list2dt",
  name: "\u5217\u8868\u8F6C\u6811\u72B6\u76EE\u5F55",
  match: /list2(md)?dt(T)?/,
  default: "list2dt",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const matchs = header.match(/list2(md)?dt(T)?/);
    if (!matchs)
      return el;
    DirProcess.list2dt(content, el, matchs[2] == "T");
    return el;
  }
});
function listdata2dirdata(list2) {
  const is_have_vbar = [];
  const newlist = [];
  for (let i = 0; i < list2.length; i++) {
    const item = list2[i];
    let type;
    if (item.content.trimEnd().endsWith("/")) {
      type = "folder";
    } else {
      const parts = item.content.split(".");
      if (parts.length === 0 || parts[parts.length - 1] === "")
        type = "";
      else
        type = parts[parts.length - 1];
    }
    let is_last = true;
    for (let j = i + 1; j < list2.length; j++) {
      if (list2[j].level < item.level) {
        is_last = true;
        break;
      } else if (list2[j].level == item.level) {
        is_last = false;
        break;
      } else {
        continue;
      }
    }
    is_have_vbar[item.level] = !is_last;
    let pre_as_text = "";
    if (item.level > 1) {
      for (let i2 = 1; i2 < item.level; i2++) {
        if (!is_have_vbar.hasOwnProperty(i2))
          pre_as_text += "[e]";
        else if (is_have_vbar[i2])
          pre_as_text += "|  ";
        else
          pre_as_text += "   ";
      }
    }
    newlist.push({
      content: item.content,
      level: item.level,
      type,
      is_last,
      pre_as_text
    });
  }
  return newlist;
}
var abc_list2astreeH = ABConvert.factory({
  id: "list2astreeH",
  name: "\u5217\u8868\u5230sacii\u76EE\u5F55\u6811",
  process_param: "string" /* text */,
  process_return: "string" /* text */,
  process: (el, header, content) => {
    let listdata = ListProcess.list2data(content);
    listdata = ListProcess.data2strict(listdata);
    const dirlistdata = listdata2dirdata(listdata);
    let newContent = "";
    for (const item of dirlistdata) {
      if (item.level == 0) {
        newContent += item.content + "\n";
      } else {
        newContent += item.pre_as_text + (item.is_last ? "\u2514\u2500 " : "\u251C\u2500 ") + item.content + "\n";
      }
    }
    newContent = newContent.trimEnd();
    return newContent;
  }
});

// ../ABConverter/converter/abc_deco.ts
var abc_md = ABConvert.factory({
  id: "md",
  name: "md",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const subEl = document.createElement("div");
    el.appendChild(subEl);
    ABConvertManager.getInstance().m_renderMarkdownFn(content, subEl);
    return el;
  }
});
var abc_text = ABConvert.factory({
  id: "text",
  name: "\u7EAF\u6587\u672C",
  detail: "\u5176\u5B9E\u4E00\u822C\u4F1A\u66F4\u63A8\u8350\u7528code()\u4EE3\u66FF\uFF0C\u90A3\u4E2A\u66F4\u7CBE\u786E",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    el.innerHTML = `<p>${content.replace(/ /g, "&nbsp;").split("\n").join("<br/>")}</p>`;
    return el;
  }
});
var abc_fold = ABConvert.factory({
  id: "fold",
  name: "\u6298\u53E0",
  process_param: "HTMLElement" /* el */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    if (content.children.length != 1)
      return content;
    const sub_el = content.children[0];
    sub_el.remove();
    sub_el.setAttribute("is_hide", "true");
    sub_el.classList.add("ab-deco-fold-content");
    sub_el.style.display = "none";
    const mid_el = document.createElement("div");
    content.appendChild(mid_el);
    mid_el.classList.add("ab-deco-fold");
    const sub_button = document.createElement("div");
    mid_el.appendChild(sub_button);
    sub_button.classList.add("ab-deco-fold-button");
    sub_button.textContent = "\u5C55\u5F00";
    const fn_fold = () => {
      const is_hide = sub_el.getAttribute("is_hide");
      if (is_hide && is_hide == "false") {
        sub_el.setAttribute("is_hide", "true");
        sub_el.style.display = "none";
        sub_button.textContent = "\u5C55\u5F00";
      } else if (is_hide && is_hide == "true") {
        sub_el.setAttribute("is_hide", "false");
        sub_el.style.display = "";
        sub_button.textContent = "\u6298\u53E0";
      }
    };
    sub_button.onclick = fn_fold;
    mid_el.appendChild(sub_button);
    mid_el.appendChild(sub_el);
    const isListTable = sub_el.classList.contains("ab-list-table-parent");
    const listTable_btn = sub_el.querySelector(".ab-table-fold");
    if (isListTable && listTable_btn) {
      if (ABCSetting.env == "obsidian" || ABCSetting.env == "obsidian-min") {
        fn_fold();
        sub_button.textContent = "\u6298\u53E0/\u5C55\u5F00";
        const fn_fold2 = () => {
          const clickEvent = new MouseEvent("click", {
            view: window,
            bubbles: true,
            cancelable: true
          });
          listTable_btn.dispatchEvent(clickEvent);
        };
        fn_fold2();
        sub_button.onclick = fn_fold2;
      } else {
      }
    }
    return content;
  }
});
var abc_scroll = ABConvert.factory({
  id: "scroll",
  name: "\u6EDA\u52A8",
  match: /^scroll(X)?(\((\d+)\))?$/,
  default: "scroll(460)",
  detail: "\u9ED8\u8BA4\u662F\u7EB5\u5411\u6EDA\u52A8\u3002\u53EF\u4EE5\u6307\u5B9A\u6EA2\u51FA\u6EDA\u52A8\u7684\u8303\u56F4\uFF0C\u53EF\u4EE5\u4F7F\u7528scrollX\u8FDB\u884C\u6A2A\u5411\u6EDA\u52A8",
  process_param: "HTMLElement" /* el */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const matchs = header.match(/^scroll(X)?(\((\d+)\))?$/);
    if (!matchs)
      return content;
    let arg1 = 0;
    if (matchs[2] && matchs[3]) {
      arg1 = Number(matchs[3]);
      if (isNaN(arg1))
        return content;
    }
    if (content.children.length != 1)
      return content;
    const sub_el = content.children[0];
    sub_el.remove();
    const mid_el = document.createElement("div");
    content.appendChild(mid_el);
    mid_el.classList.add("ab-deco-scroll");
    mid_el.appendChild(sub_el);
    if (!matchs[1]) {
      mid_el.classList.add("ab-deco-scroll-y");
      mid_el.setAttribute("style", `max-height: ${arg1 !== 0 ? arg1 + "px" : "460px"}`);
    } else {
      mid_el.classList.add("ab-deco-scroll-x");
      mid_el.setAttribute("style", `max-height: ${arg1 !== 0 ? arg1 + "px" : "100%"}`);
    }
    return content;
  }
});
var abc_overfold = ABConvert.factory({
  id: "overfold",
  name: "\u8D85\u51FA\u6298\u53E0",
  match: /^overfold(\((\d+)\))?$/,
  default: "overfold(380)",
  process_param: "HTMLElement" /* el */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const matchs = header.match(/^overfold(\((\d+)\))?$/);
    if (!matchs)
      return content;
    let arg1;
    if (!matchs[1])
      arg1 = 460;
    else {
      if (!matchs[2])
        return content;
      arg1 = Number(matchs[2]);
      if (isNaN(arg1))
        return content;
    }
    if (content.children.length != 1)
      return content;
    const sub_el = content.children[0];
    sub_el.remove();
    const mid_el = document.createElement("div");
    content.appendChild(mid_el);
    mid_el.classList.add("ab-deco-overfold");
    const sub_button = document.createElement("div");
    mid_el.appendChild(sub_button);
    sub_button.classList.add("ab-deco-overfold-button");
    sub_button.textContent = "\u5C55\u5F00";
    sub_el.classList.add("ab-deco-overfold-content");
    mid_el.appendChild(sub_el);
    mid_el.appendChild(sub_button);
    mid_el.setAttribute("style", `max-height: ${arg1}px`);
    mid_el.setAttribute("is-fold", "true");
    sub_button.onclick = () => {
      const is_fold = mid_el.getAttribute("is-fold");
      if (!is_fold)
        return;
      if (is_fold == "true") {
        mid_el.setAttribute("style", "");
        mid_el.setAttribute("is-fold", "false");
        sub_button.textContent = "\u6298\u53E0";
      } else {
        mid_el.setAttribute("style", `max-height: ${arg1}px`);
        mid_el.setAttribute("is-fold", "true");
        sub_button.textContent = "\u5C55\u5F00";
      }
    };
    return content;
  }
});
var abc_width = ABConvert.factory({
  id: "width",
  name: "\u5BBD\u5EA6\u63A7\u5236",
  match: /^width\(((?:\d*\.?\d+(?:%|px|rem)?,\s*)*\d*\.?\d+(?:%|px|rem)?)\)$/,
  detail: "\u7528\u4E8E\u63A7\u5236\u8868\u683C\u6216\u5206\u680F\u7684\u6BCF\u5217\u7684\u5BBD\u5EA6",
  process_param: "HTMLElement" /* el */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const matchs = header.match(/^width\(((?:\d*\.?\d+(?:%|px|rem)?,\s*)*\d*\.?\d+(?:%|px|rem)?)\)$/);
    if (!matchs || content.children.length != 1)
      return content;
    const args = matchs[1].split(",").map(
      (arg) => /^\d*\.?\d+$/.test(arg.trim()) ? `${arg.trim()}%` : arg.trim()
    );
    if (content.children[0].classList.contains("ab-col")) {
      const sub_els = content.children[0].children;
      if (sub_els.length == 0)
        return content;
      for (let i = 0; i < Math.min(sub_els.length, args.length); i++) {
        const sub_el = sub_els[i];
        if (args[i].endsWith("%"))
          sub_el.style.flex = `0 1 ${args[i]}`;
        else {
          sub_el.style.width = args[i];
          sub_el.style.flex = `0 0 auto`;
        }
      }
      return content;
    }
    const table2 = content.querySelector("table");
    if (table2 !== null) {
      table2.style.tableLayout = "fixed";
      table2.style.width = args.some((arg) => arg.endsWith("%")) ? "100%" : "fit-content";
      table2.querySelectorAll("tr").forEach((row) => {
        for (let i = 0; i < Math.min(row.children.length, args.length); i++) {
          const cell = row.children[i];
          cell.style.width = cell.style.minWidth = cell.style.maxWidth = args[i];
        }
      });
      return content;
    }
    return content;
  }
});
var abc_addClass = ABConvert.factory({
  id: "addClass",
  name: "\u589E\u52A0class",
  detail: "\u7ED9\u5F53\u524D\u5757\u589E\u52A0\u4E00\u4E2A\u7C7B\u540D\u3002\u652F\u6301\u6B63\u5E38\u4F7F\u7528\u7A7A\u683C\u6765\u6DFB\u52A0\u591A\u4E2Aclass, \u4E0D\u9700\u8981\u52A0dot\u7B26, \u5C31\u50CF\u5728class=''\u91CC\u5199\u7684\u90A3\u6837",
  match: /^addClass\((.*)\)$/,
  process_param: "HTMLElement" /* el */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const matchs = header.match(/^addClass\((.*)\)$/);
    if (!matchs || !matchs[1])
      return content;
    if (content.children.length != 1)
      return content;
    const sub_el = content.children[0];
    const args = matchs[1].split(" ");
    for (const arg of args) {
      sub_el.classList.add(arg);
    }
    return content;
  }
});
var abc_addStyle = ABConvert.factory({
  id: "addStyle",
  name: "\u589E\u52A0style",
  detail: "\u7ED9\u5F53\u524D\u5757\u589E\u52A0\u4E00\u4E2A\u6837\u5F0F, \u6CE8\u610F\u6700\u5916\u7684\u62EC\u53F7\u5F80\u5185\u8981\u7559\u4E00\u4E2A\u7A7A\u683C, \u907F\u514Drotate\u8FD9\u79CD\u7528\u62EC\u53F7\u65F6\u51B2\u7A81\u3002\u6DFB\u52A0\u591A\u4E2A\u5219\u6B63\u5E38\u4F7F\u7528\u5206\u53F7",
  match: /^addStyle\(\s(.*)\s\)$/,
  process_param: "HTMLElement" /* el */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const matchs = header.match(/^addStyle\(\s(.*)\s\)$/);
    if (!matchs || !matchs[1])
      return content;
    if (content.children.length != 1)
      return content;
    const sub_el = content.children[0];
    sub_el.style.cssText += String(matchs[1]);
    return content;
  }
});
var abc_addDiv = ABConvert.factory({
  id: "addDiv",
  name: "\u589E\u52A0div\u548Cclass",
  detail: "\u7ED9\u5F53\u524D\u5757\u589E\u52A0\u4E00\u4E2A\u7236\u7C7B\uFF0C\u9700\u8981\u7ED9\u8FD9\u4E2A\u7236\u7C7B\u4E00\u4E2A\u7C7B\u540D",
  match: /^addDiv\((.*)\)$/,
  process_param: "HTMLElement" /* el */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const matchs = header.match(/^addDiv\((.*)\)$/);
    if (!matchs || !matchs[1])
      return content;
    if (content.children.length != 1)
      return content;
    const sub_el = content.children[0];
    sub_el.remove();
    const mid_el = document.createElement("div");
    content.appendChild(mid_el);
    const args = matchs[1].split(" ");
    for (const arg of args) {
      mid_el.classList.add(arg);
    }
    mid_el.appendChild(sub_el);
    return content;
  }
});
var abc_title = ABConvert.factory({
  id: "title",
  name: "\u6807\u9898",
  match: /^#(.*)/,
  detail: "\u82E5\u76F4\u63A5\u5904\u7406\u4EE3\u7801\u6216\u8868\u683C\u5757\uFF0C\u5219\u4F1A\u6709\u7279\u6B8A\u98CE\u683C",
  process_param: "HTMLElement" /* el */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const matchs = header.match(/^#(.*)/);
    if (!matchs || !matchs[1])
      return content;
    const arg1 = matchs[1];
    const el_content = document.createElement("div");
    while (content.firstChild) {
      const item = content.firstChild;
      content.removeChild(item);
      el_content.appendChild(item);
    }
    const el_root = document.createElement("div");
    content.appendChild(el_root);
    el_root.classList.add("ab-deco-title");
    const el_title = document.createElement("div");
    el_root.appendChild(el_title);
    el_title.classList.add("ab-deco-title-title");
    const el_title_p = document.createElement("p");
    el_title.appendChild(el_title_p);
    el_title_p.textContent = arg1;
    el_root.appendChild(el_content);
    el_content.classList.add("ab-deco-title-content");
    let el_content_sub = el_content.childNodes[0];
    if (!el_content_sub)
      return content;
    if (el_content_sub instanceof HTMLDivElement && el_content.childNodes.length == 1 && el_content.childNodes[0].childNodes[0]) {
      el_content_sub = el_content.childNodes[0].childNodes[0];
    }
    let title_type = "none";
    if (el_content_sub instanceof HTMLQuoteElement) {
      title_type = "quote";
      el_root.classList.add("callout");
      el_title.classList.add("callout-title");
      el_content.classList.add("callout-content");
      const el_content_sub_parent = el_content_sub.parentNode;
      if (!el_content_sub_parent)
        return content;
      while (el_content_sub.firstChild) {
        el_content_sub_parent.insertBefore(el_content_sub.firstChild, el_content_sub);
      }
      el_content_sub_parent.removeChild(el_content_sub);
    } else if (el_content_sub instanceof HTMLTableElement) {
      title_type = "table";
    } else if (el_content_sub instanceof HTMLUListElement) {
      title_type = "ul";
    } else if (el_content_sub instanceof HTMLPreElement) {
      title_type = "pre";
    }
    el_title.setAttribute("title-type", title_type);
    return content;
  }
});
var abc_transposition = ABConvert.factory({
  id: "transposition",
  name: "\u8868\u683C\u8F6C\u7F6E",
  match: "transposition",
  detail: "\u5C06\u8868\u683C\u8FDB\u884C\u8F6C\u7F6E\uFF0C\u5C31\u50CF\u77E9\u9635\u8F6C\u7F6E\u90A3\u6837\u3002\u8BE5\u7248\u672C\u4E0D\u652F\u6301\u6709\u8DE8\u884C\u8DE8\u5217\u5355\u5143\u683C\u3002\u82E5\u590D\u6742\u8868\u683C\uFF0C\u8BF7\u6362\u7528trs\u7248\u672C",
  process_param: "HTMLElement" /* el */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const origi_table = content.querySelector("table");
    if (!origi_table)
      return content;
    const origi_rows = origi_table.rows;
    const origi_rowCount = origi_rows.length;
    const origi_colCount = origi_rows[0].cells.length;
    const trans_table = document.createElement("table");
    origi_table.classList.add("ab-transposition", "ab-table");
    origi_table.classList.forEach((className) => {
      trans_table.classList.add(className);
    });
    const trans_body = document.createElement("tbody");
    trans_table.appendChild(trans_body);
    for (let col = 0; col < origi_colCount; col++) {
      const newRow = trans_body.insertRow();
      for (let row = 0; row < origi_rowCount; row++) {
        const oldCell = origi_rows[row].cells[col];
        if (!oldCell)
          continue;
        const newCell = newRow.insertCell();
        newCell.innerHTML = oldCell.innerHTML;
      }
    }
    origi_table.innerHTML = trans_table.innerHTML;
    return content;
  }
});
var abc_transpose = ABConvert.factory({
  id: "transpose",
  name: "\u8868\u683C\u8F6C\u7F6E",
  match: "trs",
  detail: "\u5C06\u8868\u683C\u8FDB\u884C\u8F6C\u7F6E\uFF0C\u5C31\u50CF\u77E9\u9635\u8F6C\u7F6E\u90A3\u6837\u3002\u8BE5\u7248\u672C\u652F\u6301\u6709\u8DE8\u884C\u8DE8\u5217\u5355\u5143\u683C",
  process_param: "HTMLElement" /* el */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const origi_table = content.querySelector("table");
    if (!origi_table)
      return content;
    let { tableMap, origi_rowCount, origi_colCount } = table2tableMap(origi_table);
    const tableMap2 = new Array(origi_colCount).fill(null).map(() => new Array(origi_rowCount).fill(null));
    for (let i = 0; i < origi_rowCount; i++) {
      for (let j = 0; j < origi_colCount; j++) {
        const origi_cell = tableMap[i][j];
        if (!origi_cell)
          continue;
        else if (origi_cell == "<") {
          tableMap2[j][i] = "^";
        } else if (origi_cell == "^") {
          tableMap2[j][i] = "<";
        } else {
          let content2 = origi_cell.html;
          if (content2.innerHTML == "<" || content2.innerHTML == "&lt;")
            content2.innerHTML = "^";
          else if (content2.innerHTML == "^")
            content2.innerHTML = "<";
          tableMap2[j][i] = {
            html: origi_cell.html,
            rowSpan: origi_cell.colSpan || 1,
            colSpan: origi_cell.rowSpan || 1,
            rowIndex: origi_cell.colIndex,
            colIndex: origi_cell.rowIndex
          };
        }
      }
    }
    const tmp = origi_colCount;
    origi_colCount = origi_rowCount;
    origi_rowCount = tmp;
    const trans_table = tableMap2table(tableMap2, origi_rowCount, origi_colCount);
    origi_table.classList.forEach((className) => {
      trans_table.classList.add(className);
    });
    trans_table.classList.add("ab-transposition", "ab-table");
    origi_table.innerHTML = trans_table.innerHTML;
    return content;
  }
});
var abc_exTable = ABConvert.factory({
  id: "exTable",
  name: "\u8868\u683C\u6269\u5C55",
  match: "exTable",
  detail: "\u5C06\u8868\u683C\u5E94\u7528sheet-table\u8BED\u6CD5 (\u4F7F\u7528 `</^` \u6807\u6CE8\u5408\u5E76\u5355\u5143\u683C)",
  process_param: "HTMLElement" /* el */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const origi_table = content.querySelector("table");
    if (!origi_table)
      return content;
    let { tableMap, origi_rowCount, origi_colCount } = table2tableMap(origi_table, true);
    const map_table2 = tableMap;
    const trans_table = tableMap2table(map_table2, origi_rowCount, origi_colCount);
    origi_table.classList.forEach((className) => {
      trans_table.classList.add(className);
    });
    trans_table.classList.add("ab-extable", "ab-table");
    origi_table.innerHTML = trans_table.innerHTML;
    return content;
  }
});
var abc_strictTable = ABConvert.factory({
  id: "strictTable",
  name: "\u6B63\u89C4\u5316\u8868\u683C",
  match: "strictTable",
  detail: "\u8865\u5168\u8868\u683C\u7684\u5C3E\u4E22\u5931\u9879\uFF0Clist2table|trs\u65F6\uFF0C\u53EF\u4EE5\u6709\u6548\u907F\u514Dbug",
  process_param: "HTMLElement" /* el */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const origi_table = content.querySelector("table");
    if (!origi_table)
      return content;
    let { tableMap, origi_rowCount, origi_colCount } = table2tableMap(origi_table);
    tableMapPrint(tableMap);
    for (let i = 0; i < origi_rowCount; i++) {
      for (let j = 0; j < origi_colCount; j++) {
        const origi_cell = tableMap[i][j];
        if (!origi_cell) {
          tableMap[i][j] = {
            html: document.createElement("td"),
            rowSpan: 1,
            colSpan: 1,
            rowIndex: i,
            colIndex: j
          };
        }
      }
    }
    tableMapPrint(tableMap);
    const trans_table = tableMap2table(tableMap, origi_rowCount, origi_colCount);
    origi_table.classList.forEach((className) => {
      trans_table.classList.add(className);
    });
    trans_table.classList.add("ab-extable", "ab-table");
    origi_table.innerHTML = trans_table.innerHTML;
    return content;
  }
});
function table2tableMap(origi_table, useMergeFlag = false) {
  const origi_rows = origi_table.rows;
  let origi_rowCount = origi_rows.length;
  let origi_colCount = 0;
  {
    let map_colCount = [];
    for (let relRow = 0; relRow < origi_rowCount; relRow++) {
      for (const cell of origi_rows[relRow].cells) {
        const colSpan = cell.colSpan || 1;
        const rowSpan = cell.rowSpan || 1;
        for (let relRowSpan = relRow; relRowSpan < relRow + rowSpan; relRowSpan++) {
          if (!map_colCount[relRowSpan])
            map_colCount[relRowSpan] = colSpan;
          else
            map_colCount[relRowSpan] += colSpan;
        }
      }
    }
    origi_rowCount = map_colCount.length;
    origi_colCount = Math.max(...map_colCount);
  }
  const tableMap = new Array(origi_rowCount).fill(null).map(() => new Array(origi_colCount).fill(null));
  for (let relRow = 0; relRow < origi_rowCount; relRow++) {
    for (let relCol = 0; relCol < origi_rows[relRow].cells.length; relCol++) {
      const cell = origi_rows[relRow].cells[relCol];
      const rowIndex = relRow;
      let colIndex = relCol;
      while (true) {
        if (colIndex >= tableMap[rowIndex].length) {
          console.error(`\u8868\u683C\u89E3\u6790\u9519\u8BEF: colIndex\u8D85\u51FA\u8303\u56F4: [${rowIndex}][${colIndex}] overflow tableMap[${origi_rowCount - 1}][${origi_colCount - 1}]`, tableMap);
          throw new Error("\u8868\u683C\u89E3\u6790\u9519\u8BEF: colIndex\u8D85\u51FA\u8303\u56F4");
        }
        if (!tableMap[rowIndex][colIndex]) {
          break;
        } else
          colIndex++;
      }
      if (cell.rowSpan > 1) {
        for (let i = 1; i < cell.rowSpan; i++) {
          if (rowIndex + i >= tableMap.length) {
            break;
          }
          tableMap[rowIndex + i][colIndex] = "^";
        }
      }
      if (cell.colSpan > 1) {
        for (let i = 1; i < cell.rowSpan; i++) {
          if (colIndex + i >= tableMap[rowIndex].length) {
            break;
          }
          tableMap[rowIndex][colIndex + i] = "<";
        }
      }
      if (useMergeFlag) {
        if (cell.rowSpan == 1 && cell.colSpan == 1 && cell.textContent == "^") {
          tableMap[rowIndex][colIndex] = "^";
          for (let i = rowIndex - 1; i >= 0; i--) {
            const item = tableMap[i][colIndex];
            if (!item)
              break;
            if (item == "<")
              break;
            if (item == "^")
              continue;
            if (item.html.textContent == "<")
              break;
            if (item.html.textContent != "^" || i == 0) {
              item.rowSpan += 1;
              break;
            }
          }
        } else if (cell.rowSpan == 1 && cell.colSpan == 1 && cell.textContent == "<") {
          tableMap[rowIndex][colIndex] = "<";
          for (let j = colIndex - 1; j >= 0; j--) {
            const item = tableMap[rowIndex][j];
            if (!item)
              break;
            if (item == "^")
              break;
            if (item == "<")
              continue;
            if (item.html.textContent == "^")
              break;
            if (item.html.textContent != "<" || j == 0) {
              item.colSpan += 1;
              break;
            }
          }
        } else {
          tableMap[rowIndex][colIndex] = {
            html: cell,
            rowSpan: cell.rowSpan,
            colSpan: cell.colSpan,
            rowIndex,
            colIndex
          };
        }
      } else {
        tableMap[rowIndex][colIndex] = {
          html: cell,
          rowSpan: cell.rowSpan,
          colSpan: cell.colSpan,
          rowIndex,
          colIndex
        };
      }
    }
  }
  return {
    tableMap,
    origi_rowCount,
    origi_colCount
  };
}
function tableMap2table(tableMap, origi_rowCount, origi_colCount) {
  const trans_table = document.createElement("table");
  const trans_body = document.createElement("tbody");
  trans_table.appendChild(trans_body);
  for (let i = 0; i < origi_rowCount; i++) {
    const newRow = trans_body.insertRow();
    for (let j = 0; j < origi_colCount; j++) {
      const cell = tableMap[i][j];
      if (!cell)
        continue;
      if (cell == "<" || cell == "^")
        continue;
      const newCell = newRow.insertCell();
      newCell.innerHTML = cell.html.innerHTML;
      newCell.rowSpan = cell.rowSpan;
      newCell.colSpan = cell.colSpan;
      newCell.setAttribute("rowIndex", String(cell.rowIndex));
      newCell.setAttribute("colIndex", String(cell.colIndex));
    }
  }
  return trans_table;
}
function tableMapPrint(tableMap) {
  var _a3;
  let content = "";
  for (let i = 0; i < tableMap.length; i++) {
    let row = i + "|";
    for (let j = 0; j < tableMap[i].length; j++) {
      const cell = tableMap[i][j];
      if (cell === null)
        row += " . |";
      else if (cell === "<")
        row += " < |";
      else if (cell === "^")
        row += " ^ |";
      else
        row += ` ${((_a3 = cell.html.textContent) == null ? void 0 : _a3.trim()) || ""} |`;
    }
    content += row + "\n";
  }
  console.log("tableMap\n" + content);
}

// ../ABConverter/converter/abc_ex.ts
var abc_faq = ABConvert.factory({
  id: "faq",
  name: "FAQ",
  match: "FAQ",
  detail: "\u6E32\u67D3\u5E38\u89C1\u95EE\u9898/\u5BF9\u8BDD\u3002\u6BCF\u4E2A\u9879\u9700\u4EE5 `/^([a-zA-Z])(: |\uFF1A)(.*)/` \u5F00\u5934",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const e_faq = document.createElement("div");
    el.appendChild(e_faq);
    e_faq.classList.add("ab-faq");
    const list_content = content.split("\n");
    let mode_qa = "";
    let last_content = "";
    for (let line of list_content) {
      const m_line = line.match(/^([a-zA-Z])(: |：)(.*)/);
      if (!m_line) {
        if (mode_qa) {
          last_content = last_content + "\n" + line;
        }
        continue;
      } else {
        if (mode_qa) {
          const e_faq_line = document.createElement("div");
          e_faq.appendChild(e_faq_line);
          e_faq_line.classList.add("ab-faq-line", `ab-faq-${mode_qa}`);
          const e_faq_bubble = document.createElement("div");
          e_faq_line.appendChild(e_faq_bubble);
          e_faq_bubble.classList.add("ab-faq-bubble", `ab-faq-${mode_qa}`);
          const e_faq_content = document.createElement("div");
          e_faq_bubble.appendChild(e_faq_content);
          e_faq_content.classList.add("ab-faq-content");
          ABConvertManager.getInstance().m_renderMarkdownFn(last_content, e_faq_content);
        }
        mode_qa = m_line[1];
        last_content = m_line[3];
      }
    }
    if (mode_qa) {
      const e_faq_line = document.createElement("div");
      e_faq.appendChild(e_faq_line);
      e_faq_line.classList.add("ab-faq-line", `ab-faq-${mode_qa}`);
      const e_faq_bubble = document.createElement("div");
      e_faq_line.appendChild(e_faq_bubble);
      e_faq_bubble.classList.add("ab-faq-bubble", `ab-faq-${mode_qa}`);
      const e_faq_content = document.createElement("div");
      e_faq_bubble.appendChild(e_faq_content);
      e_faq_content.classList.add("ab-faq-content");
      ABConvertManager.getInstance().m_renderMarkdownFn(last_content, e_faq_content);
    }
    return el;
  }
});
var abc_info_converter = ABConvert.factory({
  id: "info_converter",
  name: "INFO",
  detail: "\u67E5\u770B\u5F53\u524D\u8F6F\u4EF6\u7248\u672C\u4E0B\u7684\u6CE8\u518C\u5904\u7406\u5668\u8868",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const table_p = document.createElement("div");
    el.appendChild(table_p);
    table_p.classList.add("ab-setting", "md-table-fig1");
    const table2 = document.createElement("table");
    table_p.appendChild(table2);
    table2.classList.add("ab-setting", "md-table-fig2");
    {
      const thead = document.createElement("thead");
      table2.appendChild(thead);
      const tr = document.createElement("tr");
      thead.appendChild(tr);
      let th;
      th = document.createElement("th");
      tr.appendChild(th);
      th.textContent = "\u5904\u7406\u5668\u540D\nProcessor name";
      th = document.createElement("th");
      tr.appendChild(th);
      th.textContent = "\u4E0B\u62C9\u6846\u9ED8\u8BA4\u9879\nThe default drop-down box";
      th = document.createElement("th");
      tr.appendChild(th);
      th.textContent = "\u7528\u9014\u63CF\u8FF0\nPurpose description";
      th = document.createElement("th");
      tr.appendChild(th);
      th.textContent = "\u8F93\u5165\u7C7B\u578B\nInput type";
      th = document.createElement("th");
      tr.appendChild(th);
      th.textContent = "\u8F93\u51FA\u7C7B\u578B\nOutput type";
      th = document.createElement("th");
      tr.appendChild(th);
      th.textContent = "\u6B63\u5219\nRegExp";
      th = document.createElement("th");
      tr.appendChild(th);
      th.textContent = "\u662F\u5426\u542F\u7528\nIs enable";
      th = document.createElement("th");
      tr.appendChild(th);
      th.textContent = "\u5B9A\u4E49\u6765\u6E90\nSource";
      th = document.createElement("th");
      tr.appendChild(th);
      th.textContent = "\u522B\u540D\u66FF\u6362\nAlias substitution";
    }
    const tbody = document.createElement("tbody");
    table2.appendChild(tbody);
    for (let item of ABConvertManager.getInstance().list_abConvert) {
      const tr = document.createElement("tr");
      tbody.appendChild(tr);
      let td;
      td = document.createElement("td");
      tr.appendChild(td);
      td.textContent = item.name;
      td = document.createElement("td");
      tr.appendChild(td);
      td.textContent = String(item.default);
      td = document.createElement("td");
      tr.appendChild(td);
      td.textContent = item.detail;
      td.setAttribute("style", "max-width:240px;overflow-x:auto;white-space:nowrap;");
      td = document.createElement("td");
      tr.appendChild(td);
      td.textContent = String(item.process_param);
      td = document.createElement("td");
      tr.appendChild(td);
      td.textContent = String(item.process_return);
      td = document.createElement("td");
      tr.appendChild(td);
      td.textContent = String(item.match);
      td = document.createElement("td");
      tr.appendChild(td);
      td.textContent = item.is_disable ? "No" : "Yes";
      td = document.createElement("td");
      tr.appendChild(td);
      td.textContent = item.register_from;
      td = document.createElement("td");
      tr.appendChild(td);
      td.textContent = item.process_alias;
    }
    return el;
  }
});
var abc_info_alias = ABConvert.factory({
  id: "info_alias",
  name: "INFO_Alias",
  match: "info_alias",
  detail: "\u67E5\u770B\u5F53\u524D\u8F6F\u4EF6\u7248\u672C\u4E0B\u7684\u6CE8\u518C\u522B\u540D\u8868",
  process_param: "string" /* text */,
  process_return: "json_string" /* json */,
  process: (el, header, content) => {
    return JSON.stringify(
      ABAlias_json.map((item) => {
        return {
          regex: item.regex.toString(),
          replacement: item.replacement
        };
      }),
      null,
      2
    );
  }
});

// ../ABConverter/converter/abc_mdit_container.ts
function mditTabs2listdata(content, reg) {
  const list_line = content.split("\n");
  let content_item = "";
  const list_c2listItem = [];
  for (let line_index = 0; line_index < list_line.length; line_index++) {
    const line_content = list_line[line_index];
    const line_match = line_content.match(reg);
    if (line_match) {
      add_current_content();
      list_c2listItem.push({
        content: line_match[1].trim(),
        level: 0
      });
      continue;
    } else {
      content_item += line_content + "\n";
    }
  }
  add_current_content();
  return list_c2listItem;
  function add_current_content() {
    if (content_item.trim() == "")
      return;
    list_c2listItem.push({
      content: content_item,
      level: 1
    });
    content_item = "";
  }
}
var abc_mditTabs = ABConvert.factory({
  id: "mditTabs",
  name: "mdit\u6807\u7B7E\u9875",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const c2listdata = mditTabs2listdata(content, /^@tab(.*)$/);
    C2ListProcess.c2data2tab(c2listdata, el, false);
    return el;
  }
});
var abc_mditDemo = ABConvert.factory({
  id: "mditDemo",
  name: "mdit\u5C55\u793A\u5BF9\u6BD4",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const newContent = `@tab show
${content}
@tab mdSource
~~~~~md
${content}
~~~~~`;
    abc_mditTabs.process(el, header, newContent);
    return el;
  }
});
var abc_mditABDemo = ABConvert.factory({
  id: "mditABDemo",
  name: "AnyBlock\u4E13\u7528\u5C55\u793A\u5BF9\u6BD4",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    if (ABCSetting.env == "vuepress") {
      ABConvertManager.getInstance().m_renderMarkdownFn(`::::: tabs

@tab show

${content}

@tab withoutPlugin

(noPlugin)${content.trimStart()}

@tab mdSource

~~~~~md
${content}
~~~~~

:::::`, el);
      return el;
    } else {
      const newContent = `@tab show
${content}
@tab withoutPlugin
(noPlugin)${content.trimStart()}
@tab mdSource
~~~~~md
${content}
~~~~~`;
      abc_mditTabs.process(el, header, newContent);
      return el;
    }
  }
});
var abc_midt_co = ABConvert.factory({
  id: "mditCol",
  name: "mdit\u5206\u680F",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    var _a3;
    const c2listdata = mditTabs2listdata(content, /^@col(.*)$/);
    C2ListProcess.c2data2items(c2listdata, el);
    (_a3 = el.querySelector("div")) == null ? void 0 : _a3.classList.add("ab-col");
    return el;
  }
});
var abc_midt_card = ABConvert.factory({
  id: "mditCard",
  name: "mdit\u5361\u7247",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    var _a3, _b;
    const c2listdata = mditTabs2listdata(content, /^@card(.*)$/);
    C2ListProcess.c2data2items(c2listdata, el);
    (_a3 = el.querySelector("div")) == null ? void 0 : _a3.classList.add("ab-card");
    (_b = el.querySelector("div")) == null ? void 0 : _b.classList.add("ab-lay-vfall");
    return el;
  }
});
var abc_midt_chat = ABConvert.factory({
  id: "mditChat",
  name: "mdit\u5BF9\u8BDD",
  detail: "\u663E\u793A\u6E32\u67D3\u5BF9\u8BDD\uFF0C\u9700\u8981\u914D\u5408 obsidian-view-chat-qq \u63D2\u4EF6\u4F7F\u7528",
  process_param: "string" /* text */,
  process_return: "string" /* text */,
  process: (el, header, content) => {
    const content_list = content.split("\n");
    let newContent = "";
    for (let i = 0; i < content_list.length; i++) {
      const line = content_list[i];
      if (/^@chat(.*)$/.test(line)) {
        const match2 = line.match(/^@chat(.*)$/);
        if (match2 && match2[1]) {
          newContent += "\n" + match2[1] + ":\n";
          continue;
        }
      }
      newContent += line + "\n";
    }
    return newContent;
  }
});

// ../ABConverter/converter/abc_plantuml.ts
var import_plantuml_encoder = __toESM(require_browser_index());

// ../ABConverter/converter/abc_plantuml_tools.ts
var KEYWORD_IF = "if ";
var KEYWORD_SWITCH = "switch ";
var KEYWORD_SWITCH2 = "match ";
var KEYWORD_WHILE = "while ";
var KEYWORD_GROUP = "group ";
var KEYWORD_PARTITION = "partition ";
var KEYWORD_LANE = "lane ";
var KEYWORD_ELIF = "elif ";
var KEYWORD_ELSEIF = "else if ";
var KEYWORD_ELSE = "else";
var KEYWORD_DEFAULT = "default";
var KEYWORD_DEFAULT2 = "case _";
var KEYWORD_CASE = "case ";
var BLOCK_START = ":";
var INDENT = "  ";
var Stat = class {
  constructor(content, level) {
    this.content = content.trim();
    this.level = level;
  }
  isReservedWord() {
    return this.content === "start" || this.content === "stop" || this.content === "kill" || this.content === "detach" || this.content === "break" || this.content === "end" || this.content === "fork" || this.content === "fork again" || this.content === "end fork" || this.content === "end merge";
  }
  isStatementOfType(...stateType) {
    return stateType.some((type) => this.content.startsWith(type)) && this.content.endsWith(BLOCK_START);
  }
  takeTagOfStat(type) {
    const condition = this.content.substring(type.length, this.content.length - BLOCK_START.length).trim();
    return condition;
  }
};
var statementTypes = {
  [KEYWORD_IF]: processIfStatement,
  [KEYWORD_SWITCH]: processSwitchStatement,
  [KEYWORD_SWITCH2]: processSwitchStatement,
  [KEYWORD_WHILE]: processWhileStatement,
  [KEYWORD_GROUP]: processGroupStatement,
  [KEYWORD_PARTITION]: processPartitionStatement,
  [KEYWORD_LANE]: processSwimLane
};
function processBlock(stats, index2, parentLevel) {
  let result = "";
  let next2 = index2;
  while (next2 < stats.length && (parentLevel === -1 || stats[next2].level > parentLevel)) {
    const stat = stats[next2];
    if (stat.isReservedWord()) {
      result += stat.content + "\n";
      next2++;
      continue;
    }
    let processed = false;
    for (const [statType, processor] of Object.entries(statementTypes)) {
      if (stat.isStatementOfType(statType)) {
        const { result: processedResult, nextIndex: nextNext } = processor(stats, next2, statType);
        result += processedResult;
        next2 = nextNext;
        processed = true;
        break;
      }
    }
    if (processed)
      continue;
    if (stat.content.length > 0) {
      result += `:${stat.content};
`;
    }
    next2++;
  }
  return { result, nextIndex: next2 };
}
function processIfStatement(stats, index2) {
  let result = KEYWORD_IF;
  const stat = stats[index2];
  const condition = stat.takeTagOfStat(KEYWORD_IF);
  let nextIndex = index2 + 1;
  if (nextIndex < stats.length && stats[nextIndex].level > stat.level) {
    result += `(${condition}) then (yes)
`;
    const { result: result2, nextIndex: nextIndex2 } = processBlock(stats, nextIndex, stat.level);
    result += indentContent(result2);
    nextIndex = nextIndex2;
  }
  while (nextIndex < stats.length && stats[nextIndex].level === stat.level && stats[nextIndex].isStatementOfType(KEYWORD_ELIF, KEYWORD_ELSEIF, KEYWORD_ELSE)) {
    const branch = stats[nextIndex];
    if (branch.isStatementOfType(KEYWORD_ELSEIF)) {
      const condition2 = branch.takeTagOfStat(KEYWORD_ELSEIF);
      result += `else if(${condition2}) then (yes)
`;
    } else if (branch.isStatementOfType(KEYWORD_ELIF)) {
      const condition2 = branch.takeTagOfStat(KEYWORD_ELIF);
      result += `else if(${condition2}) then (yes)
`;
    } else if (branch.isStatementOfType(KEYWORD_ELSE)) {
      result += `else (else)
`;
    }
    const { result: result2, nextIndex: nextIndex2 } = processBlock(stats, nextIndex + 1, stat.level);
    result += indentContent(result2);
    nextIndex = nextIndex2;
  }
  result += "endif\n";
  return { result, nextIndex };
}
function processSwitchStatement(stats, index2, statType) {
  let result = `switch `;
  const stat = stats[index2];
  const condition = stat.takeTagOfStat(statType);
  let nextIndex = index2 + 1;
  result += `(${condition})
`;
  let hasDefault = false;
  while (nextIndex < stats.length && stats[nextIndex].level >= stat.level && stats[nextIndex].isStatementOfType(KEYWORD_CASE, KEYWORD_DEFAULT)) {
    const nextStat = stats[nextIndex];
    nextIndex++;
    if (nextStat.isStatementOfType(KEYWORD_DEFAULT) || nextStat.isStatementOfType(KEYWORD_DEFAULT2)) {
      result += `case (default)
`;
      hasDefault = true;
      const { result: defaultResult, nextIndex: defaultNextIndex } = processBlock(stats, nextIndex, nextStat.level);
      result += indentContent(defaultResult);
      nextIndex = defaultNextIndex;
    } else if (nextStat.isStatementOfType(KEYWORD_CASE)) {
      const caseTag = nextStat.takeTagOfStat(KEYWORD_CASE);
      result += `case (${caseTag})
`;
      const { result: caseResult, nextIndex: caseNextIndex } = processBlock(stats, nextIndex, nextStat.level);
      result += indentContent(caseResult);
      nextIndex = caseNextIndex;
    }
  }
  if (!hasDefault) {
    result += "case (default)\n";
  }
  result += "endswitch\n";
  return { result, nextIndex };
}
function processWhileStatement(stats, index2) {
  const stat = stats[index2];
  const condition = stat.takeTagOfStat(KEYWORD_WHILE);
  let result = `${KEYWORD_WHILE}(${condition}) is (true)
`;
  let nextIndex = index2 + 1;
  const { result: bodyResult, nextIndex: bodyNextIndex } = processBlock(stats, nextIndex, stat.level);
  result += indentContent(bodyResult);
  nextIndex = bodyNextIndex;
  result += "endwhile\n";
  return { result, nextIndex };
}
function processGroupStatement(stats, index2) {
  const stat = stats[index2];
  const groupName = stat.takeTagOfStat(KEYWORD_GROUP);
  let result = `${KEYWORD_GROUP}${groupName}
`;
  let nextIndex = index2 + 1;
  const { result: bodyResult, nextIndex: bodyNextIndex } = processBlock(stats, nextIndex, stat.level);
  result += indentContent(bodyResult);
  nextIndex = bodyNextIndex;
  result += "endgroup\n";
  return { result, nextIndex };
}
function processPartitionStatement(stats, index2) {
  const stat = stats[index2];
  const partitionName = stat.takeTagOfStat(KEYWORD_PARTITION);
  let result = `${KEYWORD_PARTITION}${partitionName} {
`;
  let nextIndex = index2 + 1;
  const { result: bodyResult, nextIndex: bodyNextIndex } = processBlock(stats, nextIndex, stat.level);
  result += indentContent(bodyResult);
  nextIndex = bodyNextIndex;
  result += "}\n";
  return { result, nextIndex };
}
function processSwimLane(stats, index2) {
  const stat = stats[index2];
  const laneName = stat.takeTagOfStat(KEYWORD_LANE);
  return { result: "|" + laneName + "|\n", nextIndex: index2 + 1 };
}
function indentContent(content) {
  return content.split("\n").filter((x) => x !== "").map((line) => INDENT + line).join("\n") + "\n";
}
function list2ActivityDiagramText(listdata) {
  let result = "@startuml\n";
  const stats = listdata.map((item) => new Stat(item.content.trim(), item.level));
  const { result: bodyResult } = processBlock(stats, 0, -1);
  result += bodyResult;
  result += "@enduml";
  return result;
}

// ../ABConverter/converter/abc_plantuml.ts
var abc_list2jsontext = ABConvert.factory({
  id: "json2pumlJson",
  name: "json\u5230\u53EF\u89C6\u5316",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    content = "@startjson\n" + content + "\n@endjson\n";
    render_pumlText(content, el);
    return el;
  }
});
var abc_list2pumlWBS = ABConvert.factory({
  id: "list2pumlWBS",
  name: "\u5217\u8868\u5230puml\u5DE5\u4F5C\u5206\u89E3\u7ED3\u6784",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    let listdata = ListProcess.list2data(content);
    listdata = ListProcess.data2strict(listdata);
    let newContent = "@startwbs\n";
    for (let item of listdata) {
      if (item.content.startsWith("< "))
        newContent += "*".repeat(item.level + 1) + "< " + item.content.slice(2) + "\n";
      else
        newContent += "*".repeat(item.level + 1) + " " + item.content + "\n";
    }
    newContent += "@endwbs";
    render_pumlText(newContent, el);
    return el;
  }
});
var abc_list2pumlMindmap = ABConvert.factory({
  id: "list2pumlMindmap",
  name: "\u5217\u8868\u5230puml\u601D\u7EF4\u5BFC\u56FE",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    let listdata = ListProcess.list2data(content);
    listdata = ListProcess.data2strict(listdata);
    let newContent = "@startmindmap\n";
    for (let item of listdata) {
      newContent += "*".repeat(item.level + 1) + " " + item.content + "\n";
    }
    newContent += "@endmindmap";
    render_pumlText(newContent, el);
    return el;
  }
});
var abc_list2ActivityDiagramText = ABConvert.factory({
  id: "list2pumlActivityDiagramText",
  name: "\u5217\u8868\u5230puml\u6D3B\u52A8\u56FE\u6587\u672C",
  process_param: "string" /* text */,
  process_return: "string" /* text */,
  process: (el, header, content) => {
    return list2ActivityDiagramText(ListProcess.data2strict(ListProcess.list2data(content)));
  }
});
var abc_list2ActivityDiagram = ABConvert.factory({
  id: "list2pumlActivityDiagram",
  name: "\u5217\u8868\u5230puml\u6D3B\u52A8\u56FE",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    const puml = list2ActivityDiagramText(ListProcess.data2strict(ListProcess.list2data(content)));
    render_pumlText(puml, el);
    return el;
  }
});
async function render_pumlText(text4, div) {
  var encoded = import_plantuml_encoder.default.encode(text4);
  let url = "http://www.plantuml.com/plantuml/img/" + encoded;
  div.innerHTML = `<img src="${url}">`;
  return div;
}

// ../ABConverter/converter/abc_mermaid.ts
function getID(length = 16) {
  return Number(Math.random().toString().substr(3, length) + Date.now()).toString(36);
}
var abc_title2mindmap = ABConvert.factory({
  id: "title2mindmap",
  name: "\u6807\u9898\u5230\u8111\u56FE",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: async (el, header, content) => {
    const data2 = ListProcess.title2data(content);
    const el2 = await data2mindmap(data2, el);
    return el2;
  }
});
var abc_list2mindmap = ABConvert.factory({
  id: "list2mindmap",
  name: "\u5217\u8868\u8F6Cmermaid\u601D\u7EF4\u5BFC\u56FE",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: async (el, header, content) => {
    const data2 = ListProcess.list2data(content);
    const el2 = await data2mindmap(data2, el);
    return el2;
  }
});
var abc_list2mermaid = ABConvert.factory({
  id: "list2mermaid",
  name: "\u5217\u8868\u8F6Cmermaid\u6D41\u7A0B\u56FE",
  match: /^list2mermaid(\((.*)\))?$/,
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    let matchs = header.match(/^list2mermaid(\((.*)\))?$/);
    if (!matchs) {
      console.error("no match", matchs);
      return el;
    }
    let mermaid_head = "graph LR";
    if (matchs[2])
      mermaid_head = matchs[2];
    const list_itemInfo = ListProcess.list2data(content);
    const mermaidText = mermaid_head + "\n" + data2mermaidText(list_itemInfo);
    render_mermaidText(mermaidText, el);
    return el;
  }
});
var abc_list2mermaidText = ABConvert.factory({
  id: "list2mermaidText",
  name: "\u5217\u8868\u8F6Cmermaid\u6587\u672C",
  match: /^list2mermaidText(\((.*)\))?$/,
  detail: "\u5217\u8868\u8F6Cmermaid\u6587\u672C",
  process_param: "string" /* text */,
  process_return: "string" /* text */,
  process: (el, header, content) => {
    let matchs = header.match(/^list2mermaidText(\((.*)\))?$/);
    if (!matchs) {
      console.error("no match", matchs);
      return "error, no match";
    }
    let mermaid_head = "graph LR";
    if (matchs[2])
      mermaid_head = matchs[2];
    const list_itemInfo = ListProcess.list2data(content);
    const mermaidText = mermaid_head + "\n" + data2mermaidText(list_itemInfo);
    return mermaidText;
  }
});
var abc_list2mehrmaid = ABConvert.factory({
  id: "list2mehrmaidText",
  name: "\u5217\u8868\u8F6Cmehrmaid\u6587\u672C",
  match: /^list2mehrmaidText(\((.*)\))?$/,
  detail: "\u9700\u8981\u914D\u5408mehrmaid\u63D2\u4EF6\u548Ccode(mehrmaid)\u4F7F\u7528\uFF0C\u6216\u4F7F\u7528\u522B\u540D\u7B80\u5316",
  process_param: "string" /* text */,
  process_return: "string" /* text */,
  process: (el, header, content) => {
    let matchs = header.match(/^list2mehrmaidText(\((.*)\))?$/);
    if (!matchs) {
      console.error("no match", matchs);
      return "error, no match";
    }
    let mermaid_head = "flowchart LR";
    if (matchs[2])
      mermaid_head = matchs[2];
    const list_itemInfo = ListProcess.list2data(content);
    const mermaidText = mermaid_head + "\n" + data2mehrmaidText(list_itemInfo);
    return mermaidText;
  }
});
var abc_mermaid = ABConvert.factory({
  id: "mermaid-with",
  name: "\u65B0mermaid",
  match: /^mermaid(\((.*)\))?$/,
  default: "mermaid(graph TB)",
  detail: "\u7531\u4E8E\u9700\u8981\u517C\u5BB9\u8111\u56FE\uFF0C\u8FD9\u91CC\u4F1A\u4F7F\u7528\u63D2\u4EF6\u5185\u7F6E\u7684\u6700\u65B0\u7248mermaid",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: async (el, header, content) => {
    let matchs = header.match(/^mermaid(\((.*)\))?$/);
    if (!matchs)
      return el;
    if (matchs[2])
      content = matchs[2] + "\n" + content;
    const el2 = render_mermaidText(content, el);
    return el2;
  }
});
function data2mermaidText(list_itemInfo) {
  const html_mode = false;
  let list_line_content = [];
  let prev_line_content = "";
  let prev_level = 999;
  for (let i = 0; i < list_itemInfo.length; i++) {
    if (list_itemInfo[i].level > prev_level) {
      prev_line_content = prev_line_content + " --> " + list_itemInfo[i].content;
    } else {
      list_line_content.push(prev_line_content);
      prev_line_content = "";
      for (let j = i; j >= 0; j--) {
        if (list_itemInfo[j].level < list_itemInfo[i].level) {
          prev_line_content = list_itemInfo[j].content;
          break;
        }
      }
      if (prev_line_content)
        prev_line_content = prev_line_content + " --> ";
      prev_line_content = prev_line_content + list_itemInfo[i].content;
    }
    prev_level = list_itemInfo[i].level;
  }
  list_line_content.push(prev_line_content);
  let text4 = list_line_content.join("\n");
  return text4;
}
function data2mehrmaidText(list_itemInfo) {
  const mehrmaidMap = [];
  for (let i = 0; i < list_itemInfo.length; i++) {
    mehrmaidMap[i] = list_itemInfo[i].content;
    list_itemInfo[i].content = i.toString();
  }
  const html_mode = false;
  let list_line_content = [];
  let prev_line_content = "";
  let prev_level = 999;
  for (let i = 0; i < list_itemInfo.length; i++) {
    if (list_itemInfo[i].level > prev_level) {
      prev_line_content = prev_line_content + " --> " + list_itemInfo[i].content;
    } else {
      list_line_content.push(prev_line_content);
      prev_line_content = "";
      for (let j = i; j >= 0; j--) {
        if (list_itemInfo[j].level < list_itemInfo[i].level) {
          prev_line_content = list_itemInfo[j].content;
          break;
        }
      }
      if (prev_line_content)
        prev_line_content = prev_line_content + " --> ";
      prev_line_content = prev_line_content + list_itemInfo[i].content;
    }
    prev_level = list_itemInfo[i].level;
  }
  list_line_content.push(prev_line_content);
  let text4 = list_line_content.join("\n");
  text4 += "\n\n";
  for (let i = 0; i < mehrmaidMap.length; i++) {
    text4 += `${i}(("${mehrmaidMap[i]}"))
`;
  }
  return text4;
}
async function data2mindmap(list_itemInfo, div) {
  let list_newcontent = [];
  for (let item of list_itemInfo) {
    let str_indent = "";
    for (let i = 0; i < item.level; i++)
      str_indent += " ";
    list_newcontent.push(str_indent + item.content.replace("\n", "<br/>"));
  }
  const mermaidText = "mindmap\n" + list_newcontent.join("\n");
  return render_mermaidText(mermaidText, div);
}
async function render_mermaidText(mermaidText, div) {
  if ((ABCSetting.env == "obsidian" || ABCSetting.env == "obsidian-min") && ABCSetting.mermaid) {
    ABCSetting.mermaid.then(async (mermaid) => {
      const { svg } = await mermaid.render("ab-mermaid-" + getID(), mermaidText);
      div.innerHTML = svg;
    });
  } else {
    div.classList.add("ab-raw");
    div.innerHTML = `<div class="ab-raw-data" type-data="mermaid" content-data='${mermaidText}'></div>`;
  }
  {
  }
  return div;
}

// ../ABConverter/ABConvertEvent.ts
function abConvertEvent(d, isCycle = false) {
  var _a3;
  if (d.querySelector(".ab-super-width")) {
    const els_note = d.querySelectorAll(".ab-note");
    for (const el_note of els_note) {
      if (el_note.querySelector(".ab-super-width")) {
        const el_replace = el_note.parentNode;
        if (el_replace && el_replace.classList.contains("ab-replace")) {
          el_replace.classList.add("ab-super-width-p");
        }
      }
    }
    const els_view = document.querySelectorAll(".app-container .workspace-leaf");
    for (const el_view of els_view) {
      el_view.style.setProperty("--ab-width-outer", (el_view.offsetWidth - 40).toString() + "px");
    }
  }
  if (d.querySelector(".ab-nodes-node")) {
    const els_min = document.querySelectorAll(".ab-nodes.min .ab-nodes-node");
    const list_children = d.querySelectorAll(".ab-nodes-node");
    for (const children2 of list_children) {
      const el_content = children2.querySelector(".ab-nodes-content");
      if (!el_content)
        continue;
      const el_child = children2.querySelector(".ab-nodes-children");
      if (!el_child)
        continue;
      const el_bracket = el_child.querySelector(".ab-nodes-bracket");
      if (!el_bracket)
        continue;
      const el_bracket2 = el_child.querySelector(".ab-nodes-bracket2");
      if (!el_bracket2)
        continue;
      const els_child = el_child.childNodes;
      if (els_child.length < 3) {
        el_bracket.style.setProperty("display", "none");
        el_bracket2.style.setProperty("display", "none");
        continue;
      }
      const el_child_first = els_child[2];
      const el_child_last = els_child[els_child.length - 1];
      const el_child_first_content = el_child_first.querySelector(".ab-nodes-content");
      const el_child_last_content = el_child_last.querySelector(".ab-nodes-content");
      let height = 0;
      let heightToReduce = (el_child_first.offsetHeight + el_child_last.offsetHeight) / 2;
      if (els_child.length == 3) {
        height = el_child_first_content.offsetHeight - 20 > 20 ? el_child_first_content.offsetHeight - 20 : 20;
        el_bracket2.style.cssText = `
          height: ${height}px;
          top: calc(50% - ${height / 2}px);
        `;
      } else {
        el_bracket2.style.cssText = `
          height: calc(100% - ${heightToReduce}px);
          top: ${el_child_first.offsetHeight / 2}px;
        `;
      }
      if (Array.prototype.includes.call(els_min, children2)) {
        if (els_child.length == 3) {
          el_bracket.style.cssText = `
            display: block;
            top: calc(50% + ${el_content.offsetHeight / 2}px - 3px);
            clip-path: circle(40% at 50% 40%);
          `;
        } else {
          el_bracket.setAttribute("display", "none");
        }
        if (els_child.length == 3 && el_content.offsetHeight == el_child_first_content.offsetHeight) {
          el_bracket2.style.cssText = `
            height: 1px;
            top: calc(50% + ${el_content.offsetHeight / 2}px - 1px);
            width: 18px; /* \u53EF\u4EE5\u6EA2\u51FA\u70B9 */
            border-radius: 0;
            border: none;
            border-bottom: 1px solid var(--node-color);
          `;
        } else {
          if (els_child.length == 3) {
            height = el_child_last_content.offsetHeight / 2 - el_content.offsetHeight / 2;
            el_bracket2.style.setProperty("height", `${height}px`);
            el_bracket2.style.setProperty("top", `calc(50% + ${el_content.offsetHeight / 2}px)`);
            el_bracket2.style.setProperty("border-radius", `0 0 0 10px`);
            el_bracket2.style.setProperty("border-top", `0`);
          } else {
            heightToReduce = el_child_first.offsetHeight / 2 + el_child_first_content.offsetHeight / 2 + el_child_last.offsetHeight / 2 - el_child_last_content.offsetHeight / 2;
            el_bracket2.style.setProperty("height", `calc(100% - ${heightToReduce}px + 1px)`);
            el_bracket2.style.setProperty("top", `${el_child_first.offsetHeight / 2 + el_child_first_content.offsetHeight / 2 - 1}px`);
          }
          el_bracket2.style.setProperty("width", "20px");
        }
      }
    }
  }
  if (d.querySelector(".ab-items.ab-lay-vfall:not(.js-waterfall):not(.ab-lay-hfall):not(.ab-lay-grid)")) {
    const root_el_list = d.querySelectorAll(".ab-items.ab-lay-vfall:not(.js-waterfall):not(.ab-lay-hfall):not(.ab-lay-grid)");
    for (const root_el of root_el_list) {
      root_el.classList.add("js-waterfall");
      const list_children = root_el.querySelectorAll(".ab-items-item");
      const columnCountTmp = parseInt(window.getComputedStyle(root_el).getPropertyValue("column-count"));
      let columnCount;
      if (columnCountTmp && !isNaN(columnCountTmp) && columnCountTmp > 0) {
        columnCount = columnCountTmp;
      } else if (root_el.classList.contains("ab-col-auto") && list_children.length <= 4) {
        columnCount = list_children.length;
        root_el.classList.add("ab-col" + columnCount);
      } else {
        columnCount = 4;
        root_el.classList.add("ab-col" + columnCount);
      }
      const height_cache = [];
      const el_cache = [];
      for (let i = 0; i < columnCount; i++) {
        height_cache.push(0);
        el_cache.push([]);
      }
      for (const children2 of list_children) {
        const minValue = Math.min.apply(null, height_cache);
        const minIndex = height_cache.indexOf(minValue);
        const heightTmp = parseInt(window.getComputedStyle(children2).getPropertyValue("height"));
        height_cache[minIndex] += heightTmp && !isNaN(heightTmp) && heightTmp > 0 ? heightTmp : 10;
        el_cache[minIndex].push(children2);
      }
      const fillNumber = columnCount - list_children.length % columnCount;
      if (fillNumber != 4) {
        for (let i = 0; i < fillNumber; i++) {
          const children2 = document.createElement("div");
          children2.classList.add(".ab-items-item.placeholder");
          children2.setAttribute("style", "height: 20px");
          const minValue = Math.min.apply(null, height_cache);
          const minIndex = height_cache.indexOf(minValue);
          height_cache[minIndex] += 20;
          el_cache[minIndex].push(children2);
        }
      }
      root_el.innerHTML = "";
      for (let i = 0; i < columnCount; i++) {
        for (const j of el_cache[i]) {
          root_el.appendChild(j);
        }
      }
    }
  }
  if (!isCycle && d.querySelector(".ab-markmap-div")) {
    const divEl = d;
    let markmapId = "";
    if (divEl.tagName === "DIV") {
      markmapId = ((_a3 = divEl.querySelector(".ab-markmap-div")) == null ? void 0 : _a3.id) || "";
    }
    let mindmaps;
    if (markmapId) {
      mindmaps = document.querySelectorAll("#" + markmapId);
    } else {
      mindmaps = document.querySelectorAll(".ab-markmap-div");
    }
    for (const el_div of mindmaps) {
      const el_svg = el_div.querySelector("svg");
      const el_g = el_svg == null ? void 0 : el_svg.querySelector("g");
      if (el_svg && el_g) {
        const scale_new = el_g.getBBox().height / el_div.offsetWidth;
        el_svg.setAttribute("style", `height:${el_g.getBBox().height * scale_new + 40}px`);
        markmap_event(d);
      }
    }
  }
}
function markmap_event(d) {
  var _a3;
  if (d.querySelector(".ab-markmap-svg")) {
    console.log("  - markmap_event");
    let script_el = document.querySelector('script[script-id="ab-markmap-script"]');
    if (script_el)
      script_el.remove();
    const divEl = d;
    let markmapId = "";
    if (divEl.tagName === "DIV") {
      markmapId = ((_a3 = divEl.querySelector(".ab-markmap-svg")) == null ? void 0 : _a3.id) || "";
    }
    script_el = document.createElement("script");
    document.head.appendChild(script_el);
    script_el.type = "module";
    script_el.setAttribute("script-id", "ab-markmap-script");
    script_el.textContent = `
    import { Markmap, } from 'https://jspm.dev/markmap-view';
    const markmapId = "${markmapId || ""}";
    let mindmaps;
    if (markmapId) {
      mindmaps = document.querySelectorAll('#' + markmapId);
    } else {
      mindmaps = document.querySelectorAll('.ab-markmap-svg'); // \u6CE8\u610F\u4E00\u4E0B\u8FD9\u91CC\u7684\u9009\u62E9\u5668
    }
    for(const mindmap of mindmaps) {
      mindmap.innerHTML = "";
      Markmap.create(mindmap,null,JSON.parse(mindmap.getAttribute('data-json')));
    }`;
  }
}

// ../../node_modules/.pnpm/markmap-common@0.18.9/node_modules/markmap-common/dist/index.mjs
var testPath = "npm2url/dist/index.cjs";
var defaultProviders = {
  jsdelivr: (path) => `https://cdn.jsdelivr.net/npm/${path}`,
  unpkg: (path) => `https://unpkg.com/${path}`
};
async function checkUrl(url, signal) {
  const res = await fetch(url, {
    signal
  });
  if (!res.ok) {
    throw res;
  }
  await res.text();
}
var UrlBuilder = class {
  constructor() {
    this.providers = { ...defaultProviders };
    this.provider = "jsdelivr";
  }
  async getFastestProvider(timeout = 5e3, path = testPath) {
    const controller = new AbortController();
    let timer = 0;
    try {
      return await new Promise((resolve, reject) => {
        Promise.all(
          Object.entries(this.providers).map(async ([name2, factory]) => {
            try {
              await checkUrl(factory(path), controller.signal);
              resolve(name2);
            } catch (e) {
            }
          })
        ).then(() => reject(new Error("All providers failed")));
        timer = setTimeout(reject, timeout, new Error("Timed out"));
      });
    } finally {
      controller.abort();
      clearTimeout(timer);
    }
  }
  async findFastestProvider(timeout, path) {
    this.provider = await this.getFastestProvider(timeout, path);
    return this.provider;
  }
  setProvider(name2, factory) {
    if (factory) {
      this.providers[name2] = factory;
    } else {
      delete this.providers[name2];
    }
  }
  getFullUrl(path, provider = this.provider) {
    if (path.includes("://")) {
      return path;
    }
    const factory = this.providers[provider];
    if (!factory) {
      throw new Error(`Provider ${provider} not found`);
    }
    return factory(path);
  }
};
var urlBuilder = new UrlBuilder();
var Hook = class {
  constructor() {
    this.listeners = [];
  }
  tap(fn) {
    this.listeners.push(fn);
    return () => this.revoke(fn);
  }
  revoke(fn) {
    const i = this.listeners.indexOf(fn);
    if (i >= 0)
      this.listeners.splice(i, 1);
  }
  revokeAll() {
    this.listeners.splice(0);
  }
  call(...args) {
    for (const fn of this.listeners) {
      fn(...args);
    }
  }
};
var uniqId = Math.random().toString(36).slice(2, 8);
function noop() {
}
function walkTree(tree, callback) {
  const walk = (item, parent2) => callback(
    item,
    () => {
      var _a3;
      return (_a3 = item.children) == null ? void 0 : _a3.map((child) => walk(child, item));
    },
    parent2
  );
  return walk(tree);
}
function wrapFunction(fn, wrapper) {
  return (...args) => wrapper(fn, ...args);
}
function defer() {
  const obj = {};
  obj.promise = new Promise((resolve, reject) => {
    obj.resolve = resolve;
    obj.reject = reject;
  });
  return obj;
}
function memoize(fn) {
  const cache = {};
  return function memoized(...args) {
    const key = `${args[0]}`;
    let data2 = cache[key];
    if (!data2) {
      data2 = {
        value: fn(...args)
      };
      cache[key] = data2;
    }
    return data2.value;
  };
}
var VTYPE_ELEMENT = 1;
var VTYPE_FUNCTION = 2;
var SVG_NS = "http://www.w3.org/2000/svg";
var XLINK_NS = "http://www.w3.org/1999/xlink";
var NS_ATTRS = {
  show: XLINK_NS,
  actuate: XLINK_NS,
  href: XLINK_NS
};
var isLeaf = (c) => typeof c === "string" || typeof c === "number";
var isElement = (c) => (c == null ? void 0 : c.vtype) === VTYPE_ELEMENT;
var isRenderFunction = (c) => (c == null ? void 0 : c.vtype) === VTYPE_FUNCTION;
function h(type, props, ...children2) {
  props = Object.assign({}, props, {
    children: children2.length === 1 ? children2[0] : children2
  });
  return jsx(type, props);
}
function jsx(type, props) {
  let vtype;
  if (typeof type === "string")
    vtype = VTYPE_ELEMENT;
  else if (typeof type === "function")
    vtype = VTYPE_FUNCTION;
  else
    throw new Error("Invalid VNode type");
  return {
    vtype,
    type,
    props
  };
}
function Fragment(props) {
  return props.children;
}
var DEFAULT_ENV = {
  isSvg: false
};
function insertDom(parent2, nodes) {
  if (!Array.isArray(nodes))
    nodes = [nodes];
  nodes = nodes.filter(Boolean);
  if (nodes.length)
    parent2.append(...nodes);
}
function mountAttributes(domElement, props, env) {
  for (const key in props) {
    if (key === "key" || key === "children" || key === "ref")
      continue;
    if (key === "dangerouslySetInnerHTML") {
      domElement.innerHTML = props[key].__html;
    } else if (key === "innerHTML" || key === "textContent" || key === "innerText" || key === "value" && ["textarea", "select"].includes(domElement.tagName)) {
      const value = props[key];
      if (value != null)
        domElement[key] = value;
    } else if (key.startsWith("on")) {
      domElement[key.toLowerCase()] = props[key];
    } else {
      setDOMAttribute(domElement, key, props[key], env.isSvg);
    }
  }
}
var attrMap = {
  className: "class",
  labelFor: "for"
};
function setDOMAttribute(el, attr2, value, isSVG) {
  attr2 = attrMap[attr2] || attr2;
  if (value === true) {
    el.setAttribute(attr2, "");
  } else if (value === false) {
    el.removeAttribute(attr2);
  } else {
    const namespace = isSVG ? NS_ATTRS[attr2] : void 0;
    if (namespace !== void 0) {
      el.setAttributeNS(namespace, attr2, value);
    } else {
      el.setAttribute(attr2, value);
    }
  }
}
function flatten(arr) {
  return arr.reduce((prev2, item) => prev2.concat(item), []);
}
function mountChildren(children2, env) {
  return Array.isArray(children2) ? flatten(children2.map((child) => mountChildren(child, env))) : mount(children2, env);
}
function mount(vnode, env = DEFAULT_ENV) {
  if (vnode == null || typeof vnode === "boolean") {
    return null;
  }
  if (vnode instanceof Node) {
    return vnode;
  }
  if (isRenderFunction(vnode)) {
    const {
      type,
      props
    } = vnode;
    if (type === Fragment) {
      const node = document.createDocumentFragment();
      if (props.children) {
        const children2 = mountChildren(props.children, env);
        insertDom(node, children2);
      }
      return node;
    }
    const childVNode = type(props);
    return mount(childVNode, env);
  }
  if (isLeaf(vnode)) {
    return document.createTextNode(`${vnode}`);
  }
  if (isElement(vnode)) {
    let node;
    const {
      type,
      props
    } = vnode;
    if (!env.isSvg && type === "svg") {
      env = Object.assign({}, env, {
        isSvg: true
      });
    }
    if (!env.isSvg) {
      node = document.createElement(type);
    } else {
      node = document.createElementNS(SVG_NS, type);
    }
    mountAttributes(node, props, env);
    if (props.children) {
      let childEnv = env;
      if (env.isSvg && type === "foreignObject") {
        childEnv = Object.assign({}, childEnv, {
          isSvg: false
        });
      }
      const children2 = mountChildren(props.children, childEnv);
      if (children2 != null)
        insertDom(node, children2);
    }
    const {
      ref
    } = props;
    if (typeof ref === "function")
      ref(node);
    return node;
  }
  throw new Error("mount: Invalid Vnode!");
}
function mountDom(vnode) {
  return mount(vnode);
}
function hm(...args) {
  return mountDom(h(...args));
}
var memoizedPreloadJS = memoize((url) => {
  document.head.append(
    hm("link", {
      rel: "preload",
      as: "script",
      href: url
    })
  );
});
var jsCache = {};
async function loadJSItem(item, context) {
  var _a3;
  const src = item.type === "script" && ((_a3 = item.data) == null ? void 0 : _a3.src) || "";
  item.loaded || (item.loaded = jsCache[src]);
  if (!item.loaded) {
    const deferred = defer();
    item.loaded = deferred.promise;
    if (item.type === "script") {
      document.head.append(
        hm("script", {
          ...item.data,
          onLoad: () => deferred.resolve(),
          onError: deferred.reject
        })
      );
      if (!src) {
        deferred.resolve();
      } else {
        jsCache[src] = item.loaded;
      }
    }
    if (item.type === "iife") {
      const { fn, getParams } = item.data;
      fn(...(getParams == null ? void 0 : getParams(context)) || []);
      deferred.resolve();
    }
  }
  await item.loaded;
}
async function loadJS(items, context) {
  items.forEach((item) => {
    var _a3;
    if (item.type === "script" && ((_a3 = item.data) == null ? void 0 : _a3.src)) {
      memoizedPreloadJS(item.data.src);
    }
  });
  context = {
    getMarkmap: () => window.markmap,
    ...context
  };
  for (const item of items) {
    await loadJSItem(item, context);
  }
}
function buildJSItem(path) {
  return {
    type: "script",
    data: {
      src: path
    }
  };
}
function buildCSSItem(path) {
  return {
    type: "stylesheet",
    data: {
      href: path
    }
  };
}

// ../../node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/options.js
var defaultOpts = {
  xml: false,
  decodeEntities: true
};
var options_default = defaultOpts;
var xmlModeDefault = {
  _useHtmlParser2: true,
  xmlMode: true
};
function flatten2(options) {
  return (options === null || options === void 0 ? void 0 : options.xml) ? typeof options.xml === "boolean" ? xmlModeDefault : { ...xmlModeDefault, ...options.xml } : options !== null && options !== void 0 ? options : void 0;
}

// ../../node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/static.js
var static_exports = {};
__export(static_exports, {
  contains: () => contains,
  html: () => html,
  merge: () => merge,
  parseHTML: () => parseHTML,
  root: () => root,
  text: () => text,
  xml: () => xml
});

// ../../node_modules/.pnpm/domutils@3.2.2/node_modules/domutils/lib/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  DocumentPosition: () => DocumentPosition,
  append: () => append,
  appendChild: () => appendChild,
  compareDocumentPosition: () => compareDocumentPosition,
  existsOne: () => existsOne,
  filter: () => filter,
  find: () => find,
  findAll: () => findAll,
  findOne: () => findOne,
  findOneChild: () => findOneChild,
  getAttributeValue: () => getAttributeValue,
  getChildren: () => getChildren,
  getElementById: () => getElementById,
  getElements: () => getElements,
  getElementsByClassName: () => getElementsByClassName,
  getElementsByTagName: () => getElementsByTagName,
  getElementsByTagType: () => getElementsByTagType,
  getFeed: () => getFeed,
  getInnerHTML: () => getInnerHTML,
  getName: () => getName,
  getOuterHTML: () => getOuterHTML,
  getParent: () => getParent,
  getSiblings: () => getSiblings,
  getText: () => getText,
  hasAttrib: () => hasAttrib,
  hasChildren: () => hasChildren,
  innerText: () => innerText,
  isCDATA: () => isCDATA,
  isComment: () => isComment,
  isDocument: () => isDocument,
  isTag: () => isTag2,
  isText: () => isText,
  nextElementSibling: () => nextElementSibling,
  prepend: () => prepend,
  prependChild: () => prependChild,
  prevElementSibling: () => prevElementSibling,
  removeElement: () => removeElement,
  removeSubsets: () => removeSubsets,
  replaceElement: () => replaceElement,
  testElement: () => testElement,
  textContent: () => textContent,
  uniqueSort: () => uniqueSort
});

// ../../node_modules/.pnpm/domelementtype@2.3.0/node_modules/domelementtype/lib/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  CDATA: () => CDATA,
  Comment: () => Comment,
  Directive: () => Directive,
  Doctype: () => Doctype,
  ElementType: () => ElementType,
  Root: () => Root,
  Script: () => Script,
  Style: () => Style,
  Tag: () => Tag,
  Text: () => Text,
  isTag: () => isTag
});
var ElementType;
(function(ElementType2) {
  ElementType2["Root"] = "root";
  ElementType2["Text"] = "text";
  ElementType2["Directive"] = "directive";
  ElementType2["Comment"] = "comment";
  ElementType2["Script"] = "script";
  ElementType2["Style"] = "style";
  ElementType2["Tag"] = "tag";
  ElementType2["CDATA"] = "cdata";
  ElementType2["Doctype"] = "doctype";
})(ElementType || (ElementType = {}));
function isTag(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
var Root = ElementType.Root;
var Text = ElementType.Text;
var Directive = ElementType.Directive;
var Comment = ElementType.Comment;
var Script = ElementType.Script;
var Style = ElementType.Style;
var Tag = ElementType.Tag;
var CDATA = ElementType.CDATA;
var Doctype = ElementType.Doctype;

// ../../node_modules/.pnpm/domhandler@5.0.3/node_modules/domhandler/lib/esm/node.js
var Node2 = class {
  constructor() {
    this.parent = null;
    this.prev = null;
    this.next = null;
    this.startIndex = null;
    this.endIndex = null;
  }
  get parentNode() {
    return this.parent;
  }
  set parentNode(parent2) {
    this.parent = parent2;
  }
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(prev2) {
    this.prev = prev2;
  }
  get nextSibling() {
    return this.next;
  }
  set nextSibling(next2) {
    this.next = next2;
  }
  cloneNode(recursive = false) {
    return cloneNode(this, recursive);
  }
};
var DataNode = class extends Node2 {
  constructor(data2) {
    super();
    this.data = data2;
  }
  get nodeValue() {
    return this.data;
  }
  set nodeValue(data2) {
    this.data = data2;
  }
};
var Text2 = class extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Text;
  }
  get nodeType() {
    return 3;
  }
};
var Comment2 = class extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Comment;
  }
  get nodeType() {
    return 8;
  }
};
var ProcessingInstruction = class extends DataNode {
  constructor(name2, data2) {
    super(data2);
    this.name = name2;
    this.type = ElementType.Directive;
  }
  get nodeType() {
    return 1;
  }
};
var NodeWithChildren = class extends Node2 {
  constructor(children2) {
    super();
    this.children = children2;
  }
  get firstChild() {
    var _a3;
    return (_a3 = this.children[0]) !== null && _a3 !== void 0 ? _a3 : null;
  }
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  get childNodes() {
    return this.children;
  }
  set childNodes(children2) {
    this.children = children2;
  }
};
var CDATA2 = class extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.CDATA;
  }
  get nodeType() {
    return 4;
  }
};
var Document = class extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.Root;
  }
  get nodeType() {
    return 9;
  }
};
var Element = class extends NodeWithChildren {
  constructor(name2, attribs, children2 = [], type = name2 === "script" ? ElementType.Script : name2 === "style" ? ElementType.Style : ElementType.Tag) {
    super(children2);
    this.name = name2;
    this.attribs = attribs;
    this.type = type;
  }
  get nodeType() {
    return 1;
  }
  get tagName() {
    return this.name;
  }
  set tagName(name2) {
    this.name = name2;
  }
  get attributes() {
    return Object.keys(this.attribs).map((name2) => {
      var _a3, _b;
      return {
        name: name2,
        value: this.attribs[name2],
        namespace: (_a3 = this["x-attribsNamespace"]) === null || _a3 === void 0 ? void 0 : _a3[name2],
        prefix: (_b = this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name2]
      };
    });
  }
};
function isTag2(node) {
  return isTag(node);
}
function isCDATA(node) {
  return node.type === ElementType.CDATA;
}
function isText(node) {
  return node.type === ElementType.Text;
}
function isComment(node) {
  return node.type === ElementType.Comment;
}
function isDirective(node) {
  return node.type === ElementType.Directive;
}
function isDocument(node) {
  return node.type === ElementType.Root;
}
function hasChildren(node) {
  return Object.prototype.hasOwnProperty.call(node, "children");
}
function cloneNode(node, recursive = false) {
  let result;
  if (isText(node)) {
    result = new Text2(node.data);
  } else if (isComment(node)) {
    result = new Comment2(node.data);
  } else if (isTag2(node)) {
    const children2 = recursive ? cloneChildren(node.children) : [];
    const clone2 = new Element(node.name, { ...node.attribs }, children2);
    children2.forEach((child) => child.parent = clone2);
    if (node.namespace != null) {
      clone2.namespace = node.namespace;
    }
    if (node["x-attribsNamespace"]) {
      clone2["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
    }
    if (node["x-attribsPrefix"]) {
      clone2["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
    }
    result = clone2;
  } else if (isCDATA(node)) {
    const children2 = recursive ? cloneChildren(node.children) : [];
    const clone2 = new CDATA2(children2);
    children2.forEach((child) => child.parent = clone2);
    result = clone2;
  } else if (isDocument(node)) {
    const children2 = recursive ? cloneChildren(node.children) : [];
    const clone2 = new Document(children2);
    children2.forEach((child) => child.parent = clone2);
    if (node["x-mode"]) {
      clone2["x-mode"] = node["x-mode"];
    }
    result = clone2;
  } else if (isDirective(node)) {
    const instruction = new ProcessingInstruction(node.name, node.data);
    if (node["x-name"] != null) {
      instruction["x-name"] = node["x-name"];
      instruction["x-publicId"] = node["x-publicId"];
      instruction["x-systemId"] = node["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error(`Not implemented yet: ${node.type}`);
  }
  result.startIndex = node.startIndex;
  result.endIndex = node.endIndex;
  if (node.sourceCodeLocation != null) {
    result.sourceCodeLocation = node.sourceCodeLocation;
  }
  return result;
}
function cloneChildren(childs) {
  const children2 = childs.map((child) => cloneNode(child, true));
  for (let i = 1; i < children2.length; i++) {
    children2[i].prev = children2[i - 1];
    children2[i - 1].next = children2[i];
  }
  return children2;
}

// ../../node_modules/.pnpm/domhandler@5.0.3/node_modules/domhandler/lib/esm/index.js
var defaultOpts2 = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};
var DomHandler = class {
  constructor(callback, options, elementCB) {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts2;
    }
    if (typeof callback === "object") {
      options = callback;
      callback = void 0;
    }
    this.callback = callback !== null && callback !== void 0 ? callback : null;
    this.options = options !== null && options !== void 0 ? options : defaultOpts2;
    this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
  }
  onparserinit(parser) {
    this.parser = parser;
  }
  onreset() {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }
  onend() {
    if (this.done)
      return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  }
  onerror(error2) {
    this.handleCallback(error2);
  }
  onclosetag() {
    this.lastNode = null;
    const elem = this.tagStack.pop();
    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }
    if (this.elementCB)
      this.elementCB(elem);
  }
  onopentag(name2, attribs) {
    const type = this.options.xmlMode ? ElementType.Tag : void 0;
    const element = new Element(name2, attribs, void 0, type);
    this.addNode(element);
    this.tagStack.push(element);
  }
  ontext(data2) {
    const { lastNode } = this;
    if (lastNode && lastNode.type === ElementType.Text) {
      lastNode.data += data2;
      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      const node = new Text2(data2);
      this.addNode(node);
      this.lastNode = node;
    }
  }
  oncomment(data2) {
    if (this.lastNode && this.lastNode.type === ElementType.Comment) {
      this.lastNode.data += data2;
      return;
    }
    const node = new Comment2(data2);
    this.addNode(node);
    this.lastNode = node;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const text4 = new Text2("");
    const node = new CDATA2([text4]);
    this.addNode(node);
    text4.parent = node;
    this.lastNode = text4;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(name2, data2) {
    const node = new ProcessingInstruction(name2, data2);
    this.addNode(node);
  }
  handleCallback(error2) {
    if (typeof this.callback === "function") {
      this.callback(error2, this.dom);
    } else if (error2) {
      throw error2;
    }
  }
  addNode(node) {
    const parent2 = this.tagStack[this.tagStack.length - 1];
    const previousSibling = parent2.children[parent2.children.length - 1];
    if (this.options.withStartIndices) {
      node.startIndex = this.parser.startIndex;
    }
    if (this.options.withEndIndices) {
      node.endIndex = this.parser.endIndex;
    }
    parent2.children.push(node);
    if (previousSibling) {
      node.prev = previousSibling;
      previousSibling.next = node;
    }
    node.parent = parent2;
    this.lastNode = null;
  }
};

// ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array(
  '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c) => c.charCodeAt(0))
);

// ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array(
  "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c) => c.charCodeAt(0))
);

// ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/esm/decode_codepoint.js
var _a;
var decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
  let output = "";
  if (codePoint > 65535) {
    codePoint -= 65536;
    output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
    codePoint = 56320 | codePoint & 1023;
  }
  output += String.fromCharCode(codePoint);
  return output;
};
function replaceCodePoint(codePoint) {
  var _a3;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a3 = decodeMap.get(codePoint)) !== null && _a3 !== void 0 ? _a3 : codePoint;
}

// ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/esm/decode.js
var CharCodes;
(function(CharCodes4) {
  CharCodes4[CharCodes4["NUM"] = 35] = "NUM";
  CharCodes4[CharCodes4["SEMI"] = 59] = "SEMI";
  CharCodes4[CharCodes4["EQUALS"] = 61] = "EQUALS";
  CharCodes4[CharCodes4["ZERO"] = 48] = "ZERO";
  CharCodes4[CharCodes4["NINE"] = 57] = "NINE";
  CharCodes4[CharCodes4["LOWER_A"] = 97] = "LOWER_A";
  CharCodes4[CharCodes4["LOWER_F"] = 102] = "LOWER_F";
  CharCodes4[CharCodes4["LOWER_X"] = 120] = "LOWER_X";
  CharCodes4[CharCodes4["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes4[CharCodes4["UPPER_A"] = 65] = "UPPER_A";
  CharCodes4[CharCodes4["UPPER_F"] = 70] = "UPPER_F";
  CharCodes4[CharCodes4["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags3) {
  BinTrieFlags3[BinTrieFlags3["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags3[BinTrieFlags3["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags3[BinTrieFlags3["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code2) {
  return code2 >= CharCodes.ZERO && code2 <= CharCodes.NINE;
}
function isHexadecimalCharacter(code2) {
  return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_F || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code2) {
  return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_Z || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_Z || isNumber(code2);
}
function isEntityInAttributeInvalidEnd(code2) {
  return code2 === CharCodes.EQUALS || isAsciiAlphaNumeric(code2);
}
var EntityDecoderState;
(function(EntityDecoderState3) {
  EntityDecoderState3[EntityDecoderState3["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState3[EntityDecoderState3["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState3[EntityDecoderState3["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState3[EntityDecoderState3["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState3[EntityDecoderState3["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode3) {
  DecodingMode3[DecodingMode3["Legacy"] = 0] = "Legacy";
  DecodingMode3[DecodingMode3["Strict"] = 1] = "Strict";
  DecodingMode3[DecodingMode3["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
var EntityDecoder = class {
  constructor(decodeTree, emitCodePoint, errors2) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors2;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end2, base2) {
    if (start !== end2) {
      const digitCount = end2 - start;
      this.result = this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start, digitCount), base2);
      this.consumed += digitCount;
    }
  }
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  emitNumericEntity(lastCp, expectedLength) {
    var _a3;
    if (this.consumed <= expectedLength) {
      (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || this.decodeMode === DecodingMode.Attribute && (valueLength === 0 || isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  emitNotTerminatedNamedEntity() {
    var _a3;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  end() {
    var _a3;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
};
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(
        str,
        offset + 1
      );
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var htmlDecoder = getDecoder(decode_data_html_default);
var xmlDecoder = getDecoder(decode_data_xml_default);
function decodeHTML(str, mode = DecodingMode.Legacy) {
  return htmlDecoder(str, mode);
}

// ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/esm/generated/encode-html.js
function restoreDiff(arr) {
  for (let i = 1; i < arr.length; i++) {
    arr[i][0] += arr[i - 1][0] + 1;
  }
  return arr;
}
var encode_html_default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));

// ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/esm/escape.js
var xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
var xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = String.prototype.codePointAt != null ? (str, index2) => str.codePointAt(index2) : (c, index2) => (c.charCodeAt(index2) & 64512) === 55296 ? (c.charCodeAt(index2) - 55296) * 1024 + c.charCodeAt(index2 + 1) - 56320 + 65536 : c.charCodeAt(index2);
function encodeXML(str) {
  let ret = "";
  let lastIdx = 0;
  let match2;
  while ((match2 = xmlReplacer.exec(str)) !== null) {
    const i = match2.index;
    const char = str.charCodeAt(i);
    const next2 = xmlCodeMap.get(char);
    if (next2 !== void 0) {
      ret += str.substring(lastIdx, i) + next2;
      lastIdx = i + 1;
    } else {
      ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;
      lastIdx = xmlReplacer.lastIndex += Number((char & 64512) === 55296);
    }
  }
  return ret + str.substr(lastIdx);
}
function getEscaper(regex, map4) {
  return function escape3(data2) {
    let match2;
    let lastIdx = 0;
    let result = "";
    while (match2 = regex.exec(data2)) {
      if (lastIdx !== match2.index) {
        result += data2.substring(lastIdx, match2.index);
      }
      result += map4.get(match2[0].charCodeAt(0));
      lastIdx = match2.index + 1;
    }
    return result + data2.substring(lastIdx);
  };
}
var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));

// ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/esm/index.js
var EntityLevel;
(function(EntityLevel2) {
  EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
  EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var EncodingMode;
(function(EncodingMode2) {
  EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
  EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
  EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
  EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
  EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
})(EncodingMode || (EncodingMode = {}));

// ../../node_modules/.pnpm/dom-serializer@2.0.0/node_modules/dom-serializer/lib/esm/foreignNames.js
var elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((val2) => [val2.toLowerCase(), val2]));
var attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((val2) => [val2.toLowerCase(), val2]));

// ../../node_modules/.pnpm/dom-serializer@2.0.0/node_modules/dom-serializer/lib/esm/index.js
var unencodedElements = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes(attributes2, opts) {
  var _a3;
  if (!attributes2)
    return;
  const encode3 = ((_a3 = opts.encodeEntities) !== null && _a3 !== void 0 ? _a3 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
  return Object.keys(attributes2).map((key) => {
    var _a4, _b;
    const value = (_a4 = attributes2[key]) !== null && _a4 !== void 0 ? _a4 : "";
    if (opts.xmlMode === "foreign") {
      key = (_b = attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key;
    }
    return `${key}="${encode3(value)}"`;
  }).join(" ");
}
var singleTag = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render(node, options = {}) {
  const nodes = "length" in node ? node : [node];
  let output = "";
  for (let i = 0; i < nodes.length; i++) {
    output += renderNode(nodes[i], options);
  }
  return output;
}
var esm_default = render;
function renderNode(node, options) {
  switch (node.type) {
    case Root:
      return render(node.children, options);
    case Doctype:
    case Directive:
      return renderDirective(node);
    case Comment:
      return renderComment(node);
    case CDATA:
      return renderCdata(node);
    case Script:
    case Style:
    case Tag:
      return renderTag(node, options);
    case Text:
      return renderText(node, options);
  }
}
var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag(elem, opts) {
  var _a3;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a3 = elementNames.get(elem.name)) !== null && _a3 !== void 0 ? _a3 : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = { ...opts, xmlMode: false };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = { ...opts, xmlMode: "foreign" };
  }
  let tag = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag += ` ${attribs}`;
  }
  if (elem.children.length === 0 && (opts.xmlMode ? opts.selfClosingTags !== false : opts.selfClosingTags && singleTag.has(elem.name))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += `</${elem.name}>`;
    }
  }
  return tag;
}
function renderDirective(elem) {
  return `<${elem.data}>`;
}
function renderText(elem, opts) {
  var _a3;
  let data2 = elem.data || "";
  if (((_a3 = opts.encodeEntities) !== null && _a3 !== void 0 ? _a3 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data2 = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data2) : escapeText(data2);
  }
  return data2;
}
function renderCdata(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
  return `<!--${elem.data}-->`;
}

// ../../node_modules/.pnpm/domutils@3.2.2/node_modules/domutils/lib/esm/stringify.js
function getOuterHTML(node, options) {
  return esm_default(node, options);
}
function getInnerHTML(node, options) {
  return hasChildren(node) ? node.children.map((node2) => getOuterHTML(node2, options)).join("") : "";
}
function getText(node) {
  if (Array.isArray(node))
    return node.map(getText).join("");
  if (isTag2(node))
    return node.name === "br" ? "\n" : getText(node.children);
  if (isCDATA(node))
    return getText(node.children);
  if (isText(node))
    return node.data;
  return "";
}
function textContent(node) {
  if (Array.isArray(node))
    return node.map(textContent).join("");
  if (hasChildren(node) && !isComment(node)) {
    return textContent(node.children);
  }
  if (isText(node))
    return node.data;
  return "";
}
function innerText(node) {
  if (Array.isArray(node))
    return node.map(innerText).join("");
  if (hasChildren(node) && (node.type === ElementType.Tag || isCDATA(node))) {
    return innerText(node.children);
  }
  if (isText(node))
    return node.data;
  return "";
}

// ../../node_modules/.pnpm/domutils@3.2.2/node_modules/domutils/lib/esm/traversal.js
function getChildren(elem) {
  return hasChildren(elem) ? elem.children : [];
}
function getParent(elem) {
  return elem.parent || null;
}
function getSiblings(elem) {
  const parent2 = getParent(elem);
  if (parent2 != null)
    return getChildren(parent2);
  const siblings2 = [elem];
  let { prev: prev2, next: next2 } = elem;
  while (prev2 != null) {
    siblings2.unshift(prev2);
    ({ prev: prev2 } = prev2);
  }
  while (next2 != null) {
    siblings2.push(next2);
    ({ next: next2 } = next2);
  }
  return siblings2;
}
function getAttributeValue(elem, name2) {
  var _a3;
  return (_a3 = elem.attribs) === null || _a3 === void 0 ? void 0 : _a3[name2];
}
function hasAttrib(elem, name2) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name2) && elem.attribs[name2] != null;
}
function getName(elem) {
  return elem.name;
}
function nextElementSibling(elem) {
  let { next: next2 } = elem;
  while (next2 !== null && !isTag2(next2))
    ({ next: next2 } = next2);
  return next2;
}
function prevElementSibling(elem) {
  let { prev: prev2 } = elem;
  while (prev2 !== null && !isTag2(prev2))
    ({ prev: prev2 } = prev2);
  return prev2;
}

// ../../node_modules/.pnpm/domutils@3.2.2/node_modules/domutils/lib/esm/manipulation.js
function removeElement(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    const childs = elem.parent.children;
    const childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
function replaceElement(elem, replacement) {
  const prev2 = replacement.prev = elem.prev;
  if (prev2) {
    prev2.next = replacement;
  }
  const next2 = replacement.next = elem.next;
  if (next2) {
    next2.prev = replacement;
  }
  const parent2 = replacement.parent = elem.parent;
  if (parent2) {
    const childs = parent2.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
function appendChild(parent2, child) {
  removeElement(child);
  child.next = null;
  child.parent = parent2;
  if (parent2.children.push(child) > 1) {
    const sibling = parent2.children[parent2.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
function append(elem, next2) {
  removeElement(next2);
  const { parent: parent2 } = elem;
  const currNext = elem.next;
  next2.next = currNext;
  next2.prev = elem;
  elem.next = next2;
  next2.parent = parent2;
  if (currNext) {
    currNext.prev = next2;
    if (parent2) {
      const childs = parent2.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next2);
    }
  } else if (parent2) {
    parent2.children.push(next2);
  }
}
function prependChild(parent2, child) {
  removeElement(child);
  child.parent = parent2;
  child.prev = null;
  if (parent2.children.unshift(child) !== 1) {
    const sibling = parent2.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
function prepend(elem, prev2) {
  removeElement(prev2);
  const { parent: parent2 } = elem;
  if (parent2) {
    const childs = parent2.children;
    childs.splice(childs.indexOf(elem), 0, prev2);
  }
  if (elem.prev) {
    elem.prev.next = prev2;
  }
  prev2.parent = parent2;
  prev2.prev = elem.prev;
  prev2.next = elem;
  elem.prev = prev2;
}

// ../../node_modules/.pnpm/domutils@3.2.2/node_modules/domutils/lib/esm/querying.js
function filter(test2, node, recurse = true, limit = Infinity) {
  return find(test2, Array.isArray(node) ? node : [node], recurse, limit);
}
function find(test2, nodes, recurse, limit) {
  const result = [];
  const nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (indexStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (test2(elem)) {
      result.push(elem);
      if (--limit <= 0)
        return result;
    }
    if (recurse && hasChildren(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
function findOneChild(test2, nodes) {
  return nodes.find(test2);
}
function findOne(test2, nodes, recurse = true) {
  const searchedNodes = Array.isArray(nodes) ? nodes : [nodes];
  for (let i = 0; i < searchedNodes.length; i++) {
    const node = searchedNodes[i];
    if (isTag2(node) && test2(node)) {
      return node;
    }
    if (recurse && hasChildren(node) && node.children.length > 0) {
      const found = findOne(test2, node.children, true);
      if (found)
        return found;
    }
  }
  return null;
}
function existsOne(test2, nodes) {
  return (Array.isArray(nodes) ? nodes : [nodes]).some((node) => isTag2(node) && test2(node) || hasChildren(node) && existsOne(test2, node.children));
}
function findAll(test2, nodes) {
  const result = [];
  const nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (isTag2(elem) && test2(elem))
      result.push(elem);
    if (hasChildren(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}

// ../../node_modules/.pnpm/domutils@3.2.2/node_modules/domutils/lib/esm/legacy.js
var Checks = {
  tag_name(name2) {
    if (typeof name2 === "function") {
      return (elem) => isTag2(elem) && name2(elem.name);
    } else if (name2 === "*") {
      return isTag2;
    }
    return (elem) => isTag2(elem) && elem.name === name2;
  },
  tag_type(type) {
    if (typeof type === "function") {
      return (elem) => type(elem.type);
    }
    return (elem) => elem.type === type;
  },
  tag_contains(data2) {
    if (typeof data2 === "function") {
      return (elem) => isText(elem) && data2(elem.data);
    }
    return (elem) => isText(elem) && elem.data === data2;
  }
};
function getAttribCheck(attrib, value) {
  if (typeof value === "function") {
    return (elem) => isTag2(elem) && value(elem.attribs[attrib]);
  }
  return (elem) => isTag2(elem) && elem.attribs[attrib] === value;
}
function combineFuncs(a, b) {
  return (elem) => a(elem) || b(elem);
}
function compileTest(options) {
  const funcs = Object.keys(options).map((key) => {
    const value = options[key];
    return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
function testElement(options, node) {
  const test2 = compileTest(options);
  return test2 ? test2(node) : true;
}
function getElements(options, nodes, recurse, limit = Infinity) {
  const test2 = compileTest(options);
  return test2 ? filter(test2, nodes, recurse, limit) : [];
}
function getElementById(id, nodes, recurse = true) {
  if (!Array.isArray(nodes))
    nodes = [nodes];
  return findOne(getAttribCheck("id", id), nodes, recurse);
}
function getElementsByTagName(tagName, nodes, recurse = true, limit = Infinity) {
  return filter(Checks["tag_name"](tagName), nodes, recurse, limit);
}
function getElementsByClassName(className, nodes, recurse = true, limit = Infinity) {
  return filter(getAttribCheck("class", className), nodes, recurse, limit);
}
function getElementsByTagType(type, nodes, recurse = true, limit = Infinity) {
  return filter(Checks["tag_type"](type), nodes, recurse, limit);
}

// ../../node_modules/.pnpm/domutils@3.2.2/node_modules/domutils/lib/esm/helpers.js
function removeSubsets(nodes) {
  let idx = nodes.length;
  while (--idx >= 0) {
    const node = nodes[idx];
    if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
      nodes.splice(idx, 1);
      continue;
    }
    for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
      if (nodes.includes(ancestor)) {
        nodes.splice(idx, 1);
        break;
      }
    }
  }
  return nodes;
}
var DocumentPosition;
(function(DocumentPosition2) {
  DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
  DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
  DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
  DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
  DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition || (DocumentPosition = {}));
function compareDocumentPosition(nodeA, nodeB) {
  const aParents = [];
  const bParents = [];
  if (nodeA === nodeB) {
    return 0;
  }
  let current = hasChildren(nodeA) ? nodeA : nodeA.parent;
  while (current) {
    aParents.unshift(current);
    current = current.parent;
  }
  current = hasChildren(nodeB) ? nodeB : nodeB.parent;
  while (current) {
    bParents.unshift(current);
    current = current.parent;
  }
  const maxIdx = Math.min(aParents.length, bParents.length);
  let idx = 0;
  while (idx < maxIdx && aParents[idx] === bParents[idx]) {
    idx++;
  }
  if (idx === 0) {
    return DocumentPosition.DISCONNECTED;
  }
  const sharedParent = aParents[idx - 1];
  const siblings2 = sharedParent.children;
  const aSibling = aParents[idx];
  const bSibling = bParents[idx];
  if (siblings2.indexOf(aSibling) > siblings2.indexOf(bSibling)) {
    if (sharedParent === nodeB) {
      return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
    }
    return DocumentPosition.FOLLOWING;
  }
  if (sharedParent === nodeA) {
    return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
  }
  return DocumentPosition.PRECEDING;
}
function uniqueSort(nodes) {
  nodes = nodes.filter((node, i, arr) => !arr.includes(node, i + 1));
  nodes.sort((a, b) => {
    const relative = compareDocumentPosition(a, b);
    if (relative & DocumentPosition.PRECEDING) {
      return -1;
    } else if (relative & DocumentPosition.FOLLOWING) {
      return 1;
    }
    return 0;
  });
  return nodes;
}

// ../../node_modules/.pnpm/domutils@3.2.2/node_modules/domutils/lib/esm/feeds.js
function getFeed(doc) {
  const feedRoot = getOneElement(isValidFeed, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
}
function getAtomFeed(feedRoot) {
  var _a3;
  const childs = feedRoot.children;
  const feed = {
    type: "atom",
    items: getElementsByTagName("entry", childs).map((item) => {
      var _a4;
      const { children: children2 } = item;
      const entry = { media: getMediaElements(children2) };
      addConditionally(entry, "id", "id", children2);
      addConditionally(entry, "title", "title", children2);
      const href2 = (_a4 = getOneElement("link", children2)) === null || _a4 === void 0 ? void 0 : _a4.attribs["href"];
      if (href2) {
        entry.link = href2;
      }
      const description = fetch2("summary", children2) || fetch2("content", children2);
      if (description) {
        entry.description = description;
      }
      const pubDate = fetch2("updated", children2);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally(feed, "id", "id", childs);
  addConditionally(feed, "title", "title", childs);
  const href = (_a3 = getOneElement("link", childs)) === null || _a3 === void 0 ? void 0 : _a3.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally(feed, "description", "subtitle", childs);
  const updated = fetch2("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "email", childs, true);
  return feed;
}
function getRssFeed(feedRoot) {
  var _a3, _b;
  const childs = (_b = (_a3 = getOneElement("channel", feedRoot.children)) === null || _a3 === void 0 ? void 0 : _a3.children) !== null && _b !== void 0 ? _b : [];
  const feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: getElementsByTagName("item", feedRoot.children).map((item) => {
      const { children: children2 } = item;
      const entry = { media: getMediaElements(children2) };
      addConditionally(entry, "id", "guid", children2);
      addConditionally(entry, "title", "title", children2);
      addConditionally(entry, "link", "link", children2);
      addConditionally(entry, "description", "description", children2);
      const pubDate = fetch2("pubDate", children2) || fetch2("dc:date", children2);
      if (pubDate)
        entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally(feed, "title", "title", childs);
  addConditionally(feed, "link", "link", childs);
  addConditionally(feed, "description", "description", childs);
  const updated = fetch2("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "managingEditor", childs, true);
  return feed;
}
var MEDIA_KEYS_STRING = ["url", "type", "lang"];
var MEDIA_KEYS_INT = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function getMediaElements(where) {
  return getElementsByTagName("media:content", where).map((elem) => {
    const { attribs } = elem;
    const media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (const attrib of MEDIA_KEYS_STRING) {
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (const attrib of MEDIA_KEYS_INT) {
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
}
function getOneElement(tagName, node) {
  return getElementsByTagName(tagName, node, true, 1)[0];
}
function fetch2(tagName, where, recurse = false) {
  return textContent(getElementsByTagName(tagName, where, recurse, 1)).trim();
}
function addConditionally(obj, prop2, tagName, where, recurse = false) {
  const val2 = fetch2(tagName, where, recurse);
  if (val2)
    obj[prop2] = val2;
}
function isValidFeed(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}

// ../../node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/static.js
function render2(that, dom, options) {
  if (!that)
    return "";
  return that(dom !== null && dom !== void 0 ? dom : that._root.children, null, void 0, options).toString();
}
function isOptions(dom, options) {
  return !options && typeof dom === "object" && dom != null && !("length" in dom) && !("type" in dom);
}
function html(dom, options) {
  const toRender = isOptions(dom) ? (options = dom, void 0) : dom;
  const opts = {
    ...options_default,
    ...this === null || this === void 0 ? void 0 : this._options,
    ...flatten2(options !== null && options !== void 0 ? options : {})
  };
  return render2(this, toRender, opts);
}
function xml(dom) {
  const options = { ...this._options, xmlMode: true };
  return render2(this, dom, options);
}
function text(elements) {
  const elems = elements ? elements : this ? this.root() : [];
  let ret = "";
  for (let i = 0; i < elems.length; i++) {
    ret += textContent(elems[i]);
  }
  return ret;
}
function parseHTML(data2, context, keepScripts = typeof context === "boolean" ? context : false) {
  if (!data2 || typeof data2 !== "string") {
    return null;
  }
  if (typeof context === "boolean") {
    keepScripts = context;
  }
  const parsed = this.load(data2, options_default, false);
  if (!keepScripts) {
    parsed("script").remove();
  }
  return parsed.root()[0].children.slice();
}
function root() {
  return this(this._root);
}
function contains(container, contained) {
  if (contained === container) {
    return false;
  }
  let next2 = contained;
  while (next2 && next2 !== next2.parent) {
    next2 = next2.parent;
    if (next2 === container) {
      return true;
    }
  }
  return false;
}
function merge(arr1, arr2) {
  if (!isArrayLike(arr1) || !isArrayLike(arr2)) {
    return;
  }
  let newLength = arr1.length;
  const len = +arr2.length;
  for (let i = 0; i < len; i++) {
    arr1[newLength++] = arr2[i];
  }
  arr1.length = newLength;
  return arr1;
}
function isArrayLike(item) {
  if (Array.isArray(item)) {
    return true;
  }
  if (typeof item !== "object" || !Object.prototype.hasOwnProperty.call(item, "length") || typeof item.length !== "number" || item.length < 0) {
    return false;
  }
  for (let i = 0; i < item.length; i++) {
    if (!(i in item)) {
      return false;
    }
  }
  return true;
}

// ../../node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/api/attributes.js
var attributes_exports = {};
__export(attributes_exports, {
  addClass: () => addClass,
  attr: () => attr,
  data: () => data,
  hasClass: () => hasClass,
  prop: () => prop,
  removeAttr: () => removeAttr,
  removeClass: () => removeClass,
  toggleClass: () => toggleClass,
  val: () => val
});

// ../../node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/utils.js
function isCheerio(maybeCheerio) {
  return maybeCheerio.cheerio != null;
}
function camelCase(str) {
  return str.replace(/[_.-](\w|$)/g, (_, x) => x.toUpperCase());
}
function cssCase(str) {
  return str.replace(/[A-Z]/g, "-$&").toLowerCase();
}
function domEach(array, fn) {
  const len = array.length;
  for (let i = 0; i < len; i++)
    fn(array[i], i);
  return array;
}
function cloneDom(dom) {
  const clone2 = "length" in dom ? Array.prototype.map.call(dom, (el) => cloneNode(el, true)) : [cloneNode(dom, true)];
  const root3 = new Document(clone2);
  clone2.forEach((node) => {
    node.parent = root3;
  });
  return clone2;
}
var CharacterCodes;
(function(CharacterCodes2) {
  CharacterCodes2[CharacterCodes2["LowerA"] = 97] = "LowerA";
  CharacterCodes2[CharacterCodes2["LowerZ"] = 122] = "LowerZ";
  CharacterCodes2[CharacterCodes2["UpperA"] = 65] = "UpperA";
  CharacterCodes2[CharacterCodes2["UpperZ"] = 90] = "UpperZ";
  CharacterCodes2[CharacterCodes2["Exclamation"] = 33] = "Exclamation";
})(CharacterCodes || (CharacterCodes = {}));
function isHtml(str) {
  const tagStart = str.indexOf("<");
  if (tagStart < 0 || tagStart > str.length - 3)
    return false;
  const tagChar = str.charCodeAt(tagStart + 1);
  return (tagChar >= CharacterCodes.LowerA && tagChar <= CharacterCodes.LowerZ || tagChar >= CharacterCodes.UpperA && tagChar <= CharacterCodes.UpperZ || tagChar === CharacterCodes.Exclamation) && str.includes(">", tagStart + 2);
}

// ../../node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/api/attributes.js
var hasOwn = Object.prototype.hasOwnProperty;
var rspace = /\s+/;
var dataAttrPrefix = "data-";
var primitives = {
  null: null,
  true: true,
  false: false
};
var rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;
var rbrace = /^{[^]*}$|^\[[^]*]$/;
function getAttr(elem, name2, xmlMode) {
  var _a3;
  if (!elem || !isTag2(elem))
    return void 0;
  (_a3 = elem.attribs) !== null && _a3 !== void 0 ? _a3 : elem.attribs = {};
  if (!name2) {
    return elem.attribs;
  }
  if (hasOwn.call(elem.attribs, name2)) {
    return !xmlMode && rboolean.test(name2) ? name2 : elem.attribs[name2];
  }
  if (elem.name === "option" && name2 === "value") {
    return text(elem.children);
  }
  if (elem.name === "input" && (elem.attribs["type"] === "radio" || elem.attribs["type"] === "checkbox") && name2 === "value") {
    return "on";
  }
  return void 0;
}
function setAttr(el, name2, value) {
  if (value === null) {
    removeAttribute(el, name2);
  } else {
    el.attribs[name2] = `${value}`;
  }
}
function attr(name2, value) {
  if (typeof name2 === "object" || value !== void 0) {
    if (typeof value === "function") {
      if (typeof name2 !== "string") {
        {
          throw new Error("Bad combination of arguments.");
        }
      }
      return domEach(this, (el, i) => {
        if (isTag2(el))
          setAttr(el, name2, value.call(el, i, el.attribs[name2]));
      });
    }
    return domEach(this, (el) => {
      if (!isTag2(el))
        return;
      if (typeof name2 === "object") {
        Object.keys(name2).forEach((objName) => {
          const objValue = name2[objName];
          setAttr(el, objName, objValue);
        });
      } else {
        setAttr(el, name2, value);
      }
    });
  }
  return arguments.length > 1 ? this : getAttr(this[0], name2, this.options.xmlMode);
}
function getProp(el, name2, xmlMode) {
  return name2 in el ? el[name2] : !xmlMode && rboolean.test(name2) ? getAttr(el, name2, false) !== void 0 : getAttr(el, name2, xmlMode);
}
function setProp(el, name2, value, xmlMode) {
  if (name2 in el) {
    el[name2] = value;
  } else {
    setAttr(el, name2, !xmlMode && rboolean.test(name2) ? value ? "" : null : `${value}`);
  }
}
function prop(name2, value) {
  var _a3;
  if (typeof name2 === "string" && value === void 0) {
    const el = this[0];
    if (!el || !isTag2(el))
      return void 0;
    switch (name2) {
      case "style": {
        const property = this.css();
        const keys = Object.keys(property);
        keys.forEach((p, i) => {
          property[i] = p;
        });
        property.length = keys.length;
        return property;
      }
      case "tagName":
      case "nodeName": {
        return el.name.toUpperCase();
      }
      case "href":
      case "src": {
        const prop2 = (_a3 = el.attribs) === null || _a3 === void 0 ? void 0 : _a3[name2];
        if (typeof URL !== "undefined" && (name2 === "href" && (el.tagName === "a" || el.name === "link") || name2 === "src" && (el.tagName === "img" || el.tagName === "iframe" || el.tagName === "audio" || el.tagName === "video" || el.tagName === "source")) && prop2 !== void 0 && this.options.baseURI) {
          return new URL(prop2, this.options.baseURI).href;
        }
        return prop2;
      }
      case "innerText": {
        return innerText(el);
      }
      case "textContent": {
        return textContent(el);
      }
      case "outerHTML":
        return this.clone().wrap("<container />").parent().html();
      case "innerHTML":
        return this.html();
      default:
        return getProp(el, name2, this.options.xmlMode);
    }
  }
  if (typeof name2 === "object" || value !== void 0) {
    if (typeof value === "function") {
      if (typeof name2 === "object") {
        throw new Error("Bad combination of arguments.");
      }
      return domEach(this, (el, i) => {
        if (isTag2(el)) {
          setProp(el, name2, value.call(el, i, getProp(el, name2, this.options.xmlMode)), this.options.xmlMode);
        }
      });
    }
    return domEach(this, (el) => {
      if (!isTag2(el))
        return;
      if (typeof name2 === "object") {
        Object.keys(name2).forEach((key) => {
          const val2 = name2[key];
          setProp(el, key, val2, this.options.xmlMode);
        });
      } else {
        setProp(el, name2, value, this.options.xmlMode);
      }
    });
  }
  return void 0;
}
function setData(el, name2, value) {
  var _a3;
  const elem = el;
  (_a3 = elem.data) !== null && _a3 !== void 0 ? _a3 : elem.data = {};
  if (typeof name2 === "object")
    Object.assign(elem.data, name2);
  else if (typeof name2 === "string" && value !== void 0) {
    elem.data[name2] = value;
  }
}
function readData(el, name2) {
  let domNames;
  let jsNames;
  let value;
  if (name2 == null) {
    domNames = Object.keys(el.attribs).filter((attrName) => attrName.startsWith(dataAttrPrefix));
    jsNames = domNames.map((domName) => camelCase(domName.slice(dataAttrPrefix.length)));
  } else {
    domNames = [dataAttrPrefix + cssCase(name2)];
    jsNames = [name2];
  }
  for (let idx = 0; idx < domNames.length; ++idx) {
    const domName = domNames[idx];
    const jsName = jsNames[idx];
    if (hasOwn.call(el.attribs, domName) && !hasOwn.call(el.data, jsName)) {
      value = el.attribs[domName];
      if (hasOwn.call(primitives, value)) {
        value = primitives[value];
      } else if (value === String(Number(value))) {
        value = Number(value);
      } else if (rbrace.test(value)) {
        try {
          value = JSON.parse(value);
        } catch (e) {
        }
      }
      el.data[jsName] = value;
    }
  }
  return name2 == null ? el.data : value;
}
function data(name2, value) {
  var _a3;
  const elem = this[0];
  if (!elem || !isTag2(elem))
    return;
  const dataEl = elem;
  (_a3 = dataEl.data) !== null && _a3 !== void 0 ? _a3 : dataEl.data = {};
  if (!name2) {
    return readData(dataEl);
  }
  if (typeof name2 === "object" || value !== void 0) {
    domEach(this, (el) => {
      if (isTag2(el)) {
        if (typeof name2 === "object")
          setData(el, name2);
        else
          setData(el, name2, value);
      }
    });
    return this;
  }
  if (hasOwn.call(dataEl.data, name2)) {
    return dataEl.data[name2];
  }
  return readData(dataEl, name2);
}
function val(value) {
  const querying = arguments.length === 0;
  const element = this[0];
  if (!element || !isTag2(element))
    return querying ? void 0 : this;
  switch (element.name) {
    case "textarea":
      return this.text(value);
    case "select": {
      const option = this.find("option:selected");
      if (!querying) {
        if (this.attr("multiple") == null && typeof value === "object") {
          return this;
        }
        this.find("option").removeAttr("selected");
        const values = typeof value !== "object" ? [value] : value;
        for (let i = 0; i < values.length; i++) {
          this.find(`option[value="${values[i]}"]`).attr("selected", "");
        }
        return this;
      }
      return this.attr("multiple") ? option.toArray().map((el) => text(el.children)) : option.attr("value");
    }
    case "input":
    case "option":
      return querying ? this.attr("value") : this.attr("value", value);
  }
  return void 0;
}
function removeAttribute(elem, name2) {
  if (!elem.attribs || !hasOwn.call(elem.attribs, name2))
    return;
  delete elem.attribs[name2];
}
function splitNames(names) {
  return names ? names.trim().split(rspace) : [];
}
function removeAttr(name2) {
  const attrNames = splitNames(name2);
  for (let i = 0; i < attrNames.length; i++) {
    domEach(this, (elem) => {
      if (isTag2(elem))
        removeAttribute(elem, attrNames[i]);
    });
  }
  return this;
}
function hasClass(className) {
  return this.toArray().some((elem) => {
    const clazz = isTag2(elem) && elem.attribs["class"];
    let idx = -1;
    if (clazz && className.length) {
      while ((idx = clazz.indexOf(className, idx + 1)) > -1) {
        const end2 = idx + className.length;
        if ((idx === 0 || rspace.test(clazz[idx - 1])) && (end2 === clazz.length || rspace.test(clazz[end2]))) {
          return true;
        }
      }
    }
    return false;
  });
}
function addClass(value) {
  if (typeof value === "function") {
    return domEach(this, (el, i) => {
      if (isTag2(el)) {
        const className = el.attribs["class"] || "";
        addClass.call([el], value.call(el, i, className));
      }
    });
  }
  if (!value || typeof value !== "string")
    return this;
  const classNames = value.split(rspace);
  const numElements = this.length;
  for (let i = 0; i < numElements; i++) {
    const el = this[i];
    if (!isTag2(el))
      continue;
    const className = getAttr(el, "class", false);
    if (!className) {
      setAttr(el, "class", classNames.join(" ").trim());
    } else {
      let setClass = ` ${className} `;
      for (let j = 0; j < classNames.length; j++) {
        const appendClass = `${classNames[j]} `;
        if (!setClass.includes(` ${appendClass}`))
          setClass += appendClass;
      }
      setAttr(el, "class", setClass.trim());
    }
  }
  return this;
}
function removeClass(name2) {
  if (typeof name2 === "function") {
    return domEach(this, (el, i) => {
      if (isTag2(el)) {
        removeClass.call([el], name2.call(el, i, el.attribs["class"] || ""));
      }
    });
  }
  const classes = splitNames(name2);
  const numClasses = classes.length;
  const removeAll = arguments.length === 0;
  return domEach(this, (el) => {
    if (!isTag2(el))
      return;
    if (removeAll) {
      el.attribs["class"] = "";
    } else {
      const elClasses = splitNames(el.attribs["class"]);
      let changed = false;
      for (let j = 0; j < numClasses; j++) {
        const index2 = elClasses.indexOf(classes[j]);
        if (index2 >= 0) {
          elClasses.splice(index2, 1);
          changed = true;
          j--;
        }
      }
      if (changed) {
        el.attribs["class"] = elClasses.join(" ");
      }
    }
  });
}
function toggleClass(value, stateVal) {
  if (typeof value === "function") {
    return domEach(this, (el, i) => {
      if (isTag2(el)) {
        toggleClass.call([el], value.call(el, i, el.attribs["class"] || "", stateVal), stateVal);
      }
    });
  }
  if (!value || typeof value !== "string")
    return this;
  const classNames = value.split(rspace);
  const numClasses = classNames.length;
  const state = typeof stateVal === "boolean" ? stateVal ? 1 : -1 : 0;
  const numElements = this.length;
  for (let i = 0; i < numElements; i++) {
    const el = this[i];
    if (!isTag2(el))
      continue;
    const elementClasses = splitNames(el.attribs["class"]);
    for (let j = 0; j < numClasses; j++) {
      const index2 = elementClasses.indexOf(classNames[j]);
      if (state >= 0 && index2 < 0) {
        elementClasses.push(classNames[j]);
      } else if (state <= 0 && index2 >= 0) {
        elementClasses.splice(index2, 1);
      }
    }
    el.attribs["class"] = elementClasses.join(" ");
  }
  return this;
}

// ../../node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/api/traversing.js
var traversing_exports = {};
__export(traversing_exports, {
  add: () => add,
  addBack: () => addBack,
  children: () => children,
  closest: () => closest,
  contents: () => contents,
  each: () => each,
  end: () => end,
  eq: () => eq,
  filter: () => filter3,
  filterArray: () => filterArray,
  find: () => find3,
  first: () => first,
  get: () => get,
  has: () => has,
  index: () => index,
  is: () => is3,
  last: () => last,
  map: () => map,
  next: () => next,
  nextAll: () => nextAll,
  nextUntil: () => nextUntil,
  not: () => not,
  parent: () => parent,
  parents: () => parents,
  parentsUntil: () => parentsUntil,
  prev: () => prev,
  prevAll: () => prevAll,
  prevUntil: () => prevUntil,
  siblings: () => siblings,
  slice: () => slice,
  toArray: () => toArray
});

// ../../node_modules/.pnpm/css-what@6.1.0/node_modules/css-what/lib/es/types.js
var SelectorType;
(function(SelectorType2) {
  SelectorType2["Attribute"] = "attribute";
  SelectorType2["Pseudo"] = "pseudo";
  SelectorType2["PseudoElement"] = "pseudo-element";
  SelectorType2["Tag"] = "tag";
  SelectorType2["Universal"] = "universal";
  SelectorType2["Adjacent"] = "adjacent";
  SelectorType2["Child"] = "child";
  SelectorType2["Descendant"] = "descendant";
  SelectorType2["Parent"] = "parent";
  SelectorType2["Sibling"] = "sibling";
  SelectorType2["ColumnCombinator"] = "column-combinator";
})(SelectorType || (SelectorType = {}));
var AttributeAction;
(function(AttributeAction2) {
  AttributeAction2["Any"] = "any";
  AttributeAction2["Element"] = "element";
  AttributeAction2["End"] = "end";
  AttributeAction2["Equals"] = "equals";
  AttributeAction2["Exists"] = "exists";
  AttributeAction2["Hyphen"] = "hyphen";
  AttributeAction2["Not"] = "not";
  AttributeAction2["Start"] = "start";
})(AttributeAction || (AttributeAction = {}));

// ../../node_modules/.pnpm/css-what@6.1.0/node_modules/css-what/lib/es/parse.js
var reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
var actionTypes = /* @__PURE__ */ new Map([
  [126, AttributeAction.Element],
  [94, AttributeAction.Start],
  [36, AttributeAction.End],
  [42, AttributeAction.Any],
  [33, AttributeAction.Not],
  [124, AttributeAction.Hyphen]
]);
var unpackPseudos = /* @__PURE__ */ new Set([
  "has",
  "not",
  "matches",
  "is",
  "where",
  "host",
  "host-context"
]);
function isTraversal(selector) {
  switch (selector.type) {
    case SelectorType.Adjacent:
    case SelectorType.Child:
    case SelectorType.Descendant:
    case SelectorType.Parent:
    case SelectorType.Sibling:
    case SelectorType.ColumnCombinator:
      return true;
    default:
      return false;
  }
}
var stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
function funescape(_, escaped, escapedWhitespace) {
  const high = parseInt(escaped, 16) - 65536;
  return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
}
function unescapeCSS(str) {
  return str.replace(reEscape, funescape);
}
function isQuote(c) {
  return c === 39 || c === 34;
}
function isWhitespace(c) {
  return c === 32 || c === 9 || c === 10 || c === 12 || c === 13;
}
function parse(selector) {
  const subselects2 = [];
  const endIndex = parseSelector(subselects2, `${selector}`, 0);
  if (endIndex < selector.length) {
    throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
  }
  return subselects2;
}
function parseSelector(subselects2, selector, selectorIndex) {
  let tokens = [];
  function getName2(offset) {
    const match2 = selector.slice(selectorIndex + offset).match(reName);
    if (!match2) {
      throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
    }
    const [name2] = match2;
    selectorIndex += offset + name2.length;
    return unescapeCSS(name2);
  }
  function stripWhitespace(offset) {
    selectorIndex += offset;
    while (selectorIndex < selector.length && isWhitespace(selector.charCodeAt(selectorIndex))) {
      selectorIndex++;
    }
  }
  function readValueWithParenthesis() {
    selectorIndex += 1;
    const start = selectorIndex;
    let counter = 1;
    for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
      if (selector.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
        counter++;
      } else if (selector.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
        counter--;
      }
    }
    if (counter) {
      throw new Error("Parenthesis not matched");
    }
    return unescapeCSS(selector.slice(start, selectorIndex - 1));
  }
  function isEscaped(pos) {
    let slashCount = 0;
    while (selector.charCodeAt(--pos) === 92)
      slashCount++;
    return (slashCount & 1) === 1;
  }
  function ensureNotTraversal() {
    if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
      throw new Error("Did not expect successive traversals.");
    }
  }
  function addTraversal(type) {
    if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens[tokens.length - 1].type = type;
      return;
    }
    ensureNotTraversal();
    tokens.push({ type });
  }
  function addSpecialAttribute(name2, action) {
    tokens.push({
      type: SelectorType.Attribute,
      name: name2,
      action,
      value: getName2(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function finalizeSubselector() {
    if (tokens.length && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens.pop();
    }
    if (tokens.length === 0) {
      throw new Error("Empty sub-selector");
    }
    subselects2.push(tokens);
  }
  stripWhitespace(0);
  if (selector.length === selectorIndex) {
    return selectorIndex;
  }
  loop:
    while (selectorIndex < selector.length) {
      const firstChar = selector.charCodeAt(selectorIndex);
      switch (firstChar) {
        case 32:
        case 9:
        case 10:
        case 12:
        case 13: {
          if (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) {
            ensureNotTraversal();
            tokens.push({ type: SelectorType.Descendant });
          }
          stripWhitespace(1);
          break;
        }
        case 62: {
          addTraversal(SelectorType.Child);
          stripWhitespace(1);
          break;
        }
        case 60: {
          addTraversal(SelectorType.Parent);
          stripWhitespace(1);
          break;
        }
        case 126: {
          addTraversal(SelectorType.Sibling);
          stripWhitespace(1);
          break;
        }
        case 43: {
          addTraversal(SelectorType.Adjacent);
          stripWhitespace(1);
          break;
        }
        case 46: {
          addSpecialAttribute("class", AttributeAction.Element);
          break;
        }
        case 35: {
          addSpecialAttribute("id", AttributeAction.Equals);
          break;
        }
        case 91: {
          stripWhitespace(1);
          let name2;
          let namespace = null;
          if (selector.charCodeAt(selectorIndex) === 124) {
            name2 = getName2(1);
          } else if (selector.startsWith("*|", selectorIndex)) {
            namespace = "*";
            name2 = getName2(2);
          } else {
            name2 = getName2(0);
            if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 61) {
              namespace = name2;
              name2 = getName2(1);
            }
          }
          stripWhitespace(0);
          let action = AttributeAction.Exists;
          const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
          if (possibleAction) {
            action = possibleAction;
            if (selector.charCodeAt(selectorIndex + 1) !== 61) {
              throw new Error("Expected `=`");
            }
            stripWhitespace(2);
          } else if (selector.charCodeAt(selectorIndex) === 61) {
            action = AttributeAction.Equals;
            stripWhitespace(1);
          }
          let value = "";
          let ignoreCase = null;
          if (action !== "exists") {
            if (isQuote(selector.charCodeAt(selectorIndex))) {
              const quote = selector.charCodeAt(selectorIndex);
              let sectionEnd = selectorIndex + 1;
              while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
                sectionEnd += 1;
              }
              if (selector.charCodeAt(sectionEnd) !== quote) {
                throw new Error("Attribute value didn't end");
              }
              value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
              selectorIndex = sectionEnd + 1;
            } else {
              const valueStart = selectorIndex;
              while (selectorIndex < selector.length && (!isWhitespace(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
                selectorIndex += 1;
              }
              value = unescapeCSS(selector.slice(valueStart, selectorIndex));
            }
            stripWhitespace(0);
            const forceIgnore = selector.charCodeAt(selectorIndex) | 32;
            if (forceIgnore === 115) {
              ignoreCase = false;
              stripWhitespace(1);
            } else if (forceIgnore === 105) {
              ignoreCase = true;
              stripWhitespace(1);
            }
          }
          if (selector.charCodeAt(selectorIndex) !== 93) {
            throw new Error("Attribute selector didn't terminate");
          }
          selectorIndex += 1;
          const attributeSelector = {
            type: SelectorType.Attribute,
            name: name2,
            action,
            value,
            namespace,
            ignoreCase
          };
          tokens.push(attributeSelector);
          break;
        }
        case 58: {
          if (selector.charCodeAt(selectorIndex + 1) === 58) {
            tokens.push({
              type: SelectorType.PseudoElement,
              name: getName2(2).toLowerCase(),
              data: selector.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
            });
            continue;
          }
          const name2 = getName2(1).toLowerCase();
          let data2 = null;
          if (selector.charCodeAt(selectorIndex) === 40) {
            if (unpackPseudos.has(name2)) {
              if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                throw new Error(`Pseudo-selector ${name2} cannot be quoted`);
              }
              data2 = [];
              selectorIndex = parseSelector(data2, selector, selectorIndex + 1);
              if (selector.charCodeAt(selectorIndex) !== 41) {
                throw new Error(`Missing closing parenthesis in :${name2} (${selector})`);
              }
              selectorIndex += 1;
            } else {
              data2 = readValueWithParenthesis();
              if (stripQuotesFromPseudos.has(name2)) {
                const quot = data2.charCodeAt(0);
                if (quot === data2.charCodeAt(data2.length - 1) && isQuote(quot)) {
                  data2 = data2.slice(1, -1);
                }
              }
              data2 = unescapeCSS(data2);
            }
          }
          tokens.push({ type: SelectorType.Pseudo, name: name2, data: data2 });
          break;
        }
        case 44: {
          finalizeSubselector();
          tokens = [];
          stripWhitespace(1);
          break;
        }
        default: {
          if (selector.startsWith("/*", selectorIndex)) {
            const endIndex = selector.indexOf("*/", selectorIndex + 2);
            if (endIndex < 0) {
              throw new Error("Comment was not terminated");
            }
            selectorIndex = endIndex + 2;
            if (tokens.length === 0) {
              stripWhitespace(0);
            }
            break;
          }
          let namespace = null;
          let name2;
          if (firstChar === 42) {
            selectorIndex += 1;
            name2 = "*";
          } else if (firstChar === 124) {
            name2 = "";
            if (selector.charCodeAt(selectorIndex + 1) === 124) {
              addTraversal(SelectorType.ColumnCombinator);
              stripWhitespace(2);
              break;
            }
          } else if (reName.test(selector.slice(selectorIndex))) {
            name2 = getName2(0);
          } else {
            break loop;
          }
          if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 124) {
            namespace = name2;
            if (selector.charCodeAt(selectorIndex + 1) === 42) {
              name2 = "*";
              selectorIndex += 2;
            } else {
              name2 = getName2(1);
            }
          }
          tokens.push(name2 === "*" ? { type: SelectorType.Universal, namespace } : { type: SelectorType.Tag, name: name2, namespace });
        }
      }
    }
  finalizeSubselector();
  return selectorIndex;
}

// ../../node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/index.js
var import_boolbase6 = __toESM(require_boolbase(), 1);

// ../../node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/compile.js
var import_boolbase5 = __toESM(require_boolbase(), 1);

// ../../node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/sort.js
var procedure = /* @__PURE__ */ new Map([
  [SelectorType.Universal, 50],
  [SelectorType.Tag, 30],
  [SelectorType.Attribute, 1],
  [SelectorType.Pseudo, 0]
]);
function isTraversal2(token) {
  return !procedure.has(token.type);
}
var attributes = /* @__PURE__ */ new Map([
  [AttributeAction.Exists, 10],
  [AttributeAction.Equals, 8],
  [AttributeAction.Not, 7],
  [AttributeAction.Start, 6],
  [AttributeAction.End, 6],
  [AttributeAction.Any, 5]
]);
function sortByProcedure(arr) {
  const procs = arr.map(getProcedure);
  for (let i = 1; i < arr.length; i++) {
    const procNew = procs[i];
    if (procNew < 0)
      continue;
    for (let j = i - 1; j >= 0 && procNew < procs[j]; j--) {
      const token = arr[j + 1];
      arr[j + 1] = arr[j];
      arr[j] = token;
      procs[j + 1] = procs[j];
      procs[j] = procNew;
    }
  }
}
function getProcedure(token) {
  var _a3, _b;
  let proc = (_a3 = procedure.get(token.type)) !== null && _a3 !== void 0 ? _a3 : -1;
  if (token.type === SelectorType.Attribute) {
    proc = (_b = attributes.get(token.action)) !== null && _b !== void 0 ? _b : 4;
    if (token.action === AttributeAction.Equals && token.name === "id") {
      proc = 9;
    }
    if (token.ignoreCase) {
      proc >>= 1;
    }
  } else if (token.type === SelectorType.Pseudo) {
    if (!token.data) {
      proc = 3;
    } else if (token.name === "has" || token.name === "contains") {
      proc = 0;
    } else if (Array.isArray(token.data)) {
      proc = Math.min(...token.data.map((d) => Math.min(...d.map(getProcedure))));
      if (proc < 0) {
        proc = 0;
      }
    } else {
      proc = 2;
    }
  }
  return proc;
}

// ../../node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/attributes.js
var import_boolbase = __toESM(require_boolbase(), 1);
var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
function escapeRegex(value) {
  return value.replace(reChars, "\\$&");
}
var caseInsensitiveAttributes = /* @__PURE__ */ new Set([
  "accept",
  "accept-charset",
  "align",
  "alink",
  "axis",
  "bgcolor",
  "charset",
  "checked",
  "clear",
  "codetype",
  "color",
  "compact",
  "declare",
  "defer",
  "dir",
  "direction",
  "disabled",
  "enctype",
  "face",
  "frame",
  "hreflang",
  "http-equiv",
  "lang",
  "language",
  "link",
  "media",
  "method",
  "multiple",
  "nohref",
  "noresize",
  "noshade",
  "nowrap",
  "readonly",
  "rel",
  "rev",
  "rules",
  "scope",
  "scrolling",
  "selected",
  "shape",
  "target",
  "text",
  "type",
  "valign",
  "valuetype",
  "vlink"
]);
function shouldIgnoreCase(selector, options) {
  return typeof selector.ignoreCase === "boolean" ? selector.ignoreCase : selector.ignoreCase === "quirks" ? !!options.quirksMode : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
}
var attributeRules = {
  equals(next2, data2, options) {
    const { adapter: adapter2 } = options;
    const { name: name2 } = data2;
    let { value } = data2;
    if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr2 = adapter2.getAttributeValue(elem, name2);
        return attr2 != null && attr2.length === value.length && attr2.toLowerCase() === value && next2(elem);
      };
    }
    return (elem) => adapter2.getAttributeValue(elem, name2) === value && next2(elem);
  },
  hyphen(next2, data2, options) {
    const { adapter: adapter2 } = options;
    const { name: name2 } = data2;
    let { value } = data2;
    const len = value.length;
    if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return function hyphenIC(elem) {
        const attr2 = adapter2.getAttributeValue(elem, name2);
        return attr2 != null && (attr2.length === len || attr2.charAt(len) === "-") && attr2.substr(0, len).toLowerCase() === value && next2(elem);
      };
    }
    return function hyphen(elem) {
      const attr2 = adapter2.getAttributeValue(elem, name2);
      return attr2 != null && (attr2.length === len || attr2.charAt(len) === "-") && attr2.substr(0, len) === value && next2(elem);
    };
  },
  element(next2, data2, options) {
    const { adapter: adapter2 } = options;
    const { name: name2, value } = data2;
    if (/\s/.test(value)) {
      return import_boolbase.default.falseFunc;
    }
    const regex = new RegExp(`(?:^|\\s)${escapeRegex(value)}(?:$|\\s)`, shouldIgnoreCase(data2, options) ? "i" : "");
    return function element(elem) {
      const attr2 = adapter2.getAttributeValue(elem, name2);
      return attr2 != null && attr2.length >= value.length && regex.test(attr2) && next2(elem);
    };
  },
  exists(next2, { name: name2 }, { adapter: adapter2 }) {
    return (elem) => adapter2.hasAttrib(elem, name2) && next2(elem);
  },
  start(next2, data2, options) {
    const { adapter: adapter2 } = options;
    const { name: name2 } = data2;
    let { value } = data2;
    const len = value.length;
    if (len === 0) {
      return import_boolbase.default.falseFunc;
    }
    if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr2 = adapter2.getAttributeValue(elem, name2);
        return attr2 != null && attr2.length >= len && attr2.substr(0, len).toLowerCase() === value && next2(elem);
      };
    }
    return (elem) => {
      var _a3;
      return !!((_a3 = adapter2.getAttributeValue(elem, name2)) === null || _a3 === void 0 ? void 0 : _a3.startsWith(value)) && next2(elem);
    };
  },
  end(next2, data2, options) {
    const { adapter: adapter2 } = options;
    const { name: name2 } = data2;
    let { value } = data2;
    const len = -value.length;
    if (len === 0) {
      return import_boolbase.default.falseFunc;
    }
    if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return (elem) => {
        var _a3;
        return ((_a3 = adapter2.getAttributeValue(elem, name2)) === null || _a3 === void 0 ? void 0 : _a3.substr(len).toLowerCase()) === value && next2(elem);
      };
    }
    return (elem) => {
      var _a3;
      return !!((_a3 = adapter2.getAttributeValue(elem, name2)) === null || _a3 === void 0 ? void 0 : _a3.endsWith(value)) && next2(elem);
    };
  },
  any(next2, data2, options) {
    const { adapter: adapter2 } = options;
    const { name: name2, value } = data2;
    if (value === "") {
      return import_boolbase.default.falseFunc;
    }
    if (shouldIgnoreCase(data2, options)) {
      const regex = new RegExp(escapeRegex(value), "i");
      return function anyIC(elem) {
        const attr2 = adapter2.getAttributeValue(elem, name2);
        return attr2 != null && attr2.length >= value.length && regex.test(attr2) && next2(elem);
      };
    }
    return (elem) => {
      var _a3;
      return !!((_a3 = adapter2.getAttributeValue(elem, name2)) === null || _a3 === void 0 ? void 0 : _a3.includes(value)) && next2(elem);
    };
  },
  not(next2, data2, options) {
    const { adapter: adapter2 } = options;
    const { name: name2 } = data2;
    let { value } = data2;
    if (value === "") {
      return (elem) => !!adapter2.getAttributeValue(elem, name2) && next2(elem);
    } else if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr2 = adapter2.getAttributeValue(elem, name2);
        return (attr2 == null || attr2.length !== value.length || attr2.toLowerCase() !== value) && next2(elem);
      };
    }
    return (elem) => adapter2.getAttributeValue(elem, name2) !== value && next2(elem);
  }
};

// ../../node_modules/.pnpm/nth-check@2.1.1/node_modules/nth-check/lib/esm/parse.js
var whitespace = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
var ZERO = "0".charCodeAt(0);
var NINE = "9".charCodeAt(0);
function parse2(formula) {
  formula = formula.trim().toLowerCase();
  if (formula === "even") {
    return [2, 0];
  } else if (formula === "odd") {
    return [2, 1];
  }
  let idx = 0;
  let a = 0;
  let sign = readSign();
  let number = readNumber();
  if (idx < formula.length && formula.charAt(idx) === "n") {
    idx++;
    a = sign * (number !== null && number !== void 0 ? number : 1);
    skipWhitespace();
    if (idx < formula.length) {
      sign = readSign();
      skipWhitespace();
      number = readNumber();
    } else {
      sign = number = 0;
    }
  }
  if (number === null || idx < formula.length) {
    throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
  }
  return [a, sign * number];
  function readSign() {
    if (formula.charAt(idx) === "-") {
      idx++;
      return -1;
    }
    if (formula.charAt(idx) === "+") {
      idx++;
    }
    return 1;
  }
  function readNumber() {
    const start = idx;
    let value = 0;
    while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
      value = value * 10 + (formula.charCodeAt(idx) - ZERO);
      idx++;
    }
    return idx === start ? null : value;
  }
  function skipWhitespace() {
    while (idx < formula.length && whitespace.has(formula.charCodeAt(idx))) {
      idx++;
    }
  }
}

// ../../node_modules/.pnpm/nth-check@2.1.1/node_modules/nth-check/lib/esm/compile.js
var import_boolbase2 = __toESM(require_boolbase(), 1);
function compile(parsed) {
  const a = parsed[0];
  const b = parsed[1] - 1;
  if (b < 0 && a <= 0)
    return import_boolbase2.default.falseFunc;
  if (a === -1)
    return (index2) => index2 <= b;
  if (a === 0)
    return (index2) => index2 === b;
  if (a === 1)
    return b < 0 ? import_boolbase2.default.trueFunc : (index2) => index2 >= b;
  const absA = Math.abs(a);
  const bMod = (b % absA + absA) % absA;
  return a > 1 ? (index2) => index2 >= b && index2 % absA === bMod : (index2) => index2 <= b && index2 % absA === bMod;
}

// ../../node_modules/.pnpm/nth-check@2.1.1/node_modules/nth-check/lib/esm/index.js
function nthCheck(formula) {
  return compile(parse2(formula));
}

// ../../node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/pseudo-selectors/filters.js
var import_boolbase3 = __toESM(require_boolbase(), 1);
function getChildFunc(next2, adapter2) {
  return (elem) => {
    const parent2 = adapter2.getParent(elem);
    return parent2 != null && adapter2.isTag(parent2) && next2(elem);
  };
}
var filters = {
  contains(next2, text4, { adapter: adapter2 }) {
    return function contains3(elem) {
      return next2(elem) && adapter2.getText(elem).includes(text4);
    };
  },
  icontains(next2, text4, { adapter: adapter2 }) {
    const itext = text4.toLowerCase();
    return function icontains(elem) {
      return next2(elem) && adapter2.getText(elem).toLowerCase().includes(itext);
    };
  },
  "nth-child"(next2, rule, { adapter: adapter2, equals }) {
    const func = nthCheck(rule);
    if (func === import_boolbase3.default.falseFunc)
      return import_boolbase3.default.falseFunc;
    if (func === import_boolbase3.default.trueFunc)
      return getChildFunc(next2, adapter2);
    return function nthChild(elem) {
      const siblings2 = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i = 0; i < siblings2.length; i++) {
        if (equals(elem, siblings2[i]))
          break;
        if (adapter2.isTag(siblings2[i])) {
          pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  "nth-last-child"(next2, rule, { adapter: adapter2, equals }) {
    const func = nthCheck(rule);
    if (func === import_boolbase3.default.falseFunc)
      return import_boolbase3.default.falseFunc;
    if (func === import_boolbase3.default.trueFunc)
      return getChildFunc(next2, adapter2);
    return function nthLastChild(elem) {
      const siblings2 = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i = siblings2.length - 1; i >= 0; i--) {
        if (equals(elem, siblings2[i]))
          break;
        if (adapter2.isTag(siblings2[i])) {
          pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  "nth-of-type"(next2, rule, { adapter: adapter2, equals }) {
    const func = nthCheck(rule);
    if (func === import_boolbase3.default.falseFunc)
      return import_boolbase3.default.falseFunc;
    if (func === import_boolbase3.default.trueFunc)
      return getChildFunc(next2, adapter2);
    return function nthOfType(elem) {
      const siblings2 = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i = 0; i < siblings2.length; i++) {
        const currentSibling = siblings2[i];
        if (equals(elem, currentSibling))
          break;
        if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === adapter2.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  "nth-last-of-type"(next2, rule, { adapter: adapter2, equals }) {
    const func = nthCheck(rule);
    if (func === import_boolbase3.default.falseFunc)
      return import_boolbase3.default.falseFunc;
    if (func === import_boolbase3.default.trueFunc)
      return getChildFunc(next2, adapter2);
    return function nthLastOfType(elem) {
      const siblings2 = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i = siblings2.length - 1; i >= 0; i--) {
        const currentSibling = siblings2[i];
        if (equals(elem, currentSibling))
          break;
        if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === adapter2.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  root(next2, _rule, { adapter: adapter2 }) {
    return (elem) => {
      const parent2 = adapter2.getParent(elem);
      return (parent2 == null || !adapter2.isTag(parent2)) && next2(elem);
    };
  },
  scope(next2, rule, options, context) {
    const { equals } = options;
    if (!context || context.length === 0) {
      return filters["root"](next2, rule, options);
    }
    if (context.length === 1) {
      return (elem) => equals(context[0], elem) && next2(elem);
    }
    return (elem) => context.includes(elem) && next2(elem);
  },
  hover: dynamicStatePseudo("isHovered"),
  visited: dynamicStatePseudo("isVisited"),
  active: dynamicStatePseudo("isActive")
};
function dynamicStatePseudo(name2) {
  return function dynamicPseudo(next2, _rule, { adapter: adapter2 }) {
    const func = adapter2[name2];
    if (typeof func !== "function") {
      return import_boolbase3.default.falseFunc;
    }
    return function active(elem) {
      return func(elem) && next2(elem);
    };
  };
}

// ../../node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/pseudo-selectors/pseudos.js
var pseudos = {
  empty(elem, { adapter: adapter2 }) {
    return !adapter2.getChildren(elem).some((elem2) => adapter2.isTag(elem2) || adapter2.getText(elem2) !== "");
  },
  "first-child"(elem, { adapter: adapter2, equals }) {
    if (adapter2.prevElementSibling) {
      return adapter2.prevElementSibling(elem) == null;
    }
    const firstChild = adapter2.getSiblings(elem).find((elem2) => adapter2.isTag(elem2));
    return firstChild != null && equals(elem, firstChild);
  },
  "last-child"(elem, { adapter: adapter2, equals }) {
    const siblings2 = adapter2.getSiblings(elem);
    for (let i = siblings2.length - 1; i >= 0; i--) {
      if (equals(elem, siblings2[i]))
        return true;
      if (adapter2.isTag(siblings2[i]))
        break;
    }
    return false;
  },
  "first-of-type"(elem, { adapter: adapter2, equals }) {
    const siblings2 = adapter2.getSiblings(elem);
    const elemName = adapter2.getName(elem);
    for (let i = 0; i < siblings2.length; i++) {
      const currentSibling = siblings2[i];
      if (equals(elem, currentSibling))
        return true;
      if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "last-of-type"(elem, { adapter: adapter2, equals }) {
    const siblings2 = adapter2.getSiblings(elem);
    const elemName = adapter2.getName(elem);
    for (let i = siblings2.length - 1; i >= 0; i--) {
      const currentSibling = siblings2[i];
      if (equals(elem, currentSibling))
        return true;
      if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "only-of-type"(elem, { adapter: adapter2, equals }) {
    const elemName = adapter2.getName(elem);
    return adapter2.getSiblings(elem).every((sibling) => equals(elem, sibling) || !adapter2.isTag(sibling) || adapter2.getName(sibling) !== elemName);
  },
  "only-child"(elem, { adapter: adapter2, equals }) {
    return adapter2.getSiblings(elem).every((sibling) => equals(elem, sibling) || !adapter2.isTag(sibling));
  }
};
function verifyPseudoArgs(func, name2, subselect, argIndex) {
  if (subselect === null) {
    if (func.length > argIndex) {
      throw new Error(`Pseudo-class :${name2} requires an argument`);
    }
  } else if (func.length === argIndex) {
    throw new Error(`Pseudo-class :${name2} doesn't have any arguments`);
  }
}

// ../../node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/pseudo-selectors/aliases.js
var aliases = {
  "any-link": ":is(a, area, link)[href]",
  link: ":any-link:not(:visited)",
  disabled: `:is(
        :is(button, input, select, textarea, optgroup, option)[disabled],
        optgroup[disabled] > option,
        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)
    )`,
  enabled: ":not(:disabled)",
  checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
  required: ":is(input, select, textarea)[required]",
  optional: ":is(input, select, textarea):not([required])",
  selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
  checkbox: "[type=checkbox]",
  file: "[type=file]",
  password: "[type=password]",
  radio: "[type=radio]",
  reset: "[type=reset]",
  image: "[type=image]",
  submit: "[type=submit]",
  parent: ":not(:empty)",
  header: ":is(h1, h2, h3, h4, h5, h6)",
  button: ":is(button, input[type=button])",
  input: ":is(input, textarea, select, button)",
  text: "input:is(:not([type!='']), [type=text])"
};

// ../../node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/pseudo-selectors/subselects.js
var import_boolbase4 = __toESM(require_boolbase(), 1);
var PLACEHOLDER_ELEMENT = {};
function ensureIsTag(next2, adapter2) {
  if (next2 === import_boolbase4.default.falseFunc)
    return import_boolbase4.default.falseFunc;
  return (elem) => adapter2.isTag(elem) && next2(elem);
}
function getNextSiblings(elem, adapter2) {
  const siblings2 = adapter2.getSiblings(elem);
  if (siblings2.length <= 1)
    return [];
  const elemIndex = siblings2.indexOf(elem);
  if (elemIndex < 0 || elemIndex === siblings2.length - 1)
    return [];
  return siblings2.slice(elemIndex + 1).filter(adapter2.isTag);
}
function copyOptions(options) {
  return {
    xmlMode: !!options.xmlMode,
    lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
    lowerCaseTags: !!options.lowerCaseTags,
    quirksMode: !!options.quirksMode,
    cacheResults: !!options.cacheResults,
    pseudos: options.pseudos,
    adapter: options.adapter,
    equals: options.equals
  };
}
var is = (next2, token, options, context, compileToken2) => {
  const func = compileToken2(token, copyOptions(options), context);
  return func === import_boolbase4.default.trueFunc ? next2 : func === import_boolbase4.default.falseFunc ? import_boolbase4.default.falseFunc : (elem) => func(elem) && next2(elem);
};
var subselects = {
  is,
  matches: is,
  where: is,
  not(next2, token, options, context, compileToken2) {
    const func = compileToken2(token, copyOptions(options), context);
    return func === import_boolbase4.default.falseFunc ? next2 : func === import_boolbase4.default.trueFunc ? import_boolbase4.default.falseFunc : (elem) => !func(elem) && next2(elem);
  },
  has(next2, subselect, options, _context, compileToken2) {
    const { adapter: adapter2 } = options;
    const opts = copyOptions(options);
    opts.relativeSelector = true;
    const context = subselect.some((s) => s.some(isTraversal2)) ? [PLACEHOLDER_ELEMENT] : void 0;
    const compiled = compileToken2(subselect, opts, context);
    if (compiled === import_boolbase4.default.falseFunc)
      return import_boolbase4.default.falseFunc;
    const hasElement = ensureIsTag(compiled, adapter2);
    if (context && compiled !== import_boolbase4.default.trueFunc) {
      const { shouldTestNextSiblings = false } = compiled;
      return (elem) => {
        if (!next2(elem))
          return false;
        context[0] = elem;
        const childs = adapter2.getChildren(elem);
        const nextElements = shouldTestNextSiblings ? [...childs, ...getNextSiblings(elem, adapter2)] : childs;
        return adapter2.existsOne(hasElement, nextElements);
      };
    }
    return (elem) => next2(elem) && adapter2.existsOne(hasElement, adapter2.getChildren(elem));
  }
};

// ../../node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/pseudo-selectors/index.js
function compilePseudoSelector(next2, selector, options, context, compileToken2) {
  var _a3;
  const { name: name2, data: data2 } = selector;
  if (Array.isArray(data2)) {
    if (!(name2 in subselects)) {
      throw new Error(`Unknown pseudo-class :${name2}(${data2})`);
    }
    return subselects[name2](next2, data2, options, context, compileToken2);
  }
  const userPseudo = (_a3 = options.pseudos) === null || _a3 === void 0 ? void 0 : _a3[name2];
  const stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases[name2];
  if (typeof stringPseudo === "string") {
    if (data2 != null) {
      throw new Error(`Pseudo ${name2} doesn't have any arguments`);
    }
    const alias = parse(stringPseudo);
    return subselects["is"](next2, alias, options, context, compileToken2);
  }
  if (typeof userPseudo === "function") {
    verifyPseudoArgs(userPseudo, name2, data2, 1);
    return (elem) => userPseudo(elem, data2) && next2(elem);
  }
  if (name2 in filters) {
    return filters[name2](next2, data2, options, context);
  }
  if (name2 in pseudos) {
    const pseudo = pseudos[name2];
    verifyPseudoArgs(pseudo, name2, data2, 2);
    return (elem) => pseudo(elem, options, data2) && next2(elem);
  }
  throw new Error(`Unknown pseudo-class :${name2}`);
}

// ../../node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/general.js
function getElementParent(node, adapter2) {
  const parent2 = adapter2.getParent(node);
  if (parent2 && adapter2.isTag(parent2)) {
    return parent2;
  }
  return null;
}
function compileGeneralSelector(next2, selector, options, context, compileToken2) {
  const { adapter: adapter2, equals } = options;
  switch (selector.type) {
    case SelectorType.PseudoElement: {
      throw new Error("Pseudo-elements are not supported by css-select");
    }
    case SelectorType.ColumnCombinator: {
      throw new Error("Column combinators are not yet supported by css-select");
    }
    case SelectorType.Attribute: {
      if (selector.namespace != null) {
        throw new Error("Namespaced attributes are not yet supported by css-select");
      }
      if (!options.xmlMode || options.lowerCaseAttributeNames) {
        selector.name = selector.name.toLowerCase();
      }
      return attributeRules[selector.action](next2, selector, options);
    }
    case SelectorType.Pseudo: {
      return compilePseudoSelector(next2, selector, options, context, compileToken2);
    }
    case SelectorType.Tag: {
      if (selector.namespace != null) {
        throw new Error("Namespaced tag names are not yet supported by css-select");
      }
      let { name: name2 } = selector;
      if (!options.xmlMode || options.lowerCaseTags) {
        name2 = name2.toLowerCase();
      }
      return function tag(elem) {
        return adapter2.getName(elem) === name2 && next2(elem);
      };
    }
    case SelectorType.Descendant: {
      if (options.cacheResults === false || typeof WeakSet === "undefined") {
        return function descendant(elem) {
          let current = elem;
          while (current = getElementParent(current, adapter2)) {
            if (next2(current)) {
              return true;
            }
          }
          return false;
        };
      }
      const isFalseCache = /* @__PURE__ */ new WeakSet();
      return function cachedDescendant(elem) {
        let current = elem;
        while (current = getElementParent(current, adapter2)) {
          if (!isFalseCache.has(current)) {
            if (adapter2.isTag(current) && next2(current)) {
              return true;
            }
            isFalseCache.add(current);
          }
        }
        return false;
      };
    }
    case "_flexibleDescendant": {
      return function flexibleDescendant(elem) {
        let current = elem;
        do {
          if (next2(current))
            return true;
        } while (current = getElementParent(current, adapter2));
        return false;
      };
    }
    case SelectorType.Parent: {
      return function parent2(elem) {
        return adapter2.getChildren(elem).some((elem2) => adapter2.isTag(elem2) && next2(elem2));
      };
    }
    case SelectorType.Child: {
      return function child(elem) {
        const parent2 = adapter2.getParent(elem);
        return parent2 != null && adapter2.isTag(parent2) && next2(parent2);
      };
    }
    case SelectorType.Sibling: {
      return function sibling(elem) {
        const siblings2 = adapter2.getSiblings(elem);
        for (let i = 0; i < siblings2.length; i++) {
          const currentSibling = siblings2[i];
          if (equals(elem, currentSibling))
            break;
          if (adapter2.isTag(currentSibling) && next2(currentSibling)) {
            return true;
          }
        }
        return false;
      };
    }
    case SelectorType.Adjacent: {
      if (adapter2.prevElementSibling) {
        return function adjacent(elem) {
          const previous = adapter2.prevElementSibling(elem);
          return previous != null && next2(previous);
        };
      }
      return function adjacent(elem) {
        const siblings2 = adapter2.getSiblings(elem);
        let lastElement;
        for (let i = 0; i < siblings2.length; i++) {
          const currentSibling = siblings2[i];
          if (equals(elem, currentSibling))
            break;
          if (adapter2.isTag(currentSibling)) {
            lastElement = currentSibling;
          }
        }
        return !!lastElement && next2(lastElement);
      };
    }
    case SelectorType.Universal: {
      if (selector.namespace != null && selector.namespace !== "*") {
        throw new Error("Namespaced universal selectors are not yet supported by css-select");
      }
      return next2;
    }
  }
}

// ../../node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/compile.js
function compile2(selector, options, context) {
  const next2 = compileUnsafe(selector, options, context);
  return ensureIsTag(next2, options.adapter);
}
function compileUnsafe(selector, options, context) {
  const token = typeof selector === "string" ? parse(selector) : selector;
  return compileToken(token, options, context);
}
function includesScopePseudo(t2) {
  return t2.type === SelectorType.Pseudo && (t2.name === "scope" || Array.isArray(t2.data) && t2.data.some((data2) => data2.some(includesScopePseudo)));
}
var DESCENDANT_TOKEN = { type: SelectorType.Descendant };
var FLEXIBLE_DESCENDANT_TOKEN = {
  type: "_flexibleDescendant"
};
var SCOPE_TOKEN = {
  type: SelectorType.Pseudo,
  name: "scope",
  data: null
};
function absolutize(token, { adapter: adapter2 }, context) {
  const hasContext = !!(context === null || context === void 0 ? void 0 : context.every((e) => {
    const parent2 = adapter2.isTag(e) && adapter2.getParent(e);
    return e === PLACEHOLDER_ELEMENT || parent2 && adapter2.isTag(parent2);
  }));
  for (const t2 of token) {
    if (t2.length > 0 && isTraversal2(t2[0]) && t2[0].type !== SelectorType.Descendant) {
    } else if (hasContext && !t2.some(includesScopePseudo)) {
      t2.unshift(DESCENDANT_TOKEN);
    } else {
      continue;
    }
    t2.unshift(SCOPE_TOKEN);
  }
}
function compileToken(token, options, context) {
  var _a3;
  token.forEach(sortByProcedure);
  context = (_a3 = options.context) !== null && _a3 !== void 0 ? _a3 : context;
  const isArrayContext = Array.isArray(context);
  const finalContext = context && (Array.isArray(context) ? context : [context]);
  if (options.relativeSelector !== false) {
    absolutize(token, options, finalContext);
  } else if (token.some((t2) => t2.length > 0 && isTraversal2(t2[0]))) {
    throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
  }
  let shouldTestNextSiblings = false;
  const query = token.map((rules) => {
    if (rules.length >= 2) {
      const [first2, second] = rules;
      if (first2.type !== SelectorType.Pseudo || first2.name !== "scope") {
      } else if (isArrayContext && second.type === SelectorType.Descendant) {
        rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
      } else if (second.type === SelectorType.Adjacent || second.type === SelectorType.Sibling) {
        shouldTestNextSiblings = true;
      }
    }
    return compileRules(rules, options, finalContext);
  }).reduce(reduceRules, import_boolbase5.default.falseFunc);
  query.shouldTestNextSiblings = shouldTestNextSiblings;
  return query;
}
function compileRules(rules, options, context) {
  var _a3;
  return rules.reduce((previous, rule) => previous === import_boolbase5.default.falseFunc ? import_boolbase5.default.falseFunc : compileGeneralSelector(previous, rule, options, context, compileToken), (_a3 = options.rootFunc) !== null && _a3 !== void 0 ? _a3 : import_boolbase5.default.trueFunc);
}
function reduceRules(a, b) {
  if (b === import_boolbase5.default.falseFunc || a === import_boolbase5.default.trueFunc) {
    return a;
  }
  if (a === import_boolbase5.default.falseFunc || b === import_boolbase5.default.trueFunc) {
    return b;
  }
  return function combine(elem) {
    return a(elem) || b(elem);
  };
}

// ../../node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/index.js
var defaultEquals = (a, b) => a === b;
var defaultOptions = {
  adapter: esm_exports2,
  equals: defaultEquals
};
function convertOptionFormats(options) {
  var _a3, _b, _c, _d;
  const opts = options !== null && options !== void 0 ? options : defaultOptions;
  (_a3 = opts.adapter) !== null && _a3 !== void 0 ? _a3 : opts.adapter = esm_exports2;
  (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;
  return opts;
}
function wrapCompile(func) {
  return function addAdapter(selector, options, context) {
    const opts = convertOptionFormats(options);
    return func(selector, opts, context);
  };
}
var compile3 = wrapCompile(compile2);
var _compileUnsafe = wrapCompile(compileUnsafe);
var _compileToken = wrapCompile(compileToken);
function getSelectorFunc(searchFunc) {
  return function select2(query, elements, options) {
    const opts = convertOptionFormats(options);
    if (typeof query !== "function") {
      query = compileUnsafe(query, opts, elements);
    }
    const filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
    return searchFunc(query, filteredElements, opts);
  };
}
function prepareContext(elems, adapter2, shouldTestNextSiblings = false) {
  if (shouldTestNextSiblings) {
    elems = appendNextSiblings(elems, adapter2);
  }
  return Array.isArray(elems) ? adapter2.removeSubsets(elems) : adapter2.getChildren(elems);
}
function appendNextSiblings(elem, adapter2) {
  const elems = Array.isArray(elem) ? elem.slice(0) : [elem];
  const elemsLength = elems.length;
  for (let i = 0; i < elemsLength; i++) {
    const nextSiblings = getNextSiblings(elems[i], adapter2);
    elems.push(...nextSiblings);
  }
  return elems;
}
var selectAll = getSelectorFunc((query, elems, options) => query === import_boolbase6.default.falseFunc || !elems || elems.length === 0 ? [] : options.adapter.findAll(query, elems));
var selectOne = getSelectorFunc((query, elems, options) => query === import_boolbase6.default.falseFunc || !elems || elems.length === 0 ? null : options.adapter.findOne(query, elems));

// ../../node_modules/.pnpm/cheerio-select@2.1.0/node_modules/cheerio-select/lib/esm/index.js
var boolbase7 = __toESM(require_boolbase(), 1);

// ../../node_modules/.pnpm/cheerio-select@2.1.0/node_modules/cheerio-select/lib/esm/positionals.js
var filterNames = /* @__PURE__ */ new Set([
  "first",
  "last",
  "eq",
  "gt",
  "nth",
  "lt",
  "even",
  "odd"
]);
function isFilter(s) {
  if (s.type !== "pseudo")
    return false;
  if (filterNames.has(s.name))
    return true;
  if (s.name === "not" && Array.isArray(s.data)) {
    return s.data.some((s2) => s2.some(isFilter));
  }
  return false;
}
function getLimit(filter4, data2, partLimit) {
  const num = data2 != null ? parseInt(data2, 10) : NaN;
  switch (filter4) {
    case "first":
      return 1;
    case "nth":
    case "eq":
      return isFinite(num) ? num >= 0 ? num + 1 : Infinity : 0;
    case "lt":
      return isFinite(num) ? num >= 0 ? Math.min(num, partLimit) : Infinity : 0;
    case "gt":
      return isFinite(num) ? Infinity : 0;
    case "odd":
      return 2 * partLimit;
    case "even":
      return 2 * partLimit - 1;
    case "last":
    case "not":
      return Infinity;
  }
}

// ../../node_modules/.pnpm/cheerio-select@2.1.0/node_modules/cheerio-select/lib/esm/helpers.js
function getDocumentRoot(node) {
  while (node.parent)
    node = node.parent;
  return node;
}
function groupSelectors(selectors) {
  const filteredSelectors = [];
  const plainSelectors = [];
  for (const selector of selectors) {
    if (selector.some(isFilter)) {
      filteredSelectors.push(selector);
    } else {
      plainSelectors.push(selector);
    }
  }
  return [plainSelectors, filteredSelectors];
}

// ../../node_modules/.pnpm/cheerio-select@2.1.0/node_modules/cheerio-select/lib/esm/index.js
var UNIVERSAL_SELECTOR = {
  type: SelectorType.Universal,
  namespace: null
};
var SCOPE_PSEUDO = {
  type: SelectorType.Pseudo,
  name: "scope",
  data: null
};
function is2(element, selector, options = {}) {
  return some([element], selector, options);
}
function some(elements, selector, options = {}) {
  if (typeof selector === "function")
    return elements.some(selector);
  const [plain, filtered] = groupSelectors(parse(selector));
  return plain.length > 0 && elements.some(_compileToken(plain, options)) || filtered.some((sel) => filterBySelector(sel, elements, options).length > 0);
}
function filterByPosition(filter4, elems, data2, options) {
  const num = typeof data2 === "string" ? parseInt(data2, 10) : NaN;
  switch (filter4) {
    case "first":
    case "lt":
      return elems;
    case "last":
      return elems.length > 0 ? [elems[elems.length - 1]] : elems;
    case "nth":
    case "eq":
      return isFinite(num) && Math.abs(num) < elems.length ? [num < 0 ? elems[elems.length + num] : elems[num]] : [];
    case "gt":
      return isFinite(num) ? elems.slice(num + 1) : [];
    case "even":
      return elems.filter((_, i) => i % 2 === 0);
    case "odd":
      return elems.filter((_, i) => i % 2 === 1);
    case "not": {
      const filtered = new Set(filterParsed(data2, elems, options));
      return elems.filter((e) => !filtered.has(e));
    }
  }
}
function filter2(selector, elements, options = {}) {
  return filterParsed(parse(selector), elements, options);
}
function filterParsed(selector, elements, options) {
  if (elements.length === 0)
    return [];
  const [plainSelectors, filteredSelectors] = groupSelectors(selector);
  let found;
  if (plainSelectors.length) {
    const filtered = filterElements(elements, plainSelectors, options);
    if (filteredSelectors.length === 0) {
      return filtered;
    }
    if (filtered.length) {
      found = new Set(filtered);
    }
  }
  for (let i = 0; i < filteredSelectors.length && (found === null || found === void 0 ? void 0 : found.size) !== elements.length; i++) {
    const filteredSelector = filteredSelectors[i];
    const missing = found ? elements.filter((e) => isTag2(e) && !found.has(e)) : elements;
    if (missing.length === 0)
      break;
    const filtered = filterBySelector(filteredSelector, elements, options);
    if (filtered.length) {
      if (!found) {
        if (i === filteredSelectors.length - 1) {
          return filtered;
        }
        found = new Set(filtered);
      } else {
        filtered.forEach((el) => found.add(el));
      }
    }
  }
  return typeof found !== "undefined" ? found.size === elements.length ? elements : elements.filter((el) => found.has(el)) : [];
}
function filterBySelector(selector, elements, options) {
  var _a3;
  if (selector.some(isTraversal)) {
    const root3 = (_a3 = options.root) !== null && _a3 !== void 0 ? _a3 : getDocumentRoot(elements[0]);
    const opts = { ...options, context: elements, relativeSelector: false };
    selector.push(SCOPE_PSEUDO);
    return findFilterElements(root3, selector, opts, true, elements.length);
  }
  return findFilterElements(elements, selector, options, false, elements.length);
}
function select(selector, root3, options = {}, limit = Infinity) {
  if (typeof selector === "function") {
    return find2(root3, selector);
  }
  const [plain, filtered] = groupSelectors(parse(selector));
  const results = filtered.map((sel) => findFilterElements(root3, sel, options, true, limit));
  if (plain.length) {
    results.push(findElements(root3, plain, options, limit));
  }
  if (results.length === 0) {
    return [];
  }
  if (results.length === 1) {
    return results[0];
  }
  return uniqueSort(results.reduce((a, b) => [...a, ...b]));
}
function findFilterElements(root3, selector, options, queryForSelector, totalLimit) {
  const filterIndex = selector.findIndex(isFilter);
  const sub = selector.slice(0, filterIndex);
  const filter4 = selector[filterIndex];
  const partLimit = selector.length - 1 === filterIndex ? totalLimit : Infinity;
  const limit = getLimit(filter4.name, filter4.data, partLimit);
  if (limit === 0)
    return [];
  const elemsNoLimit = sub.length === 0 && !Array.isArray(root3) ? getChildren(root3).filter(isTag2) : sub.length === 0 ? (Array.isArray(root3) ? root3 : [root3]).filter(isTag2) : queryForSelector || sub.some(isTraversal) ? findElements(root3, [sub], options, limit) : filterElements(root3, [sub], options);
  const elems = elemsNoLimit.slice(0, limit);
  let result = filterByPosition(filter4.name, elems, filter4.data, options);
  if (result.length === 0 || selector.length === filterIndex + 1) {
    return result;
  }
  const remainingSelector = selector.slice(filterIndex + 1);
  const remainingHasTraversal = remainingSelector.some(isTraversal);
  if (remainingHasTraversal) {
    if (isTraversal(remainingSelector[0])) {
      const { type } = remainingSelector[0];
      if (type === SelectorType.Sibling || type === SelectorType.Adjacent) {
        result = prepareContext(result, esm_exports2, true);
      }
      remainingSelector.unshift(UNIVERSAL_SELECTOR);
    }
    options = {
      ...options,
      relativeSelector: false,
      rootFunc: (el) => result.includes(el)
    };
  } else if (options.rootFunc && options.rootFunc !== boolbase7.trueFunc) {
    options = { ...options, rootFunc: boolbase7.trueFunc };
  }
  return remainingSelector.some(isFilter) ? findFilterElements(result, remainingSelector, options, false, totalLimit) : remainingHasTraversal ? findElements(result, [remainingSelector], options, totalLimit) : filterElements(result, [remainingSelector], options);
}
function findElements(root3, sel, options, limit) {
  const query = _compileToken(sel, options, root3);
  return find2(root3, query, limit);
}
function find2(root3, query, limit = Infinity) {
  const elems = prepareContext(root3, esm_exports2, query.shouldTestNextSiblings);
  return find((node) => isTag2(node) && query(node), elems, true, limit);
}
function filterElements(elements, sel, options) {
  const els = (Array.isArray(elements) ? elements : [elements]).filter(isTag2);
  if (els.length === 0)
    return els;
  const query = _compileToken(sel, options);
  return query === boolbase7.trueFunc ? els : els.filter(query);
}

// ../../node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/api/traversing.js
var reSiblingSelector = /^\s*[~+]/;
function find3(selectorOrHaystack) {
  var _a3;
  if (!selectorOrHaystack) {
    return this._make([]);
  }
  const context = this.toArray();
  if (typeof selectorOrHaystack !== "string") {
    const haystack = isCheerio(selectorOrHaystack) ? selectorOrHaystack.toArray() : [selectorOrHaystack];
    return this._make(haystack.filter((elem) => context.some((node) => contains(node, elem))));
  }
  const elems = reSiblingSelector.test(selectorOrHaystack) ? context : this.children().toArray();
  const options = {
    context,
    root: (_a3 = this._root) === null || _a3 === void 0 ? void 0 : _a3[0],
    xmlMode: this.options.xmlMode,
    lowerCaseTags: this.options.lowerCaseTags,
    lowerCaseAttributeNames: this.options.lowerCaseAttributeNames,
    pseudos: this.options.pseudos,
    quirksMode: this.options.quirksMode
  };
  return this._make(select(selectorOrHaystack, elems, options));
}
function _getMatcher(matchMap) {
  return function(fn, ...postFns) {
    return function(selector) {
      var _a3;
      let matched = matchMap(fn, this);
      if (selector) {
        matched = filterArray(matched, selector, this.options.xmlMode, (_a3 = this._root) === null || _a3 === void 0 ? void 0 : _a3[0]);
      }
      return this._make(
        this.length > 1 && matched.length > 1 ? postFns.reduce((elems, fn2) => fn2(elems), matched) : matched
      );
    };
  };
}
var _matcher = _getMatcher((fn, elems) => {
  const ret = [];
  for (let i = 0; i < elems.length; i++) {
    const value = fn(elems[i]);
    ret.push(value);
  }
  return new Array().concat(...ret);
});
var _singleMatcher = _getMatcher((fn, elems) => {
  const ret = [];
  for (let i = 0; i < elems.length; i++) {
    const value = fn(elems[i]);
    if (value !== null) {
      ret.push(value);
    }
  }
  return ret;
});
function _matchUntil(nextElem, ...postFns) {
  let matches = null;
  const innerMatcher = _getMatcher((nextElem2, elems) => {
    const matched = [];
    domEach(elems, (elem) => {
      for (let next2; next2 = nextElem2(elem); elem = next2) {
        if (matches === null || matches === void 0 ? void 0 : matches(next2, matched.length))
          break;
        matched.push(next2);
      }
    });
    return matched;
  })(nextElem, ...postFns);
  return function(selector, filterSelector) {
    matches = typeof selector === "string" ? (elem) => is2(elem, selector, this.options) : selector ? getFilterFn(selector) : null;
    const ret = innerMatcher.call(this, filterSelector);
    matches = null;
    return ret;
  };
}
function _removeDuplicates(elems) {
  return Array.from(new Set(elems));
}
var parent = _singleMatcher(({ parent: parent2 }) => parent2 && !isDocument(parent2) ? parent2 : null, _removeDuplicates);
var parents = _matcher((elem) => {
  const matched = [];
  while (elem.parent && !isDocument(elem.parent)) {
    matched.push(elem.parent);
    elem = elem.parent;
  }
  return matched;
}, uniqueSort, (elems) => elems.reverse());
var parentsUntil = _matchUntil(({ parent: parent2 }) => parent2 && !isDocument(parent2) ? parent2 : null, uniqueSort, (elems) => elems.reverse());
function closest(selector) {
  var _a3;
  const set3 = [];
  if (!selector) {
    return this._make(set3);
  }
  const selectOpts = {
    xmlMode: this.options.xmlMode,
    root: (_a3 = this._root) === null || _a3 === void 0 ? void 0 : _a3[0]
  };
  const selectFn = typeof selector === "string" ? (elem) => is2(elem, selector, selectOpts) : getFilterFn(selector);
  domEach(this, (elem) => {
    while (elem && isTag2(elem)) {
      if (selectFn(elem, 0)) {
        if (!set3.includes(elem)) {
          set3.push(elem);
        }
        break;
      }
      elem = elem.parent;
    }
  });
  return this._make(set3);
}
var next = _singleMatcher((elem) => nextElementSibling(elem));
var nextAll = _matcher((elem) => {
  const matched = [];
  while (elem.next) {
    elem = elem.next;
    if (isTag2(elem))
      matched.push(elem);
  }
  return matched;
}, _removeDuplicates);
var nextUntil = _matchUntil((el) => nextElementSibling(el), _removeDuplicates);
var prev = _singleMatcher((elem) => prevElementSibling(elem));
var prevAll = _matcher((elem) => {
  const matched = [];
  while (elem.prev) {
    elem = elem.prev;
    if (isTag2(elem))
      matched.push(elem);
  }
  return matched;
}, _removeDuplicates);
var prevUntil = _matchUntil((el) => prevElementSibling(el), _removeDuplicates);
var siblings = _matcher((elem) => getSiblings(elem).filter((el) => isTag2(el) && el !== elem), uniqueSort);
var children = _matcher((elem) => getChildren(elem).filter(isTag2), _removeDuplicates);
function contents() {
  const elems = this.toArray().reduce((newElems, elem) => hasChildren(elem) ? newElems.concat(elem.children) : newElems, []);
  return this._make(elems);
}
function each(fn) {
  let i = 0;
  const len = this.length;
  while (i < len && fn.call(this[i], i, this[i]) !== false)
    ++i;
  return this;
}
function map(fn) {
  let elems = [];
  for (let i = 0; i < this.length; i++) {
    const el = this[i];
    const val2 = fn.call(el, i, el);
    if (val2 != null) {
      elems = elems.concat(val2);
    }
  }
  return this._make(elems);
}
function getFilterFn(match2) {
  if (typeof match2 === "function") {
    return (el, i) => match2.call(el, i, el);
  }
  if (isCheerio(match2)) {
    return (el) => Array.prototype.includes.call(match2, el);
  }
  return function(el) {
    return match2 === el;
  };
}
function filter3(match2) {
  var _a3;
  return this._make(filterArray(this.toArray(), match2, this.options.xmlMode, (_a3 = this._root) === null || _a3 === void 0 ? void 0 : _a3[0]));
}
function filterArray(nodes, match2, xmlMode, root3) {
  return typeof match2 === "string" ? filter2(match2, nodes, { xmlMode, root: root3 }) : nodes.filter(getFilterFn(match2));
}
function is3(selector) {
  const nodes = this.toArray();
  return typeof selector === "string" ? some(nodes.filter(isTag2), selector, this.options) : selector ? nodes.some(getFilterFn(selector)) : false;
}
function not(match2) {
  let nodes = this.toArray();
  if (typeof match2 === "string") {
    const matches = new Set(filter2(match2, nodes, this.options));
    nodes = nodes.filter((el) => !matches.has(el));
  } else {
    const filterFn = getFilterFn(match2);
    nodes = nodes.filter((el, i) => !filterFn(el, i));
  }
  return this._make(nodes);
}
function has(selectorOrHaystack) {
  return this.filter(typeof selectorOrHaystack === "string" ? `:has(${selectorOrHaystack})` : (_, el) => this._make(el).find(selectorOrHaystack).length > 0);
}
function first() {
  return this.length > 1 ? this._make(this[0]) : this;
}
function last() {
  return this.length > 0 ? this._make(this[this.length - 1]) : this;
}
function eq(i) {
  var _a3;
  i = +i;
  if (i === 0 && this.length <= 1)
    return this;
  if (i < 0)
    i = this.length + i;
  return this._make((_a3 = this[i]) !== null && _a3 !== void 0 ? _a3 : []);
}
function get(i) {
  if (i == null) {
    return this.toArray();
  }
  return this[i < 0 ? this.length + i : i];
}
function toArray() {
  return Array.prototype.slice.call(this);
}
function index(selectorOrNeedle) {
  let $haystack;
  let needle;
  if (selectorOrNeedle == null) {
    $haystack = this.parent().children();
    needle = this[0];
  } else if (typeof selectorOrNeedle === "string") {
    $haystack = this._make(selectorOrNeedle);
    needle = this[0];
  } else {
    $haystack = this;
    needle = isCheerio(selectorOrNeedle) ? selectorOrNeedle[0] : selectorOrNeedle;
  }
  return Array.prototype.indexOf.call($haystack, needle);
}
function slice(start, end2) {
  return this._make(Array.prototype.slice.call(this, start, end2));
}
function end() {
  var _a3;
  return (_a3 = this.prevObject) !== null && _a3 !== void 0 ? _a3 : this._make([]);
}
function add(other, context) {
  const selection = this._make(other, context);
  const contents2 = uniqueSort([...this.get(), ...selection.get()]);
  return this._make(contents2);
}
function addBack(selector) {
  return this.prevObject ? this.add(selector ? this.prevObject.filter(selector) : this.prevObject) : this;
}

// ../../node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/api/manipulation.js
var manipulation_exports = {};
__export(manipulation_exports, {
  _makeDomArray: () => _makeDomArray,
  after: () => after,
  append: () => append2,
  appendTo: () => appendTo,
  before: () => before,
  clone: () => clone,
  empty: () => empty,
  html: () => html2,
  insertAfter: () => insertAfter,
  insertBefore: () => insertBefore,
  prepend: () => prepend2,
  prependTo: () => prependTo,
  remove: () => remove,
  replaceWith: () => replaceWith,
  text: () => text2,
  toString: () => toString,
  unwrap: () => unwrap,
  wrap: () => wrap,
  wrapAll: () => wrapAll,
  wrapInner: () => wrapInner
});

// ../../node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/parse.js
function getParse(parser) {
  return function parse7(content, options, isDocument3, context) {
    if (typeof Buffer !== "undefined" && Buffer.isBuffer(content)) {
      content = content.toString();
    }
    if (typeof content === "string") {
      return parser(content, options, isDocument3, context);
    }
    const doc = content;
    if (!Array.isArray(doc) && isDocument(doc)) {
      return doc;
    }
    const root3 = new Document([]);
    update(doc, root3);
    return root3;
  };
}
function update(newChilds, parent2) {
  const arr = Array.isArray(newChilds) ? newChilds : [newChilds];
  if (parent2) {
    parent2.children = arr;
  } else {
    parent2 = null;
  }
  for (let i = 0; i < arr.length; i++) {
    const node = arr[i];
    if (node.parent && node.parent.children !== arr) {
      removeElement(node);
    }
    if (parent2) {
      node.prev = arr[i - 1] || null;
      node.next = arr[i + 1] || null;
    } else {
      node.prev = node.next = null;
    }
    node.parent = parent2;
  }
  return parent2;
}

// ../../node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/api/manipulation.js
function _makeDomArray(elem, clone2) {
  if (elem == null) {
    return [];
  }
  if (isCheerio(elem)) {
    return clone2 ? cloneDom(elem.get()) : elem.get();
  }
  if (Array.isArray(elem)) {
    return elem.reduce((newElems, el) => newElems.concat(this._makeDomArray(el, clone2)), []);
  }
  if (typeof elem === "string") {
    return this._parse(elem, this.options, false, null).children;
  }
  return clone2 ? cloneDom([elem]) : [elem];
}
function _insert(concatenator) {
  return function(...elems) {
    const lastIdx = this.length - 1;
    return domEach(this, (el, i) => {
      if (!hasChildren(el))
        return;
      const domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, this._render(el.children)) : elems;
      const dom = this._makeDomArray(domSrc, i < lastIdx);
      concatenator(dom, el.children, el);
    });
  };
}
function uniqueSplice(array, spliceIdx, spliceCount, newElems, parent2) {
  var _a3, _b;
  const spliceArgs = [
    spliceIdx,
    spliceCount,
    ...newElems
  ];
  const prev2 = spliceIdx === 0 ? null : array[spliceIdx - 1];
  const next2 = spliceIdx + spliceCount >= array.length ? null : array[spliceIdx + spliceCount];
  for (let idx = 0; idx < newElems.length; ++idx) {
    const node = newElems[idx];
    const oldParent = node.parent;
    if (oldParent) {
      const oldSiblings = oldParent.children;
      const prevIdx = oldSiblings.indexOf(node);
      if (prevIdx > -1) {
        oldParent.children.splice(prevIdx, 1);
        if (parent2 === oldParent && spliceIdx > prevIdx) {
          spliceArgs[0]--;
        }
      }
    }
    node.parent = parent2;
    if (node.prev) {
      node.prev.next = (_a3 = node.next) !== null && _a3 !== void 0 ? _a3 : null;
    }
    if (node.next) {
      node.next.prev = (_b = node.prev) !== null && _b !== void 0 ? _b : null;
    }
    node.prev = idx === 0 ? prev2 : newElems[idx - 1];
    node.next = idx === newElems.length - 1 ? next2 : newElems[idx + 1];
  }
  if (prev2) {
    prev2.next = newElems[0];
  }
  if (next2) {
    next2.prev = newElems[newElems.length - 1];
  }
  return array.splice(...spliceArgs);
}
function appendTo(target) {
  const appendTarget = isCheerio(target) ? target : this._make(target);
  appendTarget.append(this);
  return this;
}
function prependTo(target) {
  const prependTarget = isCheerio(target) ? target : this._make(target);
  prependTarget.prepend(this);
  return this;
}
var append2 = _insert((dom, children2, parent2) => {
  uniqueSplice(children2, children2.length, 0, dom, parent2);
});
var prepend2 = _insert((dom, children2, parent2) => {
  uniqueSplice(children2, 0, 0, dom, parent2);
});
function _wrap(insert) {
  return function(wrapper) {
    const lastIdx = this.length - 1;
    const lastParent = this.parents().last();
    for (let i = 0; i < this.length; i++) {
      const el = this[i];
      const wrap2 = typeof wrapper === "function" ? wrapper.call(el, i, el) : typeof wrapper === "string" && !isHtml(wrapper) ? lastParent.find(wrapper).clone() : wrapper;
      const [wrapperDom] = this._makeDomArray(wrap2, i < lastIdx);
      if (!wrapperDom || !hasChildren(wrapperDom))
        continue;
      let elInsertLocation = wrapperDom;
      let j = 0;
      while (j < elInsertLocation.children.length) {
        const child = elInsertLocation.children[j];
        if (isTag2(child)) {
          elInsertLocation = child;
          j = 0;
        } else {
          j++;
        }
      }
      insert(el, elInsertLocation, [wrapperDom]);
    }
    return this;
  };
}
var wrap = _wrap((el, elInsertLocation, wrapperDom) => {
  const { parent: parent2 } = el;
  if (!parent2)
    return;
  const siblings2 = parent2.children;
  const index2 = siblings2.indexOf(el);
  update([el], elInsertLocation);
  uniqueSplice(siblings2, index2, 0, wrapperDom, parent2);
});
var wrapInner = _wrap((el, elInsertLocation, wrapperDom) => {
  if (!hasChildren(el))
    return;
  update(el.children, elInsertLocation);
  update(wrapperDom, el);
});
function unwrap(selector) {
  this.parent(selector).not("body").each((_, el) => {
    this._make(el).replaceWith(el.children);
  });
  return this;
}
function wrapAll(wrapper) {
  const el = this[0];
  if (el) {
    const wrap2 = this._make(typeof wrapper === "function" ? wrapper.call(el, 0, el) : wrapper).insertBefore(el);
    let elInsertLocation;
    for (let i = 0; i < wrap2.length; i++) {
      if (wrap2[i].type === "tag")
        elInsertLocation = wrap2[i];
    }
    let j = 0;
    while (elInsertLocation && j < elInsertLocation.children.length) {
      const child = elInsertLocation.children[j];
      if (child.type === "tag") {
        elInsertLocation = child;
        j = 0;
      } else {
        j++;
      }
    }
    if (elInsertLocation)
      this._make(elInsertLocation).append(this);
  }
  return this;
}
function after(...elems) {
  const lastIdx = this.length - 1;
  return domEach(this, (el, i) => {
    const { parent: parent2 } = el;
    if (!hasChildren(el) || !parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    const domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, this._render(el.children)) : elems;
    const dom = this._makeDomArray(domSrc, i < lastIdx);
    uniqueSplice(siblings2, index2 + 1, 0, dom, parent2);
  });
}
function insertAfter(target) {
  if (typeof target === "string") {
    target = this._make(target);
  }
  this.remove();
  const clones = [];
  this._makeDomArray(target).forEach((el) => {
    const clonedSelf = this.clone().toArray();
    const { parent: parent2 } = el;
    if (!parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    uniqueSplice(siblings2, index2 + 1, 0, clonedSelf, parent2);
    clones.push(...clonedSelf);
  });
  return this._make(clones);
}
function before(...elems) {
  const lastIdx = this.length - 1;
  return domEach(this, (el, i) => {
    const { parent: parent2 } = el;
    if (!hasChildren(el) || !parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    const domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, this._render(el.children)) : elems;
    const dom = this._makeDomArray(domSrc, i < lastIdx);
    uniqueSplice(siblings2, index2, 0, dom, parent2);
  });
}
function insertBefore(target) {
  const targetArr = this._make(target);
  this.remove();
  const clones = [];
  domEach(targetArr, (el) => {
    const clonedSelf = this.clone().toArray();
    const { parent: parent2 } = el;
    if (!parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    uniqueSplice(siblings2, index2, 0, clonedSelf, parent2);
    clones.push(...clonedSelf);
  });
  return this._make(clones);
}
function remove(selector) {
  const elems = selector ? this.filter(selector) : this;
  domEach(elems, (el) => {
    removeElement(el);
    el.prev = el.next = el.parent = null;
  });
  return this;
}
function replaceWith(content) {
  return domEach(this, (el, i) => {
    const { parent: parent2 } = el;
    if (!parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const cont = typeof content === "function" ? content.call(el, i, el) : content;
    const dom = this._makeDomArray(cont);
    update(dom, null);
    const index2 = siblings2.indexOf(el);
    uniqueSplice(siblings2, index2, 1, dom, parent2);
    if (!dom.includes(el)) {
      el.parent = el.prev = el.next = null;
    }
  });
}
function empty() {
  return domEach(this, (el) => {
    if (!hasChildren(el))
      return;
    el.children.forEach((child) => {
      child.next = child.prev = child.parent = null;
    });
    el.children.length = 0;
  });
}
function html2(str) {
  if (str === void 0) {
    const el = this[0];
    if (!el || !hasChildren(el))
      return null;
    return this._render(el.children);
  }
  return domEach(this, (el) => {
    if (!hasChildren(el))
      return;
    el.children.forEach((child) => {
      child.next = child.prev = child.parent = null;
    });
    const content = isCheerio(str) ? str.toArray() : this._parse(`${str}`, this.options, false, el).children;
    update(content, el);
  });
}
function toString() {
  return this._render(this);
}
function text2(str) {
  if (str === void 0) {
    return text(this);
  }
  if (typeof str === "function") {
    return domEach(this, (el, i) => this._make(el).text(str.call(el, i, text([el]))));
  }
  return domEach(this, (el) => {
    if (!hasChildren(el))
      return;
    el.children.forEach((child) => {
      child.next = child.prev = child.parent = null;
    });
    const textNode = new Text2(`${str}`);
    update(textNode, el);
  });
}
function clone() {
  return this._make(cloneDom(this.get()));
}

// ../../node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/api/css.js
var css_exports = {};
__export(css_exports, {
  css: () => css
});
function css(prop2, val2) {
  if (prop2 != null && val2 != null || typeof prop2 === "object" && !Array.isArray(prop2)) {
    return domEach(this, (el, i) => {
      if (isTag2(el)) {
        setCss(el, prop2, val2, i);
      }
    });
  }
  if (this.length === 0) {
    return void 0;
  }
  return getCss(this[0], prop2);
}
function setCss(el, prop2, value, idx) {
  if (typeof prop2 === "string") {
    const styles2 = getCss(el);
    const val2 = typeof value === "function" ? value.call(el, idx, styles2[prop2]) : value;
    if (val2 === "") {
      delete styles2[prop2];
    } else if (val2 != null) {
      styles2[prop2] = val2;
    }
    el.attribs["style"] = stringify(styles2);
  } else if (typeof prop2 === "object") {
    Object.keys(prop2).forEach((k, i) => {
      setCss(el, k, prop2[k], i);
    });
  }
}
function getCss(el, prop2) {
  if (!el || !isTag2(el))
    return;
  const styles2 = parse3(el.attribs["style"]);
  if (typeof prop2 === "string") {
    return styles2[prop2];
  }
  if (Array.isArray(prop2)) {
    const newStyles = {};
    prop2.forEach((item) => {
      if (styles2[item] != null) {
        newStyles[item] = styles2[item];
      }
    });
    return newStyles;
  }
  return styles2;
}
function stringify(obj) {
  return Object.keys(obj).reduce((str, prop2) => `${str}${str ? " " : ""}${prop2}: ${obj[prop2]};`, "");
}
function parse3(styles2) {
  styles2 = (styles2 || "").trim();
  if (!styles2)
    return {};
  const obj = {};
  let key;
  for (const str of styles2.split(";")) {
    const n = str.indexOf(":");
    if (n < 1 || n === str.length - 1) {
      const trimmed = str.trimEnd();
      if (trimmed.length > 0 && key !== void 0) {
        obj[key] += `;${trimmed}`;
      }
    } else {
      key = str.slice(0, n).trim();
      obj[key] = str.slice(n + 1).trim();
    }
  }
  return obj;
}

// ../../node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/api/forms.js
var forms_exports = {};
__export(forms_exports, {
  serialize: () => serialize,
  serializeArray: () => serializeArray
});
var submittableSelector = "input,select,textarea,keygen";
var r20 = /%20/g;
var rCRLF = /\r?\n/g;
function serialize() {
  const arr = this.serializeArray();
  const retArr = arr.map((data2) => `${encodeURIComponent(data2.name)}=${encodeURIComponent(data2.value)}`);
  return retArr.join("&").replace(r20, "+");
}
function serializeArray() {
  return this.map((_, elem) => {
    const $elem = this._make(elem);
    if (isTag2(elem) && elem.name === "form") {
      return $elem.find(submittableSelector).toArray();
    }
    return $elem.filter(submittableSelector).toArray();
  }).filter(
    '[name!=""]:enabled:not(:submit, :button, :image, :reset, :file):matches([checked], :not(:checkbox, :radio))'
  ).map((_, elem) => {
    var _a3;
    const $elem = this._make(elem);
    const name2 = $elem.attr("name");
    const value = (_a3 = $elem.val()) !== null && _a3 !== void 0 ? _a3 : "";
    if (Array.isArray(value)) {
      return value.map((val2) => ({ name: name2, value: val2.replace(rCRLF, "\r\n") }));
    }
    return { name: name2, value: value.replace(rCRLF, "\r\n") };
  }).toArray();
}

// ../../node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/cheerio.js
var Cheerio = class {
  constructor(elements, root3, options) {
    this.length = 0;
    this.options = options;
    this._root = root3;
    if (elements) {
      for (let idx = 0; idx < elements.length; idx++) {
        this[idx] = elements[idx];
      }
      this.length = elements.length;
    }
  }
};
Cheerio.prototype.cheerio = "[cheerio object]";
Cheerio.prototype.splice = Array.prototype.splice;
Cheerio.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
Object.assign(Cheerio.prototype, attributes_exports, traversing_exports, manipulation_exports, css_exports, forms_exports);

// ../../node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/load.js
function getLoad(parse7, render3) {
  return function load2(content, options, isDocument3 = true) {
    if (content == null) {
      throw new Error("cheerio.load() expects a string");
    }
    const internalOpts = { ...options_default, ...flatten2(options) };
    const initialRoot = parse7(content, internalOpts, isDocument3, null);
    class LoadedCheerio extends Cheerio {
      _make(selector, context) {
        const cheerio = initialize(selector, context);
        cheerio.prevObject = this;
        return cheerio;
      }
      _parse(content2, options2, isDocument4, context) {
        return parse7(content2, options2, isDocument4, context);
      }
      _render(dom) {
        return render3(dom, this.options);
      }
    }
    function initialize(selector, context, root3 = initialRoot, opts) {
      if (selector && isCheerio(selector))
        return selector;
      const options2 = {
        ...internalOpts,
        ...flatten2(opts)
      };
      const r = typeof root3 === "string" ? [parse7(root3, options2, false, null)] : "length" in root3 ? root3 : [root3];
      const rootInstance = isCheerio(r) ? r : new LoadedCheerio(r, null, options2);
      rootInstance._root = rootInstance;
      if (!selector) {
        return new LoadedCheerio(void 0, rootInstance, options2);
      }
      const elements = typeof selector === "string" && isHtml(selector) ? parse7(selector, options2, false, null).children : isNode(selector) ? [selector] : Array.isArray(selector) ? selector : void 0;
      const instance = new LoadedCheerio(elements, rootInstance, options2);
      if (elements) {
        return instance;
      }
      if (typeof selector !== "string") {
        throw new Error("Unexpected type of selector");
      }
      let search = selector;
      const searchContext = !context ? rootInstance : typeof context === "string" ? isHtml(context) ? new LoadedCheerio([parse7(context, options2, false, null)], rootInstance, options2) : (search = `${context} ${search}`, rootInstance) : isCheerio(context) ? context : new LoadedCheerio(Array.isArray(context) ? context : [context], rootInstance, options2);
      if (!searchContext)
        return instance;
      return searchContext.find(search);
    }
    Object.assign(initialize, static_exports, {
      load: load2,
      _root: initialRoot,
      _options: internalOpts,
      fn: LoadedCheerio.prototype,
      prototype: LoadedCheerio.prototype
    });
    return initialize;
  };
}
function isNode(obj) {
  return !!obj.name || obj.type === "root" || obj.type === "text" || obj.type === "comment";
}

// ../../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/common/unicode.js
var UNDEFINED_CODE_POINTS = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]);
var REPLACEMENT_CHARACTER = "\uFFFD";
var CODE_POINTS;
(function(CODE_POINTS2) {
  CODE_POINTS2[CODE_POINTS2["EOF"] = -1] = "EOF";
  CODE_POINTS2[CODE_POINTS2["NULL"] = 0] = "NULL";
  CODE_POINTS2[CODE_POINTS2["TABULATION"] = 9] = "TABULATION";
  CODE_POINTS2[CODE_POINTS2["CARRIAGE_RETURN"] = 13] = "CARRIAGE_RETURN";
  CODE_POINTS2[CODE_POINTS2["LINE_FEED"] = 10] = "LINE_FEED";
  CODE_POINTS2[CODE_POINTS2["FORM_FEED"] = 12] = "FORM_FEED";
  CODE_POINTS2[CODE_POINTS2["SPACE"] = 32] = "SPACE";
  CODE_POINTS2[CODE_POINTS2["EXCLAMATION_MARK"] = 33] = "EXCLAMATION_MARK";
  CODE_POINTS2[CODE_POINTS2["QUOTATION_MARK"] = 34] = "QUOTATION_MARK";
  CODE_POINTS2[CODE_POINTS2["AMPERSAND"] = 38] = "AMPERSAND";
  CODE_POINTS2[CODE_POINTS2["APOSTROPHE"] = 39] = "APOSTROPHE";
  CODE_POINTS2[CODE_POINTS2["HYPHEN_MINUS"] = 45] = "HYPHEN_MINUS";
  CODE_POINTS2[CODE_POINTS2["SOLIDUS"] = 47] = "SOLIDUS";
  CODE_POINTS2[CODE_POINTS2["DIGIT_0"] = 48] = "DIGIT_0";
  CODE_POINTS2[CODE_POINTS2["DIGIT_9"] = 57] = "DIGIT_9";
  CODE_POINTS2[CODE_POINTS2["SEMICOLON"] = 59] = "SEMICOLON";
  CODE_POINTS2[CODE_POINTS2["LESS_THAN_SIGN"] = 60] = "LESS_THAN_SIGN";
  CODE_POINTS2[CODE_POINTS2["EQUALS_SIGN"] = 61] = "EQUALS_SIGN";
  CODE_POINTS2[CODE_POINTS2["GREATER_THAN_SIGN"] = 62] = "GREATER_THAN_SIGN";
  CODE_POINTS2[CODE_POINTS2["QUESTION_MARK"] = 63] = "QUESTION_MARK";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_A"] = 65] = "LATIN_CAPITAL_A";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_Z"] = 90] = "LATIN_CAPITAL_Z";
  CODE_POINTS2[CODE_POINTS2["RIGHT_SQUARE_BRACKET"] = 93] = "RIGHT_SQUARE_BRACKET";
  CODE_POINTS2[CODE_POINTS2["GRAVE_ACCENT"] = 96] = "GRAVE_ACCENT";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_A"] = 97] = "LATIN_SMALL_A";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_Z"] = 122] = "LATIN_SMALL_Z";
})(CODE_POINTS || (CODE_POINTS = {}));
var SEQUENCES = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function isSurrogate(cp) {
  return cp >= 55296 && cp <= 57343;
}
function isSurrogatePair(cp) {
  return cp >= 56320 && cp <= 57343;
}
function getSurrogatePairCodePoint(cp1, cp2) {
  return (cp1 - 55296) * 1024 + 9216 + cp2;
}
function isControlCodePoint(cp) {
  return cp !== 32 && cp !== 10 && cp !== 13 && cp !== 9 && cp !== 12 && cp >= 1 && cp <= 31 || cp >= 127 && cp <= 159;
}
function isUndefinedCodePoint(cp) {
  return cp >= 64976 && cp <= 65007 || UNDEFINED_CODE_POINTS.has(cp);
}

// ../../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/common/error-codes.js
var ERR;
(function(ERR2) {
  ERR2["controlCharacterInInputStream"] = "control-character-in-input-stream";
  ERR2["noncharacterInInputStream"] = "noncharacter-in-input-stream";
  ERR2["surrogateInInputStream"] = "surrogate-in-input-stream";
  ERR2["nonVoidHtmlElementStartTagWithTrailingSolidus"] = "non-void-html-element-start-tag-with-trailing-solidus";
  ERR2["endTagWithAttributes"] = "end-tag-with-attributes";
  ERR2["endTagWithTrailingSolidus"] = "end-tag-with-trailing-solidus";
  ERR2["unexpectedSolidusInTag"] = "unexpected-solidus-in-tag";
  ERR2["unexpectedNullCharacter"] = "unexpected-null-character";
  ERR2["unexpectedQuestionMarkInsteadOfTagName"] = "unexpected-question-mark-instead-of-tag-name";
  ERR2["invalidFirstCharacterOfTagName"] = "invalid-first-character-of-tag-name";
  ERR2["unexpectedEqualsSignBeforeAttributeName"] = "unexpected-equals-sign-before-attribute-name";
  ERR2["missingEndTagName"] = "missing-end-tag-name";
  ERR2["unexpectedCharacterInAttributeName"] = "unexpected-character-in-attribute-name";
  ERR2["unknownNamedCharacterReference"] = "unknown-named-character-reference";
  ERR2["missingSemicolonAfterCharacterReference"] = "missing-semicolon-after-character-reference";
  ERR2["unexpectedCharacterAfterDoctypeSystemIdentifier"] = "unexpected-character-after-doctype-system-identifier";
  ERR2["unexpectedCharacterInUnquotedAttributeValue"] = "unexpected-character-in-unquoted-attribute-value";
  ERR2["eofBeforeTagName"] = "eof-before-tag-name";
  ERR2["eofInTag"] = "eof-in-tag";
  ERR2["missingAttributeValue"] = "missing-attribute-value";
  ERR2["missingWhitespaceBetweenAttributes"] = "missing-whitespace-between-attributes";
  ERR2["missingWhitespaceAfterDoctypePublicKeyword"] = "missing-whitespace-after-doctype-public-keyword";
  ERR2["missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers"] = "missing-whitespace-between-doctype-public-and-system-identifiers";
  ERR2["missingWhitespaceAfterDoctypeSystemKeyword"] = "missing-whitespace-after-doctype-system-keyword";
  ERR2["missingQuoteBeforeDoctypePublicIdentifier"] = "missing-quote-before-doctype-public-identifier";
  ERR2["missingQuoteBeforeDoctypeSystemIdentifier"] = "missing-quote-before-doctype-system-identifier";
  ERR2["missingDoctypePublicIdentifier"] = "missing-doctype-public-identifier";
  ERR2["missingDoctypeSystemIdentifier"] = "missing-doctype-system-identifier";
  ERR2["abruptDoctypePublicIdentifier"] = "abrupt-doctype-public-identifier";
  ERR2["abruptDoctypeSystemIdentifier"] = "abrupt-doctype-system-identifier";
  ERR2["cdataInHtmlContent"] = "cdata-in-html-content";
  ERR2["incorrectlyOpenedComment"] = "incorrectly-opened-comment";
  ERR2["eofInScriptHtmlCommentLikeText"] = "eof-in-script-html-comment-like-text";
  ERR2["eofInDoctype"] = "eof-in-doctype";
  ERR2["nestedComment"] = "nested-comment";
  ERR2["abruptClosingOfEmptyComment"] = "abrupt-closing-of-empty-comment";
  ERR2["eofInComment"] = "eof-in-comment";
  ERR2["incorrectlyClosedComment"] = "incorrectly-closed-comment";
  ERR2["eofInCdata"] = "eof-in-cdata";
  ERR2["absenceOfDigitsInNumericCharacterReference"] = "absence-of-digits-in-numeric-character-reference";
  ERR2["nullCharacterReference"] = "null-character-reference";
  ERR2["surrogateCharacterReference"] = "surrogate-character-reference";
  ERR2["characterReferenceOutsideUnicodeRange"] = "character-reference-outside-unicode-range";
  ERR2["controlCharacterReference"] = "control-character-reference";
  ERR2["noncharacterCharacterReference"] = "noncharacter-character-reference";
  ERR2["missingWhitespaceBeforeDoctypeName"] = "missing-whitespace-before-doctype-name";
  ERR2["missingDoctypeName"] = "missing-doctype-name";
  ERR2["invalidCharacterSequenceAfterDoctypeName"] = "invalid-character-sequence-after-doctype-name";
  ERR2["duplicateAttribute"] = "duplicate-attribute";
  ERR2["nonConformingDoctype"] = "non-conforming-doctype";
  ERR2["missingDoctype"] = "missing-doctype";
  ERR2["misplacedDoctype"] = "misplaced-doctype";
  ERR2["endTagWithoutMatchingOpenElement"] = "end-tag-without-matching-open-element";
  ERR2["closingOfElementWithOpenChildElements"] = "closing-of-element-with-open-child-elements";
  ERR2["disallowedContentInNoscriptInHead"] = "disallowed-content-in-noscript-in-head";
  ERR2["openElementsLeftAfterEof"] = "open-elements-left-after-eof";
  ERR2["abandonedHeadElementChild"] = "abandoned-head-element-child";
  ERR2["misplacedStartTagForHeadElement"] = "misplaced-start-tag-for-head-element";
  ERR2["nestedNoscriptInHead"] = "nested-noscript-in-head";
  ERR2["eofInElementThatCanContainOnlyText"] = "eof-in-element-that-can-contain-only-text";
})(ERR || (ERR = {}));

// ../../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/tokenizer/preprocessor.js
var DEFAULT_BUFFER_WATERLINE = 1 << 16;
var Preprocessor = class {
  constructor(handler) {
    this.handler = handler;
    this.html = "";
    this.pos = -1;
    this.lastGapPos = -2;
    this.gapStack = [];
    this.skipNextNewLine = false;
    this.lastChunkWritten = false;
    this.endOfChunkHit = false;
    this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
    this.isEol = false;
    this.lineStartPos = 0;
    this.droppedBufferSize = 0;
    this.line = 1;
    this.lastErrOffset = -1;
  }
  get col() {
    return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(code2, cpOffset) {
    const { line, col, offset } = this;
    const startCol = col + cpOffset;
    const startOffset = offset + cpOffset;
    return {
      code: code2,
      startLine: line,
      endLine: line,
      startCol,
      endCol: startCol,
      startOffset,
      endOffset: startOffset
    };
  }
  _err(code2) {
    if (this.handler.onParseError && this.lastErrOffset !== this.offset) {
      this.lastErrOffset = this.offset;
      this.handler.onParseError(this.getError(code2, 0));
    }
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos);
    this.lastGapPos = this.pos;
  }
  _processSurrogate(cp) {
    if (this.pos !== this.html.length - 1) {
      const nextCp = this.html.charCodeAt(this.pos + 1);
      if (isSurrogatePair(nextCp)) {
        this.pos++;
        this._addGap();
        return getSurrogatePairCodePoint(cp, nextCp);
      }
    } else if (!this.lastChunkWritten) {
      this.endOfChunkHit = true;
      return CODE_POINTS.EOF;
    }
    this._err(ERR.surrogateInInputStream);
    return cp;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    if (this.willDropParsedChunk()) {
      this.html = this.html.substring(this.pos);
      this.lineStartPos -= this.pos;
      this.droppedBufferSize += this.pos;
      this.pos = 0;
      this.lastGapPos = -2;
      this.gapStack.length = 0;
    }
  }
  write(chunk, isLastChunk) {
    if (this.html.length > 0) {
      this.html += chunk;
    } else {
      this.html = chunk;
    }
    this.endOfChunkHit = false;
    this.lastChunkWritten = isLastChunk;
  }
  insertHtmlAtCurrentPos(chunk) {
    this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);
    this.endOfChunkHit = false;
  }
  startsWith(pattern, caseSensitive) {
    if (this.pos + pattern.length > this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return false;
    }
    if (caseSensitive) {
      return this.html.startsWith(pattern, this.pos);
    }
    for (let i = 0; i < pattern.length; i++) {
      const cp = this.html.charCodeAt(this.pos + i) | 32;
      if (cp !== pattern.charCodeAt(i)) {
        return false;
      }
    }
    return true;
  }
  peek(offset) {
    const pos = this.pos + offset;
    if (pos >= this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return CODE_POINTS.EOF;
    }
    const code2 = this.html.charCodeAt(pos);
    return code2 === CODE_POINTS.CARRIAGE_RETURN ? CODE_POINTS.LINE_FEED : code2;
  }
  advance() {
    this.pos++;
    if (this.isEol) {
      this.isEol = false;
      this.line++;
      this.lineStartPos = this.pos;
    }
    if (this.pos >= this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return CODE_POINTS.EOF;
    }
    let cp = this.html.charCodeAt(this.pos);
    if (cp === CODE_POINTS.CARRIAGE_RETURN) {
      this.isEol = true;
      this.skipNextNewLine = true;
      return CODE_POINTS.LINE_FEED;
    }
    if (cp === CODE_POINTS.LINE_FEED) {
      this.isEol = true;
      if (this.skipNextNewLine) {
        this.line--;
        this.skipNextNewLine = false;
        this._addGap();
        return this.advance();
      }
    }
    this.skipNextNewLine = false;
    if (isSurrogate(cp)) {
      cp = this._processSurrogate(cp);
    }
    const isCommonValidRange = this.handler.onParseError === null || cp > 31 && cp < 127 || cp === CODE_POINTS.LINE_FEED || cp === CODE_POINTS.CARRIAGE_RETURN || cp > 159 && cp < 64976;
    if (!isCommonValidRange) {
      this._checkForProblematicCharacters(cp);
    }
    return cp;
  }
  _checkForProblematicCharacters(cp) {
    if (isControlCodePoint(cp)) {
      this._err(ERR.controlCharacterInInputStream);
    } else if (isUndefinedCodePoint(cp)) {
      this._err(ERR.noncharacterInInputStream);
    }
  }
  retreat(count) {
    this.pos -= count;
    while (this.pos < this.lastGapPos) {
      this.lastGapPos = this.gapStack.pop();
      this.pos--;
    }
    this.isEol = false;
  }
};

// ../../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/common/token.js
var token_exports = {};
__export(token_exports, {
  TokenType: () => TokenType,
  getTokenAttr: () => getTokenAttr
});
var TokenType;
(function(TokenType2) {
  TokenType2[TokenType2["CHARACTER"] = 0] = "CHARACTER";
  TokenType2[TokenType2["NULL_CHARACTER"] = 1] = "NULL_CHARACTER";
  TokenType2[TokenType2["WHITESPACE_CHARACTER"] = 2] = "WHITESPACE_CHARACTER";
  TokenType2[TokenType2["START_TAG"] = 3] = "START_TAG";
  TokenType2[TokenType2["END_TAG"] = 4] = "END_TAG";
  TokenType2[TokenType2["COMMENT"] = 5] = "COMMENT";
  TokenType2[TokenType2["DOCTYPE"] = 6] = "DOCTYPE";
  TokenType2[TokenType2["EOF"] = 7] = "EOF";
  TokenType2[TokenType2["HIBERNATION"] = 8] = "HIBERNATION";
})(TokenType || (TokenType = {}));
function getTokenAttr(token, attrName) {
  for (let i = token.attrs.length - 1; i >= 0; i--) {
    if (token.attrs[i].name === attrName) {
      return token.attrs[i].value;
    }
  }
  return null;
}

// ../../node_modules/.pnpm/entities@6.0.0/node_modules/entities/dist/esm/generated/decode-data-html.js
var htmlDecodeTree = /* @__PURE__ */ new Uint16Array(
  /* @__PURE__ */ '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c) => c.charCodeAt(0))
);

// ../../node_modules/.pnpm/entities@6.0.0/node_modules/entities/dist/esm/decode-codepoint.js
var _a2;
var decodeMap2 = /* @__PURE__ */ new Map([
  [0, 65533],
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint2 = (_a2 = String.fromCodePoint) !== null && _a2 !== void 0 ? _a2 : function(codePoint) {
  let output = "";
  if (codePoint > 65535) {
    codePoint -= 65536;
    output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
    codePoint = 56320 | codePoint & 1023;
  }
  output += String.fromCharCode(codePoint);
  return output;
};
function replaceCodePoint2(codePoint) {
  var _a3;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a3 = decodeMap2.get(codePoint)) !== null && _a3 !== void 0 ? _a3 : codePoint;
}

// ../../node_modules/.pnpm/entities@6.0.0/node_modules/entities/dist/esm/decode.js
var CharCodes2;
(function(CharCodes4) {
  CharCodes4[CharCodes4["NUM"] = 35] = "NUM";
  CharCodes4[CharCodes4["SEMI"] = 59] = "SEMI";
  CharCodes4[CharCodes4["EQUALS"] = 61] = "EQUALS";
  CharCodes4[CharCodes4["ZERO"] = 48] = "ZERO";
  CharCodes4[CharCodes4["NINE"] = 57] = "NINE";
  CharCodes4[CharCodes4["LOWER_A"] = 97] = "LOWER_A";
  CharCodes4[CharCodes4["LOWER_F"] = 102] = "LOWER_F";
  CharCodes4[CharCodes4["LOWER_X"] = 120] = "LOWER_X";
  CharCodes4[CharCodes4["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes4[CharCodes4["UPPER_A"] = 65] = "UPPER_A";
  CharCodes4[CharCodes4["UPPER_F"] = 70] = "UPPER_F";
  CharCodes4[CharCodes4["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes2 || (CharCodes2 = {}));
var TO_LOWER_BIT2 = 32;
var BinTrieFlags2;
(function(BinTrieFlags3) {
  BinTrieFlags3[BinTrieFlags3["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags3[BinTrieFlags3["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags3[BinTrieFlags3["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags2 || (BinTrieFlags2 = {}));
function isNumber2(code2) {
  return code2 >= CharCodes2.ZERO && code2 <= CharCodes2.NINE;
}
function isHexadecimalCharacter2(code2) {
  return code2 >= CharCodes2.UPPER_A && code2 <= CharCodes2.UPPER_F || code2 >= CharCodes2.LOWER_A && code2 <= CharCodes2.LOWER_F;
}
function isAsciiAlphaNumeric2(code2) {
  return code2 >= CharCodes2.UPPER_A && code2 <= CharCodes2.UPPER_Z || code2 >= CharCodes2.LOWER_A && code2 <= CharCodes2.LOWER_Z || isNumber2(code2);
}
function isEntityInAttributeInvalidEnd2(code2) {
  return code2 === CharCodes2.EQUALS || isAsciiAlphaNumeric2(code2);
}
var EntityDecoderState2;
(function(EntityDecoderState3) {
  EntityDecoderState3[EntityDecoderState3["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState3[EntityDecoderState3["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState3[EntityDecoderState3["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState3[EntityDecoderState3["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState3[EntityDecoderState3["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState2 || (EntityDecoderState2 = {}));
var DecodingMode2;
(function(DecodingMode3) {
  DecodingMode3[DecodingMode3["Legacy"] = 0] = "Legacy";
  DecodingMode3[DecodingMode3["Strict"] = 1] = "Strict";
  DecodingMode3[DecodingMode3["Attribute"] = 2] = "Attribute";
})(DecodingMode2 || (DecodingMode2 = {}));
var EntityDecoder2 = class {
  constructor(decodeTree, emitCodePoint, errors2) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors2;
    this.state = EntityDecoderState2.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode2.Strict;
  }
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState2.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  write(input, offset) {
    switch (this.state) {
      case EntityDecoderState2.EntityStart: {
        if (input.charCodeAt(offset) === CharCodes2.NUM) {
          this.state = EntityDecoderState2.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(input, offset + 1);
        }
        this.state = EntityDecoderState2.NamedEntity;
        return this.stateNamedEntity(input, offset);
      }
      case EntityDecoderState2.NumericStart: {
        return this.stateNumericStart(input, offset);
      }
      case EntityDecoderState2.NumericDecimal: {
        return this.stateNumericDecimal(input, offset);
      }
      case EntityDecoderState2.NumericHex: {
        return this.stateNumericHex(input, offset);
      }
      case EntityDecoderState2.NamedEntity: {
        return this.stateNamedEntity(input, offset);
      }
    }
  }
  stateNumericStart(input, offset) {
    if (offset >= input.length) {
      return -1;
    }
    if ((input.charCodeAt(offset) | TO_LOWER_BIT2) === CharCodes2.LOWER_X) {
      this.state = EntityDecoderState2.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(input, offset + 1);
    }
    this.state = EntityDecoderState2.NumericDecimal;
    return this.stateNumericDecimal(input, offset);
  }
  addToNumericResult(input, start, end2, base2) {
    if (start !== end2) {
      const digitCount = end2 - start;
      this.result = this.result * Math.pow(base2, digitCount) + Number.parseInt(input.substr(start, digitCount), base2);
      this.consumed += digitCount;
    }
  }
  stateNumericHex(input, offset) {
    const startIndex = offset;
    while (offset < input.length) {
      const char = input.charCodeAt(offset);
      if (isNumber2(char) || isHexadecimalCharacter2(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(input, startIndex, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(input, startIndex, offset, 16);
    return -1;
  }
  stateNumericDecimal(input, offset) {
    const startIndex = offset;
    while (offset < input.length) {
      const char = input.charCodeAt(offset);
      if (isNumber2(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(input, startIndex, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(input, startIndex, offset, 10);
    return -1;
  }
  emitNumericEntity(lastCp, expectedLength) {
    var _a3;
    if (this.consumed <= expectedLength) {
      (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes2.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode2.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint2(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes2.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  stateNamedEntity(input, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags2.VALUE_LENGTH) >> 14;
    for (; offset < input.length; offset++, this.excess++) {
      const char = input.charCodeAt(offset);
      this.treeIndex = determineBranch2(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || this.decodeMode === DecodingMode2.Attribute && (valueLength === 0 || isEntityInAttributeInvalidEnd2(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags2.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes2.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode2.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  emitNotTerminatedNamedEntity() {
    var _a3;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags2.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags2.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  end() {
    var _a3;
    switch (this.state) {
      case EntityDecoderState2.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode2.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState2.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState2.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState2.NumericStart: {
        (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState2.EntityStart: {
        return 0;
      }
    }
  }
};
function determineBranch2(decodeTree, current, nodeIndex, char) {
  const branchCount = (current & BinTrieFlags2.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags2.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIndex : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIndex + value] - 1;
  }
  let lo = nodeIndex;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midValue = decodeTree[mid];
    if (midValue < char) {
      lo = mid + 1;
    } else if (midValue > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}

// ../../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/common/html.js
var html_exports = {};
__export(html_exports, {
  ATTRS: () => ATTRS,
  DOCUMENT_MODE: () => DOCUMENT_MODE,
  NS: () => NS,
  NUMBERED_HEADERS: () => NUMBERED_HEADERS,
  SPECIAL_ELEMENTS: () => SPECIAL_ELEMENTS,
  TAG_ID: () => TAG_ID,
  TAG_NAMES: () => TAG_NAMES,
  getTagID: () => getTagID,
  hasUnescapedText: () => hasUnescapedText
});
var NS;
(function(NS2) {
  NS2["HTML"] = "http://www.w3.org/1999/xhtml";
  NS2["MATHML"] = "http://www.w3.org/1998/Math/MathML";
  NS2["SVG"] = "http://www.w3.org/2000/svg";
  NS2["XLINK"] = "http://www.w3.org/1999/xlink";
  NS2["XML"] = "http://www.w3.org/XML/1998/namespace";
  NS2["XMLNS"] = "http://www.w3.org/2000/xmlns/";
})(NS || (NS = {}));
var ATTRS;
(function(ATTRS2) {
  ATTRS2["TYPE"] = "type";
  ATTRS2["ACTION"] = "action";
  ATTRS2["ENCODING"] = "encoding";
  ATTRS2["PROMPT"] = "prompt";
  ATTRS2["NAME"] = "name";
  ATTRS2["COLOR"] = "color";
  ATTRS2["FACE"] = "face";
  ATTRS2["SIZE"] = "size";
})(ATTRS || (ATTRS = {}));
var DOCUMENT_MODE;
(function(DOCUMENT_MODE2) {
  DOCUMENT_MODE2["NO_QUIRKS"] = "no-quirks";
  DOCUMENT_MODE2["QUIRKS"] = "quirks";
  DOCUMENT_MODE2["LIMITED_QUIRKS"] = "limited-quirks";
})(DOCUMENT_MODE || (DOCUMENT_MODE = {}));
var TAG_NAMES;
(function(TAG_NAMES2) {
  TAG_NAMES2["A"] = "a";
  TAG_NAMES2["ADDRESS"] = "address";
  TAG_NAMES2["ANNOTATION_XML"] = "annotation-xml";
  TAG_NAMES2["APPLET"] = "applet";
  TAG_NAMES2["AREA"] = "area";
  TAG_NAMES2["ARTICLE"] = "article";
  TAG_NAMES2["ASIDE"] = "aside";
  TAG_NAMES2["B"] = "b";
  TAG_NAMES2["BASE"] = "base";
  TAG_NAMES2["BASEFONT"] = "basefont";
  TAG_NAMES2["BGSOUND"] = "bgsound";
  TAG_NAMES2["BIG"] = "big";
  TAG_NAMES2["BLOCKQUOTE"] = "blockquote";
  TAG_NAMES2["BODY"] = "body";
  TAG_NAMES2["BR"] = "br";
  TAG_NAMES2["BUTTON"] = "button";
  TAG_NAMES2["CAPTION"] = "caption";
  TAG_NAMES2["CENTER"] = "center";
  TAG_NAMES2["CODE"] = "code";
  TAG_NAMES2["COL"] = "col";
  TAG_NAMES2["COLGROUP"] = "colgroup";
  TAG_NAMES2["DD"] = "dd";
  TAG_NAMES2["DESC"] = "desc";
  TAG_NAMES2["DETAILS"] = "details";
  TAG_NAMES2["DIALOG"] = "dialog";
  TAG_NAMES2["DIR"] = "dir";
  TAG_NAMES2["DIV"] = "div";
  TAG_NAMES2["DL"] = "dl";
  TAG_NAMES2["DT"] = "dt";
  TAG_NAMES2["EM"] = "em";
  TAG_NAMES2["EMBED"] = "embed";
  TAG_NAMES2["FIELDSET"] = "fieldset";
  TAG_NAMES2["FIGCAPTION"] = "figcaption";
  TAG_NAMES2["FIGURE"] = "figure";
  TAG_NAMES2["FONT"] = "font";
  TAG_NAMES2["FOOTER"] = "footer";
  TAG_NAMES2["FOREIGN_OBJECT"] = "foreignObject";
  TAG_NAMES2["FORM"] = "form";
  TAG_NAMES2["FRAME"] = "frame";
  TAG_NAMES2["FRAMESET"] = "frameset";
  TAG_NAMES2["H1"] = "h1";
  TAG_NAMES2["H2"] = "h2";
  TAG_NAMES2["H3"] = "h3";
  TAG_NAMES2["H4"] = "h4";
  TAG_NAMES2["H5"] = "h5";
  TAG_NAMES2["H6"] = "h6";
  TAG_NAMES2["HEAD"] = "head";
  TAG_NAMES2["HEADER"] = "header";
  TAG_NAMES2["HGROUP"] = "hgroup";
  TAG_NAMES2["HR"] = "hr";
  TAG_NAMES2["HTML"] = "html";
  TAG_NAMES2["I"] = "i";
  TAG_NAMES2["IMG"] = "img";
  TAG_NAMES2["IMAGE"] = "image";
  TAG_NAMES2["INPUT"] = "input";
  TAG_NAMES2["IFRAME"] = "iframe";
  TAG_NAMES2["KEYGEN"] = "keygen";
  TAG_NAMES2["LABEL"] = "label";
  TAG_NAMES2["LI"] = "li";
  TAG_NAMES2["LINK"] = "link";
  TAG_NAMES2["LISTING"] = "listing";
  TAG_NAMES2["MAIN"] = "main";
  TAG_NAMES2["MALIGNMARK"] = "malignmark";
  TAG_NAMES2["MARQUEE"] = "marquee";
  TAG_NAMES2["MATH"] = "math";
  TAG_NAMES2["MENU"] = "menu";
  TAG_NAMES2["META"] = "meta";
  TAG_NAMES2["MGLYPH"] = "mglyph";
  TAG_NAMES2["MI"] = "mi";
  TAG_NAMES2["MO"] = "mo";
  TAG_NAMES2["MN"] = "mn";
  TAG_NAMES2["MS"] = "ms";
  TAG_NAMES2["MTEXT"] = "mtext";
  TAG_NAMES2["NAV"] = "nav";
  TAG_NAMES2["NOBR"] = "nobr";
  TAG_NAMES2["NOFRAMES"] = "noframes";
  TAG_NAMES2["NOEMBED"] = "noembed";
  TAG_NAMES2["NOSCRIPT"] = "noscript";
  TAG_NAMES2["OBJECT"] = "object";
  TAG_NAMES2["OL"] = "ol";
  TAG_NAMES2["OPTGROUP"] = "optgroup";
  TAG_NAMES2["OPTION"] = "option";
  TAG_NAMES2["P"] = "p";
  TAG_NAMES2["PARAM"] = "param";
  TAG_NAMES2["PLAINTEXT"] = "plaintext";
  TAG_NAMES2["PRE"] = "pre";
  TAG_NAMES2["RB"] = "rb";
  TAG_NAMES2["RP"] = "rp";
  TAG_NAMES2["RT"] = "rt";
  TAG_NAMES2["RTC"] = "rtc";
  TAG_NAMES2["RUBY"] = "ruby";
  TAG_NAMES2["S"] = "s";
  TAG_NAMES2["SCRIPT"] = "script";
  TAG_NAMES2["SEARCH"] = "search";
  TAG_NAMES2["SECTION"] = "section";
  TAG_NAMES2["SELECT"] = "select";
  TAG_NAMES2["SOURCE"] = "source";
  TAG_NAMES2["SMALL"] = "small";
  TAG_NAMES2["SPAN"] = "span";
  TAG_NAMES2["STRIKE"] = "strike";
  TAG_NAMES2["STRONG"] = "strong";
  TAG_NAMES2["STYLE"] = "style";
  TAG_NAMES2["SUB"] = "sub";
  TAG_NAMES2["SUMMARY"] = "summary";
  TAG_NAMES2["SUP"] = "sup";
  TAG_NAMES2["TABLE"] = "table";
  TAG_NAMES2["TBODY"] = "tbody";
  TAG_NAMES2["TEMPLATE"] = "template";
  TAG_NAMES2["TEXTAREA"] = "textarea";
  TAG_NAMES2["TFOOT"] = "tfoot";
  TAG_NAMES2["TD"] = "td";
  TAG_NAMES2["TH"] = "th";
  TAG_NAMES2["THEAD"] = "thead";
  TAG_NAMES2["TITLE"] = "title";
  TAG_NAMES2["TR"] = "tr";
  TAG_NAMES2["TRACK"] = "track";
  TAG_NAMES2["TT"] = "tt";
  TAG_NAMES2["U"] = "u";
  TAG_NAMES2["UL"] = "ul";
  TAG_NAMES2["SVG"] = "svg";
  TAG_NAMES2["VAR"] = "var";
  TAG_NAMES2["WBR"] = "wbr";
  TAG_NAMES2["XMP"] = "xmp";
})(TAG_NAMES || (TAG_NAMES = {}));
var TAG_ID;
(function(TAG_ID2) {
  TAG_ID2[TAG_ID2["UNKNOWN"] = 0] = "UNKNOWN";
  TAG_ID2[TAG_ID2["A"] = 1] = "A";
  TAG_ID2[TAG_ID2["ADDRESS"] = 2] = "ADDRESS";
  TAG_ID2[TAG_ID2["ANNOTATION_XML"] = 3] = "ANNOTATION_XML";
  TAG_ID2[TAG_ID2["APPLET"] = 4] = "APPLET";
  TAG_ID2[TAG_ID2["AREA"] = 5] = "AREA";
  TAG_ID2[TAG_ID2["ARTICLE"] = 6] = "ARTICLE";
  TAG_ID2[TAG_ID2["ASIDE"] = 7] = "ASIDE";
  TAG_ID2[TAG_ID2["B"] = 8] = "B";
  TAG_ID2[TAG_ID2["BASE"] = 9] = "BASE";
  TAG_ID2[TAG_ID2["BASEFONT"] = 10] = "BASEFONT";
  TAG_ID2[TAG_ID2["BGSOUND"] = 11] = "BGSOUND";
  TAG_ID2[TAG_ID2["BIG"] = 12] = "BIG";
  TAG_ID2[TAG_ID2["BLOCKQUOTE"] = 13] = "BLOCKQUOTE";
  TAG_ID2[TAG_ID2["BODY"] = 14] = "BODY";
  TAG_ID2[TAG_ID2["BR"] = 15] = "BR";
  TAG_ID2[TAG_ID2["BUTTON"] = 16] = "BUTTON";
  TAG_ID2[TAG_ID2["CAPTION"] = 17] = "CAPTION";
  TAG_ID2[TAG_ID2["CENTER"] = 18] = "CENTER";
  TAG_ID2[TAG_ID2["CODE"] = 19] = "CODE";
  TAG_ID2[TAG_ID2["COL"] = 20] = "COL";
  TAG_ID2[TAG_ID2["COLGROUP"] = 21] = "COLGROUP";
  TAG_ID2[TAG_ID2["DD"] = 22] = "DD";
  TAG_ID2[TAG_ID2["DESC"] = 23] = "DESC";
  TAG_ID2[TAG_ID2["DETAILS"] = 24] = "DETAILS";
  TAG_ID2[TAG_ID2["DIALOG"] = 25] = "DIALOG";
  TAG_ID2[TAG_ID2["DIR"] = 26] = "DIR";
  TAG_ID2[TAG_ID2["DIV"] = 27] = "DIV";
  TAG_ID2[TAG_ID2["DL"] = 28] = "DL";
  TAG_ID2[TAG_ID2["DT"] = 29] = "DT";
  TAG_ID2[TAG_ID2["EM"] = 30] = "EM";
  TAG_ID2[TAG_ID2["EMBED"] = 31] = "EMBED";
  TAG_ID2[TAG_ID2["FIELDSET"] = 32] = "FIELDSET";
  TAG_ID2[TAG_ID2["FIGCAPTION"] = 33] = "FIGCAPTION";
  TAG_ID2[TAG_ID2["FIGURE"] = 34] = "FIGURE";
  TAG_ID2[TAG_ID2["FONT"] = 35] = "FONT";
  TAG_ID2[TAG_ID2["FOOTER"] = 36] = "FOOTER";
  TAG_ID2[TAG_ID2["FOREIGN_OBJECT"] = 37] = "FOREIGN_OBJECT";
  TAG_ID2[TAG_ID2["FORM"] = 38] = "FORM";
  TAG_ID2[TAG_ID2["FRAME"] = 39] = "FRAME";
  TAG_ID2[TAG_ID2["FRAMESET"] = 40] = "FRAMESET";
  TAG_ID2[TAG_ID2["H1"] = 41] = "H1";
  TAG_ID2[TAG_ID2["H2"] = 42] = "H2";
  TAG_ID2[TAG_ID2["H3"] = 43] = "H3";
  TAG_ID2[TAG_ID2["H4"] = 44] = "H4";
  TAG_ID2[TAG_ID2["H5"] = 45] = "H5";
  TAG_ID2[TAG_ID2["H6"] = 46] = "H6";
  TAG_ID2[TAG_ID2["HEAD"] = 47] = "HEAD";
  TAG_ID2[TAG_ID2["HEADER"] = 48] = "HEADER";
  TAG_ID2[TAG_ID2["HGROUP"] = 49] = "HGROUP";
  TAG_ID2[TAG_ID2["HR"] = 50] = "HR";
  TAG_ID2[TAG_ID2["HTML"] = 51] = "HTML";
  TAG_ID2[TAG_ID2["I"] = 52] = "I";
  TAG_ID2[TAG_ID2["IMG"] = 53] = "IMG";
  TAG_ID2[TAG_ID2["IMAGE"] = 54] = "IMAGE";
  TAG_ID2[TAG_ID2["INPUT"] = 55] = "INPUT";
  TAG_ID2[TAG_ID2["IFRAME"] = 56] = "IFRAME";
  TAG_ID2[TAG_ID2["KEYGEN"] = 57] = "KEYGEN";
  TAG_ID2[TAG_ID2["LABEL"] = 58] = "LABEL";
  TAG_ID2[TAG_ID2["LI"] = 59] = "LI";
  TAG_ID2[TAG_ID2["LINK"] = 60] = "LINK";
  TAG_ID2[TAG_ID2["LISTING"] = 61] = "LISTING";
  TAG_ID2[TAG_ID2["MAIN"] = 62] = "MAIN";
  TAG_ID2[TAG_ID2["MALIGNMARK"] = 63] = "MALIGNMARK";
  TAG_ID2[TAG_ID2["MARQUEE"] = 64] = "MARQUEE";
  TAG_ID2[TAG_ID2["MATH"] = 65] = "MATH";
  TAG_ID2[TAG_ID2["MENU"] = 66] = "MENU";
  TAG_ID2[TAG_ID2["META"] = 67] = "META";
  TAG_ID2[TAG_ID2["MGLYPH"] = 68] = "MGLYPH";
  TAG_ID2[TAG_ID2["MI"] = 69] = "MI";
  TAG_ID2[TAG_ID2["MO"] = 70] = "MO";
  TAG_ID2[TAG_ID2["MN"] = 71] = "MN";
  TAG_ID2[TAG_ID2["MS"] = 72] = "MS";
  TAG_ID2[TAG_ID2["MTEXT"] = 73] = "MTEXT";
  TAG_ID2[TAG_ID2["NAV"] = 74] = "NAV";
  TAG_ID2[TAG_ID2["NOBR"] = 75] = "NOBR";
  TAG_ID2[TAG_ID2["NOFRAMES"] = 76] = "NOFRAMES";
  TAG_ID2[TAG_ID2["NOEMBED"] = 77] = "NOEMBED";
  TAG_ID2[TAG_ID2["NOSCRIPT"] = 78] = "NOSCRIPT";
  TAG_ID2[TAG_ID2["OBJECT"] = 79] = "OBJECT";
  TAG_ID2[TAG_ID2["OL"] = 80] = "OL";
  TAG_ID2[TAG_ID2["OPTGROUP"] = 81] = "OPTGROUP";
  TAG_ID2[TAG_ID2["OPTION"] = 82] = "OPTION";
  TAG_ID2[TAG_ID2["P"] = 83] = "P";
  TAG_ID2[TAG_ID2["PARAM"] = 84] = "PARAM";
  TAG_ID2[TAG_ID2["PLAINTEXT"] = 85] = "PLAINTEXT";
  TAG_ID2[TAG_ID2["PRE"] = 86] = "PRE";
  TAG_ID2[TAG_ID2["RB"] = 87] = "RB";
  TAG_ID2[TAG_ID2["RP"] = 88] = "RP";
  TAG_ID2[TAG_ID2["RT"] = 89] = "RT";
  TAG_ID2[TAG_ID2["RTC"] = 90] = "RTC";
  TAG_ID2[TAG_ID2["RUBY"] = 91] = "RUBY";
  TAG_ID2[TAG_ID2["S"] = 92] = "S";
  TAG_ID2[TAG_ID2["SCRIPT"] = 93] = "SCRIPT";
  TAG_ID2[TAG_ID2["SEARCH"] = 94] = "SEARCH";
  TAG_ID2[TAG_ID2["SECTION"] = 95] = "SECTION";
  TAG_ID2[TAG_ID2["SELECT"] = 96] = "SELECT";
  TAG_ID2[TAG_ID2["SOURCE"] = 97] = "SOURCE";
  TAG_ID2[TAG_ID2["SMALL"] = 98] = "SMALL";
  TAG_ID2[TAG_ID2["SPAN"] = 99] = "SPAN";
  TAG_ID2[TAG_ID2["STRIKE"] = 100] = "STRIKE";
  TAG_ID2[TAG_ID2["STRONG"] = 101] = "STRONG";
  TAG_ID2[TAG_ID2["STYLE"] = 102] = "STYLE";
  TAG_ID2[TAG_ID2["SUB"] = 103] = "SUB";
  TAG_ID2[TAG_ID2["SUMMARY"] = 104] = "SUMMARY";
  TAG_ID2[TAG_ID2["SUP"] = 105] = "SUP";
  TAG_ID2[TAG_ID2["TABLE"] = 106] = "TABLE";
  TAG_ID2[TAG_ID2["TBODY"] = 107] = "TBODY";
  TAG_ID2[TAG_ID2["TEMPLATE"] = 108] = "TEMPLATE";
  TAG_ID2[TAG_ID2["TEXTAREA"] = 109] = "TEXTAREA";
  TAG_ID2[TAG_ID2["TFOOT"] = 110] = "TFOOT";
  TAG_ID2[TAG_ID2["TD"] = 111] = "TD";
  TAG_ID2[TAG_ID2["TH"] = 112] = "TH";
  TAG_ID2[TAG_ID2["THEAD"] = 113] = "THEAD";
  TAG_ID2[TAG_ID2["TITLE"] = 114] = "TITLE";
  TAG_ID2[TAG_ID2["TR"] = 115] = "TR";
  TAG_ID2[TAG_ID2["TRACK"] = 116] = "TRACK";
  TAG_ID2[TAG_ID2["TT"] = 117] = "TT";
  TAG_ID2[TAG_ID2["U"] = 118] = "U";
  TAG_ID2[TAG_ID2["UL"] = 119] = "UL";
  TAG_ID2[TAG_ID2["SVG"] = 120] = "SVG";
  TAG_ID2[TAG_ID2["VAR"] = 121] = "VAR";
  TAG_ID2[TAG_ID2["WBR"] = 122] = "WBR";
  TAG_ID2[TAG_ID2["XMP"] = 123] = "XMP";
})(TAG_ID || (TAG_ID = {}));
var TAG_NAME_TO_ID = /* @__PURE__ */ new Map([
  [TAG_NAMES.A, TAG_ID.A],
  [TAG_NAMES.ADDRESS, TAG_ID.ADDRESS],
  [TAG_NAMES.ANNOTATION_XML, TAG_ID.ANNOTATION_XML],
  [TAG_NAMES.APPLET, TAG_ID.APPLET],
  [TAG_NAMES.AREA, TAG_ID.AREA],
  [TAG_NAMES.ARTICLE, TAG_ID.ARTICLE],
  [TAG_NAMES.ASIDE, TAG_ID.ASIDE],
  [TAG_NAMES.B, TAG_ID.B],
  [TAG_NAMES.BASE, TAG_ID.BASE],
  [TAG_NAMES.BASEFONT, TAG_ID.BASEFONT],
  [TAG_NAMES.BGSOUND, TAG_ID.BGSOUND],
  [TAG_NAMES.BIG, TAG_ID.BIG],
  [TAG_NAMES.BLOCKQUOTE, TAG_ID.BLOCKQUOTE],
  [TAG_NAMES.BODY, TAG_ID.BODY],
  [TAG_NAMES.BR, TAG_ID.BR],
  [TAG_NAMES.BUTTON, TAG_ID.BUTTON],
  [TAG_NAMES.CAPTION, TAG_ID.CAPTION],
  [TAG_NAMES.CENTER, TAG_ID.CENTER],
  [TAG_NAMES.CODE, TAG_ID.CODE],
  [TAG_NAMES.COL, TAG_ID.COL],
  [TAG_NAMES.COLGROUP, TAG_ID.COLGROUP],
  [TAG_NAMES.DD, TAG_ID.DD],
  [TAG_NAMES.DESC, TAG_ID.DESC],
  [TAG_NAMES.DETAILS, TAG_ID.DETAILS],
  [TAG_NAMES.DIALOG, TAG_ID.DIALOG],
  [TAG_NAMES.DIR, TAG_ID.DIR],
  [TAG_NAMES.DIV, TAG_ID.DIV],
  [TAG_NAMES.DL, TAG_ID.DL],
  [TAG_NAMES.DT, TAG_ID.DT],
  [TAG_NAMES.EM, TAG_ID.EM],
  [TAG_NAMES.EMBED, TAG_ID.EMBED],
  [TAG_NAMES.FIELDSET, TAG_ID.FIELDSET],
  [TAG_NAMES.FIGCAPTION, TAG_ID.FIGCAPTION],
  [TAG_NAMES.FIGURE, TAG_ID.FIGURE],
  [TAG_NAMES.FONT, TAG_ID.FONT],
  [TAG_NAMES.FOOTER, TAG_ID.FOOTER],
  [TAG_NAMES.FOREIGN_OBJECT, TAG_ID.FOREIGN_OBJECT],
  [TAG_NAMES.FORM, TAG_ID.FORM],
  [TAG_NAMES.FRAME, TAG_ID.FRAME],
  [TAG_NAMES.FRAMESET, TAG_ID.FRAMESET],
  [TAG_NAMES.H1, TAG_ID.H1],
  [TAG_NAMES.H2, TAG_ID.H2],
  [TAG_NAMES.H3, TAG_ID.H3],
  [TAG_NAMES.H4, TAG_ID.H4],
  [TAG_NAMES.H5, TAG_ID.H5],
  [TAG_NAMES.H6, TAG_ID.H6],
  [TAG_NAMES.HEAD, TAG_ID.HEAD],
  [TAG_NAMES.HEADER, TAG_ID.HEADER],
  [TAG_NAMES.HGROUP, TAG_ID.HGROUP],
  [TAG_NAMES.HR, TAG_ID.HR],
  [TAG_NAMES.HTML, TAG_ID.HTML],
  [TAG_NAMES.I, TAG_ID.I],
  [TAG_NAMES.IMG, TAG_ID.IMG],
  [TAG_NAMES.IMAGE, TAG_ID.IMAGE],
  [TAG_NAMES.INPUT, TAG_ID.INPUT],
  [TAG_NAMES.IFRAME, TAG_ID.IFRAME],
  [TAG_NAMES.KEYGEN, TAG_ID.KEYGEN],
  [TAG_NAMES.LABEL, TAG_ID.LABEL],
  [TAG_NAMES.LI, TAG_ID.LI],
  [TAG_NAMES.LINK, TAG_ID.LINK],
  [TAG_NAMES.LISTING, TAG_ID.LISTING],
  [TAG_NAMES.MAIN, TAG_ID.MAIN],
  [TAG_NAMES.MALIGNMARK, TAG_ID.MALIGNMARK],
  [TAG_NAMES.MARQUEE, TAG_ID.MARQUEE],
  [TAG_NAMES.MATH, TAG_ID.MATH],
  [TAG_NAMES.MENU, TAG_ID.MENU],
  [TAG_NAMES.META, TAG_ID.META],
  [TAG_NAMES.MGLYPH, TAG_ID.MGLYPH],
  [TAG_NAMES.MI, TAG_ID.MI],
  [TAG_NAMES.MO, TAG_ID.MO],
  [TAG_NAMES.MN, TAG_ID.MN],
  [TAG_NAMES.MS, TAG_ID.MS],
  [TAG_NAMES.MTEXT, TAG_ID.MTEXT],
  [TAG_NAMES.NAV, TAG_ID.NAV],
  [TAG_NAMES.NOBR, TAG_ID.NOBR],
  [TAG_NAMES.NOFRAMES, TAG_ID.NOFRAMES],
  [TAG_NAMES.NOEMBED, TAG_ID.NOEMBED],
  [TAG_NAMES.NOSCRIPT, TAG_ID.NOSCRIPT],
  [TAG_NAMES.OBJECT, TAG_ID.OBJECT],
  [TAG_NAMES.OL, TAG_ID.OL],
  [TAG_NAMES.OPTGROUP, TAG_ID.OPTGROUP],
  [TAG_NAMES.OPTION, TAG_ID.OPTION],
  [TAG_NAMES.P, TAG_ID.P],
  [TAG_NAMES.PARAM, TAG_ID.PARAM],
  [TAG_NAMES.PLAINTEXT, TAG_ID.PLAINTEXT],
  [TAG_NAMES.PRE, TAG_ID.PRE],
  [TAG_NAMES.RB, TAG_ID.RB],
  [TAG_NAMES.RP, TAG_ID.RP],
  [TAG_NAMES.RT, TAG_ID.RT],
  [TAG_NAMES.RTC, TAG_ID.RTC],
  [TAG_NAMES.RUBY, TAG_ID.RUBY],
  [TAG_NAMES.S, TAG_ID.S],
  [TAG_NAMES.SCRIPT, TAG_ID.SCRIPT],
  [TAG_NAMES.SEARCH, TAG_ID.SEARCH],
  [TAG_NAMES.SECTION, TAG_ID.SECTION],
  [TAG_NAMES.SELECT, TAG_ID.SELECT],
  [TAG_NAMES.SOURCE, TAG_ID.SOURCE],
  [TAG_NAMES.SMALL, TAG_ID.SMALL],
  [TAG_NAMES.SPAN, TAG_ID.SPAN],
  [TAG_NAMES.STRIKE, TAG_ID.STRIKE],
  [TAG_NAMES.STRONG, TAG_ID.STRONG],
  [TAG_NAMES.STYLE, TAG_ID.STYLE],
  [TAG_NAMES.SUB, TAG_ID.SUB],
  [TAG_NAMES.SUMMARY, TAG_ID.SUMMARY],
  [TAG_NAMES.SUP, TAG_ID.SUP],
  [TAG_NAMES.TABLE, TAG_ID.TABLE],
  [TAG_NAMES.TBODY, TAG_ID.TBODY],
  [TAG_NAMES.TEMPLATE, TAG_ID.TEMPLATE],
  [TAG_NAMES.TEXTAREA, TAG_ID.TEXTAREA],
  [TAG_NAMES.TFOOT, TAG_ID.TFOOT],
  [TAG_NAMES.TD, TAG_ID.TD],
  [TAG_NAMES.TH, TAG_ID.TH],
  [TAG_NAMES.THEAD, TAG_ID.THEAD],
  [TAG_NAMES.TITLE, TAG_ID.TITLE],
  [TAG_NAMES.TR, TAG_ID.TR],
  [TAG_NAMES.TRACK, TAG_ID.TRACK],
  [TAG_NAMES.TT, TAG_ID.TT],
  [TAG_NAMES.U, TAG_ID.U],
  [TAG_NAMES.UL, TAG_ID.UL],
  [TAG_NAMES.SVG, TAG_ID.SVG],
  [TAG_NAMES.VAR, TAG_ID.VAR],
  [TAG_NAMES.WBR, TAG_ID.WBR],
  [TAG_NAMES.XMP, TAG_ID.XMP]
]);
function getTagID(tagName) {
  var _a3;
  return (_a3 = TAG_NAME_TO_ID.get(tagName)) !== null && _a3 !== void 0 ? _a3 : TAG_ID.UNKNOWN;
}
var $ = TAG_ID;
var SPECIAL_ELEMENTS = {
  [NS.HTML]: /* @__PURE__ */ new Set([
    $.ADDRESS,
    $.APPLET,
    $.AREA,
    $.ARTICLE,
    $.ASIDE,
    $.BASE,
    $.BASEFONT,
    $.BGSOUND,
    $.BLOCKQUOTE,
    $.BODY,
    $.BR,
    $.BUTTON,
    $.CAPTION,
    $.CENTER,
    $.COL,
    $.COLGROUP,
    $.DD,
    $.DETAILS,
    $.DIR,
    $.DIV,
    $.DL,
    $.DT,
    $.EMBED,
    $.FIELDSET,
    $.FIGCAPTION,
    $.FIGURE,
    $.FOOTER,
    $.FORM,
    $.FRAME,
    $.FRAMESET,
    $.H1,
    $.H2,
    $.H3,
    $.H4,
    $.H5,
    $.H6,
    $.HEAD,
    $.HEADER,
    $.HGROUP,
    $.HR,
    $.HTML,
    $.IFRAME,
    $.IMG,
    $.INPUT,
    $.LI,
    $.LINK,
    $.LISTING,
    $.MAIN,
    $.MARQUEE,
    $.MENU,
    $.META,
    $.NAV,
    $.NOEMBED,
    $.NOFRAMES,
    $.NOSCRIPT,
    $.OBJECT,
    $.OL,
    $.P,
    $.PARAM,
    $.PLAINTEXT,
    $.PRE,
    $.SCRIPT,
    $.SECTION,
    $.SELECT,
    $.SOURCE,
    $.STYLE,
    $.SUMMARY,
    $.TABLE,
    $.TBODY,
    $.TD,
    $.TEMPLATE,
    $.TEXTAREA,
    $.TFOOT,
    $.TH,
    $.THEAD,
    $.TITLE,
    $.TR,
    $.TRACK,
    $.UL,
    $.WBR,
    $.XMP
  ]),
  [NS.MATHML]: /* @__PURE__ */ new Set([$.MI, $.MO, $.MN, $.MS, $.MTEXT, $.ANNOTATION_XML]),
  [NS.SVG]: /* @__PURE__ */ new Set([$.TITLE, $.FOREIGN_OBJECT, $.DESC]),
  [NS.XLINK]: /* @__PURE__ */ new Set(),
  [NS.XML]: /* @__PURE__ */ new Set(),
  [NS.XMLNS]: /* @__PURE__ */ new Set()
};
var NUMBERED_HEADERS = /* @__PURE__ */ new Set([$.H1, $.H2, $.H3, $.H4, $.H5, $.H6]);
var UNESCAPED_TEXT = /* @__PURE__ */ new Set([
  TAG_NAMES.STYLE,
  TAG_NAMES.SCRIPT,
  TAG_NAMES.XMP,
  TAG_NAMES.IFRAME,
  TAG_NAMES.NOEMBED,
  TAG_NAMES.NOFRAMES,
  TAG_NAMES.PLAINTEXT
]);
function hasUnescapedText(tn, scriptingEnabled) {
  return UNESCAPED_TEXT.has(tn) || scriptingEnabled && tn === TAG_NAMES.NOSCRIPT;
}

// ../../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/tokenizer/index.js
var State;
(function(State3) {
  State3[State3["DATA"] = 0] = "DATA";
  State3[State3["RCDATA"] = 1] = "RCDATA";
  State3[State3["RAWTEXT"] = 2] = "RAWTEXT";
  State3[State3["SCRIPT_DATA"] = 3] = "SCRIPT_DATA";
  State3[State3["PLAINTEXT"] = 4] = "PLAINTEXT";
  State3[State3["TAG_OPEN"] = 5] = "TAG_OPEN";
  State3[State3["END_TAG_OPEN"] = 6] = "END_TAG_OPEN";
  State3[State3["TAG_NAME"] = 7] = "TAG_NAME";
  State3[State3["RCDATA_LESS_THAN_SIGN"] = 8] = "RCDATA_LESS_THAN_SIGN";
  State3[State3["RCDATA_END_TAG_OPEN"] = 9] = "RCDATA_END_TAG_OPEN";
  State3[State3["RCDATA_END_TAG_NAME"] = 10] = "RCDATA_END_TAG_NAME";
  State3[State3["RAWTEXT_LESS_THAN_SIGN"] = 11] = "RAWTEXT_LESS_THAN_SIGN";
  State3[State3["RAWTEXT_END_TAG_OPEN"] = 12] = "RAWTEXT_END_TAG_OPEN";
  State3[State3["RAWTEXT_END_TAG_NAME"] = 13] = "RAWTEXT_END_TAG_NAME";
  State3[State3["SCRIPT_DATA_LESS_THAN_SIGN"] = 14] = "SCRIPT_DATA_LESS_THAN_SIGN";
  State3[State3["SCRIPT_DATA_END_TAG_OPEN"] = 15] = "SCRIPT_DATA_END_TAG_OPEN";
  State3[State3["SCRIPT_DATA_END_TAG_NAME"] = 16] = "SCRIPT_DATA_END_TAG_NAME";
  State3[State3["SCRIPT_DATA_ESCAPE_START"] = 17] = "SCRIPT_DATA_ESCAPE_START";
  State3[State3["SCRIPT_DATA_ESCAPE_START_DASH"] = 18] = "SCRIPT_DATA_ESCAPE_START_DASH";
  State3[State3["SCRIPT_DATA_ESCAPED"] = 19] = "SCRIPT_DATA_ESCAPED";
  State3[State3["SCRIPT_DATA_ESCAPED_DASH"] = 20] = "SCRIPT_DATA_ESCAPED_DASH";
  State3[State3["SCRIPT_DATA_ESCAPED_DASH_DASH"] = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH";
  State3[State3["SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN"] = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN";
  State3[State3["SCRIPT_DATA_ESCAPED_END_TAG_OPEN"] = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN";
  State3[State3["SCRIPT_DATA_ESCAPED_END_TAG_NAME"] = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME";
  State3[State3["SCRIPT_DATA_DOUBLE_ESCAPE_START"] = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START";
  State3[State3["SCRIPT_DATA_DOUBLE_ESCAPED"] = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED";
  State3[State3["SCRIPT_DATA_DOUBLE_ESCAPED_DASH"] = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH";
  State3[State3["SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH"] = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH";
  State3[State3["SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN"] = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN";
  State3[State3["SCRIPT_DATA_DOUBLE_ESCAPE_END"] = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END";
  State3[State3["BEFORE_ATTRIBUTE_NAME"] = 31] = "BEFORE_ATTRIBUTE_NAME";
  State3[State3["ATTRIBUTE_NAME"] = 32] = "ATTRIBUTE_NAME";
  State3[State3["AFTER_ATTRIBUTE_NAME"] = 33] = "AFTER_ATTRIBUTE_NAME";
  State3[State3["BEFORE_ATTRIBUTE_VALUE"] = 34] = "BEFORE_ATTRIBUTE_VALUE";
  State3[State3["ATTRIBUTE_VALUE_DOUBLE_QUOTED"] = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED";
  State3[State3["ATTRIBUTE_VALUE_SINGLE_QUOTED"] = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED";
  State3[State3["ATTRIBUTE_VALUE_UNQUOTED"] = 37] = "ATTRIBUTE_VALUE_UNQUOTED";
  State3[State3["AFTER_ATTRIBUTE_VALUE_QUOTED"] = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED";
  State3[State3["SELF_CLOSING_START_TAG"] = 39] = "SELF_CLOSING_START_TAG";
  State3[State3["BOGUS_COMMENT"] = 40] = "BOGUS_COMMENT";
  State3[State3["MARKUP_DECLARATION_OPEN"] = 41] = "MARKUP_DECLARATION_OPEN";
  State3[State3["COMMENT_START"] = 42] = "COMMENT_START";
  State3[State3["COMMENT_START_DASH"] = 43] = "COMMENT_START_DASH";
  State3[State3["COMMENT"] = 44] = "COMMENT";
  State3[State3["COMMENT_LESS_THAN_SIGN"] = 45] = "COMMENT_LESS_THAN_SIGN";
  State3[State3["COMMENT_LESS_THAN_SIGN_BANG"] = 46] = "COMMENT_LESS_THAN_SIGN_BANG";
  State3[State3["COMMENT_LESS_THAN_SIGN_BANG_DASH"] = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH";
  State3[State3["COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH"] = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH";
  State3[State3["COMMENT_END_DASH"] = 49] = "COMMENT_END_DASH";
  State3[State3["COMMENT_END"] = 50] = "COMMENT_END";
  State3[State3["COMMENT_END_BANG"] = 51] = "COMMENT_END_BANG";
  State3[State3["DOCTYPE"] = 52] = "DOCTYPE";
  State3[State3["BEFORE_DOCTYPE_NAME"] = 53] = "BEFORE_DOCTYPE_NAME";
  State3[State3["DOCTYPE_NAME"] = 54] = "DOCTYPE_NAME";
  State3[State3["AFTER_DOCTYPE_NAME"] = 55] = "AFTER_DOCTYPE_NAME";
  State3[State3["AFTER_DOCTYPE_PUBLIC_KEYWORD"] = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD";
  State3[State3["BEFORE_DOCTYPE_PUBLIC_IDENTIFIER"] = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER";
  State3[State3["DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED"] = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED";
  State3[State3["DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED"] = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED";
  State3[State3["AFTER_DOCTYPE_PUBLIC_IDENTIFIER"] = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER";
  State3[State3["BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS"] = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS";
  State3[State3["AFTER_DOCTYPE_SYSTEM_KEYWORD"] = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD";
  State3[State3["BEFORE_DOCTYPE_SYSTEM_IDENTIFIER"] = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER";
  State3[State3["DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED"] = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED";
  State3[State3["DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED"] = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED";
  State3[State3["AFTER_DOCTYPE_SYSTEM_IDENTIFIER"] = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER";
  State3[State3["BOGUS_DOCTYPE"] = 67] = "BOGUS_DOCTYPE";
  State3[State3["CDATA_SECTION"] = 68] = "CDATA_SECTION";
  State3[State3["CDATA_SECTION_BRACKET"] = 69] = "CDATA_SECTION_BRACKET";
  State3[State3["CDATA_SECTION_END"] = 70] = "CDATA_SECTION_END";
  State3[State3["CHARACTER_REFERENCE"] = 71] = "CHARACTER_REFERENCE";
  State3[State3["AMBIGUOUS_AMPERSAND"] = 72] = "AMBIGUOUS_AMPERSAND";
})(State || (State = {}));
var TokenizerMode = {
  DATA: State.DATA,
  RCDATA: State.RCDATA,
  RAWTEXT: State.RAWTEXT,
  SCRIPT_DATA: State.SCRIPT_DATA,
  PLAINTEXT: State.PLAINTEXT,
  CDATA_SECTION: State.CDATA_SECTION
};
function isAsciiDigit(cp) {
  return cp >= CODE_POINTS.DIGIT_0 && cp <= CODE_POINTS.DIGIT_9;
}
function isAsciiUpper(cp) {
  return cp >= CODE_POINTS.LATIN_CAPITAL_A && cp <= CODE_POINTS.LATIN_CAPITAL_Z;
}
function isAsciiLower(cp) {
  return cp >= CODE_POINTS.LATIN_SMALL_A && cp <= CODE_POINTS.LATIN_SMALL_Z;
}
function isAsciiLetter(cp) {
  return isAsciiLower(cp) || isAsciiUpper(cp);
}
function isAsciiAlphaNumeric3(cp) {
  return isAsciiLetter(cp) || isAsciiDigit(cp);
}
function toAsciiLower(cp) {
  return cp + 32;
}
function isWhitespace2(cp) {
  return cp === CODE_POINTS.SPACE || cp === CODE_POINTS.LINE_FEED || cp === CODE_POINTS.TABULATION || cp === CODE_POINTS.FORM_FEED;
}
function isScriptDataDoubleEscapeSequenceEnd(cp) {
  return isWhitespace2(cp) || cp === CODE_POINTS.SOLIDUS || cp === CODE_POINTS.GREATER_THAN_SIGN;
}
function getErrorForNumericCharacterReference(code2) {
  if (code2 === CODE_POINTS.NULL) {
    return ERR.nullCharacterReference;
  } else if (code2 > 1114111) {
    return ERR.characterReferenceOutsideUnicodeRange;
  } else if (isSurrogate(code2)) {
    return ERR.surrogateCharacterReference;
  } else if (isUndefinedCodePoint(code2)) {
    return ERR.noncharacterCharacterReference;
  } else if (isControlCodePoint(code2) || code2 === CODE_POINTS.CARRIAGE_RETURN) {
    return ERR.controlCharacterReference;
  }
  return null;
}
var Tokenizer = class {
  constructor(options, handler) {
    this.options = options;
    this.handler = handler;
    this.paused = false;
    this.inLoop = false;
    this.inForeignNode = false;
    this.lastStartTagName = "";
    this.active = false;
    this.state = State.DATA;
    this.returnState = State.DATA;
    this.entityStartPos = 0;
    this.consumedAfterSnapshot = -1;
    this.currentCharacterToken = null;
    this.currentToken = null;
    this.currentAttr = { name: "", value: "" };
    this.preprocessor = new Preprocessor(handler);
    this.currentLocation = this.getCurrentLocation(-1);
    this.entityDecoder = new EntityDecoder2(htmlDecodeTree, (cp, consumed) => {
      this.preprocessor.pos = this.entityStartPos + consumed - 1;
      this._flushCodePointConsumedAsCharacterReference(cp);
    }, handler.onParseError ? {
      missingSemicolonAfterCharacterReference: () => {
        this._err(ERR.missingSemicolonAfterCharacterReference, 1);
      },
      absenceOfDigitsInNumericCharacterReference: (consumed) => {
        this._err(ERR.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + consumed);
      },
      validateNumericCharacterReference: (code2) => {
        const error2 = getErrorForNumericCharacterReference(code2);
        if (error2)
          this._err(error2, 1);
      }
    } : void 0);
  }
  _err(code2, cpOffset = 0) {
    var _a3, _b;
    (_b = (_a3 = this.handler).onParseError) === null || _b === void 0 ? void 0 : _b.call(_a3, this.preprocessor.getError(code2, cpOffset));
  }
  getCurrentLocation(offset) {
    if (!this.options.sourceCodeLocationInfo) {
      return null;
    }
    return {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - offset,
      startOffset: this.preprocessor.offset - offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
  }
  _runParsingLoop() {
    if (this.inLoop)
      return;
    this.inLoop = true;
    while (this.active && !this.paused) {
      this.consumedAfterSnapshot = 0;
      const cp = this._consume();
      if (!this._ensureHibernation()) {
        this._callState(cp);
      }
    }
    this.inLoop = false;
  }
  pause() {
    this.paused = true;
  }
  resume(writeCallback) {
    if (!this.paused) {
      throw new Error("Parser was already resumed");
    }
    this.paused = false;
    if (this.inLoop)
      return;
    this._runParsingLoop();
    if (!this.paused) {
      writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
    }
  }
  write(chunk, isLastChunk, writeCallback) {
    this.active = true;
    this.preprocessor.write(chunk, isLastChunk);
    this._runParsingLoop();
    if (!this.paused) {
      writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
    }
  }
  insertHtmlAtCurrentPos(chunk) {
    this.active = true;
    this.preprocessor.insertHtmlAtCurrentPos(chunk);
    this._runParsingLoop();
  }
  _ensureHibernation() {
    if (this.preprocessor.endOfChunkHit) {
      this.preprocessor.retreat(this.consumedAfterSnapshot);
      this.consumedAfterSnapshot = 0;
      this.active = false;
      return true;
    }
    return false;
  }
  _consume() {
    this.consumedAfterSnapshot++;
    return this.preprocessor.advance();
  }
  _advanceBy(count) {
    this.consumedAfterSnapshot += count;
    for (let i = 0; i < count; i++) {
      this.preprocessor.advance();
    }
  }
  _consumeSequenceIfMatch(pattern, caseSensitive) {
    if (this.preprocessor.startsWith(pattern, caseSensitive)) {
      this._advanceBy(pattern.length - 1);
      return true;
    }
    return false;
  }
  _createStartTagToken() {
    this.currentToken = {
      type: TokenType.START_TAG,
      tagName: "",
      tagID: TAG_ID.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: TokenType.END_TAG,
      tagName: "",
      tagID: TAG_ID.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(offset) {
    this.currentToken = {
      type: TokenType.COMMENT,
      data: "",
      location: this.getCurrentLocation(offset)
    };
  }
  _createDoctypeToken(initialName) {
    this.currentToken = {
      type: TokenType.DOCTYPE,
      name: initialName,
      forceQuirks: false,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(type, chars) {
    this.currentCharacterToken = {
      type,
      chars,
      location: this.currentLocation
    };
  }
  _createAttr(attrNameFirstCh) {
    this.currentAttr = {
      name: attrNameFirstCh,
      value: ""
    };
    this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var _a3;
    var _b;
    const token = this.currentToken;
    if (getTokenAttr(token, this.currentAttr.name) === null) {
      token.attrs.push(this.currentAttr);
      if (token.location && this.currentLocation) {
        const attrLocations = (_a3 = (_b = token.location).attrs) !== null && _a3 !== void 0 ? _a3 : _b.attrs = /* @__PURE__ */ Object.create(null);
        attrLocations[this.currentAttr.name] = this.currentLocation;
        this._leaveAttrValue();
      }
    } else {
      this._err(ERR.duplicateAttribute);
    }
  }
  _leaveAttrValue() {
    if (this.currentLocation) {
      this.currentLocation.endLine = this.preprocessor.line;
      this.currentLocation.endCol = this.preprocessor.col;
      this.currentLocation.endOffset = this.preprocessor.offset;
    }
  }
  prepareToken(ct) {
    this._emitCurrentCharacterToken(ct.location);
    this.currentToken = null;
    if (ct.location) {
      ct.location.endLine = this.preprocessor.line;
      ct.location.endCol = this.preprocessor.col + 1;
      ct.location.endOffset = this.preprocessor.offset + 1;
    }
    this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const ct = this.currentToken;
    this.prepareToken(ct);
    ct.tagID = getTagID(ct.tagName);
    if (ct.type === TokenType.START_TAG) {
      this.lastStartTagName = ct.tagName;
      this.handler.onStartTag(ct);
    } else {
      if (ct.attrs.length > 0) {
        this._err(ERR.endTagWithAttributes);
      }
      if (ct.selfClosing) {
        this._err(ERR.endTagWithTrailingSolidus);
      }
      this.handler.onEndTag(ct);
    }
    this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(ct) {
    this.prepareToken(ct);
    this.handler.onComment(ct);
    this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(ct) {
    this.prepareToken(ct);
    this.handler.onDoctype(ct);
    this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(nextLocation) {
    if (this.currentCharacterToken) {
      if (nextLocation && this.currentCharacterToken.location) {
        this.currentCharacterToken.location.endLine = nextLocation.startLine;
        this.currentCharacterToken.location.endCol = nextLocation.startCol;
        this.currentCharacterToken.location.endOffset = nextLocation.startOffset;
      }
      switch (this.currentCharacterToken.type) {
        case TokenType.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case TokenType.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case TokenType.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const location = this.getCurrentLocation(0);
    if (location) {
      location.endLine = location.startLine;
      location.endCol = location.startCol;
      location.endOffset = location.startOffset;
    }
    this._emitCurrentCharacterToken(location);
    this.handler.onEof({ type: TokenType.EOF, location });
    this.active = false;
  }
  _appendCharToCurrentCharacterToken(type, ch) {
    if (this.currentCharacterToken) {
      if (this.currentCharacterToken.type === type) {
        this.currentCharacterToken.chars += ch;
        return;
      } else {
        this.currentLocation = this.getCurrentLocation(0);
        this._emitCurrentCharacterToken(this.currentLocation);
        this.preprocessor.dropParsedChunk();
      }
    }
    this._createCharacterToken(type, ch);
  }
  _emitCodePoint(cp) {
    const type = isWhitespace2(cp) ? TokenType.WHITESPACE_CHARACTER : cp === CODE_POINTS.NULL ? TokenType.NULL_CHARACTER : TokenType.CHARACTER;
    this._appendCharToCurrentCharacterToken(type, String.fromCodePoint(cp));
  }
  _emitChars(ch) {
    this._appendCharToCurrentCharacterToken(TokenType.CHARACTER, ch);
  }
  _startCharacterReference() {
    this.returnState = this.state;
    this.state = State.CHARACTER_REFERENCE;
    this.entityStartPos = this.preprocessor.pos;
    this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? DecodingMode2.Attribute : DecodingMode2.Legacy);
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === State.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(cp) {
    if (this._isCharacterReferenceInAttribute()) {
      this.currentAttr.value += String.fromCodePoint(cp);
    } else {
      this._emitCodePoint(cp);
    }
  }
  _callState(cp) {
    switch (this.state) {
      case State.DATA: {
        this._stateData(cp);
        break;
      }
      case State.RCDATA: {
        this._stateRcdata(cp);
        break;
      }
      case State.RAWTEXT: {
        this._stateRawtext(cp);
        break;
      }
      case State.SCRIPT_DATA: {
        this._stateScriptData(cp);
        break;
      }
      case State.PLAINTEXT: {
        this._statePlaintext(cp);
        break;
      }
      case State.TAG_OPEN: {
        this._stateTagOpen(cp);
        break;
      }
      case State.END_TAG_OPEN: {
        this._stateEndTagOpen(cp);
        break;
      }
      case State.TAG_NAME: {
        this._stateTagName(cp);
        break;
      }
      case State.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(cp);
        break;
      }
      case State.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(cp);
        break;
      }
      case State.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(cp);
        break;
      }
      case State.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(cp);
        break;
      }
      case State.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(cp);
        break;
      }
      case State.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(cp);
        break;
      }
      case State.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(cp);
        break;
      }
      case State.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(cp);
        break;
      }
      case State.ATTRIBUTE_NAME: {
        this._stateAttributeName(cp);
        break;
      }
      case State.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(cp);
        break;
      }
      case State.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(cp);
        break;
      }
      case State.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(cp);
        break;
      }
      case State.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(cp);
        break;
      }
      case State.BOGUS_COMMENT: {
        this._stateBogusComment(cp);
        break;
      }
      case State.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(cp);
        break;
      }
      case State.COMMENT_START: {
        this._stateCommentStart(cp);
        break;
      }
      case State.COMMENT_START_DASH: {
        this._stateCommentStartDash(cp);
        break;
      }
      case State.COMMENT: {
        this._stateComment(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(cp);
        break;
      }
      case State.COMMENT_END_DASH: {
        this._stateCommentEndDash(cp);
        break;
      }
      case State.COMMENT_END: {
        this._stateCommentEnd(cp);
        break;
      }
      case State.COMMENT_END_BANG: {
        this._stateCommentEndBang(cp);
        break;
      }
      case State.DOCTYPE: {
        this._stateDoctype(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(cp);
        break;
      }
      case State.DOCTYPE_NAME: {
        this._stateDoctypeName(cp);
        break;
      }
      case State.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(cp);
        break;
      }
      case State.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(cp);
        break;
      }
      case State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(cp);
        break;
      }
      case State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(cp);
        break;
      }
      case State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(cp);
        break;
      }
      case State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(cp);
        break;
      }
      case State.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(cp);
        break;
      }
      case State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(cp);
        break;
      }
      case State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(cp);
        break;
      }
      case State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(cp);
        break;
      }
      case State.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(cp);
        break;
      }
      case State.CDATA_SECTION: {
        this._stateCdataSection(cp);
        break;
      }
      case State.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(cp);
        break;
      }
      case State.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(cp);
        break;
      }
      case State.CHARACTER_REFERENCE: {
        this._stateCharacterReference();
        break;
      }
      case State.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(cp);
        break;
      }
      default: {
        throw new Error("Unknown state");
      }
    }
  }
  _stateData(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.TAG_OPEN;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitCodePoint(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  _stateRcdata(cp) {
    switch (cp) {
      case CODE_POINTS.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  _stateRawtext(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  _stateScriptData(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  _statePlaintext(cp) {
    switch (cp) {
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  _stateTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this._createStartTagToken();
      this.state = State.TAG_NAME;
      this._stateTagName(cp);
    } else
      switch (cp) {
        case CODE_POINTS.EXCLAMATION_MARK: {
          this.state = State.MARKUP_DECLARATION_OPEN;
          break;
        }
        case CODE_POINTS.SOLIDUS: {
          this.state = State.END_TAG_OPEN;
          break;
        }
        case CODE_POINTS.QUESTION_MARK: {
          this._err(ERR.unexpectedQuestionMarkInsteadOfTagName);
          this._createCommentToken(1);
          this.state = State.BOGUS_COMMENT;
          this._stateBogusComment(cp);
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofBeforeTagName);
          this._emitChars("<");
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.invalidFirstCharacterOfTagName);
          this._emitChars("<");
          this.state = State.DATA;
          this._stateData(cp);
        }
      }
  }
  _stateEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this._createEndTagToken();
      this.state = State.TAG_NAME;
      this._stateTagName(cp);
    } else
      switch (cp) {
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.missingEndTagName);
          this.state = State.DATA;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofBeforeTagName);
          this._emitChars("</");
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.invalidFirstCharacterOfTagName);
          this._createCommentToken(2);
          this.state = State.BOGUS_COMMENT;
          this._stateBogusComment(cp);
        }
      }
  }
  _stateTagName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.tagName += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        token.tagName += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  _stateRcdataLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.RCDATA_END_TAG_OPEN;
    } else {
      this._emitChars("<");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  _stateRcdataEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.RCDATA_END_TAG_NAME;
      this._stateRcdataEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  handleSpecialEndTag(_cp) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, false)) {
      return !this._ensureHibernation();
    }
    this._createEndTagToken();
    const token = this.currentToken;
    token.tagName = this.lastStartTagName;
    const cp = this.preprocessor.peek(this.lastStartTagName.length);
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._advanceBy(this.lastStartTagName.length);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        return false;
      }
      case CODE_POINTS.SOLIDUS: {
        this._advanceBy(this.lastStartTagName.length);
        this.state = State.SELF_CLOSING_START_TAG;
        return false;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._advanceBy(this.lastStartTagName.length);
        this.emitCurrentTagToken();
        this.state = State.DATA;
        return false;
      }
      default: {
        return !this._ensureHibernation();
      }
    }
  }
  _stateRcdataEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  _stateRawtextLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.RAWTEXT_END_TAG_OPEN;
    } else {
      this._emitChars("<");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  _stateRawtextEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.RAWTEXT_END_TAG_NAME;
      this._stateRawtextEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  _stateRawtextEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  _stateScriptDataLessThanSign(cp) {
    switch (cp) {
      case CODE_POINTS.SOLIDUS: {
        this.state = State.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case CODE_POINTS.EXCLAMATION_MARK: {
        this.state = State.SCRIPT_DATA_ESCAPE_START;
        this._emitChars("<!");
        break;
      }
      default: {
        this._emitChars("<");
        this.state = State.SCRIPT_DATA;
        this._stateScriptData(cp);
      }
    }
  }
  _stateScriptDataEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.SCRIPT_DATA_END_TAG_NAME;
      this._stateScriptDataEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  _stateScriptDataEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  _stateScriptDataEscapeStart(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.SCRIPT_DATA_ESCAPE_START_DASH;
      this._emitChars("-");
    } else {
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  _stateScriptDataEscapeStartDash(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
      this._emitChars("-");
    } else {
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  _stateScriptDataEscaped(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_ESCAPED_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  _stateScriptDataEscapedDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  _stateScriptDataEscapedDashDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.SCRIPT_DATA;
        this._emitChars(">");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  _stateScriptDataEscapedLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN;
    } else if (isAsciiLetter(cp)) {
      this._emitChars("<");
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_START;
      this._stateScriptDataDoubleEscapeStart(cp);
    } else {
      this._emitChars("<");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  _stateScriptDataEscapedEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_NAME;
      this._stateScriptDataEscapedEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  _stateScriptDataEscapedEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  _stateScriptDataDoubleEscapeStart(cp) {
    if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
      this._emitCodePoint(cp);
      for (let i = 0; i < SEQUENCES.SCRIPT.length; i++) {
        this._emitCodePoint(this._consume());
      }
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else if (!this._ensureHibernation()) {
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  _stateScriptDataDoubleEscaped(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  _stateScriptDataDoubleEscapedDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  _stateScriptDataDoubleEscapedDashDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.SCRIPT_DATA;
        this._emitChars(">");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  _stateScriptDataDoubleEscapedLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_END;
      this._emitChars("/");
    } else {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
      this._stateScriptDataDoubleEscaped(cp);
    }
  }
  _stateScriptDataDoubleEscapeEnd(cp) {
    if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
      this._emitCodePoint(cp);
      for (let i = 0; i < SEQUENCES.SCRIPT.length; i++) {
        this._emitCodePoint(this._consume());
      }
      this.state = State.SCRIPT_DATA_ESCAPED;
    } else if (!this._ensureHibernation()) {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
      this._stateScriptDataDoubleEscaped(cp);
    }
  }
  _stateBeforeAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.SOLIDUS:
      case CODE_POINTS.GREATER_THAN_SIGN:
      case CODE_POINTS.EOF: {
        this.state = State.AFTER_ATTRIBUTE_NAME;
        this._stateAfterAttributeName(cp);
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this._err(ERR.unexpectedEqualsSignBeforeAttributeName);
        this._createAttr("=");
        this.state = State.ATTRIBUTE_NAME;
        break;
      }
      default: {
        this._createAttr("");
        this.state = State.ATTRIBUTE_NAME;
        this._stateAttributeName(cp);
      }
    }
  }
  _stateAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED:
      case CODE_POINTS.SOLIDUS:
      case CODE_POINTS.GREATER_THAN_SIGN:
      case CODE_POINTS.EOF: {
        this._leaveAttrName();
        this.state = State.AFTER_ATTRIBUTE_NAME;
        this._stateAfterAttributeName(cp);
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this._leaveAttrName();
        this.state = State.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK:
      case CODE_POINTS.APOSTROPHE:
      case CODE_POINTS.LESS_THAN_SIGN: {
        this._err(ERR.unexpectedCharacterInAttributeName);
        this.currentAttr.name += String.fromCodePoint(cp);
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.name += REPLACEMENT_CHARACTER;
        break;
      }
      default: {
        this.currentAttr.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  _stateAfterAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this.state = State.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._createAttr("");
        this.state = State.ATTRIBUTE_NAME;
        this._stateAttributeName(cp);
      }
    }
  }
  _stateBeforeAttributeValue(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingAttributeValue);
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      default: {
        this.state = State.ATTRIBUTE_VALUE_UNQUOTED;
        this._stateAttributeValueUnquoted(cp);
      }
    }
  }
  _stateAttributeValueDoubleQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  _stateAttributeValueSingleQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  _stateAttributeValueUnquoted(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._leaveAttrValue();
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._leaveAttrValue();
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK:
      case CODE_POINTS.APOSTROPHE:
      case CODE_POINTS.LESS_THAN_SIGN:
      case CODE_POINTS.EQUALS_SIGN:
      case CODE_POINTS.GRAVE_ACCENT: {
        this._err(ERR.unexpectedCharacterInUnquotedAttributeValue);
        this.currentAttr.value += String.fromCodePoint(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  _stateAfterAttributeValueQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._leaveAttrValue();
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this._leaveAttrValue();
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._leaveAttrValue();
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingWhitespaceBetweenAttributes);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        this._stateBeforeAttributeName(cp);
      }
    }
  }
  _stateSelfClosingStartTag(cp) {
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        const token = this.currentToken;
        token.selfClosing = true;
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.unexpectedSolidusInTag);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        this._stateBeforeAttributeName(cp);
      }
    }
  }
  _stateBogusComment(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.data += REPLACEMENT_CHARACTER;
        break;
      }
      default: {
        token.data += String.fromCodePoint(cp);
      }
    }
  }
  _stateMarkupDeclarationOpen(cp) {
    if (this._consumeSequenceIfMatch(SEQUENCES.DASH_DASH, true)) {
      this._createCommentToken(SEQUENCES.DASH_DASH.length + 1);
      this.state = State.COMMENT_START;
    } else if (this._consumeSequenceIfMatch(SEQUENCES.DOCTYPE, false)) {
      this.currentLocation = this.getCurrentLocation(SEQUENCES.DOCTYPE.length + 1);
      this.state = State.DOCTYPE;
    } else if (this._consumeSequenceIfMatch(SEQUENCES.CDATA_START, true)) {
      if (this.inForeignNode) {
        this.state = State.CDATA_SECTION;
      } else {
        this._err(ERR.cdataInHtmlContent);
        this._createCommentToken(SEQUENCES.CDATA_START.length + 1);
        this.currentToken.data = "[CDATA[";
        this.state = State.BOGUS_COMMENT;
      }
    } else if (!this._ensureHibernation()) {
      this._err(ERR.incorrectlyOpenedComment);
      this._createCommentToken(2);
      this.state = State.BOGUS_COMMENT;
      this._stateBogusComment(cp);
    }
  }
  _stateCommentStart(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_START_DASH;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptClosingOfEmptyComment);
        this.state = State.DATA;
        const token = this.currentToken;
        this.emitCurrentComment(token);
        break;
      }
      default: {
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  _stateCommentStartDash(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptClosingOfEmptyComment);
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "-";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  _stateComment(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END_DASH;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        token.data += "<";
        this.state = State.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.data += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += String.fromCodePoint(cp);
      }
    }
  }
  _stateCommentLessThanSign(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.EXCLAMATION_MARK: {
        token.data += "!";
        this.state = State.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        token.data += "<";
        break;
      }
      default: {
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  _stateCommentLessThanSignBang(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH;
    } else {
      this.state = State.COMMENT;
      this._stateComment(cp);
    }
  }
  _stateCommentLessThanSignBangDash(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH;
    } else {
      this.state = State.COMMENT_END_DASH;
      this._stateCommentEndDash(cp);
    }
  }
  _stateCommentLessThanSignBangDashDash(cp) {
    if (cp !== CODE_POINTS.GREATER_THAN_SIGN && cp !== CODE_POINTS.EOF) {
      this._err(ERR.nestedComment);
    }
    this.state = State.COMMENT_END;
    this._stateCommentEnd(cp);
  }
  _stateCommentEndDash(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "-";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  _stateCommentEnd(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EXCLAMATION_MARK: {
        this.state = State.COMMENT_END_BANG;
        break;
      }
      case CODE_POINTS.HYPHEN_MINUS: {
        token.data += "-";
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "--";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  _stateCommentEndBang(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        token.data += "--!";
        this.state = State.COMMENT_END_DASH;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.incorrectlyClosedComment);
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "--!";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  _stateDoctype(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_NAME;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.BEFORE_DOCTYPE_NAME;
        this._stateBeforeDoctypeName(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        this._createDoctypeToken(null);
        const token = this.currentToken;
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingWhitespaceBeforeDoctypeName);
        this.state = State.BEFORE_DOCTYPE_NAME;
        this._stateBeforeDoctypeName(cp);
      }
    }
  }
  _stateBeforeDoctypeName(cp) {
    if (isAsciiUpper(cp)) {
      this._createDoctypeToken(String.fromCharCode(toAsciiLower(cp)));
      this.state = State.DOCTYPE_NAME;
    } else
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          this._createDoctypeToken(REPLACEMENT_CHARACTER);
          this.state = State.DOCTYPE_NAME;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.missingDoctypeName);
          this._createDoctypeToken(null);
          const token = this.currentToken;
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this.state = State.DATA;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInDoctype);
          this._createDoctypeToken(null);
          const token = this.currentToken;
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
        default: {
          this._createDoctypeToken(String.fromCodePoint(cp));
          this.state = State.DOCTYPE_NAME;
        }
      }
  }
  _stateDoctypeName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.AFTER_DOCTYPE_NAME;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.name += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  _stateAfterDoctypeName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        if (this._consumeSequenceIfMatch(SEQUENCES.PUBLIC, false)) {
          this.state = State.AFTER_DOCTYPE_PUBLIC_KEYWORD;
        } else if (this._consumeSequenceIfMatch(SEQUENCES.SYSTEM, false)) {
          this.state = State.AFTER_DOCTYPE_SYSTEM_KEYWORD;
        } else if (!this._ensureHibernation()) {
          this._err(ERR.invalidCharacterSequenceAfterDoctypeName);
          token.forceQuirks = true;
          this.state = State.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
      }
    }
  }
  _stateAfterDoctypePublicKeyword(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  _stateBeforeDoctypePublicIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  _stateDoctypePublicIdentifierDoubleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.publicId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.publicId += String.fromCodePoint(cp);
      }
    }
  }
  _stateDoctypePublicIdentifierSingleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.publicId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.publicId += String.fromCodePoint(cp);
      }
    }
  }
  _stateAfterDoctypePublicIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  _stateBetweenDoctypePublicAndSystemIdentifiers(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  _stateAfterDoctypeSystemKeyword(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  _stateBeforeDoctypeSystemIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  _stateDoctypeSystemIdentifierDoubleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.systemId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.systemId += String.fromCodePoint(cp);
      }
    }
  }
  _stateDoctypeSystemIdentifierSingleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.systemId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.systemId += String.fromCodePoint(cp);
      }
    }
  }
  _stateAfterDoctypeSystemIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  _stateBogusDoctype(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        break;
      }
      case CODE_POINTS.EOF: {
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default:
    }
  }
  _stateCdataSection(cp) {
    switch (cp) {
      case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
        this.state = State.CDATA_SECTION_BRACKET;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInCdata);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  _stateCdataSectionBracket(cp) {
    if (cp === CODE_POINTS.RIGHT_SQUARE_BRACKET) {
      this.state = State.CDATA_SECTION_END;
    } else {
      this._emitChars("]");
      this.state = State.CDATA_SECTION;
      this._stateCdataSection(cp);
    }
  }
  _stateCdataSectionEnd(cp) {
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default: {
        this._emitChars("]]");
        this.state = State.CDATA_SECTION;
        this._stateCdataSection(cp);
      }
    }
  }
  _stateCharacterReference() {
    let length = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos);
    if (length < 0) {
      if (this.preprocessor.lastChunkWritten) {
        length = this.entityDecoder.end();
      } else {
        this.active = false;
        this.preprocessor.pos = this.preprocessor.html.length - 1;
        this.consumedAfterSnapshot = 0;
        this.preprocessor.endOfChunkHit = true;
        return;
      }
    }
    if (length === 0) {
      this.preprocessor.pos = this.entityStartPos;
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
      this.state = !this._isCharacterReferenceInAttribute() && isAsciiAlphaNumeric3(this.preprocessor.peek(1)) ? State.AMBIGUOUS_AMPERSAND : this.returnState;
    } else {
      this.state = this.returnState;
    }
  }
  _stateAmbiguousAmpersand(cp) {
    if (isAsciiAlphaNumeric3(cp)) {
      this._flushCodePointConsumedAsCharacterReference(cp);
    } else {
      if (cp === CODE_POINTS.SEMICOLON) {
        this._err(ERR.unknownNamedCharacterReference);
      }
      this.state = this.returnState;
      this._callState(cp);
    }
  }
};

// ../../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/parser/open-element-stack.js
var IMPLICIT_END_TAG_REQUIRED = /* @__PURE__ */ new Set([TAG_ID.DD, TAG_ID.DT, TAG_ID.LI, TAG_ID.OPTGROUP, TAG_ID.OPTION, TAG_ID.P, TAG_ID.RB, TAG_ID.RP, TAG_ID.RT, TAG_ID.RTC]);
var IMPLICIT_END_TAG_REQUIRED_THOROUGHLY = /* @__PURE__ */ new Set([
  ...IMPLICIT_END_TAG_REQUIRED,
  TAG_ID.CAPTION,
  TAG_ID.COLGROUP,
  TAG_ID.TBODY,
  TAG_ID.TD,
  TAG_ID.TFOOT,
  TAG_ID.TH,
  TAG_ID.THEAD,
  TAG_ID.TR
]);
var SCOPING_ELEMENTS_HTML = /* @__PURE__ */ new Set([
  TAG_ID.APPLET,
  TAG_ID.CAPTION,
  TAG_ID.HTML,
  TAG_ID.MARQUEE,
  TAG_ID.OBJECT,
  TAG_ID.TABLE,
  TAG_ID.TD,
  TAG_ID.TEMPLATE,
  TAG_ID.TH
]);
var SCOPING_ELEMENTS_HTML_LIST = /* @__PURE__ */ new Set([...SCOPING_ELEMENTS_HTML, TAG_ID.OL, TAG_ID.UL]);
var SCOPING_ELEMENTS_HTML_BUTTON = /* @__PURE__ */ new Set([...SCOPING_ELEMENTS_HTML, TAG_ID.BUTTON]);
var SCOPING_ELEMENTS_MATHML = /* @__PURE__ */ new Set([TAG_ID.ANNOTATION_XML, TAG_ID.MI, TAG_ID.MN, TAG_ID.MO, TAG_ID.MS, TAG_ID.MTEXT]);
var SCOPING_ELEMENTS_SVG = /* @__PURE__ */ new Set([TAG_ID.DESC, TAG_ID.FOREIGN_OBJECT, TAG_ID.TITLE]);
var TABLE_ROW_CONTEXT = /* @__PURE__ */ new Set([TAG_ID.TR, TAG_ID.TEMPLATE, TAG_ID.HTML]);
var TABLE_BODY_CONTEXT = /* @__PURE__ */ new Set([TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TEMPLATE, TAG_ID.HTML]);
var TABLE_CONTEXT = /* @__PURE__ */ new Set([TAG_ID.TABLE, TAG_ID.TEMPLATE, TAG_ID.HTML]);
var TABLE_CELLS = /* @__PURE__ */ new Set([TAG_ID.TD, TAG_ID.TH]);
var OpenElementStack = class {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(document2, treeAdapter, handler) {
    this.treeAdapter = treeAdapter;
    this.handler = handler;
    this.items = [];
    this.tagIDs = [];
    this.stackTop = -1;
    this.tmplCount = 0;
    this.currentTagId = TAG_ID.UNKNOWN;
    this.current = document2;
  }
  _indexOf(element) {
    return this.items.lastIndexOf(element, this.stackTop);
  }
  _isInTemplate() {
    return this.currentTagId === TAG_ID.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop];
    this.currentTagId = this.tagIDs[this.stackTop];
  }
  push(element, tagID) {
    this.stackTop++;
    this.items[this.stackTop] = element;
    this.current = element;
    this.tagIDs[this.stackTop] = tagID;
    this.currentTagId = tagID;
    if (this._isInTemplate()) {
      this.tmplCount++;
    }
    this.handler.onItemPush(element, tagID, true);
  }
  pop() {
    const popped = this.current;
    if (this.tmplCount > 0 && this._isInTemplate()) {
      this.tmplCount--;
    }
    this.stackTop--;
    this._updateCurrentElement();
    this.handler.onItemPop(popped, true);
  }
  replace(oldElement, newElement) {
    const idx = this._indexOf(oldElement);
    this.items[idx] = newElement;
    if (idx === this.stackTop) {
      this.current = newElement;
    }
  }
  insertAfter(referenceElement, newElement, newElementID) {
    const insertionIdx = this._indexOf(referenceElement) + 1;
    this.items.splice(insertionIdx, 0, newElement);
    this.tagIDs.splice(insertionIdx, 0, newElementID);
    this.stackTop++;
    if (insertionIdx === this.stackTop) {
      this._updateCurrentElement();
    }
    if (this.current && this.currentTagId !== void 0) {
      this.handler.onItemPush(this.current, this.currentTagId, insertionIdx === this.stackTop);
    }
  }
  popUntilTagNamePopped(tagName) {
    let targetIdx = this.stackTop + 1;
    do {
      targetIdx = this.tagIDs.lastIndexOf(tagName, targetIdx - 1);
    } while (targetIdx > 0 && this.treeAdapter.getNamespaceURI(this.items[targetIdx]) !== NS.HTML);
    this.shortenToLength(Math.max(targetIdx, 0));
  }
  shortenToLength(idx) {
    while (this.stackTop >= idx) {
      const popped = this.current;
      if (this.tmplCount > 0 && this._isInTemplate()) {
        this.tmplCount -= 1;
      }
      this.stackTop--;
      this._updateCurrentElement();
      this.handler.onItemPop(popped, this.stackTop < idx);
    }
  }
  popUntilElementPopped(element) {
    const idx = this._indexOf(element);
    this.shortenToLength(Math.max(idx, 0));
  }
  popUntilPopped(tagNames, targetNS) {
    const idx = this._indexOfTagNames(tagNames, targetNS);
    this.shortenToLength(Math.max(idx, 0));
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(NUMBERED_HEADERS, NS.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(TABLE_CELLS, NS.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0;
    this.shortenToLength(1);
  }
  _indexOfTagNames(tagNames, namespace) {
    for (let i = this.stackTop; i >= 0; i--) {
      if (tagNames.has(this.tagIDs[i]) && this.treeAdapter.getNamespaceURI(this.items[i]) === namespace) {
        return i;
      }
    }
    return -1;
  }
  clearBackTo(tagNames, targetNS) {
    const idx = this._indexOfTagNames(tagNames, targetNS);
    this.shortenToLength(idx + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(TABLE_CONTEXT, NS.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(TABLE_BODY_CONTEXT, NS.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(TABLE_ROW_CONTEXT, NS.HTML);
  }
  remove(element) {
    const idx = this._indexOf(element);
    if (idx >= 0) {
      if (idx === this.stackTop) {
        this.pop();
      } else {
        this.items.splice(idx, 1);
        this.tagIDs.splice(idx, 1);
        this.stackTop--;
        this._updateCurrentElement();
        this.handler.onItemPop(element, false);
      }
    }
  }
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === TAG_ID.BODY ? this.items[1] : null;
  }
  contains(element) {
    return this._indexOf(element) > -1;
  }
  getCommonAncestor(element) {
    const elementIdx = this._indexOf(element) - 1;
    return elementIdx >= 0 ? this.items[elementIdx] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === TAG_ID.HTML;
  }
  hasInDynamicScope(tagName, htmlScope) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      switch (this.treeAdapter.getNamespaceURI(this.items[i])) {
        case NS.HTML: {
          if (tn === tagName)
            return true;
          if (htmlScope.has(tn))
            return false;
          break;
        }
        case NS.SVG: {
          if (SCOPING_ELEMENTS_SVG.has(tn))
            return false;
          break;
        }
        case NS.MATHML: {
          if (SCOPING_ELEMENTS_MATHML.has(tn))
            return false;
          break;
        }
      }
    }
    return true;
  }
  hasInScope(tagName) {
    return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML);
  }
  hasInListItemScope(tagName) {
    return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML_LIST);
  }
  hasInButtonScope(tagName) {
    return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML_BUTTON);
  }
  hasNumberedHeaderInScope() {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      switch (this.treeAdapter.getNamespaceURI(this.items[i])) {
        case NS.HTML: {
          if (NUMBERED_HEADERS.has(tn))
            return true;
          if (SCOPING_ELEMENTS_HTML.has(tn))
            return false;
          break;
        }
        case NS.SVG: {
          if (SCOPING_ELEMENTS_SVG.has(tn))
            return false;
          break;
        }
        case NS.MATHML: {
          if (SCOPING_ELEMENTS_MATHML.has(tn))
            return false;
          break;
        }
      }
    }
    return true;
  }
  hasInTableScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      if (this.treeAdapter.getNamespaceURI(this.items[i]) !== NS.HTML) {
        continue;
      }
      switch (this.tagIDs[i]) {
        case tagName: {
          return true;
        }
        case TAG_ID.TABLE:
        case TAG_ID.HTML: {
          return false;
        }
      }
    }
    return true;
  }
  hasTableBodyContextInTableScope() {
    for (let i = this.stackTop; i >= 0; i--) {
      if (this.treeAdapter.getNamespaceURI(this.items[i]) !== NS.HTML) {
        continue;
      }
      switch (this.tagIDs[i]) {
        case TAG_ID.TBODY:
        case TAG_ID.THEAD:
        case TAG_ID.TFOOT: {
          return true;
        }
        case TAG_ID.TABLE:
        case TAG_ID.HTML: {
          return false;
        }
      }
    }
    return true;
  }
  hasInSelectScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      if (this.treeAdapter.getNamespaceURI(this.items[i]) !== NS.HTML) {
        continue;
      }
      switch (this.tagIDs[i]) {
        case tagName: {
          return true;
        }
        case TAG_ID.OPTION:
        case TAG_ID.OPTGROUP: {
          break;
        }
        default: {
          return false;
        }
      }
    }
    return true;
  }
  generateImpliedEndTags() {
    while (this.currentTagId !== void 0 && IMPLICIT_END_TAG_REQUIRED.has(this.currentTagId)) {
      this.pop();
    }
  }
  generateImpliedEndTagsThoroughly() {
    while (this.currentTagId !== void 0 && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
      this.pop();
    }
  }
  generateImpliedEndTagsWithExclusion(exclusionId) {
    while (this.currentTagId !== void 0 && this.currentTagId !== exclusionId && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
      this.pop();
    }
  }
};

// ../../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/parser/formatting-element-list.js
var NOAH_ARK_CAPACITY = 3;
var EntryType;
(function(EntryType2) {
  EntryType2[EntryType2["Marker"] = 0] = "Marker";
  EntryType2[EntryType2["Element"] = 1] = "Element";
})(EntryType || (EntryType = {}));
var MARKER = { type: EntryType.Marker };
var FormattingElementList = class {
  constructor(treeAdapter) {
    this.treeAdapter = treeAdapter;
    this.entries = [];
    this.bookmark = null;
  }
  _getNoahArkConditionCandidates(newElement, neAttrs) {
    const candidates = [];
    const neAttrsLength = neAttrs.length;
    const neTagName = this.treeAdapter.getTagName(newElement);
    const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
    for (let i = 0; i < this.entries.length; i++) {
      const entry = this.entries[i];
      if (entry.type === EntryType.Marker) {
        break;
      }
      const { element } = entry;
      if (this.treeAdapter.getTagName(element) === neTagName && this.treeAdapter.getNamespaceURI(element) === neNamespaceURI) {
        const elementAttrs = this.treeAdapter.getAttrList(element);
        if (elementAttrs.length === neAttrsLength) {
          candidates.push({ idx: i, attrs: elementAttrs });
        }
      }
    }
    return candidates;
  }
  _ensureNoahArkCondition(newElement) {
    if (this.entries.length < NOAH_ARK_CAPACITY)
      return;
    const neAttrs = this.treeAdapter.getAttrList(newElement);
    const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);
    if (candidates.length < NOAH_ARK_CAPACITY)
      return;
    const neAttrsMap = new Map(neAttrs.map((neAttr) => [neAttr.name, neAttr.value]));
    let validCandidates = 0;
    for (let i = 0; i < candidates.length; i++) {
      const candidate = candidates[i];
      if (candidate.attrs.every((cAttr) => neAttrsMap.get(cAttr.name) === cAttr.value)) {
        validCandidates += 1;
        if (validCandidates >= NOAH_ARK_CAPACITY) {
          this.entries.splice(candidate.idx, 1);
        }
      }
    }
  }
  insertMarker() {
    this.entries.unshift(MARKER);
  }
  pushElement(element, token) {
    this._ensureNoahArkCondition(element);
    this.entries.unshift({
      type: EntryType.Element,
      element,
      token
    });
  }
  insertElementAfterBookmark(element, token) {
    const bookmarkIdx = this.entries.indexOf(this.bookmark);
    this.entries.splice(bookmarkIdx, 0, {
      type: EntryType.Element,
      element,
      token
    });
  }
  removeEntry(entry) {
    const entryIndex = this.entries.indexOf(entry);
    if (entryIndex !== -1) {
      this.entries.splice(entryIndex, 1);
    }
  }
  clearToLastMarker() {
    const markerIdx = this.entries.indexOf(MARKER);
    if (markerIdx === -1) {
      this.entries.length = 0;
    } else {
      this.entries.splice(0, markerIdx + 1);
    }
  }
  getElementEntryInScopeWithTagName(tagName) {
    const entry = this.entries.find((entry2) => entry2.type === EntryType.Marker || this.treeAdapter.getTagName(entry2.element) === tagName);
    return entry && entry.type === EntryType.Element ? entry : null;
  }
  getElementEntry(element) {
    return this.entries.find((entry) => entry.type === EntryType.Element && entry.element === element);
  }
};

// ../../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/tree-adapters/default.js
var defaultTreeAdapter = {
  createDocument() {
    return {
      nodeName: "#document",
      mode: DOCUMENT_MODE.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(tagName, namespaceURI, attrs) {
    return {
      nodeName: tagName,
      tagName,
      attrs,
      namespaceURI,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(data2) {
    return {
      nodeName: "#comment",
      data: data2,
      parentNode: null
    };
  },
  createTextNode(value) {
    return {
      nodeName: "#text",
      value,
      parentNode: null
    };
  },
  appendChild(parentNode, newNode) {
    parentNode.childNodes.push(newNode);
    newNode.parentNode = parentNode;
  },
  insertBefore(parentNode, newNode, referenceNode) {
    const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
    parentNode.childNodes.splice(insertionIdx, 0, newNode);
    newNode.parentNode = parentNode;
  },
  setTemplateContent(templateElement, contentElement) {
    templateElement.content = contentElement;
  },
  getTemplateContent(templateElement) {
    return templateElement.content;
  },
  setDocumentType(document2, name2, publicId, systemId) {
    const doctypeNode = document2.childNodes.find((node) => node.nodeName === "#documentType");
    if (doctypeNode) {
      doctypeNode.name = name2;
      doctypeNode.publicId = publicId;
      doctypeNode.systemId = systemId;
    } else {
      const node = {
        nodeName: "#documentType",
        name: name2,
        publicId,
        systemId,
        parentNode: null
      };
      defaultTreeAdapter.appendChild(document2, node);
    }
  },
  setDocumentMode(document2, mode) {
    document2.mode = mode;
  },
  getDocumentMode(document2) {
    return document2.mode;
  },
  detachNode(node) {
    if (node.parentNode) {
      const idx = node.parentNode.childNodes.indexOf(node);
      node.parentNode.childNodes.splice(idx, 1);
      node.parentNode = null;
    }
  },
  insertText(parentNode, text4) {
    if (parentNode.childNodes.length > 0) {
      const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
      if (defaultTreeAdapter.isTextNode(prevNode)) {
        prevNode.value += text4;
        return;
      }
    }
    defaultTreeAdapter.appendChild(parentNode, defaultTreeAdapter.createTextNode(text4));
  },
  insertTextBefore(parentNode, text4, referenceNode) {
    const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
    if (prevNode && defaultTreeAdapter.isTextNode(prevNode)) {
      prevNode.value += text4;
    } else {
      defaultTreeAdapter.insertBefore(parentNode, defaultTreeAdapter.createTextNode(text4), referenceNode);
    }
  },
  adoptAttributes(recipient, attrs) {
    const recipientAttrsMap = new Set(recipient.attrs.map((attr2) => attr2.name));
    for (let j = 0; j < attrs.length; j++) {
      if (!recipientAttrsMap.has(attrs[j].name)) {
        recipient.attrs.push(attrs[j]);
      }
    }
  },
  getFirstChild(node) {
    return node.childNodes[0];
  },
  getChildNodes(node) {
    return node.childNodes;
  },
  getParentNode(node) {
    return node.parentNode;
  },
  getAttrList(element) {
    return element.attrs;
  },
  getTagName(element) {
    return element.tagName;
  },
  getNamespaceURI(element) {
    return element.namespaceURI;
  },
  getTextNodeContent(textNode) {
    return textNode.value;
  },
  getCommentNodeContent(commentNode) {
    return commentNode.data;
  },
  getDocumentTypeNodeName(doctypeNode) {
    return doctypeNode.name;
  },
  getDocumentTypeNodePublicId(doctypeNode) {
    return doctypeNode.publicId;
  },
  getDocumentTypeNodeSystemId(doctypeNode) {
    return doctypeNode.systemId;
  },
  isTextNode(node) {
    return node.nodeName === "#text";
  },
  isCommentNode(node) {
    return node.nodeName === "#comment";
  },
  isDocumentTypeNode(node) {
    return node.nodeName === "#documentType";
  },
  isElementNode(node) {
    return Object.prototype.hasOwnProperty.call(node, "tagName");
  },
  setNodeSourceCodeLocation(node, location) {
    node.sourceCodeLocation = location;
  },
  getNodeSourceCodeLocation(node) {
    return node.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(node, endLocation) {
    node.sourceCodeLocation = { ...node.sourceCodeLocation, ...endLocation };
  }
};

// ../../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/common/doctype.js
var VALID_DOCTYPE_NAME = "html";
var VALID_SYSTEM_ID = "about:legacy-compat";
var QUIRKS_MODE_SYSTEM_ID = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
var QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
];
var QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
  ...QUIRKS_MODE_PUBLIC_ID_PREFIXES,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
var QUIRKS_MODE_PUBLIC_IDS = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]);
var LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"];
var LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
  ...LIMITED_QUIRKS_PUBLIC_ID_PREFIXES,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function hasPrefix(publicId, prefixes) {
  return prefixes.some((prefix) => publicId.startsWith(prefix));
}
function isConforming(token) {
  return token.name === VALID_DOCTYPE_NAME && token.publicId === null && (token.systemId === null || token.systemId === VALID_SYSTEM_ID);
}
function getDocumentMode(token) {
  if (token.name !== VALID_DOCTYPE_NAME) {
    return DOCUMENT_MODE.QUIRKS;
  }
  const { systemId } = token;
  if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
    return DOCUMENT_MODE.QUIRKS;
  }
  let { publicId } = token;
  if (publicId !== null) {
    publicId = publicId.toLowerCase();
    if (QUIRKS_MODE_PUBLIC_IDS.has(publicId)) {
      return DOCUMENT_MODE.QUIRKS;
    }
    let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return DOCUMENT_MODE.QUIRKS;
    }
    prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return DOCUMENT_MODE.LIMITED_QUIRKS;
    }
  }
  return DOCUMENT_MODE.NO_QUIRKS;
}

// ../../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/common/foreign-content.js
var foreign_content_exports = {};
__export(foreign_content_exports, {
  SVG_TAG_NAMES_ADJUSTMENT_MAP: () => SVG_TAG_NAMES_ADJUSTMENT_MAP,
  adjustTokenMathMLAttrs: () => adjustTokenMathMLAttrs,
  adjustTokenSVGAttrs: () => adjustTokenSVGAttrs,
  adjustTokenSVGTagName: () => adjustTokenSVGTagName,
  adjustTokenXMLAttrs: () => adjustTokenXMLAttrs,
  causesExit: () => causesExit,
  isIntegrationPoint: () => isIntegrationPoint
});
var MIME_TYPES = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
};
var DEFINITION_URL_ATTR = "definitionurl";
var ADJUSTED_DEFINITION_URL_ATTR = "definitionURL";
var SVG_ATTRS_ADJUSTMENT_MAP = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((attr2) => [attr2.toLowerCase(), attr2]));
var XML_ATTRS_ADJUSTMENT_MAP = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: NS.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: NS.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: NS.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: NS.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: NS.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: NS.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: NS.XLINK }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: NS.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: NS.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: NS.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: NS.XMLNS }]
]);
var SVG_TAG_NAMES_ADJUSTMENT_MAP = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((tn) => [tn.toLowerCase(), tn]));
var EXITS_FOREIGN_CONTENT = /* @__PURE__ */ new Set([
  TAG_ID.B,
  TAG_ID.BIG,
  TAG_ID.BLOCKQUOTE,
  TAG_ID.BODY,
  TAG_ID.BR,
  TAG_ID.CENTER,
  TAG_ID.CODE,
  TAG_ID.DD,
  TAG_ID.DIV,
  TAG_ID.DL,
  TAG_ID.DT,
  TAG_ID.EM,
  TAG_ID.EMBED,
  TAG_ID.H1,
  TAG_ID.H2,
  TAG_ID.H3,
  TAG_ID.H4,
  TAG_ID.H5,
  TAG_ID.H6,
  TAG_ID.HEAD,
  TAG_ID.HR,
  TAG_ID.I,
  TAG_ID.IMG,
  TAG_ID.LI,
  TAG_ID.LISTING,
  TAG_ID.MENU,
  TAG_ID.META,
  TAG_ID.NOBR,
  TAG_ID.OL,
  TAG_ID.P,
  TAG_ID.PRE,
  TAG_ID.RUBY,
  TAG_ID.S,
  TAG_ID.SMALL,
  TAG_ID.SPAN,
  TAG_ID.STRONG,
  TAG_ID.STRIKE,
  TAG_ID.SUB,
  TAG_ID.SUP,
  TAG_ID.TABLE,
  TAG_ID.TT,
  TAG_ID.U,
  TAG_ID.UL,
  TAG_ID.VAR
]);
function causesExit(startTagToken) {
  const tn = startTagToken.tagID;
  const isFontWithAttrs = tn === TAG_ID.FONT && startTagToken.attrs.some(({ name: name2 }) => name2 === ATTRS.COLOR || name2 === ATTRS.SIZE || name2 === ATTRS.FACE);
  return isFontWithAttrs || EXITS_FOREIGN_CONTENT.has(tn);
}
function adjustTokenMathMLAttrs(token) {
  for (let i = 0; i < token.attrs.length; i++) {
    if (token.attrs[i].name === DEFINITION_URL_ATTR) {
      token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
      break;
    }
  }
}
function adjustTokenSVGAttrs(token) {
  for (let i = 0; i < token.attrs.length; i++) {
    const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
    if (adjustedAttrName != null) {
      token.attrs[i].name = adjustedAttrName;
    }
  }
}
function adjustTokenXMLAttrs(token) {
  for (let i = 0; i < token.attrs.length; i++) {
    const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
    if (adjustedAttrEntry) {
      token.attrs[i].prefix = adjustedAttrEntry.prefix;
      token.attrs[i].name = adjustedAttrEntry.name;
      token.attrs[i].namespace = adjustedAttrEntry.namespace;
    }
  }
}
function adjustTokenSVGTagName(token) {
  const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP.get(token.tagName);
  if (adjustedTagName != null) {
    token.tagName = adjustedTagName;
    token.tagID = getTagID(token.tagName);
  }
}
function isMathMLTextIntegrationPoint(tn, ns) {
  return ns === NS.MATHML && (tn === TAG_ID.MI || tn === TAG_ID.MO || tn === TAG_ID.MN || tn === TAG_ID.MS || tn === TAG_ID.MTEXT);
}
function isHtmlIntegrationPoint(tn, ns, attrs) {
  if (ns === NS.MATHML && tn === TAG_ID.ANNOTATION_XML) {
    for (let i = 0; i < attrs.length; i++) {
      if (attrs[i].name === ATTRS.ENCODING) {
        const value = attrs[i].value.toLowerCase();
        return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
      }
    }
  }
  return ns === NS.SVG && (tn === TAG_ID.FOREIGN_OBJECT || tn === TAG_ID.DESC || tn === TAG_ID.TITLE);
}
function isIntegrationPoint(tn, ns, attrs, foreignNS) {
  return (!foreignNS || foreignNS === NS.HTML) && isHtmlIntegrationPoint(tn, ns, attrs) || (!foreignNS || foreignNS === NS.MATHML) && isMathMLTextIntegrationPoint(tn, ns);
}

// ../../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/parser/index.js
var HIDDEN_INPUT_TYPE = "hidden";
var AA_OUTER_LOOP_ITER = 8;
var AA_INNER_LOOP_ITER = 3;
var InsertionMode;
(function(InsertionMode2) {
  InsertionMode2[InsertionMode2["INITIAL"] = 0] = "INITIAL";
  InsertionMode2[InsertionMode2["BEFORE_HTML"] = 1] = "BEFORE_HTML";
  InsertionMode2[InsertionMode2["BEFORE_HEAD"] = 2] = "BEFORE_HEAD";
  InsertionMode2[InsertionMode2["IN_HEAD"] = 3] = "IN_HEAD";
  InsertionMode2[InsertionMode2["IN_HEAD_NO_SCRIPT"] = 4] = "IN_HEAD_NO_SCRIPT";
  InsertionMode2[InsertionMode2["AFTER_HEAD"] = 5] = "AFTER_HEAD";
  InsertionMode2[InsertionMode2["IN_BODY"] = 6] = "IN_BODY";
  InsertionMode2[InsertionMode2["TEXT"] = 7] = "TEXT";
  InsertionMode2[InsertionMode2["IN_TABLE"] = 8] = "IN_TABLE";
  InsertionMode2[InsertionMode2["IN_TABLE_TEXT"] = 9] = "IN_TABLE_TEXT";
  InsertionMode2[InsertionMode2["IN_CAPTION"] = 10] = "IN_CAPTION";
  InsertionMode2[InsertionMode2["IN_COLUMN_GROUP"] = 11] = "IN_COLUMN_GROUP";
  InsertionMode2[InsertionMode2["IN_TABLE_BODY"] = 12] = "IN_TABLE_BODY";
  InsertionMode2[InsertionMode2["IN_ROW"] = 13] = "IN_ROW";
  InsertionMode2[InsertionMode2["IN_CELL"] = 14] = "IN_CELL";
  InsertionMode2[InsertionMode2["IN_SELECT"] = 15] = "IN_SELECT";
  InsertionMode2[InsertionMode2["IN_SELECT_IN_TABLE"] = 16] = "IN_SELECT_IN_TABLE";
  InsertionMode2[InsertionMode2["IN_TEMPLATE"] = 17] = "IN_TEMPLATE";
  InsertionMode2[InsertionMode2["AFTER_BODY"] = 18] = "AFTER_BODY";
  InsertionMode2[InsertionMode2["IN_FRAMESET"] = 19] = "IN_FRAMESET";
  InsertionMode2[InsertionMode2["AFTER_FRAMESET"] = 20] = "AFTER_FRAMESET";
  InsertionMode2[InsertionMode2["AFTER_AFTER_BODY"] = 21] = "AFTER_AFTER_BODY";
  InsertionMode2[InsertionMode2["AFTER_AFTER_FRAMESET"] = 22] = "AFTER_AFTER_FRAMESET";
})(InsertionMode || (InsertionMode = {}));
var BASE_LOC = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
};
var TABLE_STRUCTURE_TAGS = /* @__PURE__ */ new Set([TAG_ID.TABLE, TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TR]);
var defaultParserOptions = {
  scriptingEnabled: true,
  sourceCodeLocationInfo: false,
  treeAdapter: defaultTreeAdapter,
  onParseError: null
};
var Parser = class {
  constructor(options, document2, fragmentContext = null, scriptHandler = null) {
    this.fragmentContext = fragmentContext;
    this.scriptHandler = scriptHandler;
    this.currentToken = null;
    this.stopped = false;
    this.insertionMode = InsertionMode.INITIAL;
    this.originalInsertionMode = InsertionMode.INITIAL;
    this.headElement = null;
    this.formElement = null;
    this.currentNotInHTML = false;
    this.tmplInsertionModeStack = [];
    this.pendingCharacterTokens = [];
    this.hasNonWhitespacePendingCharacterToken = false;
    this.framesetOk = true;
    this.skipNextNewLine = false;
    this.fosterParentingEnabled = false;
    this.options = {
      ...defaultParserOptions,
      ...options
    };
    this.treeAdapter = this.options.treeAdapter;
    this.onParseError = this.options.onParseError;
    if (this.onParseError) {
      this.options.sourceCodeLocationInfo = true;
    }
    this.document = document2 !== null && document2 !== void 0 ? document2 : this.treeAdapter.createDocument();
    this.tokenizer = new Tokenizer(this.options, this);
    this.activeFormattingElements = new FormattingElementList(this.treeAdapter);
    this.fragmentContextID = fragmentContext ? getTagID(this.treeAdapter.getTagName(fragmentContext)) : TAG_ID.UNKNOWN;
    this._setContextModes(fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : this.document, this.fragmentContextID);
    this.openElements = new OpenElementStack(this.document, this.treeAdapter, this);
  }
  static parse(html3, options) {
    const parser = new this(options);
    parser.tokenizer.write(html3, true);
    return parser.document;
  }
  static getFragmentParser(fragmentContext, options) {
    const opts = {
      ...defaultParserOptions,
      ...options
    };
    fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : fragmentContext = opts.treeAdapter.createElement(TAG_NAMES.TEMPLATE, NS.HTML, []);
    const documentMock = opts.treeAdapter.createElement("documentmock", NS.HTML, []);
    const parser = new this(opts, documentMock, fragmentContext);
    if (parser.fragmentContextID === TAG_ID.TEMPLATE) {
      parser.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
    }
    parser._initTokenizerForFragmentParsing();
    parser._insertFakeRootElement();
    parser._resetInsertionMode();
    parser._findFormInFragmentContext();
    return parser;
  }
  getFragment() {
    const rootElement = this.treeAdapter.getFirstChild(this.document);
    const fragment = this.treeAdapter.createDocumentFragment();
    this._adoptNodes(rootElement, fragment);
    return fragment;
  }
  _err(token, code2, beforeToken) {
    var _a3;
    if (!this.onParseError)
      return;
    const loc = (_a3 = token.location) !== null && _a3 !== void 0 ? _a3 : BASE_LOC;
    const err = {
      code: code2,
      startLine: loc.startLine,
      startCol: loc.startCol,
      startOffset: loc.startOffset,
      endLine: beforeToken ? loc.startLine : loc.endLine,
      endCol: beforeToken ? loc.startCol : loc.endCol,
      endOffset: beforeToken ? loc.startOffset : loc.endOffset
    };
    this.onParseError(err);
  }
  onItemPush(node, tid, isTop) {
    var _a3, _b;
    (_b = (_a3 = this.treeAdapter).onItemPush) === null || _b === void 0 ? void 0 : _b.call(_a3, node);
    if (isTop && this.openElements.stackTop > 0)
      this._setContextModes(node, tid);
  }
  onItemPop(node, isTop) {
    var _a3, _b;
    if (this.options.sourceCodeLocationInfo) {
      this._setEndLocation(node, this.currentToken);
    }
    (_b = (_a3 = this.treeAdapter).onItemPop) === null || _b === void 0 ? void 0 : _b.call(_a3, node, this.openElements.current);
    if (isTop) {
      let current;
      let currentTagId;
      if (this.openElements.stackTop === 0 && this.fragmentContext) {
        current = this.fragmentContext;
        currentTagId = this.fragmentContextID;
      } else {
        ({ current, currentTagId } = this.openElements);
      }
      this._setContextModes(current, currentTagId);
    }
  }
  _setContextModes(current, tid) {
    const isHTML = current === this.document || current && this.treeAdapter.getNamespaceURI(current) === NS.HTML;
    this.currentNotInHTML = !isHTML;
    this.tokenizer.inForeignNode = !isHTML && current !== void 0 && tid !== void 0 && !this._isIntegrationPoint(tid, current);
  }
  _switchToTextParsing(currentToken, nextTokenizerState) {
    this._insertElement(currentToken, NS.HTML);
    this.tokenizer.state = nextTokenizerState;
    this.originalInsertionMode = this.insertionMode;
    this.insertionMode = InsertionMode.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = InsertionMode.TEXT;
    this.originalInsertionMode = InsertionMode.IN_BODY;
    this.tokenizer.state = TokenizerMode.PLAINTEXT;
  }
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  _findFormInFragmentContext() {
    let node = this.fragmentContext;
    while (node) {
      if (this.treeAdapter.getTagName(node) === TAG_NAMES.FORM) {
        this.formElement = node;
        break;
      }
      node = this.treeAdapter.getParentNode(node);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== NS.HTML) {
      return;
    }
    switch (this.fragmentContextID) {
      case TAG_ID.TITLE:
      case TAG_ID.TEXTAREA: {
        this.tokenizer.state = TokenizerMode.RCDATA;
        break;
      }
      case TAG_ID.STYLE:
      case TAG_ID.XMP:
      case TAG_ID.IFRAME:
      case TAG_ID.NOEMBED:
      case TAG_ID.NOFRAMES:
      case TAG_ID.NOSCRIPT: {
        this.tokenizer.state = TokenizerMode.RAWTEXT;
        break;
      }
      case TAG_ID.SCRIPT: {
        this.tokenizer.state = TokenizerMode.SCRIPT_DATA;
        break;
      }
      case TAG_ID.PLAINTEXT: {
        this.tokenizer.state = TokenizerMode.PLAINTEXT;
        break;
      }
      default:
    }
  }
  _setDocumentType(token) {
    const name2 = token.name || "";
    const publicId = token.publicId || "";
    const systemId = token.systemId || "";
    this.treeAdapter.setDocumentType(this.document, name2, publicId, systemId);
    if (token.location) {
      const documentChildren = this.treeAdapter.getChildNodes(this.document);
      const docTypeNode = documentChildren.find((node) => this.treeAdapter.isDocumentTypeNode(node));
      if (docTypeNode) {
        this.treeAdapter.setNodeSourceCodeLocation(docTypeNode, token.location);
      }
    }
  }
  _attachElementToTree(element, location) {
    if (this.options.sourceCodeLocationInfo) {
      const loc = location && {
        ...location,
        startTag: location
      };
      this.treeAdapter.setNodeSourceCodeLocation(element, loc);
    }
    if (this._shouldFosterParentOnInsertion()) {
      this._fosterParentElement(element);
    } else {
      const parent2 = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(parent2 !== null && parent2 !== void 0 ? parent2 : this.document, element);
    }
  }
  _appendElement(token, namespaceURI) {
    const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
    this._attachElementToTree(element, token.location);
  }
  _insertElement(token, namespaceURI) {
    const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
    this._attachElementToTree(element, token.location);
    this.openElements.push(element, token.tagID);
  }
  _insertFakeElement(tagName, tagID) {
    const element = this.treeAdapter.createElement(tagName, NS.HTML, []);
    this._attachElementToTree(element, null);
    this.openElements.push(element, tagID);
  }
  _insertTemplate(token) {
    const tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs);
    const content = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(tmpl, content);
    this._attachElementToTree(tmpl, token.location);
    this.openElements.push(tmpl, token.tagID);
    if (this.options.sourceCodeLocationInfo)
      this.treeAdapter.setNodeSourceCodeLocation(content, null);
  }
  _insertFakeRootElement() {
    const element = this.treeAdapter.createElement(TAG_NAMES.HTML, NS.HTML, []);
    if (this.options.sourceCodeLocationInfo)
      this.treeAdapter.setNodeSourceCodeLocation(element, null);
    this.treeAdapter.appendChild(this.openElements.current, element);
    this.openElements.push(element, TAG_ID.HTML);
  }
  _appendCommentNode(token, parent2) {
    const commentNode = this.treeAdapter.createCommentNode(token.data);
    this.treeAdapter.appendChild(parent2, commentNode);
    if (this.options.sourceCodeLocationInfo) {
      this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
    }
  }
  _insertCharacters(token) {
    let parent2;
    let beforeElement;
    if (this._shouldFosterParentOnInsertion()) {
      ({ parent: parent2, beforeElement } = this._findFosterParentingLocation());
      if (beforeElement) {
        this.treeAdapter.insertTextBefore(parent2, token.chars, beforeElement);
      } else {
        this.treeAdapter.insertText(parent2, token.chars);
      }
    } else {
      parent2 = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.insertText(parent2, token.chars);
    }
    if (!token.location)
      return;
    const siblings2 = this.treeAdapter.getChildNodes(parent2);
    const textNodeIdx = beforeElement ? siblings2.lastIndexOf(beforeElement) : siblings2.length;
    const textNode = siblings2[textNodeIdx - 1];
    const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
    if (tnLoc) {
      const { endLine, endCol, endOffset } = token.location;
      this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });
    } else if (this.options.sourceCodeLocationInfo) {
      this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
    }
  }
  _adoptNodes(donor, recipient) {
    for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
      this.treeAdapter.detachNode(child);
      this.treeAdapter.appendChild(recipient, child);
    }
  }
  _setEndLocation(element, closingToken) {
    if (this.treeAdapter.getNodeSourceCodeLocation(element) && closingToken.location) {
      const ctLoc = closingToken.location;
      const tn = this.treeAdapter.getTagName(element);
      const endLoc = closingToken.type === TokenType.END_TAG && tn === closingToken.tagName ? {
        endTag: { ...ctLoc },
        endLine: ctLoc.endLine,
        endCol: ctLoc.endCol,
        endOffset: ctLoc.endOffset
      } : {
        endLine: ctLoc.startLine,
        endCol: ctLoc.startCol,
        endOffset: ctLoc.startOffset
      };
      this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);
    }
  }
  shouldProcessStartTagTokenInForeignContent(token) {
    if (!this.currentNotInHTML)
      return false;
    let current;
    let currentTagId;
    if (this.openElements.stackTop === 0 && this.fragmentContext) {
      current = this.fragmentContext;
      currentTagId = this.fragmentContextID;
    } else {
      ({ current, currentTagId } = this.openElements);
    }
    if (token.tagID === TAG_ID.SVG && this.treeAdapter.getTagName(current) === TAG_NAMES.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(current) === NS.MATHML) {
      return false;
    }
    return this.tokenizer.inForeignNode || (token.tagID === TAG_ID.MGLYPH || token.tagID === TAG_ID.MALIGNMARK) && currentTagId !== void 0 && !this._isIntegrationPoint(currentTagId, current, NS.HTML);
  }
  _processToken(token) {
    switch (token.type) {
      case TokenType.CHARACTER: {
        this.onCharacter(token);
        break;
      }
      case TokenType.NULL_CHARACTER: {
        this.onNullCharacter(token);
        break;
      }
      case TokenType.COMMENT: {
        this.onComment(token);
        break;
      }
      case TokenType.DOCTYPE: {
        this.onDoctype(token);
        break;
      }
      case TokenType.START_TAG: {
        this._processStartTag(token);
        break;
      }
      case TokenType.END_TAG: {
        this.onEndTag(token);
        break;
      }
      case TokenType.EOF: {
        this.onEof(token);
        break;
      }
      case TokenType.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(token);
        break;
      }
    }
  }
  _isIntegrationPoint(tid, element, foreignNS) {
    const ns = this.treeAdapter.getNamespaceURI(element);
    const attrs = this.treeAdapter.getAttrList(element);
    return isIntegrationPoint(tid, ns, attrs, foreignNS);
  }
  _reconstructActiveFormattingElements() {
    const listLength = this.activeFormattingElements.entries.length;
    if (listLength) {
      const endIndex = this.activeFormattingElements.entries.findIndex((entry) => entry.type === EntryType.Marker || this.openElements.contains(entry.element));
      const unopenIdx = endIndex === -1 ? listLength - 1 : endIndex - 1;
      for (let i = unopenIdx; i >= 0; i--) {
        const entry = this.activeFormattingElements.entries[i];
        this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
        entry.element = this.openElements.current;
      }
    }
  }
  _closeTableCell() {
    this.openElements.generateImpliedEndTags();
    this.openElements.popUntilTableCellPopped();
    this.activeFormattingElements.clearToLastMarker();
    this.insertionMode = InsertionMode.IN_ROW;
  }
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.P);
    this.openElements.popUntilTagNamePopped(TAG_ID.P);
  }
  _resetInsertionMode() {
    for (let i = this.openElements.stackTop; i >= 0; i--) {
      switch (i === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[i]) {
        case TAG_ID.TR: {
          this.insertionMode = InsertionMode.IN_ROW;
          return;
        }
        case TAG_ID.TBODY:
        case TAG_ID.THEAD:
        case TAG_ID.TFOOT: {
          this.insertionMode = InsertionMode.IN_TABLE_BODY;
          return;
        }
        case TAG_ID.CAPTION: {
          this.insertionMode = InsertionMode.IN_CAPTION;
          return;
        }
        case TAG_ID.COLGROUP: {
          this.insertionMode = InsertionMode.IN_COLUMN_GROUP;
          return;
        }
        case TAG_ID.TABLE: {
          this.insertionMode = InsertionMode.IN_TABLE;
          return;
        }
        case TAG_ID.BODY: {
          this.insertionMode = InsertionMode.IN_BODY;
          return;
        }
        case TAG_ID.FRAMESET: {
          this.insertionMode = InsertionMode.IN_FRAMESET;
          return;
        }
        case TAG_ID.SELECT: {
          this._resetInsertionModeForSelect(i);
          return;
        }
        case TAG_ID.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case TAG_ID.HTML: {
          this.insertionMode = this.headElement ? InsertionMode.AFTER_HEAD : InsertionMode.BEFORE_HEAD;
          return;
        }
        case TAG_ID.TD:
        case TAG_ID.TH: {
          if (i > 0) {
            this.insertionMode = InsertionMode.IN_CELL;
            return;
          }
          break;
        }
        case TAG_ID.HEAD: {
          if (i > 0) {
            this.insertionMode = InsertionMode.IN_HEAD;
            return;
          }
          break;
        }
      }
    }
    this.insertionMode = InsertionMode.IN_BODY;
  }
  _resetInsertionModeForSelect(selectIdx) {
    if (selectIdx > 0) {
      for (let i = selectIdx - 1; i > 0; i--) {
        const tn = this.openElements.tagIDs[i];
        if (tn === TAG_ID.TEMPLATE) {
          break;
        } else if (tn === TAG_ID.TABLE) {
          this.insertionMode = InsertionMode.IN_SELECT_IN_TABLE;
          return;
        }
      }
    }
    this.insertionMode = InsertionMode.IN_SELECT;
  }
  _isElementCausesFosterParenting(tn) {
    return TABLE_STRUCTURE_TAGS.has(tn);
  }
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this.openElements.currentTagId !== void 0 && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  _findFosterParentingLocation() {
    for (let i = this.openElements.stackTop; i >= 0; i--) {
      const openElement = this.openElements.items[i];
      switch (this.openElements.tagIDs[i]) {
        case TAG_ID.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(openElement) === NS.HTML) {
            return { parent: this.treeAdapter.getTemplateContent(openElement), beforeElement: null };
          }
          break;
        }
        case TAG_ID.TABLE: {
          const parent2 = this.treeAdapter.getParentNode(openElement);
          if (parent2) {
            return { parent: parent2, beforeElement: openElement };
          }
          return { parent: this.openElements.items[i - 1], beforeElement: null };
        }
        default:
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  _fosterParentElement(element) {
    const location = this._findFosterParentingLocation();
    if (location.beforeElement) {
      this.treeAdapter.insertBefore(location.parent, element, location.beforeElement);
    } else {
      this.treeAdapter.appendChild(location.parent, element);
    }
  }
  _isSpecialElement(element, id) {
    const ns = this.treeAdapter.getNamespaceURI(element);
    return SPECIAL_ELEMENTS[ns].has(id);
  }
  onCharacter(token) {
    this.skipNextNewLine = false;
    if (this.tokenizer.inForeignNode) {
      characterInForeignContent(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE: {
        characterInBody(this, token);
        break;
      }
      case InsertionMode.TEXT:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        characterInTableText(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        tokenInColumnGroup(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        tokenAfterBody(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token);
        break;
      }
      default:
    }
  }
  onNullCharacter(token) {
    this.skipNextNewLine = false;
    if (this.tokenizer.inForeignNode) {
      nullCharacterInForeignContent(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        tokenInColumnGroup(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        tokenAfterBody(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token);
        break;
      }
      default:
    }
  }
  onComment(token) {
    this.skipNextNewLine = false;
    if (this.currentNotInHTML) {
      appendComment(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL:
      case InsertionMode.BEFORE_HTML:
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET: {
        appendComment(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        appendCommentToRootHtmlElement(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        appendCommentToDocument(this, token);
        break;
      }
      default:
    }
  }
  onDoctype(token) {
    this.skipNextNewLine = false;
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        doctypeInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD: {
        this._err(token, ERR.misplacedDoctype);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      default:
    }
  }
  onStartTag(token) {
    this.skipNextNewLine = false;
    this.currentToken = token;
    this._processStartTag(token);
    if (token.selfClosing && !token.ackSelfClosing) {
      this._err(token, ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
    }
  }
  _processStartTag(token) {
    if (this.shouldProcessStartTagTokenInForeignContent(token)) {
      startTagInForeignContent(this, token);
    } else {
      this._startTagOutsideForeignContent(token);
    }
  }
  _startTagOutsideForeignContent(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        startTagBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        startTagBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        startTagInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        startTagInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        startTagAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY: {
        startTagInBody(this, token);
        break;
      }
      case InsertionMode.IN_TABLE: {
        startTagInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.IN_CAPTION: {
        startTagInCaption(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        startTagInColumnGroup(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_BODY: {
        startTagInTableBody(this, token);
        break;
      }
      case InsertionMode.IN_ROW: {
        startTagInRow(this, token);
        break;
      }
      case InsertionMode.IN_CELL: {
        startTagInCell(this, token);
        break;
      }
      case InsertionMode.IN_SELECT: {
        startTagInSelect(this, token);
        break;
      }
      case InsertionMode.IN_SELECT_IN_TABLE: {
        startTagInSelectInTable(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        startTagInTemplate(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        startTagAfterBody(this, token);
        break;
      }
      case InsertionMode.IN_FRAMESET: {
        startTagInFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_FRAMESET: {
        startTagAfterFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        startTagAfterAfterBody(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        startTagAfterAfterFrameset(this, token);
        break;
      }
      default:
    }
  }
  onEndTag(token) {
    this.skipNextNewLine = false;
    this.currentToken = token;
    if (this.currentNotInHTML) {
      endTagInForeignContent(this, token);
    } else {
      this._endTagOutsideForeignContent(token);
    }
  }
  _endTagOutsideForeignContent(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        endTagBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        endTagBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        endTagInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        endTagInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        endTagAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY: {
        endTagInBody(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        endTagInText(this, token);
        break;
      }
      case InsertionMode.IN_TABLE: {
        endTagInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.IN_CAPTION: {
        endTagInCaption(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        endTagInColumnGroup(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_BODY: {
        endTagInTableBody(this, token);
        break;
      }
      case InsertionMode.IN_ROW: {
        endTagInRow(this, token);
        break;
      }
      case InsertionMode.IN_CELL: {
        endTagInCell(this, token);
        break;
      }
      case InsertionMode.IN_SELECT: {
        endTagInSelect(this, token);
        break;
      }
      case InsertionMode.IN_SELECT_IN_TABLE: {
        endTagInSelectInTable(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        endTagInTemplate(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        endTagAfterBody(this, token);
        break;
      }
      case InsertionMode.IN_FRAMESET: {
        endTagInFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_FRAMESET: {
        endTagAfterFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token);
        break;
      }
      default:
    }
  }
  onEof(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE: {
        eofInBody(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        eofInText(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        eofInTemplate(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        stopParsing(this, token);
        break;
      }
      default:
    }
  }
  onWhitespaceCharacter(token) {
    if (this.skipNextNewLine) {
      this.skipNextNewLine = false;
      if (token.chars.charCodeAt(0) === CODE_POINTS.LINE_FEED) {
        if (token.chars.length === 1) {
          return;
        }
        token.chars = token.chars.substr(1);
      }
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.TEXT:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.AFTER_BODY:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        whitespaceCharacterInBody(this, token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        whitespaceCharacterInTableText(this, token);
        break;
      }
      default:
    }
  }
};
function aaObtainFormattingElementEntry(p, token) {
  let formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);
  if (formattingElementEntry) {
    if (!p.openElements.contains(formattingElementEntry.element)) {
      p.activeFormattingElements.removeEntry(formattingElementEntry);
      formattingElementEntry = null;
    } else if (!p.openElements.hasInScope(token.tagID)) {
      formattingElementEntry = null;
    }
  } else {
    genericEndTagInBody(p, token);
  }
  return formattingElementEntry;
}
function aaObtainFurthestBlock(p, formattingElementEntry) {
  let furthestBlock = null;
  let idx = p.openElements.stackTop;
  for (; idx >= 0; idx--) {
    const element = p.openElements.items[idx];
    if (element === formattingElementEntry.element) {
      break;
    }
    if (p._isSpecialElement(element, p.openElements.tagIDs[idx])) {
      furthestBlock = element;
    }
  }
  if (!furthestBlock) {
    p.openElements.shortenToLength(Math.max(idx, 0));
    p.activeFormattingElements.removeEntry(formattingElementEntry);
  }
  return furthestBlock;
}
function aaInnerLoop(p, furthestBlock, formattingElement) {
  let lastElement = furthestBlock;
  let nextElement = p.openElements.getCommonAncestor(furthestBlock);
  for (let i = 0, element = nextElement; element !== formattingElement; i++, element = nextElement) {
    nextElement = p.openElements.getCommonAncestor(element);
    const elementEntry = p.activeFormattingElements.getElementEntry(element);
    const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;
    const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
    if (shouldRemoveFromOpenElements) {
      if (counterOverflow) {
        p.activeFormattingElements.removeEntry(elementEntry);
      }
      p.openElements.remove(element);
    } else {
      element = aaRecreateElementFromEntry(p, elementEntry);
      if (lastElement === furthestBlock) {
        p.activeFormattingElements.bookmark = elementEntry;
      }
      p.treeAdapter.detachNode(lastElement);
      p.treeAdapter.appendChild(element, lastElement);
      lastElement = element;
    }
  }
  return lastElement;
}
function aaRecreateElementFromEntry(p, elementEntry) {
  const ns = p.treeAdapter.getNamespaceURI(elementEntry.element);
  const newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);
  p.openElements.replace(elementEntry.element, newElement);
  elementEntry.element = newElement;
  return newElement;
}
function aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement) {
  const tn = p.treeAdapter.getTagName(commonAncestor);
  const tid = getTagID(tn);
  if (p._isElementCausesFosterParenting(tid)) {
    p._fosterParentElement(lastElement);
  } else {
    const ns = p.treeAdapter.getNamespaceURI(commonAncestor);
    if (tid === TAG_ID.TEMPLATE && ns === NS.HTML) {
      commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);
    }
    p.treeAdapter.appendChild(commonAncestor, lastElement);
  }
}
function aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry) {
  const ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element);
  const { token } = formattingElementEntry;
  const newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);
  p._adoptNodes(furthestBlock, newElement);
  p.treeAdapter.appendChild(furthestBlock, newElement);
  p.activeFormattingElements.insertElementAfterBookmark(newElement, token);
  p.activeFormattingElements.removeEntry(formattingElementEntry);
  p.openElements.remove(formattingElementEntry.element);
  p.openElements.insertAfter(furthestBlock, newElement, token.tagID);
}
function callAdoptionAgency(p, token) {
  for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {
    const formattingElementEntry = aaObtainFormattingElementEntry(p, token);
    if (!formattingElementEntry) {
      break;
    }
    const furthestBlock = aaObtainFurthestBlock(p, formattingElementEntry);
    if (!furthestBlock) {
      break;
    }
    p.activeFormattingElements.bookmark = formattingElementEntry;
    const lastElement = aaInnerLoop(p, furthestBlock, formattingElementEntry.element);
    const commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);
    p.treeAdapter.detachNode(lastElement);
    if (commonAncestor)
      aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement);
    aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry);
  }
}
function appendComment(p, token) {
  p._appendCommentNode(token, p.openElements.currentTmplContentOrNode);
}
function appendCommentToRootHtmlElement(p, token) {
  p._appendCommentNode(token, p.openElements.items[0]);
}
function appendCommentToDocument(p, token) {
  p._appendCommentNode(token, p.document);
}
function stopParsing(p, token) {
  p.stopped = true;
  if (token.location) {
    const target = p.fragmentContext ? 0 : 2;
    for (let i = p.openElements.stackTop; i >= target; i--) {
      p._setEndLocation(p.openElements.items[i], token);
    }
    if (!p.fragmentContext && p.openElements.stackTop >= 0) {
      const htmlElement = p.openElements.items[0];
      const htmlLocation = p.treeAdapter.getNodeSourceCodeLocation(htmlElement);
      if (htmlLocation && !htmlLocation.endTag) {
        p._setEndLocation(htmlElement, token);
        if (p.openElements.stackTop >= 1) {
          const bodyElement = p.openElements.items[1];
          const bodyLocation = p.treeAdapter.getNodeSourceCodeLocation(bodyElement);
          if (bodyLocation && !bodyLocation.endTag) {
            p._setEndLocation(bodyElement, token);
          }
        }
      }
    }
  }
}
function doctypeInInitialMode(p, token) {
  p._setDocumentType(token);
  const mode = token.forceQuirks ? DOCUMENT_MODE.QUIRKS : getDocumentMode(token);
  if (!isConforming(token)) {
    p._err(token, ERR.nonConformingDoctype);
  }
  p.treeAdapter.setDocumentMode(p.document, mode);
  p.insertionMode = InsertionMode.BEFORE_HTML;
}
function tokenInInitialMode(p, token) {
  p._err(token, ERR.missingDoctype, true);
  p.treeAdapter.setDocumentMode(p.document, DOCUMENT_MODE.QUIRKS);
  p.insertionMode = InsertionMode.BEFORE_HTML;
  p._processToken(token);
}
function startTagBeforeHtml(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    p._insertElement(token, NS.HTML);
    p.insertionMode = InsertionMode.BEFORE_HEAD;
  } else {
    tokenBeforeHtml(p, token);
  }
}
function endTagBeforeHtml(p, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.HTML || tn === TAG_ID.HEAD || tn === TAG_ID.BODY || tn === TAG_ID.BR) {
    tokenBeforeHtml(p, token);
  }
}
function tokenBeforeHtml(p, token) {
  p._insertFakeRootElement();
  p.insertionMode = InsertionMode.BEFORE_HEAD;
  p._processToken(token);
}
function startTagBeforeHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.HEAD: {
      p._insertElement(token, NS.HTML);
      p.headElement = p.openElements.current;
      p.insertionMode = InsertionMode.IN_HEAD;
      break;
    }
    default: {
      tokenBeforeHead(p, token);
    }
  }
}
function endTagBeforeHead(p, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.HEAD || tn === TAG_ID.BODY || tn === TAG_ID.HTML || tn === TAG_ID.BR) {
    tokenBeforeHead(p, token);
  } else {
    p._err(token, ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenBeforeHead(p, token) {
  p._insertFakeElement(TAG_NAMES.HEAD, TAG_ID.HEAD);
  p.headElement = p.openElements.current;
  p.insertionMode = InsertionMode.IN_HEAD;
  p._processToken(token);
}
function startTagInHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META: {
      p._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.TITLE: {
      p._switchToTextParsing(token, TokenizerMode.RCDATA);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      if (p.options.scriptingEnabled) {
        p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
      } else {
        p._insertElement(token, NS.HTML);
        p.insertionMode = InsertionMode.IN_HEAD_NO_SCRIPT;
      }
      break;
    }
    case TAG_ID.NOFRAMES:
    case TAG_ID.STYLE: {
      p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
      break;
    }
    case TAG_ID.SCRIPT: {
      p._switchToTextParsing(token, TokenizerMode.SCRIPT_DATA);
      break;
    }
    case TAG_ID.TEMPLATE: {
      p._insertTemplate(token);
      p.activeFormattingElements.insertMarker();
      p.framesetOk = false;
      p.insertionMode = InsertionMode.IN_TEMPLATE;
      p.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
      break;
    }
    case TAG_ID.HEAD: {
      p._err(token, ERR.misplacedStartTagForHeadElement);
      break;
    }
    default: {
      tokenInHead(p, token);
    }
  }
}
function endTagInHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.HEAD: {
      p.openElements.pop();
      p.insertionMode = InsertionMode.AFTER_HEAD;
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.BR:
    case TAG_ID.HTML: {
      tokenInHead(p, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    default: {
      p._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function templateEndTagInHead(p, token) {
  if (p.openElements.tmplCount > 0) {
    p.openElements.generateImpliedEndTagsThoroughly();
    if (p.openElements.currentTagId !== TAG_ID.TEMPLATE) {
      p._err(token, ERR.closingOfElementWithOpenChildElements);
    }
    p.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
    p.activeFormattingElements.clearToLastMarker();
    p.tmplInsertionModeStack.shift();
    p._resetInsertionMode();
  } else {
    p._err(token, ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenInHead(p, token) {
  p.openElements.pop();
  p.insertionMode = InsertionMode.AFTER_HEAD;
  p._processToken(token);
}
function startTagInHeadNoScript(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.HEAD:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.STYLE: {
      startTagInHead(p, token);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      p._err(token, ERR.nestedNoscriptInHead);
      break;
    }
    default: {
      tokenInHeadNoScript(p, token);
    }
  }
}
function endTagInHeadNoScript(p, token) {
  switch (token.tagID) {
    case TAG_ID.NOSCRIPT: {
      p.openElements.pop();
      p.insertionMode = InsertionMode.IN_HEAD;
      break;
    }
    case TAG_ID.BR: {
      tokenInHeadNoScript(p, token);
      break;
    }
    default: {
      p._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function tokenInHeadNoScript(p, token) {
  const errCode = token.type === TokenType.EOF ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;
  p._err(token, errCode);
  p.openElements.pop();
  p.insertionMode = InsertionMode.IN_HEAD;
  p._processToken(token);
}
function startTagAfterHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.BODY: {
      p._insertElement(token, NS.HTML);
      p.framesetOk = false;
      p.insertionMode = InsertionMode.IN_BODY;
      break;
    }
    case TAG_ID.FRAMESET: {
      p._insertElement(token, NS.HTML);
      p.insertionMode = InsertionMode.IN_FRAMESET;
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.SCRIPT:
    case TAG_ID.STYLE:
    case TAG_ID.TEMPLATE:
    case TAG_ID.TITLE: {
      p._err(token, ERR.abandonedHeadElementChild);
      p.openElements.push(p.headElement, TAG_ID.HEAD);
      startTagInHead(p, token);
      p.openElements.remove(p.headElement);
      break;
    }
    case TAG_ID.HEAD: {
      p._err(token, ERR.misplacedStartTagForHeadElement);
      break;
    }
    default: {
      tokenAfterHead(p, token);
    }
  }
}
function endTagAfterHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.BODY:
    case TAG_ID.HTML:
    case TAG_ID.BR: {
      tokenAfterHead(p, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    default: {
      p._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function tokenAfterHead(p, token) {
  p._insertFakeElement(TAG_NAMES.BODY, TAG_ID.BODY);
  p.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p, token);
}
function modeInBody(p, token) {
  switch (token.type) {
    case TokenType.CHARACTER: {
      characterInBody(p, token);
      break;
    }
    case TokenType.WHITESPACE_CHARACTER: {
      whitespaceCharacterInBody(p, token);
      break;
    }
    case TokenType.COMMENT: {
      appendComment(p, token);
      break;
    }
    case TokenType.START_TAG: {
      startTagInBody(p, token);
      break;
    }
    case TokenType.END_TAG: {
      endTagInBody(p, token);
      break;
    }
    case TokenType.EOF: {
      eofInBody(p, token);
      break;
    }
    default:
  }
}
function whitespaceCharacterInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertCharacters(token);
}
function characterInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertCharacters(token);
  p.framesetOk = false;
}
function htmlStartTagInBody(p, token) {
  if (p.openElements.tmplCount === 0) {
    p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);
  }
}
function bodyStartTagInBody(p, token) {
  const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
  if (bodyElement && p.openElements.tmplCount === 0) {
    p.framesetOk = false;
    p.treeAdapter.adoptAttributes(bodyElement, token.attrs);
  }
}
function framesetStartTagInBody(p, token) {
  const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
  if (p.framesetOk && bodyElement) {
    p.treeAdapter.detachNode(bodyElement);
    p.openElements.popAllUpToHtmlElement();
    p._insertElement(token, NS.HTML);
    p.insertionMode = InsertionMode.IN_FRAMESET;
  }
}
function addressStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
}
function numberedHeaderStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  if (p.openElements.currentTagId !== void 0 && NUMBERED_HEADERS.has(p.openElements.currentTagId)) {
    p.openElements.pop();
  }
  p._insertElement(token, NS.HTML);
}
function preStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
  p.skipNextNewLine = true;
  p.framesetOk = false;
}
function formStartTagInBody(p, token) {
  const inTemplate = p.openElements.tmplCount > 0;
  if (!p.formElement || inTemplate) {
    if (p.openElements.hasInButtonScope(TAG_ID.P)) {
      p._closePElement();
    }
    p._insertElement(token, NS.HTML);
    if (!inTemplate) {
      p.formElement = p.openElements.current;
    }
  }
}
function listItemStartTagInBody(p, token) {
  p.framesetOk = false;
  const tn = token.tagID;
  for (let i = p.openElements.stackTop; i >= 0; i--) {
    const elementId = p.openElements.tagIDs[i];
    if (tn === TAG_ID.LI && elementId === TAG_ID.LI || (tn === TAG_ID.DD || tn === TAG_ID.DT) && (elementId === TAG_ID.DD || elementId === TAG_ID.DT)) {
      p.openElements.generateImpliedEndTagsWithExclusion(elementId);
      p.openElements.popUntilTagNamePopped(elementId);
      break;
    }
    if (elementId !== TAG_ID.ADDRESS && elementId !== TAG_ID.DIV && elementId !== TAG_ID.P && p._isSpecialElement(p.openElements.items[i], elementId)) {
      break;
    }
  }
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
}
function plaintextStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
  p.tokenizer.state = TokenizerMode.PLAINTEXT;
}
function buttonStartTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.BUTTON)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(TAG_ID.BUTTON);
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.framesetOk = false;
}
function aStartTagInBody(p, token) {
  const activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(TAG_NAMES.A);
  if (activeElementEntry) {
    callAdoptionAgency(p, token);
    p.openElements.remove(activeElementEntry.element);
    p.activeFormattingElements.removeEntry(activeElementEntry);
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function bStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function nobrStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  if (p.openElements.hasInScope(TAG_ID.NOBR)) {
    callAdoptionAgency(p, token);
    p._reconstructActiveFormattingElements();
  }
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function appletStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.insertMarker();
  p.framesetOk = false;
}
function tableStartTagInBody(p, token) {
  if (p.treeAdapter.getDocumentMode(p.document) !== DOCUMENT_MODE.QUIRKS && p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
  p.framesetOk = false;
  p.insertionMode = InsertionMode.IN_TABLE;
}
function areaStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._appendElement(token, NS.HTML);
  p.framesetOk = false;
  token.ackSelfClosing = true;
}
function isHiddenInput(token) {
  const inputType = getTokenAttr(token, ATTRS.TYPE);
  return inputType != null && inputType.toLowerCase() === HIDDEN_INPUT_TYPE;
}
function inputStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._appendElement(token, NS.HTML);
  if (!isHiddenInput(token)) {
    p.framesetOk = false;
  }
  token.ackSelfClosing = true;
}
function paramStartTagInBody(p, token) {
  p._appendElement(token, NS.HTML);
  token.ackSelfClosing = true;
}
function hrStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._appendElement(token, NS.HTML);
  p.framesetOk = false;
  token.ackSelfClosing = true;
}
function imageStartTagInBody(p, token) {
  token.tagName = TAG_NAMES.IMG;
  token.tagID = TAG_ID.IMG;
  areaStartTagInBody(p, token);
}
function textareaStartTagInBody(p, token) {
  p._insertElement(token, NS.HTML);
  p.skipNextNewLine = true;
  p.tokenizer.state = TokenizerMode.RCDATA;
  p.originalInsertionMode = p.insertionMode;
  p.framesetOk = false;
  p.insertionMode = InsertionMode.TEXT;
}
function xmpStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._reconstructActiveFormattingElements();
  p.framesetOk = false;
  p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function iframeStartTagInBody(p, token) {
  p.framesetOk = false;
  p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function rawTextStartTagInBody(p, token) {
  p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function selectStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.framesetOk = false;
  p.insertionMode = p.insertionMode === InsertionMode.IN_TABLE || p.insertionMode === InsertionMode.IN_CAPTION || p.insertionMode === InsertionMode.IN_TABLE_BODY || p.insertionMode === InsertionMode.IN_ROW || p.insertionMode === InsertionMode.IN_CELL ? InsertionMode.IN_SELECT_IN_TABLE : InsertionMode.IN_SELECT;
}
function optgroupStartTagInBody(p, token) {
  if (p.openElements.currentTagId === TAG_ID.OPTION) {
    p.openElements.pop();
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
}
function rbStartTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.RUBY)) {
    p.openElements.generateImpliedEndTags();
  }
  p._insertElement(token, NS.HTML);
}
function rtStartTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.RUBY)) {
    p.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.RTC);
  }
  p._insertElement(token, NS.HTML);
}
function mathStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  adjustTokenMathMLAttrs(token);
  adjustTokenXMLAttrs(token);
  if (token.selfClosing) {
    p._appendElement(token, NS.MATHML);
  } else {
    p._insertElement(token, NS.MATHML);
  }
  token.ackSelfClosing = true;
}
function svgStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  adjustTokenSVGAttrs(token);
  adjustTokenXMLAttrs(token);
  if (token.selfClosing) {
    p._appendElement(token, NS.SVG);
  } else {
    p._insertElement(token, NS.SVG);
  }
  token.ackSelfClosing = true;
}
function genericStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
}
function startTagInBody(p, token) {
  switch (token.tagID) {
    case TAG_ID.I:
    case TAG_ID.S:
    case TAG_ID.B:
    case TAG_ID.U:
    case TAG_ID.EM:
    case TAG_ID.TT:
    case TAG_ID.BIG:
    case TAG_ID.CODE:
    case TAG_ID.FONT:
    case TAG_ID.SMALL:
    case TAG_ID.STRIKE:
    case TAG_ID.STRONG: {
      bStartTagInBody(p, token);
      break;
    }
    case TAG_ID.A: {
      aStartTagInBody(p, token);
      break;
    }
    case TAG_ID.H1:
    case TAG_ID.H2:
    case TAG_ID.H3:
    case TAG_ID.H4:
    case TAG_ID.H5:
    case TAG_ID.H6: {
      numberedHeaderStartTagInBody(p, token);
      break;
    }
    case TAG_ID.P:
    case TAG_ID.DL:
    case TAG_ID.OL:
    case TAG_ID.UL:
    case TAG_ID.DIV:
    case TAG_ID.DIR:
    case TAG_ID.NAV:
    case TAG_ID.MAIN:
    case TAG_ID.MENU:
    case TAG_ID.ASIDE:
    case TAG_ID.CENTER:
    case TAG_ID.FIGURE:
    case TAG_ID.FOOTER:
    case TAG_ID.HEADER:
    case TAG_ID.HGROUP:
    case TAG_ID.DIALOG:
    case TAG_ID.DETAILS:
    case TAG_ID.ADDRESS:
    case TAG_ID.ARTICLE:
    case TAG_ID.SEARCH:
    case TAG_ID.SECTION:
    case TAG_ID.SUMMARY:
    case TAG_ID.FIELDSET:
    case TAG_ID.BLOCKQUOTE:
    case TAG_ID.FIGCAPTION: {
      addressStartTagInBody(p, token);
      break;
    }
    case TAG_ID.LI:
    case TAG_ID.DD:
    case TAG_ID.DT: {
      listItemStartTagInBody(p, token);
      break;
    }
    case TAG_ID.BR:
    case TAG_ID.IMG:
    case TAG_ID.WBR:
    case TAG_ID.AREA:
    case TAG_ID.EMBED:
    case TAG_ID.KEYGEN: {
      areaStartTagInBody(p, token);
      break;
    }
    case TAG_ID.HR: {
      hrStartTagInBody(p, token);
      break;
    }
    case TAG_ID.RB:
    case TAG_ID.RTC: {
      rbStartTagInBody(p, token);
      break;
    }
    case TAG_ID.RT:
    case TAG_ID.RP: {
      rtStartTagInBody(p, token);
      break;
    }
    case TAG_ID.PRE:
    case TAG_ID.LISTING: {
      preStartTagInBody(p, token);
      break;
    }
    case TAG_ID.XMP: {
      xmpStartTagInBody(p, token);
      break;
    }
    case TAG_ID.SVG: {
      svgStartTagInBody(p, token);
      break;
    }
    case TAG_ID.HTML: {
      htmlStartTagInBody(p, token);
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.STYLE:
    case TAG_ID.TITLE:
    case TAG_ID.SCRIPT:
    case TAG_ID.BGSOUND:
    case TAG_ID.BASEFONT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(p, token);
      break;
    }
    case TAG_ID.BODY: {
      bodyStartTagInBody(p, token);
      break;
    }
    case TAG_ID.FORM: {
      formStartTagInBody(p, token);
      break;
    }
    case TAG_ID.NOBR: {
      nobrStartTagInBody(p, token);
      break;
    }
    case TAG_ID.MATH: {
      mathStartTagInBody(p, token);
      break;
    }
    case TAG_ID.TABLE: {
      tableStartTagInBody(p, token);
      break;
    }
    case TAG_ID.INPUT: {
      inputStartTagInBody(p, token);
      break;
    }
    case TAG_ID.PARAM:
    case TAG_ID.TRACK:
    case TAG_ID.SOURCE: {
      paramStartTagInBody(p, token);
      break;
    }
    case TAG_ID.IMAGE: {
      imageStartTagInBody(p, token);
      break;
    }
    case TAG_ID.BUTTON: {
      buttonStartTagInBody(p, token);
      break;
    }
    case TAG_ID.APPLET:
    case TAG_ID.OBJECT:
    case TAG_ID.MARQUEE: {
      appletStartTagInBody(p, token);
      break;
    }
    case TAG_ID.IFRAME: {
      iframeStartTagInBody(p, token);
      break;
    }
    case TAG_ID.SELECT: {
      selectStartTagInBody(p, token);
      break;
    }
    case TAG_ID.OPTION:
    case TAG_ID.OPTGROUP: {
      optgroupStartTagInBody(p, token);
      break;
    }
    case TAG_ID.NOEMBED:
    case TAG_ID.NOFRAMES: {
      rawTextStartTagInBody(p, token);
      break;
    }
    case TAG_ID.FRAMESET: {
      framesetStartTagInBody(p, token);
      break;
    }
    case TAG_ID.TEXTAREA: {
      textareaStartTagInBody(p, token);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      if (p.options.scriptingEnabled) {
        rawTextStartTagInBody(p, token);
      } else {
        genericStartTagInBody(p, token);
      }
      break;
    }
    case TAG_ID.PLAINTEXT: {
      plaintextStartTagInBody(p, token);
      break;
    }
    case TAG_ID.COL:
    case TAG_ID.TH:
    case TAG_ID.TD:
    case TAG_ID.TR:
    case TAG_ID.HEAD:
    case TAG_ID.FRAME:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.CAPTION:
    case TAG_ID.COLGROUP: {
      break;
    }
    default: {
      genericStartTagInBody(p, token);
    }
  }
}
function bodyEndTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.BODY)) {
    p.insertionMode = InsertionMode.AFTER_BODY;
    if (p.options.sourceCodeLocationInfo) {
      const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
      if (bodyElement) {
        p._setEndLocation(bodyElement, token);
      }
    }
  }
}
function htmlEndTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.BODY)) {
    p.insertionMode = InsertionMode.AFTER_BODY;
    endTagAfterBody(p, token);
  }
}
function addressEndTagInBody(p, token) {
  const tn = token.tagID;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(tn);
  }
}
function formEndTagInBody(p) {
  const inTemplate = p.openElements.tmplCount > 0;
  const { formElement } = p;
  if (!inTemplate) {
    p.formElement = null;
  }
  if ((formElement || inTemplate) && p.openElements.hasInScope(TAG_ID.FORM)) {
    p.openElements.generateImpliedEndTags();
    if (inTemplate) {
      p.openElements.popUntilTagNamePopped(TAG_ID.FORM);
    } else if (formElement) {
      p.openElements.remove(formElement);
    }
  }
}
function pEndTagInBody(p) {
  if (!p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._insertFakeElement(TAG_NAMES.P, TAG_ID.P);
  }
  p._closePElement();
}
function liEndTagInBody(p) {
  if (p.openElements.hasInListItemScope(TAG_ID.LI)) {
    p.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.LI);
    p.openElements.popUntilTagNamePopped(TAG_ID.LI);
  }
}
function ddEndTagInBody(p, token) {
  const tn = token.tagID;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTagsWithExclusion(tn);
    p.openElements.popUntilTagNamePopped(tn);
  }
}
function numberedHeaderEndTagInBody(p) {
  if (p.openElements.hasNumberedHeaderInScope()) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilNumberedHeaderPopped();
  }
}
function appletEndTagInBody(p, token) {
  const tn = token.tagID;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(tn);
    p.activeFormattingElements.clearToLastMarker();
  }
}
function brEndTagInBody(p) {
  p._reconstructActiveFormattingElements();
  p._insertFakeElement(TAG_NAMES.BR, TAG_ID.BR);
  p.openElements.pop();
  p.framesetOk = false;
}
function genericEndTagInBody(p, token) {
  const tn = token.tagName;
  const tid = token.tagID;
  for (let i = p.openElements.stackTop; i > 0; i--) {
    const element = p.openElements.items[i];
    const elementId = p.openElements.tagIDs[i];
    if (tid === elementId && (tid !== TAG_ID.UNKNOWN || p.treeAdapter.getTagName(element) === tn)) {
      p.openElements.generateImpliedEndTagsWithExclusion(tid);
      if (p.openElements.stackTop >= i)
        p.openElements.shortenToLength(i);
      break;
    }
    if (p._isSpecialElement(element, elementId)) {
      break;
    }
  }
}
function endTagInBody(p, token) {
  switch (token.tagID) {
    case TAG_ID.A:
    case TAG_ID.B:
    case TAG_ID.I:
    case TAG_ID.S:
    case TAG_ID.U:
    case TAG_ID.EM:
    case TAG_ID.TT:
    case TAG_ID.BIG:
    case TAG_ID.CODE:
    case TAG_ID.FONT:
    case TAG_ID.NOBR:
    case TAG_ID.SMALL:
    case TAG_ID.STRIKE:
    case TAG_ID.STRONG: {
      callAdoptionAgency(p, token);
      break;
    }
    case TAG_ID.P: {
      pEndTagInBody(p);
      break;
    }
    case TAG_ID.DL:
    case TAG_ID.UL:
    case TAG_ID.OL:
    case TAG_ID.DIR:
    case TAG_ID.DIV:
    case TAG_ID.NAV:
    case TAG_ID.PRE:
    case TAG_ID.MAIN:
    case TAG_ID.MENU:
    case TAG_ID.ASIDE:
    case TAG_ID.BUTTON:
    case TAG_ID.CENTER:
    case TAG_ID.FIGURE:
    case TAG_ID.FOOTER:
    case TAG_ID.HEADER:
    case TAG_ID.HGROUP:
    case TAG_ID.DIALOG:
    case TAG_ID.ADDRESS:
    case TAG_ID.ARTICLE:
    case TAG_ID.DETAILS:
    case TAG_ID.SEARCH:
    case TAG_ID.SECTION:
    case TAG_ID.SUMMARY:
    case TAG_ID.LISTING:
    case TAG_ID.FIELDSET:
    case TAG_ID.BLOCKQUOTE:
    case TAG_ID.FIGCAPTION: {
      addressEndTagInBody(p, token);
      break;
    }
    case TAG_ID.LI: {
      liEndTagInBody(p);
      break;
    }
    case TAG_ID.DD:
    case TAG_ID.DT: {
      ddEndTagInBody(p, token);
      break;
    }
    case TAG_ID.H1:
    case TAG_ID.H2:
    case TAG_ID.H3:
    case TAG_ID.H4:
    case TAG_ID.H5:
    case TAG_ID.H6: {
      numberedHeaderEndTagInBody(p);
      break;
    }
    case TAG_ID.BR: {
      brEndTagInBody(p);
      break;
    }
    case TAG_ID.BODY: {
      bodyEndTagInBody(p, token);
      break;
    }
    case TAG_ID.HTML: {
      htmlEndTagInBody(p, token);
      break;
    }
    case TAG_ID.FORM: {
      formEndTagInBody(p);
      break;
    }
    case TAG_ID.APPLET:
    case TAG_ID.OBJECT:
    case TAG_ID.MARQUEE: {
      appletEndTagInBody(p, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    default: {
      genericEndTagInBody(p, token);
    }
  }
}
function eofInBody(p, token) {
  if (p.tmplInsertionModeStack.length > 0) {
    eofInTemplate(p, token);
  } else {
    stopParsing(p, token);
  }
}
function endTagInText(p, token) {
  var _a3;
  if (token.tagID === TAG_ID.SCRIPT) {
    (_a3 = p.scriptHandler) === null || _a3 === void 0 ? void 0 : _a3.call(p, p.openElements.current);
  }
  p.openElements.pop();
  p.insertionMode = p.originalInsertionMode;
}
function eofInText(p, token) {
  p._err(token, ERR.eofInElementThatCanContainOnlyText);
  p.openElements.pop();
  p.insertionMode = p.originalInsertionMode;
  p.onEof(token);
}
function characterInTable(p, token) {
  if (p.openElements.currentTagId !== void 0 && TABLE_STRUCTURE_TAGS.has(p.openElements.currentTagId)) {
    p.pendingCharacterTokens.length = 0;
    p.hasNonWhitespacePendingCharacterToken = false;
    p.originalInsertionMode = p.insertionMode;
    p.insertionMode = InsertionMode.IN_TABLE_TEXT;
    switch (token.type) {
      case TokenType.CHARACTER: {
        characterInTableText(p, token);
        break;
      }
      case TokenType.WHITESPACE_CHARACTER: {
        whitespaceCharacterInTableText(p, token);
        break;
      }
    }
  } else {
    tokenInTable(p, token);
  }
}
function captionStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p.activeFormattingElements.insertMarker();
  p._insertElement(token, NS.HTML);
  p.insertionMode = InsertionMode.IN_CAPTION;
}
function colgroupStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertElement(token, NS.HTML);
  p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
}
function colStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertFakeElement(TAG_NAMES.COLGROUP, TAG_ID.COLGROUP);
  p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
  startTagInColumnGroup(p, token);
}
function tbodyStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertElement(token, NS.HTML);
  p.insertionMode = InsertionMode.IN_TABLE_BODY;
}
function tdStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertFakeElement(TAG_NAMES.TBODY, TAG_ID.TBODY);
  p.insertionMode = InsertionMode.IN_TABLE_BODY;
  startTagInTableBody(p, token);
}
function tableStartTagInTable(p, token) {
  if (p.openElements.hasInTableScope(TAG_ID.TABLE)) {
    p.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
    p._resetInsertionMode();
    p._processStartTag(token);
  }
}
function inputStartTagInTable(p, token) {
  if (isHiddenInput(token)) {
    p._appendElement(token, NS.HTML);
  } else {
    tokenInTable(p, token);
  }
  token.ackSelfClosing = true;
}
function formStartTagInTable(p, token) {
  if (!p.formElement && p.openElements.tmplCount === 0) {
    p._insertElement(token, NS.HTML);
    p.formElement = p.openElements.current;
    p.openElements.pop();
  }
}
function startTagInTable(p, token) {
  switch (token.tagID) {
    case TAG_ID.TD:
    case TAG_ID.TH:
    case TAG_ID.TR: {
      tdStartTagInTable(p, token);
      break;
    }
    case TAG_ID.STYLE:
    case TAG_ID.SCRIPT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(p, token);
      break;
    }
    case TAG_ID.COL: {
      colStartTagInTable(p, token);
      break;
    }
    case TAG_ID.FORM: {
      formStartTagInTable(p, token);
      break;
    }
    case TAG_ID.TABLE: {
      tableStartTagInTable(p, token);
      break;
    }
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      tbodyStartTagInTable(p, token);
      break;
    }
    case TAG_ID.INPUT: {
      inputStartTagInTable(p, token);
      break;
    }
    case TAG_ID.CAPTION: {
      captionStartTagInTable(p, token);
      break;
    }
    case TAG_ID.COLGROUP: {
      colgroupStartTagInTable(p, token);
      break;
    }
    default: {
      tokenInTable(p, token);
    }
  }
}
function endTagInTable(p, token) {
  switch (token.tagID) {
    case TAG_ID.TABLE: {
      if (p.openElements.hasInTableScope(TAG_ID.TABLE)) {
        p.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
        p._resetInsertionMode();
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TBODY:
    case TAG_ID.TD:
    case TAG_ID.TFOOT:
    case TAG_ID.TH:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      break;
    }
    default: {
      tokenInTable(p, token);
    }
  }
}
function tokenInTable(p, token) {
  const savedFosterParentingState = p.fosterParentingEnabled;
  p.fosterParentingEnabled = true;
  modeInBody(p, token);
  p.fosterParentingEnabled = savedFosterParentingState;
}
function whitespaceCharacterInTableText(p, token) {
  p.pendingCharacterTokens.push(token);
}
function characterInTableText(p, token) {
  p.pendingCharacterTokens.push(token);
  p.hasNonWhitespacePendingCharacterToken = true;
}
function tokenInTableText(p, token) {
  let i = 0;
  if (p.hasNonWhitespacePendingCharacterToken) {
    for (; i < p.pendingCharacterTokens.length; i++) {
      tokenInTable(p, p.pendingCharacterTokens[i]);
    }
  } else {
    for (; i < p.pendingCharacterTokens.length; i++) {
      p._insertCharacters(p.pendingCharacterTokens[i]);
    }
  }
  p.insertionMode = p.originalInsertionMode;
  p._processToken(token);
}
var TABLE_VOID_ELEMENTS = /* @__PURE__ */ new Set([TAG_ID.CAPTION, TAG_ID.COL, TAG_ID.COLGROUP, TAG_ID.TBODY, TAG_ID.TD, TAG_ID.TFOOT, TAG_ID.TH, TAG_ID.THEAD, TAG_ID.TR]);
function startTagInCaption(p, token) {
  const tn = token.tagID;
  if (TABLE_VOID_ELEMENTS.has(tn)) {
    if (p.openElements.hasInTableScope(TAG_ID.CAPTION)) {
      p.openElements.generateImpliedEndTags();
      p.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
      p.activeFormattingElements.clearToLastMarker();
      p.insertionMode = InsertionMode.IN_TABLE;
      startTagInTable(p, token);
    }
  } else {
    startTagInBody(p, token);
  }
}
function endTagInCaption(p, token) {
  const tn = token.tagID;
  switch (tn) {
    case TAG_ID.CAPTION:
    case TAG_ID.TABLE: {
      if (p.openElements.hasInTableScope(TAG_ID.CAPTION)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
        p.activeFormattingElements.clearToLastMarker();
        p.insertionMode = InsertionMode.IN_TABLE;
        if (tn === TAG_ID.TABLE) {
          endTagInTable(p, token);
        }
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TBODY:
    case TAG_ID.TD:
    case TAG_ID.TFOOT:
    case TAG_ID.TH:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      break;
    }
    default: {
      endTagInBody(p, token);
    }
  }
}
function startTagInColumnGroup(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.COL: {
      p._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.TEMPLATE: {
      startTagInHead(p, token);
      break;
    }
    default: {
      tokenInColumnGroup(p, token);
    }
  }
}
function endTagInColumnGroup(p, token) {
  switch (token.tagID) {
    case TAG_ID.COLGROUP: {
      if (p.openElements.currentTagId === TAG_ID.COLGROUP) {
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    case TAG_ID.COL: {
      break;
    }
    default: {
      tokenInColumnGroup(p, token);
    }
  }
}
function tokenInColumnGroup(p, token) {
  if (p.openElements.currentTagId === TAG_ID.COLGROUP) {
    p.openElements.pop();
    p.insertionMode = InsertionMode.IN_TABLE;
    p._processToken(token);
  }
}
function startTagInTableBody(p, token) {
  switch (token.tagID) {
    case TAG_ID.TR: {
      p.openElements.clearBackToTableBodyContext();
      p._insertElement(token, NS.HTML);
      p.insertionMode = InsertionMode.IN_ROW;
      break;
    }
    case TAG_ID.TH:
    case TAG_ID.TD: {
      p.openElements.clearBackToTableBodyContext();
      p._insertFakeElement(TAG_NAMES.TR, TAG_ID.TR);
      p.insertionMode = InsertionMode.IN_ROW;
      startTagInRow(p, token);
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (p.openElements.hasTableBodyContextInTableScope()) {
        p.openElements.clearBackToTableBodyContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
        startTagInTable(p, token);
      }
      break;
    }
    default: {
      startTagInTable(p, token);
    }
  }
}
function endTagInTableBody(p, token) {
  const tn = token.tagID;
  switch (token.tagID) {
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (p.openElements.hasInTableScope(tn)) {
        p.openElements.clearBackToTableBodyContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
      }
      break;
    }
    case TAG_ID.TABLE: {
      if (p.openElements.hasTableBodyContextInTableScope()) {
        p.openElements.clearBackToTableBodyContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
        endTagInTable(p, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TD:
    case TAG_ID.TH:
    case TAG_ID.TR: {
      break;
    }
    default: {
      endTagInTable(p, token);
    }
  }
}
function startTagInRow(p, token) {
  switch (token.tagID) {
    case TAG_ID.TH:
    case TAG_ID.TD: {
      p.openElements.clearBackToTableRowContext();
      p._insertElement(token, NS.HTML);
      p.insertionMode = InsertionMode.IN_CELL;
      p.activeFormattingElements.insertMarker();
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      if (p.openElements.hasInTableScope(TAG_ID.TR)) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
        startTagInTableBody(p, token);
      }
      break;
    }
    default: {
      startTagInTable(p, token);
    }
  }
}
function endTagInRow(p, token) {
  switch (token.tagID) {
    case TAG_ID.TR: {
      if (p.openElements.hasInTableScope(TAG_ID.TR)) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
      }
      break;
    }
    case TAG_ID.TABLE: {
      if (p.openElements.hasInTableScope(TAG_ID.TR)) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
        endTagInTableBody(p, token);
      }
      break;
    }
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (p.openElements.hasInTableScope(token.tagID) || p.openElements.hasInTableScope(TAG_ID.TR)) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
        endTagInTableBody(p, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TD:
    case TAG_ID.TH: {
      break;
    }
    default: {
      endTagInTable(p, token);
    }
  }
}
function startTagInCell(p, token) {
  const tn = token.tagID;
  if (TABLE_VOID_ELEMENTS.has(tn)) {
    if (p.openElements.hasInTableScope(TAG_ID.TD) || p.openElements.hasInTableScope(TAG_ID.TH)) {
      p._closeTableCell();
      startTagInRow(p, token);
    }
  } else {
    startTagInBody(p, token);
  }
}
function endTagInCell(p, token) {
  const tn = token.tagID;
  switch (tn) {
    case TAG_ID.TD:
    case TAG_ID.TH: {
      if (p.openElements.hasInTableScope(tn)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(tn);
        p.activeFormattingElements.clearToLastMarker();
        p.insertionMode = InsertionMode.IN_ROW;
      }
      break;
    }
    case TAG_ID.TABLE:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      if (p.openElements.hasInTableScope(tn)) {
        p._closeTableCell();
        endTagInRow(p, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML: {
      break;
    }
    default: {
      endTagInBody(p, token);
    }
  }
}
function startTagInSelect(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.OPTION: {
      if (p.openElements.currentTagId === TAG_ID.OPTION) {
        p.openElements.pop();
      }
      p._insertElement(token, NS.HTML);
      break;
    }
    case TAG_ID.OPTGROUP: {
      if (p.openElements.currentTagId === TAG_ID.OPTION) {
        p.openElements.pop();
      }
      if (p.openElements.currentTagId === TAG_ID.OPTGROUP) {
        p.openElements.pop();
      }
      p._insertElement(token, NS.HTML);
      break;
    }
    case TAG_ID.HR: {
      if (p.openElements.currentTagId === TAG_ID.OPTION) {
        p.openElements.pop();
      }
      if (p.openElements.currentTagId === TAG_ID.OPTGROUP) {
        p.openElements.pop();
      }
      p._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.INPUT:
    case TAG_ID.KEYGEN:
    case TAG_ID.TEXTAREA:
    case TAG_ID.SELECT: {
      if (p.openElements.hasInSelectScope(TAG_ID.SELECT)) {
        p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
        p._resetInsertionMode();
        if (token.tagID !== TAG_ID.SELECT) {
          p._processStartTag(token);
        }
      }
      break;
    }
    case TAG_ID.SCRIPT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(p, token);
      break;
    }
    default:
  }
}
function endTagInSelect(p, token) {
  switch (token.tagID) {
    case TAG_ID.OPTGROUP: {
      if (p.openElements.stackTop > 0 && p.openElements.currentTagId === TAG_ID.OPTION && p.openElements.tagIDs[p.openElements.stackTop - 1] === TAG_ID.OPTGROUP) {
        p.openElements.pop();
      }
      if (p.openElements.currentTagId === TAG_ID.OPTGROUP) {
        p.openElements.pop();
      }
      break;
    }
    case TAG_ID.OPTION: {
      if (p.openElements.currentTagId === TAG_ID.OPTION) {
        p.openElements.pop();
      }
      break;
    }
    case TAG_ID.SELECT: {
      if (p.openElements.hasInSelectScope(TAG_ID.SELECT)) {
        p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
        p._resetInsertionMode();
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    default:
  }
}
function startTagInSelectInTable(p, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.CAPTION || tn === TAG_ID.TABLE || tn === TAG_ID.TBODY || tn === TAG_ID.TFOOT || tn === TAG_ID.THEAD || tn === TAG_ID.TR || tn === TAG_ID.TD || tn === TAG_ID.TH) {
    p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
    p._resetInsertionMode();
    p._processStartTag(token);
  } else {
    startTagInSelect(p, token);
  }
}
function endTagInSelectInTable(p, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.CAPTION || tn === TAG_ID.TABLE || tn === TAG_ID.TBODY || tn === TAG_ID.TFOOT || tn === TAG_ID.THEAD || tn === TAG_ID.TR || tn === TAG_ID.TD || tn === TAG_ID.TH) {
    if (p.openElements.hasInTableScope(tn)) {
      p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
      p._resetInsertionMode();
      p.onEndTag(token);
    }
  } else {
    endTagInSelect(p, token);
  }
}
function startTagInTemplate(p, token) {
  switch (token.tagID) {
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.SCRIPT:
    case TAG_ID.STYLE:
    case TAG_ID.TEMPLATE:
    case TAG_ID.TITLE: {
      startTagInHead(p, token);
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE;
      p.insertionMode = InsertionMode.IN_TABLE;
      startTagInTable(p, token);
      break;
    }
    case TAG_ID.COL: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_COLUMN_GROUP;
      p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
      startTagInColumnGroup(p, token);
      break;
    }
    case TAG_ID.TR: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE_BODY;
      p.insertionMode = InsertionMode.IN_TABLE_BODY;
      startTagInTableBody(p, token);
      break;
    }
    case TAG_ID.TD:
    case TAG_ID.TH: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_ROW;
      p.insertionMode = InsertionMode.IN_ROW;
      startTagInRow(p, token);
      break;
    }
    default: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_BODY;
      p.insertionMode = InsertionMode.IN_BODY;
      startTagInBody(p, token);
    }
  }
}
function endTagInTemplate(p, token) {
  if (token.tagID === TAG_ID.TEMPLATE) {
    templateEndTagInHead(p, token);
  }
}
function eofInTemplate(p, token) {
  if (p.openElements.tmplCount > 0) {
    p.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
    p.activeFormattingElements.clearToLastMarker();
    p.tmplInsertionModeStack.shift();
    p._resetInsertionMode();
    p.onEof(token);
  } else {
    stopParsing(p, token);
  }
}
function startTagAfterBody(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    startTagInBody(p, token);
  } else {
    tokenAfterBody(p, token);
  }
}
function endTagAfterBody(p, token) {
  var _a3;
  if (token.tagID === TAG_ID.HTML) {
    if (!p.fragmentContext) {
      p.insertionMode = InsertionMode.AFTER_AFTER_BODY;
    }
    if (p.options.sourceCodeLocationInfo && p.openElements.tagIDs[0] === TAG_ID.HTML) {
      p._setEndLocation(p.openElements.items[0], token);
      const bodyElement = p.openElements.items[1];
      if (bodyElement && !((_a3 = p.treeAdapter.getNodeSourceCodeLocation(bodyElement)) === null || _a3 === void 0 ? void 0 : _a3.endTag)) {
        p._setEndLocation(bodyElement, token);
      }
    }
  } else {
    tokenAfterBody(p, token);
  }
}
function tokenAfterBody(p, token) {
  p.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p, token);
}
function startTagInFrameset(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.FRAMESET: {
      p._insertElement(token, NS.HTML);
      break;
    }
    case TAG_ID.FRAME: {
      p._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(p, token);
      break;
    }
    default:
  }
}
function endTagInFrameset(p, token) {
  if (token.tagID === TAG_ID.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {
    p.openElements.pop();
    if (!p.fragmentContext && p.openElements.currentTagId !== TAG_ID.FRAMESET) {
      p.insertionMode = InsertionMode.AFTER_FRAMESET;
    }
  }
}
function startTagAfterFrameset(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(p, token);
      break;
    }
    default:
  }
}
function endTagAfterFrameset(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    p.insertionMode = InsertionMode.AFTER_AFTER_FRAMESET;
  }
}
function startTagAfterAfterBody(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    startTagInBody(p, token);
  } else {
    tokenAfterAfterBody(p, token);
  }
}
function tokenAfterAfterBody(p, token) {
  p.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p, token);
}
function startTagAfterAfterFrameset(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(p, token);
      break;
    }
    default:
  }
}
function nullCharacterInForeignContent(p, token) {
  token.chars = REPLACEMENT_CHARACTER;
  p._insertCharacters(token);
}
function characterInForeignContent(p, token) {
  p._insertCharacters(token);
  p.framesetOk = false;
}
function popUntilHtmlOrIntegrationPoint(p) {
  while (p.treeAdapter.getNamespaceURI(p.openElements.current) !== NS.HTML && p.openElements.currentTagId !== void 0 && !p._isIntegrationPoint(p.openElements.currentTagId, p.openElements.current)) {
    p.openElements.pop();
  }
}
function startTagInForeignContent(p, token) {
  if (causesExit(token)) {
    popUntilHtmlOrIntegrationPoint(p);
    p._startTagOutsideForeignContent(token);
  } else {
    const current = p._getAdjustedCurrentElement();
    const currentNs = p.treeAdapter.getNamespaceURI(current);
    if (currentNs === NS.MATHML) {
      adjustTokenMathMLAttrs(token);
    } else if (currentNs === NS.SVG) {
      adjustTokenSVGTagName(token);
      adjustTokenSVGAttrs(token);
    }
    adjustTokenXMLAttrs(token);
    if (token.selfClosing) {
      p._appendElement(token, currentNs);
    } else {
      p._insertElement(token, currentNs);
    }
    token.ackSelfClosing = true;
  }
}
function endTagInForeignContent(p, token) {
  if (token.tagID === TAG_ID.P || token.tagID === TAG_ID.BR) {
    popUntilHtmlOrIntegrationPoint(p);
    p._endTagOutsideForeignContent(token);
    return;
  }
  for (let i = p.openElements.stackTop; i > 0; i--) {
    const element = p.openElements.items[i];
    if (p.treeAdapter.getNamespaceURI(element) === NS.HTML) {
      p._endTagOutsideForeignContent(token);
      break;
    }
    const tagName = p.treeAdapter.getTagName(element);
    if (tagName.toLowerCase() === token.tagName) {
      token.tagName = tagName;
      p.openElements.shortenToLength(i);
      break;
    }
  }
}

// ../../node_modules/.pnpm/entities@6.0.0/node_modules/entities/dist/esm/escape.js
var getCodePoint2 = String.prototype.codePointAt == null ? (c, index2) => (c.charCodeAt(index2) & 64512) === 55296 ? (c.charCodeAt(index2) - 55296) * 1024 + c.charCodeAt(index2 + 1) - 56320 + 65536 : c.charCodeAt(index2) : (input, index2) => input.codePointAt(index2);
function getEscaper2(regex, map4) {
  return function escape3(data2) {
    let match2;
    let lastIndex = 0;
    let result = "";
    while (match2 = regex.exec(data2)) {
      if (lastIndex !== match2.index) {
        result += data2.substring(lastIndex, match2.index);
      }
      result += map4.get(match2[0].charCodeAt(0));
      lastIndex = match2.index + 1;
    }
    return result + data2.substring(lastIndex);
  };
}
var escapeAttribute2 = /* @__PURE__ */ getEscaper2(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText2 = /* @__PURE__ */ getEscaper2(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));

// ../../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/serializer/index.js
var VOID_ELEMENTS = /* @__PURE__ */ new Set([
  TAG_NAMES.AREA,
  TAG_NAMES.BASE,
  TAG_NAMES.BASEFONT,
  TAG_NAMES.BGSOUND,
  TAG_NAMES.BR,
  TAG_NAMES.COL,
  TAG_NAMES.EMBED,
  TAG_NAMES.FRAME,
  TAG_NAMES.HR,
  TAG_NAMES.IMG,
  TAG_NAMES.INPUT,
  TAG_NAMES.KEYGEN,
  TAG_NAMES.LINK,
  TAG_NAMES.META,
  TAG_NAMES.PARAM,
  TAG_NAMES.SOURCE,
  TAG_NAMES.TRACK,
  TAG_NAMES.WBR
]);
function isVoidElement(node, options) {
  return options.treeAdapter.isElementNode(node) && options.treeAdapter.getNamespaceURI(node) === NS.HTML && VOID_ELEMENTS.has(options.treeAdapter.getTagName(node));
}
var defaultOpts3 = { treeAdapter: defaultTreeAdapter, scriptingEnabled: true };
function serializeOuter(node, options) {
  const opts = { ...defaultOpts3, ...options };
  return serializeNode(node, opts);
}
function serializeChildNodes(parentNode, options) {
  let html3 = "";
  const container = options.treeAdapter.isElementNode(parentNode) && options.treeAdapter.getTagName(parentNode) === TAG_NAMES.TEMPLATE && options.treeAdapter.getNamespaceURI(parentNode) === NS.HTML ? options.treeAdapter.getTemplateContent(parentNode) : parentNode;
  const childNodes = options.treeAdapter.getChildNodes(container);
  if (childNodes) {
    for (const currentNode of childNodes) {
      html3 += serializeNode(currentNode, options);
    }
  }
  return html3;
}
function serializeNode(node, options) {
  if (options.treeAdapter.isElementNode(node)) {
    return serializeElement(node, options);
  }
  if (options.treeAdapter.isTextNode(node)) {
    return serializeTextNode(node, options);
  }
  if (options.treeAdapter.isCommentNode(node)) {
    return serializeCommentNode(node, options);
  }
  if (options.treeAdapter.isDocumentTypeNode(node)) {
    return serializeDocumentTypeNode(node, options);
  }
  return "";
}
function serializeElement(node, options) {
  const tn = options.treeAdapter.getTagName(node);
  return `<${tn}${serializeAttributes(node, options)}>${isVoidElement(node, options) ? "" : `${serializeChildNodes(node, options)}</${tn}>`}`;
}
function serializeAttributes(node, { treeAdapter }) {
  let html3 = "";
  for (const attr2 of treeAdapter.getAttrList(node)) {
    html3 += " ";
    if (attr2.namespace) {
      switch (attr2.namespace) {
        case NS.XML: {
          html3 += `xml:${attr2.name}`;
          break;
        }
        case NS.XMLNS: {
          if (attr2.name !== "xmlns") {
            html3 += "xmlns:";
          }
          html3 += attr2.name;
          break;
        }
        case NS.XLINK: {
          html3 += `xlink:${attr2.name}`;
          break;
        }
        default: {
          html3 += `${attr2.prefix}:${attr2.name}`;
        }
      }
    } else {
      html3 += attr2.name;
    }
    html3 += `="${escapeAttribute2(attr2.value)}"`;
  }
  return html3;
}
function serializeTextNode(node, options) {
  const { treeAdapter } = options;
  const content = treeAdapter.getTextNodeContent(node);
  const parent2 = treeAdapter.getParentNode(node);
  const parentTn = parent2 && treeAdapter.isElementNode(parent2) && treeAdapter.getTagName(parent2);
  return parentTn && treeAdapter.getNamespaceURI(parent2) === NS.HTML && hasUnescapedText(parentTn, options.scriptingEnabled) ? content : escapeText2(content);
}
function serializeCommentNode(node, { treeAdapter }) {
  return `<!--${treeAdapter.getCommentNodeContent(node)}-->`;
}
function serializeDocumentTypeNode(node, { treeAdapter }) {
  return `<!DOCTYPE ${treeAdapter.getDocumentTypeNodeName(node)}>`;
}

// ../../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/index.js
function parse4(html3, options) {
  return Parser.parse(html3, options);
}
function parseFragment(fragmentContext, html3, options) {
  if (typeof fragmentContext === "string") {
    options = html3;
    html3 = fragmentContext;
    fragmentContext = null;
  }
  const parser = Parser.getFragmentParser(fragmentContext, options);
  parser.tokenizer.write(html3, true);
  return parser.getFragment();
}

// ../../node_modules/.pnpm/parse5-htmlparser2-tree-adapter@7.1.0/node_modules/parse5-htmlparser2-tree-adapter/dist/index.js
function enquoteDoctypeId(id) {
  const quote = id.includes('"') ? "'" : '"';
  return quote + id + quote;
}
function serializeDoctypeContent(name2, publicId, systemId) {
  let str = "!DOCTYPE ";
  if (name2) {
    str += name2;
  }
  if (publicId) {
    str += ` PUBLIC ${enquoteDoctypeId(publicId)}`;
  } else if (systemId) {
    str += " SYSTEM";
  }
  if (systemId) {
    str += ` ${enquoteDoctypeId(systemId)}`;
  }
  return str;
}
var adapter = {
  isCommentNode: isComment,
  isElementNode: isTag2,
  isTextNode: isText,
  createDocument() {
    const node = new Document([]);
    node["x-mode"] = html_exports.DOCUMENT_MODE.NO_QUIRKS;
    return node;
  },
  createDocumentFragment() {
    return new Document([]);
  },
  createElement(tagName, namespaceURI, attrs) {
    const attribs = /* @__PURE__ */ Object.create(null);
    const attribsNamespace = /* @__PURE__ */ Object.create(null);
    const attribsPrefix = /* @__PURE__ */ Object.create(null);
    for (let i = 0; i < attrs.length; i++) {
      const attrName = attrs[i].name;
      attribs[attrName] = attrs[i].value;
      attribsNamespace[attrName] = attrs[i].namespace;
      attribsPrefix[attrName] = attrs[i].prefix;
    }
    const node = new Element(tagName, attribs, []);
    node.namespace = namespaceURI;
    node["x-attribsNamespace"] = attribsNamespace;
    node["x-attribsPrefix"] = attribsPrefix;
    return node;
  },
  createCommentNode(data2) {
    return new Comment2(data2);
  },
  createTextNode(value) {
    return new Text2(value);
  },
  appendChild(parentNode, newNode) {
    const prev2 = parentNode.children[parentNode.children.length - 1];
    if (prev2) {
      prev2.next = newNode;
      newNode.prev = prev2;
    }
    parentNode.children.push(newNode);
    newNode.parent = parentNode;
  },
  insertBefore(parentNode, newNode, referenceNode) {
    const insertionIdx = parentNode.children.indexOf(referenceNode);
    const { prev: prev2 } = referenceNode;
    if (prev2) {
      prev2.next = newNode;
      newNode.prev = prev2;
    }
    referenceNode.prev = newNode;
    newNode.next = referenceNode;
    parentNode.children.splice(insertionIdx, 0, newNode);
    newNode.parent = parentNode;
  },
  setTemplateContent(templateElement, contentElement) {
    adapter.appendChild(templateElement, contentElement);
  },
  getTemplateContent(templateElement) {
    return templateElement.children[0];
  },
  setDocumentType(document2, name2, publicId, systemId) {
    const data2 = serializeDoctypeContent(name2, publicId, systemId);
    let doctypeNode = document2.children.find((node) => isDirective(node) && node.name === "!doctype");
    if (doctypeNode) {
      doctypeNode.data = data2 !== null && data2 !== void 0 ? data2 : null;
    } else {
      doctypeNode = new ProcessingInstruction("!doctype", data2);
      adapter.appendChild(document2, doctypeNode);
    }
    doctypeNode["x-name"] = name2;
    doctypeNode["x-publicId"] = publicId;
    doctypeNode["x-systemId"] = systemId;
  },
  setDocumentMode(document2, mode) {
    document2["x-mode"] = mode;
  },
  getDocumentMode(document2) {
    return document2["x-mode"];
  },
  detachNode(node) {
    if (node.parent) {
      const idx = node.parent.children.indexOf(node);
      const { prev: prev2, next: next2 } = node;
      node.prev = null;
      node.next = null;
      if (prev2) {
        prev2.next = next2;
      }
      if (next2) {
        next2.prev = prev2;
      }
      node.parent.children.splice(idx, 1);
      node.parent = null;
    }
  },
  insertText(parentNode, text4) {
    const lastChild = parentNode.children[parentNode.children.length - 1];
    if (lastChild && isText(lastChild)) {
      lastChild.data += text4;
    } else {
      adapter.appendChild(parentNode, adapter.createTextNode(text4));
    }
  },
  insertTextBefore(parentNode, text4, referenceNode) {
    const prevNode = parentNode.children[parentNode.children.indexOf(referenceNode) - 1];
    if (prevNode && isText(prevNode)) {
      prevNode.data += text4;
    } else {
      adapter.insertBefore(parentNode, adapter.createTextNode(text4), referenceNode);
    }
  },
  adoptAttributes(recipient, attrs) {
    for (let i = 0; i < attrs.length; i++) {
      const attrName = attrs[i].name;
      if (recipient.attribs[attrName] === void 0) {
        recipient.attribs[attrName] = attrs[i].value;
        recipient["x-attribsNamespace"][attrName] = attrs[i].namespace;
        recipient["x-attribsPrefix"][attrName] = attrs[i].prefix;
      }
    }
  },
  getFirstChild(node) {
    return node.children[0];
  },
  getChildNodes(node) {
    return node.children;
  },
  getParentNode(node) {
    return node.parent;
  },
  getAttrList(element) {
    return element.attributes;
  },
  getTagName(element) {
    return element.name;
  },
  getNamespaceURI(element) {
    return element.namespace;
  },
  getTextNodeContent(textNode) {
    return textNode.data;
  },
  getCommentNodeContent(commentNode) {
    return commentNode.data;
  },
  getDocumentTypeNodeName(doctypeNode) {
    var _a3;
    return (_a3 = doctypeNode["x-name"]) !== null && _a3 !== void 0 ? _a3 : "";
  },
  getDocumentTypeNodePublicId(doctypeNode) {
    var _a3;
    return (_a3 = doctypeNode["x-publicId"]) !== null && _a3 !== void 0 ? _a3 : "";
  },
  getDocumentTypeNodeSystemId(doctypeNode) {
    var _a3;
    return (_a3 = doctypeNode["x-systemId"]) !== null && _a3 !== void 0 ? _a3 : "";
  },
  isDocumentTypeNode(node) {
    return isDirective(node) && node.name === "!doctype";
  },
  setNodeSourceCodeLocation(node, location) {
    if (location) {
      node.startIndex = location.startOffset;
      node.endIndex = location.endOffset;
    }
    node.sourceCodeLocation = location;
  },
  getNodeSourceCodeLocation(node) {
    return node.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(node, endLocation) {
    if (endLocation.endOffset != null)
      node.endIndex = endLocation.endOffset;
    node.sourceCodeLocation = {
      ...node.sourceCodeLocation,
      ...endLocation
    };
  }
};

// ../../node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/parsers/parse5-adapter.js
function parseWithParse5(content, options, isDocument3, context) {
  const opts = {
    scriptingEnabled: typeof options.scriptingEnabled === "boolean" ? options.scriptingEnabled : true,
    treeAdapter: adapter,
    sourceCodeLocationInfo: options.sourceCodeLocationInfo
  };
  return isDocument3 ? parse4(content, opts) : parseFragment(context, content, opts);
}
var renderOpts = { treeAdapter: adapter };
function renderWithParse5(dom) {
  const nodes = "length" in dom ? dom : [dom];
  for (let index2 = 0; index2 < nodes.length; index2 += 1) {
    const node = nodes[index2];
    if (isDocument(node)) {
      Array.prototype.splice.call(nodes, index2, 1, ...node.children);
    }
  }
  let result = "";
  for (let index2 = 0; index2 < nodes.length; index2 += 1) {
    const node = nodes[index2];
    result += serializeOuter(node, renderOpts);
  }
  return result;
}

// ../../node_modules/.pnpm/htmlparser2@8.0.2/node_modules/htmlparser2/lib/esm/Tokenizer.js
var CharCodes3;
(function(CharCodes4) {
  CharCodes4[CharCodes4["Tab"] = 9] = "Tab";
  CharCodes4[CharCodes4["NewLine"] = 10] = "NewLine";
  CharCodes4[CharCodes4["FormFeed"] = 12] = "FormFeed";
  CharCodes4[CharCodes4["CarriageReturn"] = 13] = "CarriageReturn";
  CharCodes4[CharCodes4["Space"] = 32] = "Space";
  CharCodes4[CharCodes4["ExclamationMark"] = 33] = "ExclamationMark";
  CharCodes4[CharCodes4["Number"] = 35] = "Number";
  CharCodes4[CharCodes4["Amp"] = 38] = "Amp";
  CharCodes4[CharCodes4["SingleQuote"] = 39] = "SingleQuote";
  CharCodes4[CharCodes4["DoubleQuote"] = 34] = "DoubleQuote";
  CharCodes4[CharCodes4["Dash"] = 45] = "Dash";
  CharCodes4[CharCodes4["Slash"] = 47] = "Slash";
  CharCodes4[CharCodes4["Zero"] = 48] = "Zero";
  CharCodes4[CharCodes4["Nine"] = 57] = "Nine";
  CharCodes4[CharCodes4["Semi"] = 59] = "Semi";
  CharCodes4[CharCodes4["Lt"] = 60] = "Lt";
  CharCodes4[CharCodes4["Eq"] = 61] = "Eq";
  CharCodes4[CharCodes4["Gt"] = 62] = "Gt";
  CharCodes4[CharCodes4["Questionmark"] = 63] = "Questionmark";
  CharCodes4[CharCodes4["UpperA"] = 65] = "UpperA";
  CharCodes4[CharCodes4["LowerA"] = 97] = "LowerA";
  CharCodes4[CharCodes4["UpperF"] = 70] = "UpperF";
  CharCodes4[CharCodes4["LowerF"] = 102] = "LowerF";
  CharCodes4[CharCodes4["UpperZ"] = 90] = "UpperZ";
  CharCodes4[CharCodes4["LowerZ"] = 122] = "LowerZ";
  CharCodes4[CharCodes4["LowerX"] = 120] = "LowerX";
  CharCodes4[CharCodes4["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes3 || (CharCodes3 = {}));
var State2;
(function(State3) {
  State3[State3["Text"] = 1] = "Text";
  State3[State3["BeforeTagName"] = 2] = "BeforeTagName";
  State3[State3["InTagName"] = 3] = "InTagName";
  State3[State3["InSelfClosingTag"] = 4] = "InSelfClosingTag";
  State3[State3["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
  State3[State3["InClosingTagName"] = 6] = "InClosingTagName";
  State3[State3["AfterClosingTagName"] = 7] = "AfterClosingTagName";
  State3[State3["BeforeAttributeName"] = 8] = "BeforeAttributeName";
  State3[State3["InAttributeName"] = 9] = "InAttributeName";
  State3[State3["AfterAttributeName"] = 10] = "AfterAttributeName";
  State3[State3["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
  State3[State3["InAttributeValueDq"] = 12] = "InAttributeValueDq";
  State3[State3["InAttributeValueSq"] = 13] = "InAttributeValueSq";
  State3[State3["InAttributeValueNq"] = 14] = "InAttributeValueNq";
  State3[State3["BeforeDeclaration"] = 15] = "BeforeDeclaration";
  State3[State3["InDeclaration"] = 16] = "InDeclaration";
  State3[State3["InProcessingInstruction"] = 17] = "InProcessingInstruction";
  State3[State3["BeforeComment"] = 18] = "BeforeComment";
  State3[State3["CDATASequence"] = 19] = "CDATASequence";
  State3[State3["InSpecialComment"] = 20] = "InSpecialComment";
  State3[State3["InCommentLike"] = 21] = "InCommentLike";
  State3[State3["BeforeSpecialS"] = 22] = "BeforeSpecialS";
  State3[State3["SpecialStartSequence"] = 23] = "SpecialStartSequence";
  State3[State3["InSpecialTag"] = 24] = "InSpecialTag";
  State3[State3["BeforeEntity"] = 25] = "BeforeEntity";
  State3[State3["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
  State3[State3["InNamedEntity"] = 27] = "InNamedEntity";
  State3[State3["InNumericEntity"] = 28] = "InNumericEntity";
  State3[State3["InHexEntity"] = 29] = "InHexEntity";
})(State2 || (State2 = {}));
function isWhitespace3(c) {
  return c === CharCodes3.Space || c === CharCodes3.NewLine || c === CharCodes3.Tab || c === CharCodes3.FormFeed || c === CharCodes3.CarriageReturn;
}
function isEndOfTagSection(c) {
  return c === CharCodes3.Slash || c === CharCodes3.Gt || isWhitespace3(c);
}
function isNumber3(c) {
  return c >= CharCodes3.Zero && c <= CharCodes3.Nine;
}
function isASCIIAlpha(c) {
  return c >= CharCodes3.LowerA && c <= CharCodes3.LowerZ || c >= CharCodes3.UpperA && c <= CharCodes3.UpperZ;
}
function isHexDigit(c) {
  return c >= CharCodes3.UpperA && c <= CharCodes3.UpperF || c >= CharCodes3.LowerA && c <= CharCodes3.LowerF;
}
var QuoteType;
(function(QuoteType2) {
  QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
  QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
  QuoteType2[QuoteType2["Single"] = 2] = "Single";
  QuoteType2[QuoteType2["Double"] = 3] = "Double";
})(QuoteType || (QuoteType = {}));
var Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  CdataEnd: new Uint8Array([93, 93, 62]),
  CommentEnd: new Uint8Array([45, 45, 62]),
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
};
var Tokenizer2 = class {
  constructor({ xmlMode = false, decodeEntities = true }, cbs) {
    this.cbs = cbs;
    this.state = State2.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State2.Text;
    this.isSpecial = false;
    this.running = true;
    this.offset = 0;
    this.currentSequence = void 0;
    this.sequenceIndex = 0;
    this.trieIndex = 0;
    this.trieCurrent = 0;
    this.entityResult = 0;
    this.entityExcess = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityTrie = xmlMode ? decode_data_xml_default : decode_data_html_default;
  }
  reset() {
    this.state = State2.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State2.Text;
    this.currentSequence = void 0;
    this.running = true;
    this.offset = 0;
  }
  write(chunk) {
    this.offset += this.buffer.length;
    this.buffer = chunk;
    this.parse();
  }
  end() {
    if (this.running)
      this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true;
    if (this.index < this.buffer.length + this.offset) {
      this.parse();
    }
  }
  getIndex() {
    return this.index;
  }
  getSectionStart() {
    return this.sectionStart;
  }
  stateText(c) {
    if (c === CharCodes3.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes3.Lt)) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = State2.BeforeTagName;
      this.sectionStart = this.index;
    } else if (this.decodeEntities && c === CharCodes3.Amp) {
      this.state = State2.BeforeEntity;
    }
  }
  stateSpecialStartSequence(c) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? isEndOfTagSection(c) : (c | 32) === this.currentSequence[this.sequenceIndex];
    if (!isMatch) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = State2.InTagName;
    this.stateInTagName(c);
  }
  stateInSpecialTag(c) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c === CharCodes3.Gt || isWhitespace3(c)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c);
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd) {
        if (this.decodeEntities && c === CharCodes3.Amp) {
          this.state = State2.BeforeEntity;
        }
      } else if (this.fastForwardTo(CharCodes3.Lt)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c === CharCodes3.Lt);
    }
  }
  stateCDATASequence(c) {
    if (c === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = State2.InCommentLike;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = State2.InDeclaration;
      this.stateInDeclaration(c);
    }
  }
  fastForwardTo(c) {
    while (++this.index < this.buffer.length + this.offset) {
      if (this.buffer.charCodeAt(this.index - this.offset) === c) {
        return true;
      }
    }
    this.index = this.buffer.length + this.offset - 1;
    return false;
  }
  stateInCommentLike(c) {
    if (c === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index, 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index, 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = State2.Text;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  isTagStartChar(c) {
    return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
  }
  startSpecial(sequence, offset) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
    this.state = State2.SpecialStartSequence;
  }
  stateBeforeTagName(c) {
    if (c === CharCodes3.ExclamationMark) {
      this.state = State2.BeforeDeclaration;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes3.Questionmark) {
      this.state = State2.InProcessingInstruction;
      this.sectionStart = this.index + 1;
    } else if (this.isTagStartChar(c)) {
      const lower = c | 32;
      this.sectionStart = this.index;
      if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
        this.startSpecial(Sequences.TitleEnd, 3);
      } else {
        this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State2.BeforeSpecialS : State2.InTagName;
      }
    } else if (c === CharCodes3.Slash) {
      this.state = State2.BeforeClosingTagName;
    } else {
      this.state = State2.Text;
      this.stateText(c);
    }
  }
  stateInTagName(c) {
    if (isEndOfTagSection(c)) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State2.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    }
  }
  stateBeforeClosingTagName(c) {
    if (isWhitespace3(c)) {
    } else if (c === CharCodes3.Gt) {
      this.state = State2.Text;
    } else {
      this.state = this.isTagStartChar(c) ? State2.InClosingTagName : State2.InSpecialComment;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c) {
    if (c === CharCodes3.Gt || isWhitespace3(c)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State2.AfterClosingTagName;
      this.stateAfterClosingTagName(c);
    }
  }
  stateAfterClosingTagName(c) {
    if (c === CharCodes3.Gt || this.fastForwardTo(CharCodes3.Gt)) {
      this.state = State2.Text;
      this.baseState = State2.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttributeName(c) {
    if (c === CharCodes3.Gt) {
      this.cbs.onopentagend(this.index);
      if (this.isSpecial) {
        this.state = State2.InSpecialTag;
        this.sequenceIndex = 0;
      } else {
        this.state = State2.Text;
      }
      this.baseState = this.state;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes3.Slash) {
      this.state = State2.InSelfClosingTag;
    } else if (!isWhitespace3(c)) {
      this.state = State2.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c) {
    if (c === CharCodes3.Gt) {
      this.cbs.onselfclosingtag(this.index);
      this.state = State2.Text;
      this.baseState = State2.Text;
      this.sectionStart = this.index + 1;
      this.isSpecial = false;
    } else if (!isWhitespace3(c)) {
      this.state = State2.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    }
  }
  stateInAttributeName(c) {
    if (c === CharCodes3.Eq || isEndOfTagSection(c)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State2.AfterAttributeName;
      this.stateAfterAttributeName(c);
    }
  }
  stateAfterAttributeName(c) {
    if (c === CharCodes3.Eq) {
      this.state = State2.BeforeAttributeValue;
    } else if (c === CharCodes3.Slash || c === CharCodes3.Gt) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State2.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    } else if (!isWhitespace3(c)) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State2.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateBeforeAttributeValue(c) {
    if (c === CharCodes3.DoubleQuote) {
      this.state = State2.InAttributeValueDq;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes3.SingleQuote) {
      this.state = State2.InAttributeValueSq;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace3(c)) {
      this.sectionStart = this.index;
      this.state = State2.InAttributeValueNq;
      this.stateInAttributeValueNoQuotes(c);
    }
  }
  handleInAttributeValue(c, quote) {
    if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(quote === CharCodes3.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
      this.state = State2.BeforeAttributeName;
    } else if (this.decodeEntities && c === CharCodes3.Amp) {
      this.baseState = this.state;
      this.state = State2.BeforeEntity;
    }
  }
  stateInAttributeValueDoubleQuotes(c) {
    this.handleInAttributeValue(c, CharCodes3.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(c) {
    this.handleInAttributeValue(c, CharCodes3.SingleQuote);
  }
  stateInAttributeValueNoQuotes(c) {
    if (isWhitespace3(c) || c === CharCodes3.Gt) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(QuoteType.Unquoted, this.index);
      this.state = State2.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    } else if (this.decodeEntities && c === CharCodes3.Amp) {
      this.baseState = this.state;
      this.state = State2.BeforeEntity;
    }
  }
  stateBeforeDeclaration(c) {
    if (c === CharCodes3.OpeningSquareBracket) {
      this.state = State2.CDATASequence;
      this.sequenceIndex = 0;
    } else {
      this.state = c === CharCodes3.Dash ? State2.BeforeComment : State2.InDeclaration;
    }
  }
  stateInDeclaration(c) {
    if (c === CharCodes3.Gt || this.fastForwardTo(CharCodes3.Gt)) {
      this.cbs.ondeclaration(this.sectionStart, this.index);
      this.state = State2.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c) {
    if (c === CharCodes3.Gt || this.fastForwardTo(CharCodes3.Gt)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = State2.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c) {
    if (c === CharCodes3.Dash) {
      this.state = State2.InCommentLike;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = State2.InDeclaration;
    }
  }
  stateInSpecialComment(c) {
    if (c === CharCodes3.Gt || this.fastForwardTo(CharCodes3.Gt)) {
      this.cbs.oncomment(this.sectionStart, this.index, 0);
      this.state = State2.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c) {
    const lower = c | 32;
    if (lower === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (lower === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = State2.InTagName;
      this.stateInTagName(c);
    }
  }
  stateBeforeEntity(c) {
    this.entityExcess = 1;
    this.entityResult = 0;
    if (c === CharCodes3.Number) {
      this.state = State2.BeforeNumericEntity;
    } else if (c === CharCodes3.Amp) {
    } else {
      this.trieIndex = 0;
      this.trieCurrent = this.entityTrie[0];
      this.state = State2.InNamedEntity;
      this.stateInNamedEntity(c);
    }
  }
  stateInNamedEntity(c) {
    this.entityExcess += 1;
    this.trieIndex = determineBranch(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
    if (this.trieIndex < 0) {
      this.emitNamedEntity();
      this.index--;
      return;
    }
    this.trieCurrent = this.entityTrie[this.trieIndex];
    const masked = this.trieCurrent & BinTrieFlags.VALUE_LENGTH;
    if (masked) {
      const valueLength = (masked >> 14) - 1;
      if (!this.allowLegacyEntity() && c !== CharCodes3.Semi) {
        this.trieIndex += valueLength;
      } else {
        const entityStart = this.index - this.entityExcess + 1;
        if (entityStart > this.sectionStart) {
          this.emitPartial(this.sectionStart, entityStart);
        }
        this.entityResult = this.trieIndex;
        this.trieIndex += valueLength;
        this.entityExcess = 0;
        this.sectionStart = this.index + 1;
        if (valueLength === 0) {
          this.emitNamedEntity();
        }
      }
    }
  }
  emitNamedEntity() {
    this.state = this.baseState;
    if (this.entityResult === 0) {
      return;
    }
    const valueLength = (this.entityTrie[this.entityResult] & BinTrieFlags.VALUE_LENGTH) >> 14;
    switch (valueLength) {
      case 1: {
        this.emitCodePoint(this.entityTrie[this.entityResult] & ~BinTrieFlags.VALUE_LENGTH);
        break;
      }
      case 2: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        break;
      }
      case 3: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
      }
    }
  }
  stateBeforeNumericEntity(c) {
    if ((c | 32) === CharCodes3.LowerX) {
      this.entityExcess++;
      this.state = State2.InHexEntity;
    } else {
      this.state = State2.InNumericEntity;
      this.stateInNumericEntity(c);
    }
  }
  emitNumericEntity(strict) {
    const entityStart = this.index - this.entityExcess - 1;
    const numberStart = entityStart + 2 + Number(this.state === State2.InHexEntity);
    if (numberStart !== this.index) {
      if (entityStart > this.sectionStart) {
        this.emitPartial(this.sectionStart, entityStart);
      }
      this.sectionStart = this.index + Number(strict);
      this.emitCodePoint(replaceCodePoint(this.entityResult));
    }
    this.state = this.baseState;
  }
  stateInNumericEntity(c) {
    if (c === CharCodes3.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber3(c)) {
      this.entityResult = this.entityResult * 10 + (c - CharCodes3.Zero);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  stateInHexEntity(c) {
    if (c === CharCodes3.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber3(c)) {
      this.entityResult = this.entityResult * 16 + (c - CharCodes3.Zero);
      this.entityExcess++;
    } else if (isHexDigit(c)) {
      this.entityResult = this.entityResult * 16 + ((c | 32) - CharCodes3.LowerA + 10);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  allowLegacyEntity() {
    return !this.xmlMode && (this.baseState === State2.Text || this.baseState === State2.InSpecialTag);
  }
  cleanup() {
    if (this.running && this.sectionStart !== this.index) {
      if (this.state === State2.Text || this.state === State2.InSpecialTag && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === State2.InAttributeValueDq || this.state === State2.InAttributeValueSq || this.state === State2.InAttributeValueNq) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  parse() {
    while (this.shouldContinue()) {
      const c = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case State2.Text: {
          this.stateText(c);
          break;
        }
        case State2.SpecialStartSequence: {
          this.stateSpecialStartSequence(c);
          break;
        }
        case State2.InSpecialTag: {
          this.stateInSpecialTag(c);
          break;
        }
        case State2.CDATASequence: {
          this.stateCDATASequence(c);
          break;
        }
        case State2.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(c);
          break;
        }
        case State2.InAttributeName: {
          this.stateInAttributeName(c);
          break;
        }
        case State2.InCommentLike: {
          this.stateInCommentLike(c);
          break;
        }
        case State2.InSpecialComment: {
          this.stateInSpecialComment(c);
          break;
        }
        case State2.BeforeAttributeName: {
          this.stateBeforeAttributeName(c);
          break;
        }
        case State2.InTagName: {
          this.stateInTagName(c);
          break;
        }
        case State2.InClosingTagName: {
          this.stateInClosingTagName(c);
          break;
        }
        case State2.BeforeTagName: {
          this.stateBeforeTagName(c);
          break;
        }
        case State2.AfterAttributeName: {
          this.stateAfterAttributeName(c);
          break;
        }
        case State2.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(c);
          break;
        }
        case State2.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(c);
          break;
        }
        case State2.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(c);
          break;
        }
        case State2.AfterClosingTagName: {
          this.stateAfterClosingTagName(c);
          break;
        }
        case State2.BeforeSpecialS: {
          this.stateBeforeSpecialS(c);
          break;
        }
        case State2.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(c);
          break;
        }
        case State2.InSelfClosingTag: {
          this.stateInSelfClosingTag(c);
          break;
        }
        case State2.InDeclaration: {
          this.stateInDeclaration(c);
          break;
        }
        case State2.BeforeDeclaration: {
          this.stateBeforeDeclaration(c);
          break;
        }
        case State2.BeforeComment: {
          this.stateBeforeComment(c);
          break;
        }
        case State2.InProcessingInstruction: {
          this.stateInProcessingInstruction(c);
          break;
        }
        case State2.InNamedEntity: {
          this.stateInNamedEntity(c);
          break;
        }
        case State2.BeforeEntity: {
          this.stateBeforeEntity(c);
          break;
        }
        case State2.InHexEntity: {
          this.stateInHexEntity(c);
          break;
        }
        case State2.InNumericEntity: {
          this.stateInNumericEntity(c);
          break;
        }
        default: {
          this.stateBeforeNumericEntity(c);
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    if (this.state === State2.InNamedEntity) {
      this.emitNamedEntity();
    }
    if (this.sectionStart < this.index) {
      this.handleTrailingData();
    }
    this.cbs.onend();
  }
  handleTrailingData() {
    const endIndex = this.buffer.length + this.offset;
    if (this.state === State2.InCommentLike) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex, 0);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex, 0);
      }
    } else if (this.state === State2.InNumericEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State2.InHexEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State2.InTagName || this.state === State2.BeforeAttributeName || this.state === State2.BeforeAttributeValue || this.state === State2.AfterAttributeName || this.state === State2.InAttributeName || this.state === State2.InAttributeValueSq || this.state === State2.InAttributeValueDq || this.state === State2.InAttributeValueNq || this.state === State2.InClosingTagName) {
    } else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitPartial(start, endIndex) {
    if (this.baseState !== State2.Text && this.baseState !== State2.InSpecialTag) {
      this.cbs.onattribdata(start, endIndex);
    } else {
      this.cbs.ontext(start, endIndex);
    }
  }
  emitCodePoint(cp) {
    if (this.baseState !== State2.Text && this.baseState !== State2.InSpecialTag) {
      this.cbs.onattribentity(cp);
    } else {
      this.cbs.ontextentity(cp);
    }
  }
};

// ../../node_modules/.pnpm/htmlparser2@8.0.2/node_modules/htmlparser2/lib/esm/Parser.js
var formTags = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
var pTag = /* @__PURE__ */ new Set(["p"]);
var tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
var ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
var rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
var openImpliesClose = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", pTag],
  ["h1", pTag],
  ["h2", pTag],
  ["h3", pTag],
  ["h4", pTag],
  ["h5", pTag],
  ["h6", pTag],
  ["select", formTags],
  ["input", formTags],
  ["output", formTags],
  ["button", formTags],
  ["datalist", formTags],
  ["textarea", formTags],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", ddtTags],
  ["dt", ddtTags],
  ["address", pTag],
  ["article", pTag],
  ["aside", pTag],
  ["blockquote", pTag],
  ["details", pTag],
  ["div", pTag],
  ["dl", pTag],
  ["fieldset", pTag],
  ["figcaption", pTag],
  ["figure", pTag],
  ["footer", pTag],
  ["form", pTag],
  ["header", pTag],
  ["hr", pTag],
  ["main", pTag],
  ["nav", pTag],
  ["ol", pTag],
  ["pre", pTag],
  ["section", pTag],
  ["table", pTag],
  ["ul", pTag],
  ["rt", rtpTags],
  ["rp", rtpTags],
  ["tbody", tableSectionTags],
  ["tfoot", tableSectionTags]
]);
var voidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
var htmlIntegrationElements = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
var reNameEnd = /\s|\//;
var Parser2 = class {
  constructor(cbs, options = {}) {
    var _a3, _b, _c, _d, _e;
    this.options = options;
    this.startIndex = 0;
    this.endIndex = 0;
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.foreignContext = [];
    this.buffers = [];
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
    this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
    this.lowerCaseTagNames = (_a3 = options.lowerCaseTags) !== null && _a3 !== void 0 ? _a3 : !options.xmlMode;
    this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
    this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer2)(this.options, this);
    (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
  }
  ontext(start, endIndex) {
    var _a3, _b;
    const data2 = this.getSlice(start, endIndex);
    this.endIndex = endIndex - 1;
    (_b = (_a3 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a3, data2);
    this.startIndex = endIndex;
  }
  ontextentity(cp) {
    var _a3, _b;
    const index2 = this.tokenizer.getSectionStart();
    this.endIndex = index2 - 1;
    (_b = (_a3 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a3, fromCodePoint(cp));
    this.startIndex = index2;
  }
  isVoidElement(name2) {
    return !this.options.xmlMode && voidElements.has(name2);
  }
  onopentagname(start, endIndex) {
    this.endIndex = endIndex;
    let name2 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    this.emitOpenTag(name2);
  }
  emitOpenTag(name2) {
    var _a3, _b, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name2;
    const impliesClose = !this.options.xmlMode && openImpliesClose.get(name2);
    if (impliesClose) {
      while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
        const element = this.stack.pop();
        (_b = (_a3 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a3, element, true);
      }
    }
    if (!this.isVoidElement(name2)) {
      this.stack.push(name2);
      if (foreignContextElements.has(name2)) {
        this.foreignContext.push(true);
      } else if (htmlIntegrationElements.has(name2)) {
        this.foreignContext.push(false);
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name2);
    if (this.cbs.onopentag)
      this.attribs = {};
  }
  endOpenTag(isImplied) {
    var _a3, _b;
    this.startIndex = this.openTagStart;
    if (this.attribs) {
      (_b = (_a3 = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a3, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  }
  onopentagend(endIndex) {
    this.endIndex = endIndex;
    this.endOpenTag(false);
    this.startIndex = endIndex + 1;
  }
  onclosetag(start, endIndex) {
    var _a3, _b, _c, _d, _e, _f;
    this.endIndex = endIndex;
    let name2 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    if (foreignContextElements.has(name2) || htmlIntegrationElements.has(name2)) {
      this.foreignContext.pop();
    }
    if (!this.isVoidElement(name2)) {
      const pos = this.stack.lastIndexOf(name2);
      if (pos !== -1) {
        if (this.cbs.onclosetag) {
          let count = this.stack.length - pos;
          while (count--) {
            this.cbs.onclosetag(this.stack.pop(), count !== 0);
          }
        } else
          this.stack.length = pos;
      } else if (!this.options.xmlMode && name2 === "p") {
        this.emitOpenTag("p");
        this.closeCurrentTag(true);
      }
    } else if (!this.options.xmlMode && name2 === "br") {
      (_b = (_a3 = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a3, "br");
      (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
      (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
    }
    this.startIndex = endIndex + 1;
  }
  onselfclosingtag(endIndex) {
    this.endIndex = endIndex;
    if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
      this.closeCurrentTag(false);
      this.startIndex = endIndex + 1;
    } else {
      this.onopentagend(endIndex);
    }
  }
  closeCurrentTag(isOpenImplied) {
    var _a3, _b;
    const name2 = this.tagname;
    this.endOpenTag(isOpenImplied);
    if (this.stack[this.stack.length - 1] === name2) {
      (_b = (_a3 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a3, name2, !isOpenImplied);
      this.stack.pop();
    }
  }
  onattribname(start, endIndex) {
    this.startIndex = start;
    const name2 = this.getSlice(start, endIndex);
    this.attribname = this.lowerCaseAttributeNames ? name2.toLowerCase() : name2;
  }
  onattribdata(start, endIndex) {
    this.attribvalue += this.getSlice(start, endIndex);
  }
  onattribentity(cp) {
    this.attribvalue += fromCodePoint(cp);
  }
  onattribend(quote, endIndex) {
    var _a3, _b;
    this.endIndex = endIndex;
    (_b = (_a3 = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a3, this.attribname, this.attribvalue, quote === QuoteType.Double ? '"' : quote === QuoteType.Single ? "'" : quote === QuoteType.NoValue ? void 0 : null);
    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribvalue = "";
  }
  getInstructionName(value) {
    const index2 = value.search(reNameEnd);
    let name2 = index2 < 0 ? value : value.substr(0, index2);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    return name2;
  }
  ondeclaration(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`!${name2}`, `!${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  onprocessinginstruction(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`?${name2}`, `?${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  oncomment(start, endIndex, offset) {
    var _a3, _b, _c, _d;
    this.endIndex = endIndex;
    (_b = (_a3 = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a3, this.getSlice(start, endIndex - offset));
    (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
    this.startIndex = endIndex + 1;
  }
  oncdata(start, endIndex, offset) {
    var _a3, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex - offset);
    if (this.options.xmlMode || this.options.recognizeCDATA) {
      (_b = (_a3 = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a3);
      (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
      (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);
      (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
    }
    this.startIndex = endIndex + 1;
  }
  onend() {
    var _a3, _b;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let index2 = this.stack.length; index2 > 0; this.cbs.onclosetag(this.stack[--index2], true))
        ;
    }
    (_b = (_a3 = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a3);
  }
  reset() {
    var _a3, _b, _c, _d;
    (_b = (_a3 = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a3);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack.length = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
    this.buffers.length = 0;
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
  }
  parseComplete(data2) {
    this.reset();
    this.end(data2);
  }
  getSlice(start, end2) {
    while (start - this.bufferOffset >= this.buffers[0].length) {
      this.shiftBuffer();
    }
    let slice2 = this.buffers[0].slice(start - this.bufferOffset, end2 - this.bufferOffset);
    while (end2 - this.bufferOffset > this.buffers[0].length) {
      this.shiftBuffer();
      slice2 += this.buffers[0].slice(0, end2 - this.bufferOffset);
    }
    return slice2;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length;
    this.writeIndex--;
    this.buffers.shift();
  }
  write(chunk) {
    var _a3, _b;
    if (this.ended) {
      (_b = (_a3 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a3, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(chunk);
    if (this.tokenizer.running) {
      this.tokenizer.write(chunk);
      this.writeIndex++;
    }
  }
  end(chunk) {
    var _a3, _b;
    if (this.ended) {
      (_b = (_a3 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a3, new Error(".end() after done!"));
      return;
    }
    if (chunk)
      this.write(chunk);
    this.ended = true;
    this.tokenizer.end();
  }
  pause() {
    this.tokenizer.pause();
  }
  resume() {
    this.tokenizer.resume();
    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    }
    if (this.ended)
      this.tokenizer.end();
  }
  parseChunk(chunk) {
    this.write(chunk);
  }
  done(chunk) {
    this.end(chunk);
  }
};

// ../../node_modules/.pnpm/htmlparser2@8.0.2/node_modules/htmlparser2/lib/esm/index.js
function parseDocument(data2, options) {
  const handler = new DomHandler(void 0, options);
  new Parser2(handler, options).end(data2);
  return handler.root;
}

// ../../node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/index.js
var parse5 = getParse((content, options, isDocument3, context) => options.xmlMode || options._useHtmlParser2 ? parseDocument(content, options) : parseWithParse5(content, options, isDocument3, context));
var load = getLoad(parse5, (dom, options) => options.xmlMode || options._useHtmlParser2 ? esm_default(dom, options) : renderWithParse5(dom));
var esm_default2 = load([]);
var { contains: contains2 } = static_exports;
var { merge: merge2 } = static_exports;
var { parseHTML: parseHTML2 } = static_exports;
var { root: root2 } = static_exports;

// ../../node_modules/.pnpm/markmap-html-parser@0.17.1_markmap-common@0.18.9/node_modules/markmap-html-parser/dist/index.mjs
var defaultSelectorRules = {
  "div,p": ({ $node }) => ({
    queue: $node.children()
  }),
  "h1,h2,h3,h4,h5,h6": ({ $node, getContent }) => ({
    ...getContent($node.contents())
  }),
  "ul,ol": ({ $node }) => ({
    queue: $node.children(),
    nesting: true
  }),
  li: ({ $node, getContent }) => {
    const queue = $node.children().filter("ul,ol");
    let content;
    if ($node.contents().first().is("div,p")) {
      content = getContent($node.children().first());
    } else {
      let $contents = $node.contents();
      const i = $contents.index(queue);
      if (i >= 0)
        $contents = $contents.slice(0, i);
      content = getContent($contents);
    }
    return {
      queue,
      nesting: true,
      ...content
    };
  },
  "table,pre,p>img:only-child": ({ $node, getContent }) => ({
    ...getContent($node)
  })
};
var defaultOptions2 = {
  selector: "h1,h2,h3,h4,h5,h6,ul,ol,li,table,pre,p>img:only-child",
  selectorRules: defaultSelectorRules
};
var MARKMAP_COMMENT_PREFIX = "markmap: ";
var SELECTOR_HEADING = /^h[1-6]$/;
var SELECTOR_LIST = /^[uo]l$/;
var SELECTOR_LIST_ITEM = /^li$/;
function getLevel(tagName) {
  if (SELECTOR_HEADING.test(tagName))
    return +tagName[1];
  if (SELECTOR_LIST.test(tagName))
    return 8;
  if (SELECTOR_LIST_ITEM.test(tagName))
    return 9;
  return 7;
}
function parseHtml(html3, opts) {
  const options = {
    ...defaultOptions2,
    ...opts
  };
  const $2 = load(html3);
  const $root = $2("body");
  let id = 0;
  const rootNode = {
    id,
    tag: "",
    html: "",
    level: 0,
    parent: 0,
    childrenLevel: 0,
    children: []
  };
  const headingStack = [];
  let skippingHeading = 0;
  checkNodes($root.children());
  return rootNode;
  function addChild(props) {
    var _a3;
    const { parent: parent2 } = props;
    const node = {
      id: ++id,
      tag: props.tagName,
      level: props.level,
      html: props.html,
      childrenLevel: 0,
      children: props.nesting ? [] : void 0,
      parent: parent2.id
    };
    if ((_a3 = props.comments) == null ? void 0 : _a3.length) {
      node.comments = props.comments;
    }
    if (Object.keys(props.data || {}).length) {
      node.data = props.data;
    }
    if (parent2.children) {
      if (parent2.childrenLevel === 0 || parent2.childrenLevel > node.level) {
        parent2.children = [];
        parent2.childrenLevel = node.level;
      }
      if (parent2.childrenLevel === node.level) {
        parent2.children.push(node);
      }
    }
    return node;
  }
  function getCurrentHeading(level) {
    let heading2;
    while ((heading2 = headingStack.at(-1)) && heading2.level >= level) {
      headingStack.pop();
    }
    return heading2 || rootNode;
  }
  function getContent($node) {
    var _a3;
    const result = extractMagicComments($node);
    const html22 = (_a3 = $2.html(result.$node)) == null ? void 0 : _a3.trimEnd();
    return { comments: result.comments, html: html22 };
  }
  function extractMagicComments($node) {
    const comments = [];
    $node = $node.filter((_, child) => {
      if (child.type === "comment") {
        const data2 = child.data.trim();
        if (data2.startsWith(MARKMAP_COMMENT_PREFIX)) {
          comments.push(data2.slice(MARKMAP_COMMENT_PREFIX.length).trim());
          return false;
        }
      }
      return true;
    });
    return { $node, comments };
  }
  function checkNodes($els, node) {
    $els.each((_, child) => {
      var _a3;
      const $child = $2(child);
      const rule = (_a3 = Object.entries(options.selectorRules).find(
        ([selector]) => $child.is(selector)
      )) == null ? void 0 : _a3[1];
      const result = rule == null ? void 0 : rule({ $node: $child, $: $2, getContent });
      if ((result == null ? void 0 : result.queue) && !result.nesting) {
        checkNodes(result.queue, node);
        return;
      }
      const level = getLevel(child.tagName);
      if (!result) {
        if (level <= 6) {
          skippingHeading = level;
        }
        return;
      }
      if (skippingHeading > 0 && level > skippingHeading)
        return;
      if (!$child.is(options.selector))
        return;
      skippingHeading = 0;
      const isHeading = level <= 6;
      let data2 = $child.data();
      if ($child.children("code:only-child").length) {
        data2 = {
          ...data2,
          ...$child.children().data()
        };
      }
      const childNode = addChild({
        parent: node || getCurrentHeading(level),
        nesting: !!result.queue || isHeading,
        tagName: child.tagName,
        level,
        html: result.html || "",
        comments: result.comments,
        data: data2
      });
      if (isHeading)
        headingStack.push(childNode);
      if (result.queue)
        checkNodes(result.queue, childNode);
    });
  }
}
function convertNode(htmlRoot) {
  return walkTree(htmlRoot, (htmlNode, next2) => {
    const node = {
      content: htmlNode.html,
      children: next2() || []
    };
    if (htmlNode.data) {
      node.payload = {
        ...htmlNode.data
      };
    }
    if (htmlNode.comments) {
      if (htmlNode.comments.includes("foldAll")) {
        node.payload = { ...node.payload, fold: 2 };
      } else if (htmlNode.comments.includes("fold")) {
        node.payload = { ...node.payload, fold: 1 };
      }
    }
    return node;
  });
}
function buildTree(html3, opts) {
  const htmlRoot = parseHtml(html3, opts);
  return convertNode(htmlRoot);
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/common/utils.mjs
var utils_exports = {};
__export(utils_exports, {
  arrayReplaceAt: () => arrayReplaceAt,
  assign: () => assign,
  escapeHtml: () => escapeHtml,
  escapeRE: () => escapeRE,
  fromCodePoint: () => fromCodePoint3,
  has: () => has2,
  isMdAsciiPunct: () => isMdAsciiPunct,
  isPunctChar: () => isPunctChar,
  isSpace: () => isSpace,
  isString: () => isString,
  isValidEntityCode: () => isValidEntityCode,
  isWhiteSpace: () => isWhiteSpace,
  lib: () => lib,
  normalizeReference: () => normalizeReference,
  unescapeAll: () => unescapeAll,
  unescapeMd: () => unescapeMd
});

// ../../node_modules/.pnpm/mdurl@2.0.0/node_modules/mdurl/index.mjs
var mdurl_exports = {};
__export(mdurl_exports, {
  decode: () => decode_default,
  encode: () => encode_default,
  format: () => format,
  parse: () => parse_default
});

// ../../node_modules/.pnpm/mdurl@2.0.0/node_modules/mdurl/lib/decode.mjs
var decodeCache = {};
function getDecodeCache(exclude) {
  let cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = decodeCache[exclude] = [];
  for (let i = 0; i < 128; i++) {
    const ch = String.fromCharCode(i);
    cache.push(ch);
  }
  for (let i = 0; i < exclude.length; i++) {
    const ch = exclude.charCodeAt(i);
    cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
  }
  return cache;
}
function decode(string2, exclude) {
  if (typeof exclude !== "string") {
    exclude = decode.defaultChars;
  }
  const cache = getDecodeCache(exclude);
  return string2.replace(/(%[a-f0-9]{2})+/gi, function(seq2) {
    let result = "";
    for (let i = 0, l = seq2.length; i < l; i += 3) {
      const b1 = parseInt(seq2.slice(i + 1, i + 3), 16);
      if (b1 < 128) {
        result += cache[b1];
        continue;
      }
      if ((b1 & 224) === 192 && i + 3 < l) {
        const b2 = parseInt(seq2.slice(i + 4, i + 6), 16);
        if ((b2 & 192) === 128) {
          const chr = b1 << 6 & 1984 | b2 & 63;
          if (chr < 128) {
            result += "\uFFFD\uFFFD";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 3;
          continue;
        }
      }
      if ((b1 & 240) === 224 && i + 6 < l) {
        const b2 = parseInt(seq2.slice(i + 4, i + 6), 16);
        const b3 = parseInt(seq2.slice(i + 7, i + 9), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128) {
          const chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
          if (chr < 2048 || chr >= 55296 && chr <= 57343) {
            result += "\uFFFD\uFFFD\uFFFD";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 6;
          continue;
        }
      }
      if ((b1 & 248) === 240 && i + 9 < l) {
        const b2 = parseInt(seq2.slice(i + 4, i + 6), 16);
        const b3 = parseInt(seq2.slice(i + 7, i + 9), 16);
        const b4 = parseInt(seq2.slice(i + 10, i + 12), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
          let chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
          if (chr < 65536 || chr > 1114111) {
            result += "\uFFFD\uFFFD\uFFFD\uFFFD";
          } else {
            chr -= 65536;
            result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
          }
          i += 9;
          continue;
        }
      }
      result += "\uFFFD";
    }
    return result;
  });
}
decode.defaultChars = ";/?:@&=+$,#";
decode.componentChars = "";
var decode_default = decode;

// ../../node_modules/.pnpm/mdurl@2.0.0/node_modules/mdurl/lib/encode.mjs
var encodeCache = {};
function getEncodeCache(exclude) {
  let cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = encodeCache[exclude] = [];
  for (let i = 0; i < 128; i++) {
    const ch = String.fromCharCode(i);
    if (/^[0-9a-z]$/i.test(ch)) {
      cache.push(ch);
    } else {
      cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
    }
  }
  for (let i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }
  return cache;
}
function encode(string2, exclude, keepEscaped) {
  if (typeof exclude !== "string") {
    keepEscaped = exclude;
    exclude = encode.defaultChars;
  }
  if (typeof keepEscaped === "undefined") {
    keepEscaped = true;
  }
  const cache = getEncodeCache(exclude);
  let result = "";
  for (let i = 0, l = string2.length; i < l; i++) {
    const code2 = string2.charCodeAt(i);
    if (keepEscaped && code2 === 37 && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string2.slice(i + 1, i + 3))) {
        result += string2.slice(i, i + 3);
        i += 2;
        continue;
      }
    }
    if (code2 < 128) {
      result += cache[code2];
      continue;
    }
    if (code2 >= 55296 && code2 <= 57343) {
      if (code2 >= 55296 && code2 <= 56319 && i + 1 < l) {
        const nextCode = string2.charCodeAt(i + 1);
        if (nextCode >= 56320 && nextCode <= 57343) {
          result += encodeURIComponent(string2[i] + string2[i + 1]);
          i++;
          continue;
        }
      }
      result += "%EF%BF%BD";
      continue;
    }
    result += encodeURIComponent(string2[i]);
  }
  return result;
}
encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";
var encode_default = encode;

// ../../node_modules/.pnpm/mdurl@2.0.0/node_modules/mdurl/lib/format.mjs
function format(url) {
  let result = "";
  result += url.protocol || "";
  result += url.slashes ? "//" : "";
  result += url.auth ? url.auth + "@" : "";
  if (url.hostname && url.hostname.indexOf(":") !== -1) {
    result += "[" + url.hostname + "]";
  } else {
    result += url.hostname || "";
  }
  result += url.port ? ":" + url.port : "";
  result += url.pathname || "";
  result += url.search || "";
  result += url.hash || "";
  return result;
}

// ../../node_modules/.pnpm/mdurl@2.0.0/node_modules/mdurl/lib/parse.mjs
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i;
var portPattern = /:[0-9]*$/;
var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
var autoEscape = ["'"].concat(unwise);
var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
var hostEndingChars = ["/", "?", "#"];
var hostnameMaxLen = 255;
var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
var hostlessProtocol = {
  javascript: true,
  "javascript:": true
};
var slashedProtocol = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url)
    return url;
  const u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}
Url.prototype.parse = function(url, slashesDenoteHost) {
  let lowerProto, hec, slashes;
  let rest = url;
  rest = rest.trim();
  if (!slashesDenoteHost && url.split("#").length === 1) {
    const simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }
  let proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    let hostEnd = -1;
    for (let i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    let auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }
    hostEnd = -1;
    for (let i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }
    if (rest[hostEnd - 1] === ":") {
      hostEnd--;
    }
    const host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost(host);
    this.hostname = this.hostname || "";
    const ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      const hostparts = this.hostname.split(/\./);
      for (let i = 0, l = hostparts.length; i < l; i++) {
        const part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          let newpart = "";
          for (let j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              newpart += "x";
            } else {
              newpart += part[j];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            const validParts = hostparts.slice(0, i);
            const notHost = hostparts.slice(i + 1);
            const bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    }
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }
  const hash = rest.indexOf("#");
  if (hash !== -1) {
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  const qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "";
  }
  return this;
};
Url.prototype.parseHost = function(host) {
  let port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};
var parse_default = urlParse;

// ../../node_modules/.pnpm/uc.micro@2.1.0/node_modules/uc.micro/index.mjs
var uc_exports = {};
__export(uc_exports, {
  Any: () => regex_default,
  Cc: () => regex_default2,
  Cf: () => regex_default3,
  P: () => regex_default4,
  S: () => regex_default5,
  Z: () => regex_default6
});

// ../../node_modules/.pnpm/uc.micro@2.1.0/node_modules/uc.micro/properties/Any/regex.mjs
var regex_default = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

// ../../node_modules/.pnpm/uc.micro@2.1.0/node_modules/uc.micro/categories/Cc/regex.mjs
var regex_default2 = /[\0-\x1F\x7F-\x9F]/;

// ../../node_modules/.pnpm/uc.micro@2.1.0/node_modules/uc.micro/categories/Cf/regex.mjs
var regex_default3 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

// ../../node_modules/.pnpm/uc.micro@2.1.0/node_modules/uc.micro/categories/P/regex.mjs
var regex_default4 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

// ../../node_modules/.pnpm/uc.micro@2.1.0/node_modules/uc.micro/categories/S/regex.mjs
var regex_default5 = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/;

// ../../node_modules/.pnpm/uc.micro@2.1.0/node_modules/uc.micro/categories/Z/regex.mjs
var regex_default6 = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/common/utils.mjs
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString(obj) {
  return _class(obj) === "[object String]";
}
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function has2(object, key) {
  return _hasOwnProperty.call(object, key);
}
function assign(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be object");
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}
function isValidEntityCode(c) {
  if (c >= 55296 && c <= 57343) {
    return false;
  }
  if (c >= 64976 && c <= 65007) {
    return false;
  }
  if ((c & 65535) === 65535 || (c & 65535) === 65534) {
    return false;
  }
  if (c >= 0 && c <= 8) {
    return false;
  }
  if (c === 11) {
    return false;
  }
  if (c >= 14 && c <= 31) {
    return false;
  }
  if (c >= 127 && c <= 159) {
    return false;
  }
  if (c > 1114111) {
    return false;
  }
  return true;
}
function fromCodePoint3(c) {
  if (c > 65535) {
    c -= 65536;
    const surrogate1 = 55296 + (c >> 10);
    const surrogate2 = 56320 + (c & 1023);
    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}
var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function replaceEntityPattern(match2, name2) {
  if (name2.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name2)) {
    const code2 = name2[1].toLowerCase() === "x" ? parseInt(name2.slice(2), 16) : parseInt(name2.slice(1), 10);
    if (isValidEntityCode(code2)) {
      return fromCodePoint3(code2);
    }
    return match2;
  }
  const decoded = decodeHTML(match2);
  if (decoded !== match2) {
    return decoded;
  }
  return match2;
}
function unescapeMd(str) {
  if (str.indexOf("\\") < 0) {
    return str;
  }
  return str.replace(UNESCAPE_MD_RE, "$1");
}
function unescapeAll(str) {
  if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
    return str;
  }
  return str.replace(UNESCAPE_ALL_RE, function(match2, escaped, entity2) {
    if (escaped) {
      return escaped;
    }
    return replaceEntityPattern(match2, entity2);
  });
}
var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}
function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}
var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, "\\$&");
}
function isSpace(code2) {
  switch (code2) {
    case 9:
    case 32:
      return true;
  }
  return false;
}
function isWhiteSpace(code2) {
  if (code2 >= 8192 && code2 <= 8202) {
    return true;
  }
  switch (code2) {
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return true;
  }
  return false;
}
function isPunctChar(ch) {
  return regex_default4.test(ch) || regex_default5.test(ch);
}
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function normalizeReference(str) {
  str = str.trim().replace(/\s+/g, " ");
  if ("\u1E9E".toLowerCase() === "\u1E7E") {
    str = str.replace(/ẞ/g, "\xDF");
  }
  return str.toLowerCase().toUpperCase();
}
var lib = { mdurl: mdurl_exports, ucmicro: uc_exports };

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/helpers/index.mjs
var helpers_exports = {};
__export(helpers_exports, {
  parseLinkDestination: () => parseLinkDestination,
  parseLinkLabel: () => parseLinkLabel,
  parseLinkTitle: () => parseLinkTitle
});

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/helpers/parse_link_label.mjs
function parseLinkLabel(state, start, disableNested) {
  let level, found, marker, prevPos;
  const max = state.posMax;
  const oldPos = state.pos;
  state.pos = start + 1;
  level = 1;
  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 93) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }
    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 91) {
      if (prevPos === state.pos - 1) {
        level++;
      } else if (disableNested) {
        state.pos = oldPos;
        return -1;
      }
    }
  }
  let labelEnd = -1;
  if (found) {
    labelEnd = state.pos;
  }
  state.pos = oldPos;
  return labelEnd;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/helpers/parse_link_destination.mjs
function parseLinkDestination(str, start, max) {
  let code2;
  let pos = start;
  const result = {
    ok: false,
    pos: 0,
    str: ""
  };
  if (str.charCodeAt(pos) === 60) {
    pos++;
    while (pos < max) {
      code2 = str.charCodeAt(pos);
      if (code2 === 10) {
        return result;
      }
      if (code2 === 60) {
        return result;
      }
      if (code2 === 62) {
        result.pos = pos + 1;
        result.str = unescapeAll(str.slice(start + 1, pos));
        result.ok = true;
        return result;
      }
      if (code2 === 92 && pos + 1 < max) {
        pos += 2;
        continue;
      }
      pos++;
    }
    return result;
  }
  let level = 0;
  while (pos < max) {
    code2 = str.charCodeAt(pos);
    if (code2 === 32) {
      break;
    }
    if (code2 < 32 || code2 === 127) {
      break;
    }
    if (code2 === 92 && pos + 1 < max) {
      if (str.charCodeAt(pos + 1) === 32) {
        break;
      }
      pos += 2;
      continue;
    }
    if (code2 === 40) {
      level++;
      if (level > 32) {
        return result;
      }
    }
    if (code2 === 41) {
      if (level === 0) {
        break;
      }
      level--;
    }
    pos++;
  }
  if (start === pos) {
    return result;
  }
  if (level !== 0) {
    return result;
  }
  result.str = unescapeAll(str.slice(start, pos));
  result.pos = pos;
  result.ok = true;
  return result;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/helpers/parse_link_title.mjs
function parseLinkTitle(str, start, max, prev_state) {
  let code2;
  let pos = start;
  const state = {
    ok: false,
    can_continue: false,
    pos: 0,
    str: "",
    marker: 0
  };
  if (prev_state) {
    state.str = prev_state.str;
    state.marker = prev_state.marker;
  } else {
    if (pos >= max) {
      return state;
    }
    let marker = str.charCodeAt(pos);
    if (marker !== 34 && marker !== 39 && marker !== 40) {
      return state;
    }
    start++;
    pos++;
    if (marker === 40) {
      marker = 41;
    }
    state.marker = marker;
  }
  while (pos < max) {
    code2 = str.charCodeAt(pos);
    if (code2 === state.marker) {
      state.pos = pos + 1;
      state.str += unescapeAll(str.slice(start, pos));
      state.ok = true;
      return state;
    } else if (code2 === 40 && state.marker === 41) {
      return state;
    } else if (code2 === 92 && pos + 1 < max) {
      pos++;
    }
    pos++;
  }
  state.can_continue = true;
  state.str += unescapeAll(str.slice(start, pos));
  return state;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/renderer.mjs
var default_rules = {};
default_rules.code_inline = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  return "<code" + slf.renderAttrs(token) + ">" + escapeHtml(token.content) + "</code>";
};
default_rules.code_block = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
};
default_rules.fence = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  const info = token.info ? unescapeAll(token.info).trim() : "";
  let langName = "";
  let langAttrs = "";
  if (info) {
    const arr = info.split(/(\s+)/g);
    langName = arr[0];
    langAttrs = arr.slice(2).join("");
  }
  let highlighted;
  if (options.highlight) {
    highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }
  if (highlighted.indexOf("<pre") === 0) {
    return highlighted + "\n";
  }
  if (info) {
    const i = token.attrIndex("class");
    const tmpAttrs = token.attrs ? token.attrs.slice() : [];
    if (i < 0) {
      tmpAttrs.push(["class", options.langPrefix + langName]);
    } else {
      tmpAttrs[i] = tmpAttrs[i].slice();
      tmpAttrs[i][1] += " " + options.langPrefix + langName;
    }
    const tmpToken = {
      attrs: tmpAttrs
    };
    return `<pre><code${slf.renderAttrs(tmpToken)}>${highlighted}</code></pre>
`;
  }
  return `<pre><code${slf.renderAttrs(token)}>${highlighted}</code></pre>
`;
};
default_rules.image = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env);
  return slf.renderToken(tokens, idx, options);
};
default_rules.hardbreak = function(tokens, idx, options) {
  return options.xhtmlOut ? "<br />\n" : "<br>\n";
};
default_rules.softbreak = function(tokens, idx, options) {
  return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
};
default_rules.text = function(tokens, idx) {
  return escapeHtml(tokens[idx].content);
};
default_rules.html_block = function(tokens, idx) {
  return tokens[idx].content;
};
default_rules.html_inline = function(tokens, idx) {
  return tokens[idx].content;
};
function Renderer() {
  this.rules = assign({}, default_rules);
}
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  let i, l, result;
  if (!token.attrs) {
    return "";
  }
  result = "";
  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += " " + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }
  return result;
};
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  const token = tokens[idx];
  let result = "";
  if (token.hidden) {
    return "";
  }
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += "\n";
  }
  result += (token.nesting === -1 ? "</" : "<") + token.tag;
  result += this.renderAttrs(token);
  if (token.nesting === 0 && options.xhtmlOut) {
    result += " /";
  }
  let needLf = false;
  if (token.block) {
    needLf = true;
    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        const nextToken = tokens[idx + 1];
        if (nextToken.type === "inline" || nextToken.hidden) {
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          needLf = false;
        }
      }
    }
  }
  result += needLf ? ">\n" : ">";
  return result;
};
Renderer.prototype.renderInline = function(tokens, options, env) {
  let result = "";
  const rules = this.rules;
  for (let i = 0, len = tokens.length; i < len; i++) {
    const type = tokens[i].type;
    if (typeof rules[type] !== "undefined") {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }
  return result;
};
Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
  let result = "";
  for (let i = 0, len = tokens.length; i < len; i++) {
    switch (tokens[i].type) {
      case "text":
        result += tokens[i].content;
        break;
      case "image":
        result += this.renderInlineAsText(tokens[i].children, options, env);
        break;
      case "html_inline":
      case "html_block":
        result += tokens[i].content;
        break;
      case "softbreak":
      case "hardbreak":
        result += "\n";
        break;
      default:
    }
  }
  return result;
};
Renderer.prototype.render = function(tokens, options, env) {
  let result = "";
  const rules = this.rules;
  for (let i = 0, len = tokens.length; i < len; i++) {
    const type = tokens[i].type;
    if (type === "inline") {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== "undefined") {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }
  return result;
};
var renderer_default = Renderer;

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/ruler.mjs
function Ruler() {
  this.__rules__ = [];
  this.__cache__ = null;
}
Ruler.prototype.__find__ = function(name2) {
  for (let i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name2) {
      return i;
    }
  }
  return -1;
};
Ruler.prototype.__compile__ = function() {
  const self2 = this;
  const chains = [""];
  self2.__rules__.forEach(function(rule) {
    if (!rule.enabled) {
      return;
    }
    rule.alt.forEach(function(altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });
  self2.__cache__ = {};
  chains.forEach(function(chain) {
    self2.__cache__[chain] = [];
    self2.__rules__.forEach(function(rule) {
      if (!rule.enabled) {
        return;
      }
      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }
      self2.__cache__[chain].push(rule.fn);
    });
  });
};
Ruler.prototype.at = function(name2, fn, options) {
  const index2 = this.__find__(name2);
  const opt = options || {};
  if (index2 === -1) {
    throw new Error("Parser rule not found: " + name2);
  }
  this.__rules__[index2].fn = fn;
  this.__rules__[index2].alt = opt.alt || [];
  this.__cache__ = null;
};
Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
  const index2 = this.__find__(beforeName);
  const opt = options || {};
  if (index2 === -1) {
    throw new Error("Parser rule not found: " + beforeName);
  }
  this.__rules__.splice(index2, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.after = function(afterName, ruleName, fn, options) {
  const index2 = this.__find__(afterName);
  const opt = options || {};
  if (index2 === -1) {
    throw new Error("Parser rule not found: " + afterName);
  }
  this.__rules__.splice(index2 + 1, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.push = function(ruleName, fn, options) {
  const opt = options || {};
  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.enable = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  const result = [];
  list2.forEach(function(name2) {
    const idx = this.__find__(name2);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name2);
    }
    this.__rules__[idx].enabled = true;
    result.push(name2);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler.prototype.enableOnly = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  this.__rules__.forEach(function(rule) {
    rule.enabled = false;
  });
  this.enable(list2, ignoreInvalid);
};
Ruler.prototype.disable = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  const result = [];
  list2.forEach(function(name2) {
    const idx = this.__find__(name2);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name2);
    }
    this.__rules__[idx].enabled = false;
    result.push(name2);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler.prototype.getRules = function(chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }
  return this.__cache__[chainName] || [];
};
var ruler_default = Ruler;

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/token.mjs
function Token(type, tag, nesting) {
  this.type = type;
  this.tag = tag;
  this.attrs = null;
  this.map = null;
  this.nesting = nesting;
  this.level = 0;
  this.children = null;
  this.content = "";
  this.markup = "";
  this.info = "";
  this.meta = null;
  this.block = false;
  this.hidden = false;
}
Token.prototype.attrIndex = function attrIndex(name2) {
  if (!this.attrs) {
    return -1;
  }
  const attrs = this.attrs;
  for (let i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name2) {
      return i;
    }
  }
  return -1;
};
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};
Token.prototype.attrSet = function attrSet(name2, value) {
  const idx = this.attrIndex(name2);
  const attrData = [name2, value];
  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};
Token.prototype.attrGet = function attrGet(name2) {
  const idx = this.attrIndex(name2);
  let value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};
Token.prototype.attrJoin = function attrJoin(name2, value) {
  const idx = this.attrIndex(name2);
  if (idx < 0) {
    this.attrPush([name2, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
  }
};
var token_default = Token;

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_core/state_core.mjs
function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md;
}
StateCore.prototype.Token = token_default;
var state_core_default = StateCore;

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_core/normalize.mjs
var NEWLINES_RE = /\r\n?|\n/g;
var NULL_RE = /\0/g;
function normalize(state) {
  let str;
  str = state.src.replace(NEWLINES_RE, "\n");
  str = str.replace(NULL_RE, "\uFFFD");
  state.src = str;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_core/block.mjs
function block(state) {
  let token;
  if (state.inlineMode) {
    token = new state.Token("inline", "", 0);
    token.content = state.src;
    token.map = [0, 1];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_core/inline.mjs
function inline(state) {
  const tokens = state.tokens;
  for (let i = 0, l = tokens.length; i < l; i++) {
    const tok = tokens[i];
    if (tok.type === "inline") {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_core/linkify.mjs
function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str);
}
function linkify(state) {
  const blockTokens = state.tokens;
  if (!state.md.options.linkify) {
    return;
  }
  for (let j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }
    let tokens = blockTokens[j].children;
    let htmlLinkLevel = 0;
    for (let i = tokens.length - 1; i >= 0; i--) {
      const currentToken = tokens[i];
      if (currentToken.type === "link_close") {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
          i--;
        }
        continue;
      }
      if (currentToken.type === "html_inline") {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }
      if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
        const text4 = currentToken.content;
        let links = state.md.linkify.match(text4);
        const nodes = [];
        let level = currentToken.level;
        let lastPos = 0;
        if (links.length > 0 && links[0].index === 0 && i > 0 && tokens[i - 1].type === "text_special") {
          links = links.slice(1);
        }
        for (let ln = 0; ln < links.length; ln++) {
          const url = links[ln].url;
          const fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }
          let urlText = links[ln].text;
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
          } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }
          const pos = links[ln].index;
          if (pos > lastPos) {
            const token = new state.Token("text", "", 0);
            token.content = text4.slice(lastPos, pos);
            token.level = level;
            nodes.push(token);
          }
          const token_o = new state.Token("link_open", "a", 1);
          token_o.attrs = [["href", fullUrl]];
          token_o.level = level++;
          token_o.markup = "linkify";
          token_o.info = "auto";
          nodes.push(token_o);
          const token_t = new state.Token("text", "", 0);
          token_t.content = urlText;
          token_t.level = level;
          nodes.push(token_t);
          const token_c = new state.Token("link_close", "a", -1);
          token_c.level = --level;
          token_c.markup = "linkify";
          token_c.info = "auto";
          nodes.push(token_c);
          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text4.length) {
          const token = new state.Token("text", "", 0);
          token.content = text4.slice(lastPos);
          token.level = level;
          nodes.push(token);
        }
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_core/replacements.mjs
var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
var SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
var SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
var SCOPED_ABBR = {
  c: "\xA9",
  r: "\xAE",
  tm: "\u2122"
};
function replaceFn(match2, name2) {
  return SCOPED_ABBR[name2.toLowerCase()];
}
function replace_scoped(inlineTokens) {
  let inside_autolink = 0;
  for (let i = inlineTokens.length - 1; i >= 0; i--) {
    const token = inlineTokens[i];
    if (token.type === "text" && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }
    if (token.type === "link_open" && token.info === "auto") {
      inside_autolink--;
    }
    if (token.type === "link_close" && token.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace_rare(inlineTokens) {
  let inside_autolink = 0;
  for (let i = inlineTokens.length - 1; i >= 0; i--) {
    const token = inlineTokens[i];
    if (token.type === "text" && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013");
      }
    }
    if (token.type === "link_open" && token.info === "auto") {
      inside_autolink--;
    }
    if (token.type === "link_close" && token.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace(state) {
  let blkIdx;
  if (!state.md.options.typographer) {
    return;
  }
  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== "inline") {
      continue;
    }
    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }
    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_core/smartquotes.mjs
var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = "\u2019";
function replaceAt(str, index2, ch) {
  return str.slice(0, index2) + ch + str.slice(index2 + 1);
}
function process_inlines(tokens, state) {
  let j;
  const stack = [];
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    const thisLevel = tokens[i].level;
    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;
    if (token.type !== "text") {
      continue;
    }
    let text4 = token.content;
    let pos = 0;
    let max = text4.length;
    OUTER:
      while (pos < max) {
        QUOTE_RE.lastIndex = pos;
        const t2 = QUOTE_RE.exec(text4);
        if (!t2) {
          break;
        }
        let canOpen = true;
        let canClose = true;
        pos = t2.index + 1;
        const isSingle = t2[0] === "'";
        let lastChar = 32;
        if (t2.index - 1 >= 0) {
          lastChar = text4.charCodeAt(t2.index - 1);
        } else {
          for (j = i - 1; j >= 0; j--) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
              break;
            if (!tokens[j].content)
              continue;
            lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
            break;
          }
        }
        let nextChar = 32;
        if (pos < max) {
          nextChar = text4.charCodeAt(pos);
        } else {
          for (j = i + 1; j < tokens.length; j++) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
              break;
            if (!tokens[j].content)
              continue;
            nextChar = tokens[j].content.charCodeAt(0);
            break;
          }
        }
        const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
        const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
        const isLastWhiteSpace = isWhiteSpace(lastChar);
        const isNextWhiteSpace = isWhiteSpace(nextChar);
        if (isNextWhiteSpace) {
          canOpen = false;
        } else if (isNextPunctChar) {
          if (!(isLastWhiteSpace || isLastPunctChar)) {
            canOpen = false;
          }
        }
        if (isLastWhiteSpace) {
          canClose = false;
        } else if (isLastPunctChar) {
          if (!(isNextWhiteSpace || isNextPunctChar)) {
            canClose = false;
          }
        }
        if (nextChar === 34 && t2[0] === '"') {
          if (lastChar >= 48 && lastChar <= 57) {
            canClose = canOpen = false;
          }
        }
        if (canOpen && canClose) {
          canOpen = isLastPunctChar;
          canClose = isNextPunctChar;
        }
        if (!canOpen && !canClose) {
          if (isSingle) {
            token.content = replaceAt(token.content, t2.index, APOSTROPHE);
          }
          continue;
        }
        if (canClose) {
          for (j = stack.length - 1; j >= 0; j--) {
            let item = stack[j];
            if (stack[j].level < thisLevel) {
              break;
            }
            if (item.single === isSingle && stack[j].level === thisLevel) {
              item = stack[j];
              let openQuote;
              let closeQuote;
              if (isSingle) {
                openQuote = state.md.options.quotes[2];
                closeQuote = state.md.options.quotes[3];
              } else {
                openQuote = state.md.options.quotes[0];
                closeQuote = state.md.options.quotes[1];
              }
              token.content = replaceAt(token.content, t2.index, closeQuote);
              tokens[item.token].content = replaceAt(
                tokens[item.token].content,
                item.pos,
                openQuote
              );
              pos += closeQuote.length - 1;
              if (item.token === i) {
                pos += openQuote.length - 1;
              }
              text4 = token.content;
              max = text4.length;
              stack.length = j;
              continue OUTER;
            }
          }
        }
        if (canOpen) {
          stack.push({
            token: i,
            pos: t2.index,
            single: isSingle,
            level: thisLevel
          });
        } else if (canClose && isSingle) {
          token.content = replaceAt(token.content, t2.index, APOSTROPHE);
        }
      }
  }
}
function smartquotes(state) {
  if (!state.md.options.typographer) {
    return;
  }
  for (let blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }
    process_inlines(state.tokens[blkIdx].children, state);
  }
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_core/text_join.mjs
function text_join(state) {
  let curr, last2;
  const blockTokens = state.tokens;
  const l = blockTokens.length;
  for (let j = 0; j < l; j++) {
    if (blockTokens[j].type !== "inline")
      continue;
    const tokens = blockTokens[j].children;
    const max = tokens.length;
    for (curr = 0; curr < max; curr++) {
      if (tokens[curr].type === "text_special") {
        tokens[curr].type = "text";
      }
    }
    for (curr = last2 = 0; curr < max; curr++) {
      if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
      } else {
        if (curr !== last2) {
          tokens[last2] = tokens[curr];
        }
        last2++;
      }
    }
    if (curr !== last2) {
      tokens.length = last2;
    }
  }
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/parser_core.mjs
var _rules = [
  ["normalize", normalize],
  ["block", block],
  ["inline", inline],
  ["linkify", linkify],
  ["replacements", replace],
  ["smartquotes", smartquotes],
  ["text_join", text_join]
];
function Core() {
  this.ruler = new ruler_default();
  for (let i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}
Core.prototype.process = function(state) {
  const rules = this.ruler.getRules("");
  for (let i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};
Core.prototype.State = state_core_default;
var parser_core_default = Core;

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/state_block.mjs
function StateBlock(src, md, env, tokens) {
  this.src = src;
  this.md = md;
  this.env = env;
  this.tokens = tokens;
  this.bMarks = [];
  this.eMarks = [];
  this.tShift = [];
  this.sCount = [];
  this.bsCount = [];
  this.blkIndent = 0;
  this.line = 0;
  this.lineMax = 0;
  this.tight = false;
  this.ddIndent = -1;
  this.listIndent = -1;
  this.parentType = "root";
  this.level = 0;
  const s = this.src;
  for (let start = 0, pos = 0, indent = 0, offset = 0, len = s.length, indent_found = false; pos < len; pos++) {
    const ch = s.charCodeAt(pos);
    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;
        if (ch === 9) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }
    if (ch === 10 || pos === len - 1) {
      if (ch !== 10) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);
      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);
  this.lineMax = this.bMarks.length - 1;
}
StateBlock.prototype.push = function(type, tag, nesting) {
  const token = new token_default(type, tag, nesting);
  token.block = true;
  if (nesting < 0)
    this.level--;
  token.level = this.level;
  if (nesting > 0)
    this.level++;
  this.tokens.push(token);
  return token;
};
StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};
StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (let max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  for (let max = this.src.length; pos < max; pos++) {
    const ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.skipChars = function skipChars(pos, code2) {
  for (let max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code2) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (code2 !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.getLines = function getLines(begin, end2, indent, keepLastLF) {
  if (begin >= end2) {
    return "";
  }
  const queue = new Array(end2 - begin);
  for (let i = 0, line = begin; line < end2; line++, i++) {
    let lineIndent = 0;
    const lineStart = this.bMarks[line];
    let first2 = lineStart;
    let last2;
    if (line + 1 < end2 || keepLastLF) {
      last2 = this.eMarks[line] + 1;
    } else {
      last2 = this.eMarks[line];
    }
    while (first2 < last2 && lineIndent < indent) {
      const ch = this.src.charCodeAt(first2);
      if (isSpace(ch)) {
        if (ch === 9) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first2 - lineStart < this.tShift[line]) {
        lineIndent++;
      } else {
        break;
      }
      first2++;
    }
    if (lineIndent > indent) {
      queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first2, last2);
    } else {
      queue[i] = this.src.slice(first2, last2);
    }
  }
  return queue.join("");
};
StateBlock.prototype.Token = token_default;
var state_block_default = StateBlock;

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/table.mjs
var MAX_AUTOCOMPLETED_CELLS = 65536;
function getLine(state, line) {
  const pos = state.bMarks[line] + state.tShift[line];
  const max = state.eMarks[line];
  return state.src.slice(pos, max);
}
function escapedSplit(str) {
  const result = [];
  const max = str.length;
  let pos = 0;
  let ch = str.charCodeAt(pos);
  let isEscaped = false;
  let lastPos = 0;
  let current = "";
  while (pos < max) {
    if (ch === 124) {
      if (!isEscaped) {
        result.push(current + str.substring(lastPos, pos));
        current = "";
        lastPos = pos + 1;
      } else {
        current += str.substring(lastPos, pos - 1);
        lastPos = pos;
      }
    }
    isEscaped = ch === 92;
    pos++;
    ch = str.charCodeAt(pos);
  }
  result.push(current + str.substring(lastPos));
  return result;
}
function table(state, startLine, endLine, silent) {
  if (startLine + 2 > endLine) {
    return false;
  }
  let nextLine = startLine + 1;
  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }
  let pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  const firstCh = state.src.charCodeAt(pos++);
  if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
    return false;
  }
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  const secondCh = state.src.charCodeAt(pos++);
  if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
    return false;
  }
  if (firstCh === 45 && isSpace(secondCh)) {
    return false;
  }
  while (pos < state.eMarks[nextLine]) {
    const ch = state.src.charCodeAt(pos);
    if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
      return false;
    }
    pos++;
  }
  let lineText = getLine(state, startLine + 1);
  let columns = lineText.split("|");
  const aligns = [];
  for (let i = 0; i < columns.length; i++) {
    const t2 = columns[i].trim();
    if (!t2) {
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }
    if (!/^:?-+:?$/.test(t2)) {
      return false;
    }
    if (t2.charCodeAt(t2.length - 1) === 58) {
      aligns.push(t2.charCodeAt(0) === 58 ? "center" : "right");
    } else if (t2.charCodeAt(0) === 58) {
      aligns.push("left");
    } else {
      aligns.push("");
    }
  }
  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf("|") === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText);
  if (columns.length && columns[0] === "")
    columns.shift();
  if (columns.length && columns[columns.length - 1] === "")
    columns.pop();
  const columnCount = columns.length;
  if (columnCount === 0 || columnCount !== aligns.length) {
    return false;
  }
  if (silent) {
    return true;
  }
  const oldParentType = state.parentType;
  state.parentType = "table";
  const terminatorRules = state.md.block.ruler.getRules("blockquote");
  const token_to = state.push("table_open", "table", 1);
  const tableLines = [startLine, 0];
  token_to.map = tableLines;
  const token_tho = state.push("thead_open", "thead", 1);
  token_tho.map = [startLine, startLine + 1];
  const token_htro = state.push("tr_open", "tr", 1);
  token_htro.map = [startLine, startLine + 1];
  for (let i = 0; i < columns.length; i++) {
    const token_ho = state.push("th_open", "th", 1);
    if (aligns[i]) {
      token_ho.attrs = [["style", "text-align:" + aligns[i]]];
    }
    const token_il = state.push("inline", "", 0);
    token_il.content = columns[i].trim();
    token_il.children = [];
    state.push("th_close", "th", -1);
  }
  state.push("tr_close", "tr", -1);
  state.push("thead_close", "thead", -1);
  let tbodyLines;
  let autocompletedCells = 0;
  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    lineText = getLine(state, nextLine).trim();
    if (!lineText) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === "")
      columns.shift();
    if (columns.length && columns[columns.length - 1] === "")
      columns.pop();
    autocompletedCells += columnCount - columns.length;
    if (autocompletedCells > MAX_AUTOCOMPLETED_CELLS) {
      break;
    }
    if (nextLine === startLine + 2) {
      const token_tbo = state.push("tbody_open", "tbody", 1);
      token_tbo.map = tbodyLines = [startLine + 2, 0];
    }
    const token_tro = state.push("tr_open", "tr", 1);
    token_tro.map = [nextLine, nextLine + 1];
    for (let i = 0; i < columnCount; i++) {
      const token_tdo = state.push("td_open", "td", 1);
      if (aligns[i]) {
        token_tdo.attrs = [["style", "text-align:" + aligns[i]]];
      }
      const token_il = state.push("inline", "", 0);
      token_il.content = columns[i] ? columns[i].trim() : "";
      token_il.children = [];
      state.push("td_close", "td", -1);
    }
    state.push("tr_close", "tr", -1);
  }
  if (tbodyLines) {
    state.push("tbody_close", "tbody", -1);
    tbodyLines[1] = nextLine;
  }
  state.push("table_close", "table", -1);
  tableLines[1] = nextLine;
  state.parentType = oldParentType;
  state.line = nextLine;
  return true;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/code.mjs
function code(state, startLine, endLine) {
  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }
  let nextLine = startLine + 1;
  let last2 = nextLine;
  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last2 = nextLine;
      continue;
    }
    break;
  }
  state.line = last2;
  const token = state.push("code_block", "code", 0);
  token.content = state.getLines(startLine, last2, 4 + state.blkIndent, false) + "\n";
  token.map = [startLine, state.line];
  return true;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/fence.mjs
function fence(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (pos + 3 > max) {
    return false;
  }
  const marker = state.src.charCodeAt(pos);
  if (marker !== 126 && marker !== 96) {
    return false;
  }
  let mem = pos;
  pos = state.skipChars(pos, marker);
  let len = pos - mem;
  if (len < 3) {
    return false;
  }
  const markup = state.src.slice(mem, pos);
  const params = state.src.slice(pos, max);
  if (marker === 96) {
    if (params.indexOf(String.fromCharCode(marker)) >= 0) {
      return false;
    }
  }
  if (silent) {
    return true;
  }
  let nextLine = startLine;
  let haveEndMarker = false;
  for (; ; ) {
    nextLine++;
    if (nextLine >= endLine) {
      break;
    }
    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];
    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    if (state.src.charCodeAt(pos) !== marker) {
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      continue;
    }
    pos = state.skipChars(pos, marker);
    if (pos - mem < len) {
      continue;
    }
    pos = state.skipSpaces(pos);
    if (pos < max) {
      continue;
    }
    haveEndMarker = true;
    break;
  }
  len = state.sCount[startLine];
  state.line = nextLine + (haveEndMarker ? 1 : 0);
  const token = state.push("fence", "code", 0);
  token.info = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup = markup;
  token.map = [startLine, state.line];
  return true;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/blockquote.mjs
function blockquote(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  const oldLineMax = state.lineMax;
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 62) {
    return false;
  }
  if (silent) {
    return true;
  }
  const oldBMarks = [];
  const oldBSCount = [];
  const oldSCount = [];
  const oldTShift = [];
  const terminatorRules = state.md.block.ruler.getRules("blockquote");
  const oldParentType = state.parentType;
  state.parentType = "blockquote";
  let lastLineEmpty = false;
  let nextLine;
  for (nextLine = startLine; nextLine < endLine; nextLine++) {
    const isOutdented = state.sCount[nextLine] < state.blkIndent;
    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];
    if (pos >= max) {
      break;
    }
    if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
      let initial = state.sCount[nextLine] + 1;
      let spaceAfterMarker;
      let adjustTab;
      if (state.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state.bsCount[nextLine] + initial) % 4 === 3) {
          pos++;
          initial++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      let offset = initial;
      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;
      while (pos < max) {
        const ch = state.src.charCodeAt(pos);
        if (isSpace(ch)) {
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }
        pos++;
      }
      lastLineEmpty = pos >= max;
      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;
      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }
    if (lastLineEmpty) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      state.lineMax = nextLine;
      if (state.blkIndent !== 0) {
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }
      break;
    }
    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);
    state.sCount[nextLine] = -1;
  }
  const oldIndent = state.blkIndent;
  state.blkIndent = 0;
  const token_o = state.push("blockquote_open", "blockquote", 1);
  token_o.markup = ">";
  const lines = [startLine, 0];
  token_o.map = lines;
  state.md.block.tokenize(state, startLine, nextLine);
  const token_c = state.push("blockquote_close", "blockquote", -1);
  token_c.markup = ">";
  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;
  for (let i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;
  return true;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/hr.mjs
function hr(state, startLine, endLine, silent) {
  const max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  const marker = state.src.charCodeAt(pos++);
  if (marker !== 42 && marker !== 45 && marker !== 95) {
    return false;
  }
  let cnt = 1;
  while (pos < max) {
    const ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }
  if (cnt < 3) {
    return false;
  }
  if (silent) {
    return true;
  }
  state.line = startLine + 1;
  const token = state.push("hr", "hr", 0);
  token.map = [startLine, state.line];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
  return true;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/list.mjs
function skipBulletListMarker(state, startLine) {
  const max = state.eMarks[startLine];
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  const marker = state.src.charCodeAt(pos++);
  if (marker !== 42 && marker !== 45 && marker !== 43) {
    return -1;
  }
  if (pos < max) {
    const ch = state.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      return -1;
    }
  }
  return pos;
}
function skipOrderedListMarker(state, startLine) {
  const start = state.bMarks[startLine] + state.tShift[startLine];
  const max = state.eMarks[startLine];
  let pos = start;
  if (pos + 1 >= max) {
    return -1;
  }
  let ch = state.src.charCodeAt(pos++);
  if (ch < 48 || ch > 57) {
    return -1;
  }
  for (; ; ) {
    if (pos >= max) {
      return -1;
    }
    ch = state.src.charCodeAt(pos++);
    if (ch >= 48 && ch <= 57) {
      if (pos - start >= 10) {
        return -1;
      }
      continue;
    }
    if (ch === 41 || ch === 46) {
      break;
    }
    return -1;
  }
  if (pos < max) {
    ch = state.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      return -1;
    }
  }
  return pos;
}
function markTightParagraphs(state, idx) {
  const level = state.level + 2;
  for (let i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}
function list(state, startLine, endLine, silent) {
  let max, pos, start, token;
  let nextLine = startLine;
  let tight = true;
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.listIndent >= 0 && state.sCount[nextLine] - state.listIndent >= 4 && state.sCount[nextLine] < state.blkIndent) {
    return false;
  }
  let isTerminatingParagraph = false;
  if (silent && state.parentType === "paragraph") {
    if (state.sCount[nextLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }
  let isOrdered;
  let markerValue;
  let posAfterMarker;
  if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[nextLine] + state.tShift[nextLine];
    markerValue = Number(state.src.slice(start, posAfterMarker - 1));
    if (isTerminatingParagraph && markerValue !== 1)
      return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine])
      return false;
  }
  if (silent) {
    return true;
  }
  const markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
  const listTokIdx = state.tokens.length;
  if (isOrdered) {
    token = state.push("ordered_list_open", "ol", 1);
    if (markerValue !== 1) {
      token.attrs = [["start", markerValue]];
    }
  } else {
    token = state.push("bullet_list_open", "ul", 1);
  }
  const listLines = [nextLine, 0];
  token.map = listLines;
  token.markup = String.fromCharCode(markerCharCode);
  let prevEmptyEnd = false;
  const terminatorRules = state.md.block.ruler.getRules("list");
  const oldParentType = state.parentType;
  state.parentType = "list";
  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];
    const initial = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine]);
    let offset = initial;
    while (pos < max) {
      const ch = state.src.charCodeAt(pos);
      if (ch === 9) {
        offset += 4 - (offset + state.bsCount[nextLine]) % 4;
      } else if (ch === 32) {
        offset++;
      } else {
        break;
      }
      pos++;
    }
    const contentStart = pos;
    let indentAfterMarker;
    if (contentStart >= max) {
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }
    const indent = initial + indentAfterMarker;
    token = state.push("list_item_open", "li", 1);
    token.markup = String.fromCharCode(markerCharCode);
    const itemLines = [nextLine, 0];
    token.map = itemLines;
    if (isOrdered) {
      token.info = state.src.slice(start, posAfterMarker - 1);
    }
    const oldTight = state.tight;
    const oldTShift = state.tShift[nextLine];
    const oldSCount = state.sCount[nextLine];
    const oldListIndent = state.listIndent;
    state.listIndent = state.blkIndent;
    state.blkIndent = indent;
    state.tight = true;
    state.tShift[nextLine] = contentStart - state.bMarks[nextLine];
    state.sCount[nextLine] = offset;
    if (contentStart >= max && state.isEmpty(nextLine + 1)) {
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, nextLine, endLine, true);
    }
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    prevEmptyEnd = state.line - nextLine > 1 && state.isEmpty(state.line - 1);
    state.blkIndent = state.listIndent;
    state.listIndent = oldListIndent;
    state.tShift[nextLine] = oldTShift;
    state.sCount[nextLine] = oldSCount;
    state.tight = oldTight;
    token = state.push("list_item_close", "li", -1);
    token.markup = String.fromCharCode(markerCharCode);
    nextLine = state.line;
    itemLines[1] = nextLine;
    if (nextLine >= endLine) {
      break;
    }
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
      start = state.bMarks[nextLine] + state.tShift[nextLine];
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }
    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }
  if (isOrdered) {
    token = state.push("ordered_list_close", "ol", -1);
  } else {
    token = state.push("bullet_list_close", "ul", -1);
  }
  token.markup = String.fromCharCode(markerCharCode);
  listLines[1] = nextLine;
  state.line = nextLine;
  state.parentType = oldParentType;
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }
  return true;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/reference.mjs
function reference(state, startLine, _endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  let nextLine = startLine + 1;
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 91) {
    return false;
  }
  function getNextLine(nextLine2) {
    const endLine = state.lineMax;
    if (nextLine2 >= endLine || state.isEmpty(nextLine2)) {
      return null;
    }
    let isContinuation = false;
    if (state.sCount[nextLine2] - state.blkIndent > 3) {
      isContinuation = true;
    }
    if (state.sCount[nextLine2] < 0) {
      isContinuation = true;
    }
    if (!isContinuation) {
      const terminatorRules = state.md.block.ruler.getRules("reference");
      const oldParentType = state.parentType;
      state.parentType = "reference";
      let terminate = false;
      for (let i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine2, endLine, true)) {
          terminate = true;
          break;
        }
      }
      state.parentType = oldParentType;
      if (terminate) {
        return null;
      }
    }
    const pos2 = state.bMarks[nextLine2] + state.tShift[nextLine2];
    const max2 = state.eMarks[nextLine2];
    return state.src.slice(pos2, max2 + 1);
  }
  let str = state.src.slice(pos, max + 1);
  max = str.length;
  let labelEnd = -1;
  for (pos = 1; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 91) {
      return false;
    } else if (ch === 93) {
      labelEnd = pos;
      break;
    } else if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (ch === 92) {
      pos++;
      if (pos < max && str.charCodeAt(pos) === 10) {
        const lineContent = getNextLine(nextLine);
        if (lineContent !== null) {
          str += lineContent;
          max = str.length;
          nextLine++;
        }
      }
    }
  }
  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
    return false;
  }
  for (pos = labelEnd + 2; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (isSpace(ch)) {
    } else {
      break;
    }
  }
  const destRes = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!destRes.ok) {
    return false;
  }
  const href = state.md.normalizeLink(destRes.str);
  if (!state.md.validateLink(href)) {
    return false;
  }
  pos = destRes.pos;
  const destEndPos = pos;
  const destEndLineNo = nextLine;
  const start = pos;
  for (; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (isSpace(ch)) {
    } else {
      break;
    }
  }
  let titleRes = state.md.helpers.parseLinkTitle(str, pos, max);
  while (titleRes.can_continue) {
    const lineContent = getNextLine(nextLine);
    if (lineContent === null)
      break;
    str += lineContent;
    pos = max;
    max = str.length;
    nextLine++;
    titleRes = state.md.helpers.parseLinkTitle(str, pos, max, titleRes);
  }
  let title;
  if (pos < max && start !== pos && titleRes.ok) {
    title = titleRes.str;
    pos = titleRes.pos;
  } else {
    title = "";
    pos = destEndPos;
    nextLine = destEndLineNo;
  }
  while (pos < max) {
    const ch = str.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
    pos++;
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    if (title) {
      title = "";
      pos = destEndPos;
      nextLine = destEndLineNo;
      while (pos < max) {
        const ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
    }
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    return false;
  }
  const label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    return false;
  }
  if (silent) {
    return true;
  }
  if (typeof state.env.references === "undefined") {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === "undefined") {
    state.env.references[label] = { title, href };
  }
  state.line = nextLine;
  return true;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/common/html_blocks.mjs
var html_blocks_default = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/common/html_re.mjs
var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var unquoted = "[^\"'=<>`\\x00-\\x20]+";
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';
var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var comment = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->";
var processing = "<[?][\\s\\S]*?[?]>";
var declaration = "<![A-Za-z][^>]*>";
var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/html_block.mjs
var HTML_SEQUENCES = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
  [/^<!--/, /-->/, true],
  [/^<\?/, /\?>/, true],
  [/^<![A-Z]/, />/, true],
  [/^<!\[CDATA\[/, /\]\]>/, true],
  [new RegExp("^</?(" + html_blocks_default.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
  [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
];
function html_block(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (!state.md.options.html) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 60) {
    return false;
  }
  let lineText = state.src.slice(pos, max);
  let i = 0;
  for (; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }
  if (i === HTML_SEQUENCES.length) {
    return false;
  }
  if (silent) {
    return HTML_SEQUENCES[i][2];
  }
  let nextLine = startLine + 1;
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);
      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }
  state.line = nextLine;
  const token = state.push("html_block", "", 0);
  token.map = [startLine, nextLine];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
  return true;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/heading.mjs
function heading(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  let ch = state.src.charCodeAt(pos);
  if (ch !== 35 || pos >= max) {
    return false;
  }
  let level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 35 && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }
  if (level > 6 || pos < max && !isSpace(ch)) {
    return false;
  }
  if (silent) {
    return true;
  }
  max = state.skipSpacesBack(max, pos);
  const tmp = state.skipCharsBack(max, 35, pos);
  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }
  state.line = startLine + 1;
  const token_o = state.push("heading_open", "h" + String(level), 1);
  token_o.markup = "########".slice(0, level);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = state.src.slice(pos, max).trim();
  token_i.map = [startLine, state.line];
  token_i.children = [];
  const token_c = state.push("heading_close", "h" + String(level), -1);
  token_c.markup = "########".slice(0, level);
  return true;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/lheading.mjs
function lheading(state, startLine, endLine) {
  const terminatorRules = state.md.block.ruler.getRules("paragraph");
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  const oldParentType = state.parentType;
  state.parentType = "paragraph";
  let level = 0;
  let marker;
  let nextLine = startLine + 1;
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] >= state.blkIndent) {
      let pos = state.bMarks[nextLine] + state.tShift[nextLine];
      const max = state.eMarks[nextLine];
      if (pos < max) {
        marker = state.src.charCodeAt(pos);
        if (marker === 45 || marker === 61) {
          pos = state.skipChars(pos, marker);
          pos = state.skipSpaces(pos);
          if (pos >= max) {
            level = marker === 61 ? 1 : 2;
            break;
          }
        }
      }
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  if (!level) {
    return false;
  }
  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine + 1;
  const token_o = state.push("heading_open", "h" + String(level), 1);
  token_o.markup = String.fromCharCode(marker);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = content;
  token_i.map = [startLine, state.line - 1];
  token_i.children = [];
  const token_c = state.push("heading_close", "h" + String(level), -1);
  token_c.markup = String.fromCharCode(marker);
  state.parentType = oldParentType;
  return true;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/paragraph.mjs
function paragraph(state, startLine, endLine) {
  const terminatorRules = state.md.block.ruler.getRules("paragraph");
  const oldParentType = state.parentType;
  let nextLine = startLine + 1;
  state.parentType = "paragraph";
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine;
  const token_o = state.push("paragraph_open", "p", 1);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = content;
  token_i.map = [startLine, state.line];
  token_i.children = [];
  state.push("paragraph_close", "p", -1);
  state.parentType = oldParentType;
  return true;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/parser_block.mjs
var _rules2 = [
  ["table", table, ["paragraph", "reference"]],
  ["code", code],
  ["fence", fence, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", blockquote, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", hr, ["paragraph", "reference", "blockquote", "list"]],
  ["list", list, ["paragraph", "reference", "blockquote"]],
  ["reference", reference],
  ["html_block", html_block, ["paragraph", "reference", "blockquote"]],
  ["heading", heading, ["paragraph", "reference", "blockquote"]],
  ["lheading", lheading],
  ["paragraph", paragraph]
];
function ParserBlock() {
  this.ruler = new ruler_default();
  for (let i = 0; i < _rules2.length; i++) {
    this.ruler.push(_rules2[i][0], _rules2[i][1], { alt: (_rules2[i][2] || []).slice() });
  }
}
ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const maxNesting = state.md.options.maxNesting;
  let line = startLine;
  let hasEmptyLines = false;
  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }
    if (state.sCount[line] < state.blkIndent) {
      break;
    }
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }
    const prevLine = state.line;
    let ok = false;
    for (let i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        if (prevLine >= state.line) {
          throw new Error("block rule didn't increment state.line");
        }
        break;
      }
    }
    if (!ok)
      throw new Error("none of the block rules matched");
    state.tight = !hasEmptyLines;
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }
    line = state.line;
    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};
ParserBlock.prototype.parse = function(src, md, env, outTokens) {
  if (!src) {
    return;
  }
  const state = new this.State(src, md, env, outTokens);
  this.tokenize(state, state.line, state.lineMax);
};
ParserBlock.prototype.State = state_block_default;
var parser_block_default = ParserBlock;

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/state_inline.mjs
function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;
  this.tokens_meta = Array(outTokens.length);
  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = "";
  this.pendingLevel = 0;
  this.cache = {};
  this.delimiters = [];
  this._prev_delimiters = [];
  this.backticks = {};
  this.backticksScanned = false;
  this.linkLevel = 0;
}
StateInline.prototype.pushPending = function() {
  const token = new token_default("text", "", 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = "";
  return token;
};
StateInline.prototype.push = function(type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }
  const token = new token_default(type, tag, nesting);
  let token_meta = null;
  if (nesting < 0) {
    this.level--;
    this.delimiters = this._prev_delimiters.pop();
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
    this._prev_delimiters.push(this.delimiters);
    this.delimiters = [];
    token_meta = { delimiters: this.delimiters };
  }
  this.pendingLevel = this.level;
  this.tokens.push(token);
  this.tokens_meta.push(token_meta);
  return token;
};
StateInline.prototype.scanDelims = function(start, canSplitWord) {
  const max = this.posMax;
  const marker = this.src.charCodeAt(start);
  const lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
  let pos = start;
  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++;
  }
  const count = pos - start;
  const nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
  const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
  const isLastWhiteSpace = isWhiteSpace(lastChar);
  const isNextWhiteSpace = isWhiteSpace(nextChar);
  const left_flanking = !isNextWhiteSpace && (!isNextPunctChar || isLastWhiteSpace || isLastPunctChar);
  const right_flanking = !isLastWhiteSpace && (!isLastPunctChar || isNextWhiteSpace || isNextPunctChar);
  const can_open = left_flanking && (canSplitWord || !right_flanking || isLastPunctChar);
  const can_close = right_flanking && (canSplitWord || !left_flanking || isNextPunctChar);
  return { can_open, can_close, length: count };
};
StateInline.prototype.Token = token_default;
var state_inline_default = StateInline;

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/text.mjs
function isTerminatorChar(ch) {
  switch (ch) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function text3(state, silent) {
  let pos = state.pos;
  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }
  if (pos === state.pos) {
    return false;
  }
  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }
  state.pos = pos;
  return true;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/linkify.mjs
var SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function linkify2(state, silent) {
  if (!state.md.options.linkify)
    return false;
  if (state.linkLevel > 0)
    return false;
  const pos = state.pos;
  const max = state.posMax;
  if (pos + 3 > max)
    return false;
  if (state.src.charCodeAt(pos) !== 58)
    return false;
  if (state.src.charCodeAt(pos + 1) !== 47)
    return false;
  if (state.src.charCodeAt(pos + 2) !== 47)
    return false;
  const match2 = state.pending.match(SCHEME_RE);
  if (!match2)
    return false;
  const proto = match2[1];
  const link2 = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));
  if (!link2)
    return false;
  let url = link2.url;
  if (url.length <= proto.length)
    return false;
  url = url.replace(/\*+$/, "");
  const fullUrl = state.md.normalizeLink(url);
  if (!state.md.validateLink(fullUrl))
    return false;
  if (!silent) {
    state.pending = state.pending.slice(0, -proto.length);
    const token_o = state.push("link_open", "a", 1);
    token_o.attrs = [["href", fullUrl]];
    token_o.markup = "linkify";
    token_o.info = "auto";
    const token_t = state.push("text", "", 0);
    token_t.content = state.md.normalizeLinkText(url);
    const token_c = state.push("link_close", "a", -1);
    token_c.markup = "linkify";
    token_c.info = "auto";
  }
  state.pos += url.length - proto.length;
  return true;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/newline.mjs
function newline(state, silent) {
  let pos = state.pos;
  if (state.src.charCodeAt(pos) !== 10) {
    return false;
  }
  const pmax = state.pending.length - 1;
  const max = state.posMax;
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
        let ws = pmax - 1;
        while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
          ws--;
        state.pending = state.pending.slice(0, ws);
        state.push("hardbreak", "br", 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push("softbreak", "br", 0);
      }
    } else {
      state.push("softbreak", "br", 0);
    }
  }
  pos++;
  while (pos < max && isSpace(state.src.charCodeAt(pos))) {
    pos++;
  }
  state.pos = pos;
  return true;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/escape.mjs
var ESCAPED = [];
for (let i = 0; i < 256; i++) {
  ESCAPED.push(0);
}
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});
function escape2(state, silent) {
  let pos = state.pos;
  const max = state.posMax;
  if (state.src.charCodeAt(pos) !== 92)
    return false;
  pos++;
  if (pos >= max)
    return false;
  let ch1 = state.src.charCodeAt(pos);
  if (ch1 === 10) {
    if (!silent) {
      state.push("hardbreak", "br", 0);
    }
    pos++;
    while (pos < max) {
      ch1 = state.src.charCodeAt(pos);
      if (!isSpace(ch1))
        break;
      pos++;
    }
    state.pos = pos;
    return true;
  }
  let escapedStr = state.src[pos];
  if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max) {
    const ch2 = state.src.charCodeAt(pos + 1);
    if (ch2 >= 56320 && ch2 <= 57343) {
      escapedStr += state.src[pos + 1];
      pos++;
    }
  }
  const origStr = "\\" + escapedStr;
  if (!silent) {
    const token = state.push("text_special", "", 0);
    if (ch1 < 256 && ESCAPED[ch1] !== 0) {
      token.content = escapedStr;
    } else {
      token.content = origStr;
    }
    token.markup = origStr;
    token.info = "escape";
  }
  state.pos = pos + 1;
  return true;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/backticks.mjs
function backtick(state, silent) {
  let pos = state.pos;
  const ch = state.src.charCodeAt(pos);
  if (ch !== 96) {
    return false;
  }
  const start = pos;
  pos++;
  const max = state.posMax;
  while (pos < max && state.src.charCodeAt(pos) === 96) {
    pos++;
  }
  const marker = state.src.slice(start, pos);
  const openerLength = marker.length;
  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
    if (!silent)
      state.pending += marker;
    state.pos += openerLength;
    return true;
  }
  let matchEnd = pos;
  let matchStart;
  while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
    matchEnd = matchStart + 1;
    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
      matchEnd++;
    }
    const closerLength = matchEnd - matchStart;
    if (closerLength === openerLength) {
      if (!silent) {
        const token = state.push("code_inline", "code", 0);
        token.markup = marker;
        token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      state.pos = matchEnd;
      return true;
    }
    state.backticks[closerLength] = matchStart;
  }
  state.backticksScanned = true;
  if (!silent)
    state.pending += marker;
  state.pos += openerLength;
  return true;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/strikethrough.mjs
function strikethrough_tokenize(state, silent) {
  const start = state.pos;
  const marker = state.src.charCodeAt(start);
  if (silent) {
    return false;
  }
  if (marker !== 126) {
    return false;
  }
  const scanned = state.scanDelims(state.pos, true);
  let len = scanned.length;
  const ch = String.fromCharCode(marker);
  if (len < 2) {
    return false;
  }
  let token;
  if (len % 2) {
    token = state.push("text", "", 0);
    token.content = ch;
    len--;
  }
  for (let i = 0; i < len; i += 2) {
    token = state.push("text", "", 0);
    token.content = ch + ch;
    state.delimiters.push({
      marker,
      length: 0,
      token: state.tokens.length - 1,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
}
function postProcess(state, delimiters) {
  let token;
  const loneMarkers = [];
  const max = delimiters.length;
  for (let i = 0; i < max; i++) {
    const startDelim = delimiters[i];
    if (startDelim.marker !== 126) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    const endDelim = delimiters[startDelim.end];
    token = state.tokens[startDelim.token];
    token.type = "s_open";
    token.tag = "s";
    token.nesting = 1;
    token.markup = "~~";
    token.content = "";
    token = state.tokens[endDelim.token];
    token.type = "s_close";
    token.tag = "s";
    token.nesting = -1;
    token.markup = "~~";
    token.content = "";
    if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
      loneMarkers.push(endDelim.token - 1);
    }
  }
  while (loneMarkers.length) {
    const i = loneMarkers.pop();
    let j = i + 1;
    while (j < state.tokens.length && state.tokens[j].type === "s_close") {
      j++;
    }
    j--;
    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
}
function strikethrough_postProcess(state) {
  const tokens_meta = state.tokens_meta;
  const max = state.tokens_meta.length;
  postProcess(state, state.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state, tokens_meta[curr].delimiters);
    }
  }
}
var strikethrough_default = {
  tokenize: strikethrough_tokenize,
  postProcess: strikethrough_postProcess
};

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/emphasis.mjs
function emphasis_tokenize(state, silent) {
  const start = state.pos;
  const marker = state.src.charCodeAt(start);
  if (silent) {
    return false;
  }
  if (marker !== 95 && marker !== 42) {
    return false;
  }
  const scanned = state.scanDelims(state.pos, marker === 42);
  for (let i = 0; i < scanned.length; i++) {
    const token = state.push("text", "", 0);
    token.content = String.fromCharCode(marker);
    state.delimiters.push({
      marker,
      length: scanned.length,
      token: state.tokens.length - 1,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
}
function postProcess2(state, delimiters) {
  const max = delimiters.length;
  for (let i = max - 1; i >= 0; i--) {
    const startDelim = delimiters[i];
    if (startDelim.marker !== 95 && startDelim.marker !== 42) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    const endDelim = delimiters[startDelim.end];
    const isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1;
    const ch = String.fromCharCode(startDelim.marker);
    const token_o = state.tokens[startDelim.token];
    token_o.type = isStrong ? "strong_open" : "em_open";
    token_o.tag = isStrong ? "strong" : "em";
    token_o.nesting = 1;
    token_o.markup = isStrong ? ch + ch : ch;
    token_o.content = "";
    const token_c = state.tokens[endDelim.token];
    token_c.type = isStrong ? "strong_close" : "em_close";
    token_c.tag = isStrong ? "strong" : "em";
    token_c.nesting = -1;
    token_c.markup = isStrong ? ch + ch : ch;
    token_c.content = "";
    if (isStrong) {
      state.tokens[delimiters[i - 1].token].content = "";
      state.tokens[delimiters[startDelim.end + 1].token].content = "";
      i--;
    }
  }
}
function emphasis_post_process(state) {
  const tokens_meta = state.tokens_meta;
  const max = state.tokens_meta.length;
  postProcess2(state, state.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess2(state, tokens_meta[curr].delimiters);
    }
  }
}
var emphasis_default = {
  tokenize: emphasis_tokenize,
  postProcess: emphasis_post_process
};

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/link.mjs
function link(state, silent) {
  let code2, label, res, ref;
  let href = "";
  let title = "";
  let start = state.pos;
  let parseReference = true;
  if (state.src.charCodeAt(state.pos) !== 91) {
    return false;
  }
  const oldPos = state.pos;
  const max = state.posMax;
  const labelStart = state.pos + 1;
  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
  if (labelEnd < 0) {
    return false;
  }
  let pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 40) {
    parseReference = false;
    pos++;
    for (; pos < max; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
      start = pos;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
      }
    }
    if (pos >= max || state.src.charCodeAt(pos) !== 41) {
      parseReference = true;
    }
    pos++;
  }
  if (parseReference) {
    if (typeof state.env.references === "undefined") {
      return false;
    }
    if (pos < max && state.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;
    const token_o = state.push("link_open", "a", 1);
    const attrs = [["href", href]];
    token_o.attrs = attrs;
    if (title) {
      attrs.push(["title", title]);
    }
    state.linkLevel++;
    state.md.inline.tokenize(state);
    state.linkLevel--;
    state.push("link_close", "a", -1);
  }
  state.pos = pos;
  state.posMax = max;
  return true;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/image.mjs
function image(state, silent) {
  let code2, content, label, pos, ref, res, title, start;
  let href = "";
  const oldPos = state.pos;
  const max = state.posMax;
  if (state.src.charCodeAt(state.pos) !== 33) {
    return false;
  }
  if (state.src.charCodeAt(state.pos + 1) !== 91) {
    return false;
  }
  const labelStart = state.pos + 2;
  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
  if (labelEnd < 0) {
    return false;
  }
  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 40) {
    pos++;
    for (; pos < max; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
    }
    start = pos;
    for (; pos < max; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
    if (pos < max && start !== pos && res.ok) {
      title = res.str;
      pos = res.pos;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
    } else {
      title = "";
    }
    if (pos >= max || state.src.charCodeAt(pos) !== 41) {
      state.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    if (typeof state.env.references === "undefined") {
      return false;
    }
    if (pos < max && state.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);
    const tokens = [];
    state.md.inline.parse(
      content,
      state.md,
      state.env,
      tokens
    );
    const token = state.push("image", "img", 0);
    const attrs = [["src", href], ["alt", ""]];
    token.attrs = attrs;
    token.children = tokens;
    token.content = content;
    if (title) {
      attrs.push(["title", title]);
    }
  }
  state.pos = pos;
  state.posMax = max;
  return true;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/autolink.mjs
var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function autolink(state, silent) {
  let pos = state.pos;
  if (state.src.charCodeAt(pos) !== 60) {
    return false;
  }
  const start = state.pos;
  const max = state.posMax;
  for (; ; ) {
    if (++pos >= max)
      return false;
    const ch = state.src.charCodeAt(pos);
    if (ch === 60)
      return false;
    if (ch === 62)
      break;
  }
  const url = state.src.slice(start + 1, pos);
  if (AUTOLINK_RE.test(url)) {
    const fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      const token_o = state.push("link_open", "a", 1);
      token_o.attrs = [["href", fullUrl]];
      token_o.markup = "autolink";
      token_o.info = "auto";
      const token_t = state.push("text", "", 0);
      token_t.content = state.md.normalizeLinkText(url);
      const token_c = state.push("link_close", "a", -1);
      token_c.markup = "autolink";
      token_c.info = "auto";
    }
    state.pos += url.length + 2;
    return true;
  }
  if (EMAIL_RE.test(url)) {
    const fullUrl = state.md.normalizeLink("mailto:" + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      const token_o = state.push("link_open", "a", 1);
      token_o.attrs = [["href", fullUrl]];
      token_o.markup = "autolink";
      token_o.info = "auto";
      const token_t = state.push("text", "", 0);
      token_t.content = state.md.normalizeLinkText(url);
      const token_c = state.push("link_close", "a", -1);
      token_c.markup = "autolink";
      token_c.info = "auto";
    }
    state.pos += url.length + 2;
    return true;
  }
  return false;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/html_inline.mjs
function isLinkOpen2(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose2(str) {
  return /^<\/a\s*>/i.test(str);
}
function isLetter(ch) {
  const lc = ch | 32;
  return lc >= 97 && lc <= 122;
}
function html_inline(state, silent) {
  if (!state.md.options.html) {
    return false;
  }
  const max = state.posMax;
  const pos = state.pos;
  if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
    return false;
  }
  const ch = state.src.charCodeAt(pos + 1);
  if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
    return false;
  }
  const match2 = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match2) {
    return false;
  }
  if (!silent) {
    const token = state.push("html_inline", "", 0);
    token.content = match2[0];
    if (isLinkOpen2(token.content))
      state.linkLevel++;
    if (isLinkClose2(token.content))
      state.linkLevel--;
  }
  state.pos += match2[0].length;
  return true;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/entity.mjs
var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
function entity(state, silent) {
  const pos = state.pos;
  const max = state.posMax;
  if (state.src.charCodeAt(pos) !== 38)
    return false;
  if (pos + 1 >= max)
    return false;
  const ch = state.src.charCodeAt(pos + 1);
  if (ch === 35) {
    const match2 = state.src.slice(pos).match(DIGITAL_RE);
    if (match2) {
      if (!silent) {
        const code2 = match2[1][0].toLowerCase() === "x" ? parseInt(match2[1].slice(1), 16) : parseInt(match2[1], 10);
        const token = state.push("text_special", "", 0);
        token.content = isValidEntityCode(code2) ? fromCodePoint3(code2) : fromCodePoint3(65533);
        token.markup = match2[0];
        token.info = "entity";
      }
      state.pos += match2[0].length;
      return true;
    }
  } else {
    const match2 = state.src.slice(pos).match(NAMED_RE);
    if (match2) {
      const decoded = decodeHTML(match2[0]);
      if (decoded !== match2[0]) {
        if (!silent) {
          const token = state.push("text_special", "", 0);
          token.content = decoded;
          token.markup = match2[0];
          token.info = "entity";
        }
        state.pos += match2[0].length;
        return true;
      }
    }
  }
  return false;
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/balance_pairs.mjs
function processDelimiters(delimiters) {
  const openersBottom = {};
  const max = delimiters.length;
  if (!max)
    return;
  let headerIdx = 0;
  let lastTokenIdx = -2;
  const jumps = [];
  for (let closerIdx = 0; closerIdx < max; closerIdx++) {
    const closer = delimiters[closerIdx];
    jumps.push(0);
    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
      headerIdx = closerIdx;
    }
    lastTokenIdx = closer.token;
    closer.length = closer.length || 0;
    if (!closer.close)
      continue;
    if (!openersBottom.hasOwnProperty(closer.marker)) {
      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
    }
    const minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
    let openerIdx = headerIdx - jumps[headerIdx] - 1;
    let newMinOpenerIdx = openerIdx;
    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
      const opener = delimiters[openerIdx];
      if (opener.marker !== closer.marker)
        continue;
      if (opener.open && opener.end < 0) {
        let isOddMatch = false;
        if (opener.close || closer.open) {
          if ((opener.length + closer.length) % 3 === 0) {
            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
              isOddMatch = true;
            }
          }
        }
        if (!isOddMatch) {
          const lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
          jumps[closerIdx] = closerIdx - openerIdx + lastJump;
          jumps[openerIdx] = lastJump;
          closer.open = false;
          opener.end = closerIdx;
          opener.close = false;
          newMinOpenerIdx = -1;
          lastTokenIdx = -2;
          break;
        }
      }
    }
    if (newMinOpenerIdx !== -1) {
      openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
    }
  }
}
function link_pairs(state) {
  const tokens_meta = state.tokens_meta;
  const max = state.tokens_meta.length;
  processDelimiters(state.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      processDelimiters(tokens_meta[curr].delimiters);
    }
  }
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/fragments_join.mjs
function fragments_join(state) {
  let curr, last2;
  let level = 0;
  const tokens = state.tokens;
  const max = state.tokens.length;
  for (curr = last2 = 0; curr < max; curr++) {
    if (tokens[curr].nesting < 0)
      level--;
    tokens[curr].level = level;
    if (tokens[curr].nesting > 0)
      level++;
    if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last2) {
        tokens[last2] = tokens[curr];
      }
      last2++;
    }
  }
  if (curr !== last2) {
    tokens.length = last2;
  }
}

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/parser_inline.mjs
var _rules3 = [
  ["text", text3],
  ["linkify", linkify2],
  ["newline", newline],
  ["escape", escape2],
  ["backticks", backtick],
  ["strikethrough", strikethrough_default.tokenize],
  ["emphasis", emphasis_default.tokenize],
  ["link", link],
  ["image", image],
  ["autolink", autolink],
  ["html_inline", html_inline],
  ["entity", entity]
];
var _rules22 = [
  ["balance_pairs", link_pairs],
  ["strikethrough", strikethrough_default.postProcess],
  ["emphasis", emphasis_default.postProcess],
  ["fragments_join", fragments_join]
];
function ParserInline() {
  this.ruler = new ruler_default();
  for (let i = 0; i < _rules3.length; i++) {
    this.ruler.push(_rules3[i][0], _rules3[i][1]);
  }
  this.ruler2 = new ruler_default();
  for (let i = 0; i < _rules22.length; i++) {
    this.ruler2.push(_rules22[i][0], _rules22[i][1]);
  }
}
ParserInline.prototype.skipToken = function(state) {
  const pos = state.pos;
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const maxNesting = state.md.options.maxNesting;
  const cache = state.cache;
  if (typeof cache[pos] !== "undefined") {
    state.pos = cache[pos];
    return;
  }
  let ok = false;
  if (state.level < maxNesting) {
    for (let i = 0; i < len; i++) {
      state.level++;
      ok = rules[i](state, true);
      state.level--;
      if (ok) {
        if (pos >= state.pos) {
          throw new Error("inline rule didn't increment state.pos");
        }
        break;
      }
    }
  } else {
    state.pos = state.posMax;
  }
  if (!ok) {
    state.pos++;
  }
  cache[pos] = state.pos;
};
ParserInline.prototype.tokenize = function(state) {
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const end2 = state.posMax;
  const maxNesting = state.md.options.maxNesting;
  while (state.pos < end2) {
    const prevPos = state.pos;
    let ok = false;
    if (state.level < maxNesting) {
      for (let i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) {
          if (prevPos >= state.pos) {
            throw new Error("inline rule didn't increment state.pos");
          }
          break;
        }
      }
    }
    if (ok) {
      if (state.pos >= end2) {
        break;
      }
      continue;
    }
    state.pending += state.src[state.pos++];
  }
  if (state.pending) {
    state.pushPending();
  }
};
ParserInline.prototype.parse = function(str, md, env, outTokens) {
  const state = new this.State(str, md, env, outTokens);
  this.tokenize(state);
  const rules = this.ruler2.getRules("");
  const len = rules.length;
  for (let i = 0; i < len; i++) {
    rules[i](state);
  }
};
ParserInline.prototype.State = state_inline_default;
var parser_inline_default = ParserInline;

// ../../node_modules/.pnpm/linkify-it@5.0.0/node_modules/linkify-it/lib/re.mjs
function re_default(opts) {
  const re = {};
  opts = opts || {};
  re.src_Any = regex_default.source;
  re.src_Cc = regex_default2.source;
  re.src_Z = regex_default6.source;
  re.src_P = regex_default4.source;
  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
  re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
  const text_separators = "[><\uFF5C]";
  re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
  re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
  re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
  re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
  re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
  re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re.src_ZCc + "|$)|;(?!" + re.src_ZCc + "|$)|\\!+(?!" + re.src_ZCc + "|[!]|$)|\\?(?!" + re.src_ZCc + "|[?]|$))+|\\/)?";
  re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
  re.src_xn = "xn--[a-z0-9\\-]{1,59}";
  re.src_domain_root = "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
  re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
  re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
  re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
  re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
  re.src_host_strict = re.src_host + re.src_host_terminator;
  re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
  re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
  re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
  re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
  re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
  re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
  re.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
  re.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
  return re;
}

// ../../node_modules/.pnpm/linkify-it@5.0.0/node_modules/linkify-it/index.mjs
function assign2(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function _class2(obj) {
  return Object.prototype.toString.call(obj);
}
function isString2(obj) {
  return _class2(obj) === "[object String]";
}
function isObject(obj) {
  return _class2(obj) === "[object Object]";
}
function isRegExp(obj) {
  return _class2(obj) === "[object RegExp]";
}
function isFunction(obj) {
  return _class2(obj) === "[object Function]";
}
function escapeRE2(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var defaultOptions3 = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};
function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function(acc, k) {
    return acc || defaultOptions3.hasOwnProperty(k);
  }, false);
}
var defaultSchemas = {
  "http:": {
    validate: function(text4, pos, self2) {
      const tail = text4.slice(pos);
      if (!self2.re.http) {
        self2.re.http = new RegExp(
          "^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path,
          "i"
        );
      }
      if (self2.re.http.test(tail)) {
        return tail.match(self2.re.http)[0].length;
      }
      return 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(text4, pos, self2) {
      const tail = text4.slice(pos);
      if (!self2.re.no_http) {
        self2.re.no_http = new RegExp(
          "^" + self2.re.src_auth + "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path,
          "i"
        );
      }
      if (self2.re.no_http.test(tail)) {
        if (pos >= 3 && text4[pos - 3] === ":") {
          return 0;
        }
        if (pos >= 3 && text4[pos - 3] === "/") {
          return 0;
        }
        return tail.match(self2.re.no_http)[0].length;
      }
      return 0;
    }
  },
  "mailto:": {
    validate: function(text4, pos, self2) {
      const tail = text4.slice(pos);
      if (!self2.re.mailto) {
        self2.re.mailto = new RegExp(
          "^" + self2.re.src_email_name + "@" + self2.re.src_host_strict,
          "i"
        );
      }
      if (self2.re.mailto.test(tail)) {
        return tail.match(self2.re.mailto)[0].length;
      }
      return 0;
    }
  }
};
var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
function resetScanCache(self2) {
  self2.__index__ = -1;
  self2.__text_cache__ = "";
}
function createValidator(re) {
  return function(text4, pos) {
    const tail = text4.slice(pos);
    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}
function createNormalizer() {
  return function(match2, self2) {
    self2.normalize(match2);
  };
}
function compile4(self2) {
  const re = self2.re = re_default(self2.__opts__);
  const tlds2 = self2.__tlds__.slice();
  self2.onCompile();
  if (!self2.__tlds_replaced__) {
    tlds2.push(tlds_2ch_src_re);
  }
  tlds2.push(re.src_xn);
  re.src_tlds = tlds2.join("|");
  function untpl(tpl) {
    return tpl.replace("%TLDS%", re.src_tlds);
  }
  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
  const aliases2 = [];
  self2.__compiled__ = {};
  function schemaError(name2, val2) {
    throw new Error('(LinkifyIt) Invalid schema "' + name2 + '": ' + val2);
  }
  Object.keys(self2.__schemas__).forEach(function(name2) {
    const val2 = self2.__schemas__[name2];
    if (val2 === null) {
      return;
    }
    const compiled = { validate: null, link: null };
    self2.__compiled__[name2] = compiled;
    if (isObject(val2)) {
      if (isRegExp(val2.validate)) {
        compiled.validate = createValidator(val2.validate);
      } else if (isFunction(val2.validate)) {
        compiled.validate = val2.validate;
      } else {
        schemaError(name2, val2);
      }
      if (isFunction(val2.normalize)) {
        compiled.normalize = val2.normalize;
      } else if (!val2.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name2, val2);
      }
      return;
    }
    if (isString2(val2)) {
      aliases2.push(name2);
      return;
    }
    schemaError(name2, val2);
  });
  aliases2.forEach(function(alias) {
    if (!self2.__compiled__[self2.__schemas__[alias]]) {
      return;
    }
    self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
    self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
  });
  self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
  const slist = Object.keys(self2.__compiled__).filter(function(name2) {
    return name2.length > 0 && self2.__compiled__[name2];
  }).map(escapeRE2).join("|");
  self2.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "i");
  self2.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
  self2.re.schema_at_start = RegExp("^" + self2.re.schema_search.source, "i");
  self2.re.pretest = RegExp(
    "(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@",
    "i"
  );
  resetScanCache(self2);
}
function Match(self2, shift) {
  const start = self2.__index__;
  const end2 = self2.__last_index__;
  const text4 = self2.__text_cache__.slice(start, end2);
  this.schema = self2.__schema__.toLowerCase();
  this.index = start + shift;
  this.lastIndex = end2 + shift;
  this.raw = text4;
  this.text = text4;
  this.url = text4;
}
function createMatch(self2, shift) {
  const match2 = new Match(self2, shift);
  self2.__compiled__[match2.schema].normalize(match2, self2);
  return match2;
}
function LinkifyIt(schemas2, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas2, options);
  }
  if (!options) {
    if (isOptionsObj(schemas2)) {
      options = schemas2;
      schemas2 = {};
    }
  }
  this.__opts__ = assign2({}, defaultOptions3, options);
  this.__index__ = -1;
  this.__last_index__ = -1;
  this.__schema__ = "";
  this.__text_cache__ = "";
  this.__schemas__ = assign2({}, defaultSchemas, schemas2);
  this.__compiled__ = {};
  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;
  this.re = {};
  compile4(this);
}
LinkifyIt.prototype.add = function add2(schema4, definition) {
  this.__schemas__[schema4] = definition;
  compile4(this);
  return this;
};
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign2(this.__opts__, options);
  return this;
};
LinkifyIt.prototype.test = function test(text4) {
  this.__text_cache__ = text4;
  this.__index__ = -1;
  if (!text4.length) {
    return false;
  }
  let m, ml, me, len, shift, next2, re, tld_pos, at_pos;
  if (this.re.schema_test.test(text4)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text4)) !== null) {
      len = this.testSchemaAt(text4, m[2], re.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }
  if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
    tld_pos = text4.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text4.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
          shift = ml.index + ml[1].length;
          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = "";
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }
  if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
    at_pos = text4.indexOf("@");
    if (at_pos >= 0) {
      if ((me = text4.match(this.re.email_fuzzy)) !== null) {
        shift = me.index + me[1].length;
        next2 = me.index + me[0].length;
        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next2 > this.__last_index__) {
          this.__schema__ = "mailto:";
          this.__index__ = shift;
          this.__last_index__ = next2;
        }
      }
    }
  }
  return this.__index__ >= 0;
};
LinkifyIt.prototype.pretest = function pretest(text4) {
  return this.re.pretest.test(text4);
};
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text4, schema4, pos) {
  if (!this.__compiled__[schema4.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema4.toLowerCase()].validate(text4, pos, this);
};
LinkifyIt.prototype.match = function match(text4) {
  const result = [];
  let shift = 0;
  if (this.__index__ >= 0 && this.__text_cache__ === text4) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }
  let tail = shift ? text4.slice(shift) : text4;
  while (this.test(tail)) {
    result.push(createMatch(this, shift));
    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }
  if (result.length) {
    return result;
  }
  return null;
};
LinkifyIt.prototype.matchAtStart = function matchAtStart(text4) {
  this.__text_cache__ = text4;
  this.__index__ = -1;
  if (!text4.length)
    return null;
  const m = this.re.schema_at_start.exec(text4);
  if (!m)
    return null;
  const len = this.testSchemaAt(text4, m[2], m[0].length);
  if (!len)
    return null;
  this.__schema__ = m[2];
  this.__index__ = m.index + m[1].length;
  this.__last_index__ = m.index + m[0].length + len;
  return createMatch(this, 0);
};
LinkifyIt.prototype.tlds = function tlds(list2, keepOld) {
  list2 = Array.isArray(list2) ? list2 : [list2];
  if (!keepOld) {
    this.__tlds__ = list2.slice();
    this.__tlds_replaced__ = true;
    compile4(this);
    return this;
  }
  this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function(el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();
  compile4(this);
  return this;
};
LinkifyIt.prototype.normalize = function normalize2(match2) {
  if (!match2.schema) {
    match2.url = "http://" + match2.url;
  }
  if (match2.schema === "mailto:" && !/^mailto:/i.test(match2.url)) {
    match2.url = "mailto:" + match2.url;
  }
};
LinkifyIt.prototype.onCompile = function onCompile() {
};
var linkify_it_default = LinkifyIt;

// ../../node_modules/.pnpm/punycode.js@2.3.1/node_modules/punycode.js/punycode.es6.js
var maxInt = 2147483647;
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128;
var delimiter = "-";
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\0-\x7F]/;
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
var errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;
function error(type) {
  throw new RangeError(errors[type]);
}
function map2(array, callback) {
  const result = [];
  let length = array.length;
  while (length--) {
    result[length] = callback(array[length]);
  }
  return result;
}
function mapDomain(domain, callback) {
  const parts = domain.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    domain = parts[1];
  }
  domain = domain.replace(regexSeparators, ".");
  const labels = domain.split(".");
  const encoded = map2(labels, callback).join(".");
  return result + encoded;
}
function ucs2decode(string2) {
  const output = [];
  let counter = 0;
  const length = string2.length;
  while (counter < length) {
    const value = string2.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string2.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
var ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
var basicToDigit = function(codePoint) {
  if (codePoint >= 48 && codePoint < 58) {
    return 26 + (codePoint - 48);
  }
  if (codePoint >= 65 && codePoint < 91) {
    return codePoint - 65;
  }
  if (codePoint >= 97 && codePoint < 123) {
    return codePoint - 97;
  }
  return base;
};
var digitToBasic = function(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};
var adapt = function(delta, numPoints, firstTime) {
  let k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};
var decode2 = function(input) {
  const output = [];
  const inputLength = input.length;
  let i = 0;
  let n = initialN;
  let bias = initialBias;
  let basic = input.lastIndexOf(delimiter);
  if (basic < 0) {
    basic = 0;
  }
  for (let j = 0; j < basic; ++j) {
    if (input.charCodeAt(j) >= 128) {
      error("not-basic");
    }
    output.push(input.charCodeAt(j));
  }
  for (let index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
    const oldi = i;
    for (let w = 1, k = base; ; k += base) {
      if (index2 >= inputLength) {
        error("invalid-input");
      }
      const digit = basicToDigit(input.charCodeAt(index2++));
      if (digit >= base) {
        error("invalid-input");
      }
      if (digit > floor((maxInt - i) / w)) {
        error("overflow");
      }
      i += digit * w;
      const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
      if (digit < t2) {
        break;
      }
      const baseMinusT = base - t2;
      if (w > floor(maxInt / baseMinusT)) {
        error("overflow");
      }
      w *= baseMinusT;
    }
    const out = output.length + 1;
    bias = adapt(i - oldi, out, oldi == 0);
    if (floor(i / out) > maxInt - n) {
      error("overflow");
    }
    n += floor(i / out);
    i %= out;
    output.splice(i++, 0, n);
  }
  return String.fromCodePoint(...output);
};
var encode2 = function(input) {
  const output = [];
  input = ucs2decode(input);
  const inputLength = input.length;
  let n = initialN;
  let delta = 0;
  let bias = initialBias;
  for (const currentValue of input) {
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  const basicLength = output.length;
  let handledCPCount = basicLength;
  if (basicLength) {
    output.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    let m = maxInt;
    for (const currentValue of input) {
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta += (m - n) * handledCPCountPlusOne;
    n = m;
    for (const currentValue of input) {
      if (currentValue < n && ++delta > maxInt) {
        error("overflow");
      }
      if (currentValue === n) {
        let q = delta;
        for (let k = base; ; k += base) {
          const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (q < t2) {
            break;
          }
          const qMinusT = q - t2;
          const baseMinusT = base - t2;
          output.push(
            stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0))
          );
          q = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n;
  }
  return output.join("");
};
var toUnicode = function(input) {
  return mapDomain(input, function(string2) {
    return regexPunycode.test(string2) ? decode2(string2.slice(4).toLowerCase()) : string2;
  });
};
var toASCII = function(input) {
  return mapDomain(input, function(string2) {
    return regexNonASCII.test(string2) ? "xn--" + encode2(string2) : string2;
  });
};
var punycode = {
  "version": "2.3.1",
  "ucs2": {
    "decode": ucs2decode,
    "encode": ucs2encode
  },
  "decode": decode2,
  "encode": encode2,
  "toASCII": toASCII,
  "toUnicode": toUnicode
};
var punycode_es6_default = punycode;

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/presets/default.mjs
var default_default = {
  options: {
    html: false,
    xhtmlOut: false,
    breaks: false,
    langPrefix: "language-",
    linkify: false,
    typographer: false,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
};

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/presets/zero.mjs
var zero_default = {
  options: {
    html: false,
    xhtmlOut: false,
    breaks: false,
    langPrefix: "language-",
    linkify: false,
    typographer: false,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
};

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/presets/commonmark.mjs
var commonmark_default = {
  options: {
    html: true,
    xhtmlOut: true,
    breaks: false,
    langPrefix: "language-",
    linkify: false,
    typographer: false,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
};

// ../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/index.mjs
var config = {
  default: default_default,
  zero: zero_default,
  commonmark: commonmark_default
};
var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
function validateLink(url) {
  const str = url.trim().toLowerCase();
  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) : true;
}
var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
function normalizeLink(url) {
  const parsed = parse_default(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode_es6_default.toASCII(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return encode_default(format(parsed));
}
function normalizeLinkText(url) {
  const parsed = parse_default(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode_es6_default.toUnicode(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return decode_default(format(parsed), decode_default.defaultChars + "%");
}
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }
  if (!options) {
    if (!isString(presetName)) {
      options = presetName || {};
      presetName = "default";
    }
  }
  this.inline = new parser_inline_default();
  this.block = new parser_block_default();
  this.core = new parser_core_default();
  this.renderer = new renderer_default();
  this.linkify = new linkify_it_default();
  this.validateLink = validateLink;
  this.normalizeLink = normalizeLink;
  this.normalizeLinkText = normalizeLinkText;
  this.utils = utils_exports;
  this.helpers = assign({}, helpers_exports);
  this.options = {};
  this.configure(presetName);
  if (options) {
    this.set(options);
  }
}
MarkdownIt.prototype.set = function(options) {
  assign(this.options, options);
  return this;
};
MarkdownIt.prototype.configure = function(presets) {
  const self2 = this;
  if (isString(presets)) {
    const presetName = presets;
    presets = config[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }
  if (!presets) {
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  }
  if (presets.options) {
    self2.set(presets.options);
  }
  if (presets.components) {
    Object.keys(presets.components).forEach(function(name2) {
      if (presets.components[name2].rules) {
        self2[name2].ruler.enableOnly(presets.components[name2].rules);
      }
      if (presets.components[name2].rules2) {
        self2[name2].ruler2.enableOnly(presets.components[name2].rules2);
      }
    });
  }
  return this;
};
MarkdownIt.prototype.enable = function(list2, ignoreInvalid) {
  let result = [];
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.enable(list2, true));
  }, this);
  result = result.concat(this.inline.ruler2.enable(list2, true));
  const missed = list2.filter(function(name2) {
    return result.indexOf(name2) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.disable = function(list2, ignoreInvalid) {
  let result = [];
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.disable(list2, true));
  }, this);
  result = result.concat(this.inline.ruler2.disable(list2, true));
  const missed = list2.filter(function(name2) {
    return result.indexOf(name2) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.use = function(plugin2) {
  const args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin2.apply(plugin2, args);
  return this;
};
MarkdownIt.prototype.parse = function(src, env) {
  if (typeof src !== "string") {
    throw new Error("Input data should be a String");
  }
  const state = new this.core.State(src, this, env);
  this.core.process(state);
  return state.tokens;
};
MarkdownIt.prototype.render = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parse(src, env), this.options, env);
};
MarkdownIt.prototype.parseInline = function(src, env) {
  const state = new this.core.State(src, this, env);
  state.inlineMode = true;
  this.core.process(state);
  return state.tokens;
};
MarkdownIt.prototype.renderInline = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parseInline(src, env), this.options, env);
};
var lib_default = MarkdownIt;

// ../../node_modules/.pnpm/markdown-it-ins@4.0.0/node_modules/markdown-it-ins/index.mjs
function ins_plugin(md) {
  function tokenize(state, silent) {
    const start = state.pos;
    const marker = state.src.charCodeAt(start);
    if (silent) {
      return false;
    }
    if (marker !== 43) {
      return false;
    }
    const scanned = state.scanDelims(state.pos, true);
    let len = scanned.length;
    const ch = String.fromCharCode(marker);
    if (len < 2) {
      return false;
    }
    if (len % 2) {
      const token = state.push("text", "", 0);
      token.content = ch;
      len--;
    }
    for (let i = 0; i < len; i += 2) {
      const token = state.push("text", "", 0);
      token.content = ch + ch;
      if (!scanned.can_open && !scanned.can_close) {
        continue;
      }
      state.delimiters.push({
        marker,
        length: 0,
        jump: i / 2,
        token: state.tokens.length - 1,
        end: -1,
        open: scanned.can_open,
        close: scanned.can_close
      });
    }
    state.pos += scanned.length;
    return true;
  }
  function postProcess3(state, delimiters) {
    let token;
    const loneMarkers = [];
    const max = delimiters.length;
    for (let i = 0; i < max; i++) {
      const startDelim = delimiters[i];
      if (startDelim.marker !== 43) {
        continue;
      }
      if (startDelim.end === -1) {
        continue;
      }
      const endDelim = delimiters[startDelim.end];
      token = state.tokens[startDelim.token];
      token.type = "ins_open";
      token.tag = "ins";
      token.nesting = 1;
      token.markup = "++";
      token.content = "";
      token = state.tokens[endDelim.token];
      token.type = "ins_close";
      token.tag = "ins";
      token.nesting = -1;
      token.markup = "++";
      token.content = "";
      if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "+") {
        loneMarkers.push(endDelim.token - 1);
      }
    }
    while (loneMarkers.length) {
      const i = loneMarkers.pop();
      let j = i + 1;
      while (j < state.tokens.length && state.tokens[j].type === "ins_close") {
        j++;
      }
      j--;
      if (i !== j) {
        token = state.tokens[j];
        state.tokens[j] = state.tokens[i];
        state.tokens[i] = token;
      }
    }
  }
  md.inline.ruler.before("emphasis", "ins", tokenize);
  md.inline.ruler2.before("emphasis", "ins", function(state) {
    const tokens_meta = state.tokens_meta;
    const max = (state.tokens_meta || []).length;
    postProcess3(state, state.delimiters);
    for (let curr = 0; curr < max; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        postProcess3(state, tokens_meta[curr].delimiters);
      }
    }
  });
}

// ../../node_modules/.pnpm/markdown-it-mark@4.0.0/node_modules/markdown-it-mark/index.mjs
function ins_plugin2(md) {
  function tokenize(state, silent) {
    const start = state.pos;
    const marker = state.src.charCodeAt(start);
    if (silent) {
      return false;
    }
    if (marker !== 61) {
      return false;
    }
    const scanned = state.scanDelims(state.pos, true);
    let len = scanned.length;
    const ch = String.fromCharCode(marker);
    if (len < 2) {
      return false;
    }
    if (len % 2) {
      const token = state.push("text", "", 0);
      token.content = ch;
      len--;
    }
    for (let i = 0; i < len; i += 2) {
      const token = state.push("text", "", 0);
      token.content = ch + ch;
      if (!scanned.can_open && !scanned.can_close) {
        continue;
      }
      state.delimiters.push({
        marker,
        length: 0,
        jump: i / 2,
        token: state.tokens.length - 1,
        end: -1,
        open: scanned.can_open,
        close: scanned.can_close
      });
    }
    state.pos += scanned.length;
    return true;
  }
  function postProcess3(state, delimiters) {
    const loneMarkers = [];
    const max = delimiters.length;
    for (let i = 0; i < max; i++) {
      const startDelim = delimiters[i];
      if (startDelim.marker !== 61) {
        continue;
      }
      if (startDelim.end === -1) {
        continue;
      }
      const endDelim = delimiters[startDelim.end];
      const token_o = state.tokens[startDelim.token];
      token_o.type = "mark_open";
      token_o.tag = "mark";
      token_o.nesting = 1;
      token_o.markup = "==";
      token_o.content = "";
      const token_c = state.tokens[endDelim.token];
      token_c.type = "mark_close";
      token_c.tag = "mark";
      token_c.nesting = -1;
      token_c.markup = "==";
      token_c.content = "";
      if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "=") {
        loneMarkers.push(endDelim.token - 1);
      }
    }
    while (loneMarkers.length) {
      const i = loneMarkers.pop();
      let j = i + 1;
      while (j < state.tokens.length && state.tokens[j].type === "mark_close") {
        j++;
      }
      j--;
      if (i !== j) {
        const token = state.tokens[j];
        state.tokens[j] = state.tokens[i];
        state.tokens[i] = token;
      }
    }
  }
  md.inline.ruler.before("emphasis", "mark", tokenize);
  md.inline.ruler2.before("emphasis", "mark", function(state) {
    let curr;
    const tokens_meta = state.tokens_meta;
    const max = (state.tokens_meta || []).length;
    postProcess3(state, state.delimiters);
    for (curr = 0; curr < max; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        postProcess3(state, tokens_meta[curr].delimiters);
      }
    }
  });
}

// ../../node_modules/.pnpm/markdown-it-sub@2.0.0/node_modules/markdown-it-sub/index.mjs
var UNESCAPE_RE = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/g;
function subscript(state, silent) {
  const max = state.posMax;
  const start = state.pos;
  if (state.src.charCodeAt(start) !== 126) {
    return false;
  }
  if (silent) {
    return false;
  }
  if (start + 2 >= max) {
    return false;
  }
  state.pos = start + 1;
  let found = false;
  while (state.pos < max) {
    if (state.src.charCodeAt(state.pos) === 126) {
      found = true;
      break;
    }
    state.md.inline.skipToken(state);
  }
  if (!found || start + 1 === state.pos) {
    state.pos = start;
    return false;
  }
  const content = state.src.slice(start + 1, state.pos);
  if (content.match(/(^|[^\\])(\\\\)*\s/)) {
    state.pos = start;
    return false;
  }
  state.posMax = state.pos;
  state.pos = start + 1;
  const token_so = state.push("sub_open", "sub", 1);
  token_so.markup = "~";
  const token_t = state.push("text", "", 0);
  token_t.content = content.replace(UNESCAPE_RE, "$1");
  const token_sc = state.push("sub_close", "sub", -1);
  token_sc.markup = "~";
  state.pos = state.posMax + 1;
  state.posMax = max;
  return true;
}
function sub_plugin(md) {
  md.inline.ruler.after("emphasis", "sub", subscript);
}

// ../../node_modules/.pnpm/markdown-it-sup@2.0.0/node_modules/markdown-it-sup/index.mjs
var UNESCAPE_RE2 = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/g;
function superscript(state, silent) {
  const max = state.posMax;
  const start = state.pos;
  if (state.src.charCodeAt(start) !== 94) {
    return false;
  }
  if (silent) {
    return false;
  }
  if (start + 2 >= max) {
    return false;
  }
  state.pos = start + 1;
  let found = false;
  while (state.pos < max) {
    if (state.src.charCodeAt(state.pos) === 94) {
      found = true;
      break;
    }
    state.md.inline.skipToken(state);
  }
  if (!found || start + 1 === state.pos) {
    state.pos = start;
    return false;
  }
  const content = state.src.slice(start + 1, state.pos);
  if (content.match(/(^|[^\\])(\\\\)*\s/)) {
    state.pos = start;
    return false;
  }
  state.posMax = state.pos;
  state.pos = start + 1;
  const token_so = state.push("sup_open", "sup", 1);
  token_so.markup = "^";
  const token_t = state.push("text", "", 0);
  token_t.content = content.replace(UNESCAPE_RE2, "$1");
  const token_sc = state.push("sup_close", "sup", -1);
  token_sc.markup = "^";
  state.pos = state.posMax + 1;
  state.posMax = max;
  return true;
}
function sup_plugin(md) {
  md.inline.ruler.after("emphasis", "sup", superscript);
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/nodes/identity.js
var ALIAS = Symbol.for("yaml.alias");
var DOC = Symbol.for("yaml.document");
var MAP = Symbol.for("yaml.map");
var PAIR = Symbol.for("yaml.pair");
var SCALAR = Symbol.for("yaml.scalar");
var SEQ = Symbol.for("yaml.seq");
var NODE_TYPE = Symbol.for("yaml.node.type");
var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
var isDocument2 = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
function isCollection(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode2(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR:
      case SEQ:
        return true;
    }
  return false;
}
var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/visit.js
var BREAK = Symbol("break visit");
var SKIP = Symbol("skip children");
var REMOVE = Symbol("remove node");
function visit(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument2(node)) {
    const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    visit_(null, node, visitor_, Object.freeze([]));
}
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
function visit_(key, node, visitor, path) {
  const ctrl = callVisitor(key, node, visitor, path);
  if (isNode2(ctrl) || isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visit_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = visit_(i, node.items[i], visitor, path);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = visit_("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = visit_("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
async function visitAsync(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument2(node)) {
    const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    await visitAsync_(null, node, visitor_, Object.freeze([]));
}
visitAsync.BREAK = BREAK;
visitAsync.SKIP = SKIP;
visitAsync.REMOVE = REMOVE;
async function visitAsync_(key, node, visitor, path) {
  const ctrl = await callVisitor(key, node, visitor, path);
  if (isNode2(ctrl) || isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visitAsync_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = await visitAsync_(i, node.items[i], visitor, path);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = await visitAsync_("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = await visitAsync_("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node, visitor, path) {
  var _a3, _b, _c, _d, _e;
  if (typeof visitor === "function")
    return visitor(key, node, path);
  if (isMap(node))
    return (_a3 = visitor.Map) == null ? void 0 : _a3.call(visitor, key, node, path);
  if (isSeq(node))
    return (_b = visitor.Seq) == null ? void 0 : _b.call(visitor, key, node, path);
  if (isPair(node))
    return (_c = visitor.Pair) == null ? void 0 : _c.call(visitor, key, node, path);
  if (isScalar(node))
    return (_d = visitor.Scalar) == null ? void 0 : _d.call(visitor, key, node, path);
  if (isAlias(node))
    return (_e = visitor.Alias) == null ? void 0 : _e.call(visitor, key, node, path);
  return void 0;
}
function replaceNode(key, path, node) {
  const parent2 = path[path.length - 1];
  if (isCollection(parent2)) {
    parent2.items[key] = node;
  } else if (isPair(parent2)) {
    if (key === "key")
      parent2.key = node;
    else
      parent2.value = node;
  } else if (isDocument2(parent2)) {
    parent2.contents = node;
  } else {
    const pt = isAlias(parent2) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/doc/directives.js
var escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
var Directives = class {
  constructor(yaml, tags) {
    this.docStart = null;
    this.docEnd = false;
    this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
    this.tags = Object.assign({}, Directives.defaultTags, tags);
  }
  clone() {
    const copy = new Directives(this.yaml, this.tags);
    copy.docStart = this.docStart;
    return copy;
  }
  atDocument() {
    const res = new Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, Directives.defaultTags);
        break;
    }
    return res;
  }
  add(line, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line.trim().split(/[ \t]+/);
    const name2 = parts.shift();
    switch (name2) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle, prefix] = parts;
        this.tags[handle] = prefix;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length !== 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version] = parts;
        if (version === "1.1" || version === "1.2") {
          this.yaml.version = version;
          return true;
        } else {
          const isValid = /^\d+\.\d+$/.test(version);
          onError(6, `Unsupported YAML version ${version}`, isValid);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name2}`, true);
        return false;
    }
  }
  tagName(source, onError) {
    if (source === "!")
      return "!";
    if (source[0] !== "!") {
      onError(`Not a valid tag: ${source}`);
      return null;
    }
    if (source[1] === "<") {
      const verbatim = source.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
        return null;
      }
      if (source[source.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
    if (!suffix)
      onError(`The ${source} tag has no suffix`);
    const prefix = this.tags[handle];
    if (prefix) {
      try {
        return prefix + decodeURIComponent(suffix);
      } catch (error2) {
        onError(String(error2));
        return null;
      }
    }
    if (handle === "!")
      return source;
    onError(`Could not resolve tag: ${source}`);
    return null;
  }
  tagString(tag) {
    for (const [handle, prefix] of Object.entries(this.tags)) {
      if (tag.startsWith(prefix))
        return handle + escapeTagName(tag.substring(prefix.length));
    }
    return tag[0] === "!" ? tag : `!<${tag}>`;
  }
  toString(doc) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc && tagEntries.length > 0 && isNode2(doc.contents)) {
      const tags = {};
      visit(doc.contents, (_key, node) => {
        if (isNode2(node) && node.tag)
          tags[node.tag] = true;
      });
      tagNames = Object.keys(tags);
    } else
      tagNames = [];
    for (const [handle, prefix] of tagEntries) {
      if (handle === "!!" && prefix === "tag:yaml.org,2002:")
        continue;
      if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
        lines.push(`%TAG ${handle} ${prefix}`);
    }
    return lines.join("\n");
  }
};
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/doc/anchors.js
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root3) {
  const anchors = /* @__PURE__ */ new Set();
  visit(root3, {
    Value(_key, node) {
      if (node.anchor)
        anchors.add(node.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i = 1; true; ++i) {
    const name2 = `${prefix}${i}`;
    if (!exclude.has(name2))
      return name2;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref = sourceObjects.get(source);
        if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error2 = new Error("Failed to resolve repeated object (this should not happen)");
          error2.source = source;
          throw error2;
        }
      }
    },
    sourceObjects
  };
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/doc/applyReviver.js
function applyReviver(reviver, obj, key, val2) {
  if (val2 && typeof val2 === "object") {
    if (Array.isArray(val2)) {
      for (let i = 0, len = val2.length; i < len; ++i) {
        const v0 = val2[i];
        const v1 = applyReviver(reviver, val2, String(i), v0);
        if (v1 === void 0)
          delete val2[i];
        else if (v1 !== v0)
          val2[i] = v1;
      }
    } else if (val2 instanceof Map) {
      for (const k of Array.from(val2.keys())) {
        const v0 = val2.get(k);
        const v1 = applyReviver(reviver, val2, k, v0);
        if (v1 === void 0)
          val2.delete(k);
        else if (v1 !== v0)
          val2.set(k, v1);
      }
    } else if (val2 instanceof Set) {
      for (const v0 of Array.from(val2)) {
        const v1 = applyReviver(reviver, val2, v0, v0);
        if (v1 === void 0)
          val2.delete(v0);
        else if (v1 !== v0) {
          val2.delete(v0);
          val2.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val2)) {
        const v1 = applyReviver(reviver, val2, k, v0);
        if (v1 === void 0)
          delete val2[k];
        else if (v1 !== v0)
          val2[k] = v1;
      }
    }
  }
  return reviver.call(obj, key, val2);
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/nodes/toJS.js
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v, i) => toJS(v, String(i), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data2 = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data2);
    ctx.onCreate = (res2) => {
      data2.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !(ctx == null ? void 0 : ctx.keep))
    return Number(value);
  return value;
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/nodes/Node.js
var NodeBase = class {
  constructor(type) {
    Object.defineProperty(this, NODE_TYPE, { value: type });
  }
  clone() {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    if (!isDocument2(doc))
      throw new TypeError("A document argument is required");
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc,
      keep: true,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this, "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/nodes/Alias.js
var Alias = class extends NodeBase {
  constructor(source) {
    super(ALIAS);
    this.source = source;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  resolve(doc) {
    let found = void 0;
    visit(doc, {
      Node: (_key, node) => {
        if (node === this)
          return visit.BREAK;
        if (node.anchor === this.source)
          found = node;
      }
    });
    return found;
  }
  toJSON(_arg, ctx) {
    if (!ctx)
      return { source: this.source };
    const { anchors, doc, maxAliasCount } = ctx;
    const source = this.resolve(doc);
    if (!source) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    let data2 = anchors.get(source);
    if (!data2) {
      toJS(source, null, ctx);
      data2 = anchors.get(source);
    }
    if (!data2 || data2.res === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data2.count += 1;
      if (data2.aliasCount === 0)
        data2.aliasCount = getAliasCount(doc, source, anchors);
      if (data2.count * data2.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data2.res;
  }
  toString(ctx, _onComment, _onChompKeep) {
    const src = `*${this.source}`;
    if (ctx) {
      anchorIsValid(this.source);
      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx.implicitKey)
        return `${src} `;
    }
    return src;
  }
};
function getAliasCount(doc, node, anchors) {
  if (isAlias(node)) {
    const source = node.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection(node)) {
    let count = 0;
    for (const item of node.items) {
      const c = getAliasCount(doc, item, anchors);
      if (c > count)
        count = c;
    }
    return count;
  } else if (isPair(node)) {
    const kc = getAliasCount(doc, node.key, anchors);
    const vc = getAliasCount(doc, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/nodes/Scalar.js
var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
var Scalar = class extends NodeBase {
  constructor(value) {
    super(SCALAR);
    this.value = value;
  }
  toJSON(arg, ctx) {
    return (ctx == null ? void 0 : ctx.keep) ? this.value : toJS(this.value, arg, ctx);
  }
  toString() {
    return String(this.value);
  }
};
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/doc/createNode.js
var defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value, tagName, tags) {
  var _a3;
  if (tagName) {
    const match2 = tags.filter((t2) => t2.tag === tagName);
    const tagObj = (_a3 = match2.find((t2) => !t2.format)) != null ? _a3 : match2[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t2) => {
    var _a4;
    return ((_a4 = t2.identify) == null ? void 0 : _a4.call(t2, value)) && !t2.format;
  });
}
function createNode(value, tagName, ctx) {
  var _a3, _b, _c;
  if (isDocument2(value))
    value = value.contents;
  if (isNode2(value))
    return value;
  if (isPair(value)) {
    const map4 = (_b = (_a3 = ctx.schema[MAP]).createNode) == null ? void 0 : _b.call(_a3, ctx.schema, null, ctx);
    map4.items.push(value);
    return map4;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema4, sourceObjects } = ctx;
  let ref = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref = sourceObjects.get(value);
    if (ref) {
      if (!ref.anchor)
        ref.anchor = onAnchor(value);
      return new Alias(ref.anchor);
    } else {
      ref = { anchor: null, node: null };
      sourceObjects.set(value, ref);
    }
  }
  if (tagName == null ? void 0 : tagName.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema4.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (!value || typeof value !== "object") {
      const node2 = new Scalar(value);
      if (ref)
        ref.node = node2;
      return node2;
    }
    tagObj = value instanceof Map ? schema4[MAP] : Symbol.iterator in Object(value) ? schema4[SEQ] : schema4[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = (tagObj == null ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx.schema, value, ctx) : typeof ((_c = tagObj == null ? void 0 : tagObj.nodeClass) == null ? void 0 : _c.from) === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node.tag = tagName;
  else if (!tagObj.default)
    node.tag = tagObj.tag;
  if (ref)
    ref.node = node;
  return node;
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/nodes/Collection.js
function collectionFromPath(schema4, path, value) {
  let v = value;
  for (let i = path.length - 1; i >= 0; --i) {
    const k = path[i];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      v = /* @__PURE__ */ new Map([[k, v]]);
    }
  }
  return createNode(v, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema4,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
var Collection = class extends NodeBase {
  constructor(type, schema4) {
    super(type);
    Object.defineProperty(this, "schema", {
      value: schema4,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  clone(schema4) {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema4)
      copy.schema = schema4;
    copy.items = copy.items.map((it) => isNode2(it) || isPair(it) ? it.clone(schema4) : it);
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  addIn(path, value) {
    if (isEmptyPath(path))
      this.add(value);
    else {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (isCollection(node))
        node.addIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
  deleteIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.delete(key);
    const node = this.get(key, true);
    if (isCollection(node))
      return node.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }
  getIn(path, keepScalar) {
    const [key, ...rest] = path;
    const node = this.get(key, true);
    if (rest.length === 0)
      return !keepScalar && isScalar(node) ? node.value : node;
    else
      return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node) => {
      if (!isPair(node))
        return false;
      const n = node.value;
      return n == null || allowScalar && isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  hasIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.has(key);
    const node = this.get(key, true);
    return isCollection(node) ? node.hasIn(rest) : false;
  }
  setIn(path, value) {
    const [key, ...rest] = path;
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (isCollection(node))
        node.setIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/stringify/stringifyComment.js
var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(comment2, indent) {
  if (/^\n+$/.test(comment2))
    return comment2.substring(1);
  return indent ? comment2.replace(/^(?! *$)/gm, indent) : comment2;
}
var lineComment = (str, indent, comment2) => str.endsWith("\n") ? indentComment(comment2, indent) : comment2.includes("\n") ? "\n" + indentComment(comment2, indent) : (str.endsWith(" ") ? "" : " ") + comment2;

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/stringify/foldFlowLines.js
var FOLD_FLOW = "flow";
var FOLD_BLOCK = "block";
var FOLD_QUOTED = "quoted";
function foldFlowLines(text4, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text4;
  if (lineWidth < minContentWidth)
    minContentWidth = 0;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text4.length <= endStep)
    return text4;
  const folds = [];
  const escapedFolds = {};
  let end2 = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end2 = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev2 = void 0;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text4, i, indent.length);
    if (i !== -1)
      end2 = i + endStep;
  }
  for (let ch; ch = text4[i += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text4[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text4, i, indent.length);
      end2 = i + indent.length + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev2 && prev2 !== " " && prev2 !== "\n" && prev2 !== "	") {
        const next2 = text4[i + 1];
        if (next2 && next2 !== " " && next2 !== "\n" && next2 !== "	")
          split = i;
      }
      if (i >= end2) {
        if (split) {
          folds.push(split);
          end2 = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev2 === " " || prev2 === "	") {
            prev2 = ch;
            ch = text4[i += 1];
            overflow = true;
          }
          const j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text4;
          folds.push(j);
          escapedFolds[j] = true;
          end2 = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev2 = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text4;
  if (onFold)
    onFold();
  let res = text4.slice(0, folds[0]);
  for (let i2 = 0; i2 < folds.length; ++i2) {
    const fold = folds[i2];
    const end3 = folds[i2 + 1] || text4.length;
    if (fold === 0)
      res = `
${indent}${text4.slice(0, end3)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text4[fold]}\\`;
      res += `
${indent}${text4.slice(fold + 1, end3)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text4, i, indent) {
  let end2 = i;
  let start = i + 1;
  let ch = text4[start];
  while (ch === " " || ch === "	") {
    if (i < start + indent) {
      ch = text4[++i];
    } else {
      do {
        ch = text4[++i];
      } while (ch && ch !== "\n");
      end2 = i;
      start = i + 1;
      ch = text4[start];
    }
  }
  return end2;
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/stringify/stringifyString.js
var getFoldOptions = (ctx, isBlock2) => ({
  indentAtStart: isBlock2 ? ctx.indent.length : ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
});
var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === "\n") {
      if (i - start > limit)
        return true;
      start = i + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start = 0;
  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
      str += json.slice(start, i) + "\\ ";
      i += 1;
      start = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i + 1]) {
        case "u":
          {
            str += json.slice(start, i);
            const code2 = json.substr(i + 2, 4);
            switch (code2) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code2.substr(0, 2) === "00")
                  str += "\\x" + code2.substr(2);
                else
                  str += json.substr(i, 6);
            }
            i += 5;
            start = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json.slice(start, i) + "\n\n";
            while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json[i + 2] === " ")
              str += "\\";
            i += 1;
            start = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
var blockEndNewlines;
try {
  blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
} catch (e) {
  blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment: comment2, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end2 = value.substring(endStart);
  const endNlPos = end2.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end2 || endNlPos !== end2.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end2) {
    value = value.slice(0, -end2.length);
    if (end2[end2.length - 1] === "\n")
      end2 = end2.slice(0, -1);
    end2 = end2.replace(blockEndNewlines, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value = value.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (startWithSpace ? indentSize : "") + chomp;
  if (comment2) {
    header += " " + commentString(comment2.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (!literal) {
    const foldedValue = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
    let literalFallback = false;
    const foldOptions = getFoldOptions(ctx, true);
    if (blockQuote !== "folded" && type !== Scalar.BLOCK_FOLDED) {
      foldOptions.onOverflow = () => {
        literalFallback = true;
      };
    }
    const body = foldFlowLines(`${start}${foldedValue}${end2}`, indent, FOLD_BLOCK, foldOptions);
    if (!literalFallback)
      return `>${header}
${indent}${body}`;
  }
  value = value.replace(/\n+/g, `$&${indent}`);
  return `|${header}
${indent}${start}${value}${end2}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
  if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (containsDocumentMarker(value)) {
    if (indent === "") {
      ctx.forceBlockIndent = true;
      return blockString(item, ctx, onComment, onChompKeep);
    } else if (implicitKey && indent === indentStep) {
      return quotedString(value, ctx);
    }
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test2 = (tag) => {
      var _a3;
      return tag.default && tag.tag !== "tag:yaml.org,2002:str" && ((_a3 = tag.test) == null ? void 0 : _a3.test(str));
    };
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test2) || (compat == null ? void 0 : compat.some(test2)))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t2 = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t2);
    if (res === null)
      throw new Error(`Unsupported default string type ${t2}`);
  }
  return res;
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/stringify/stringify.js
function createStringifyContext(doc, options) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  var _a3, _b, _c, _d;
  if (item.tag) {
    const match2 = tags.filter((t2) => t2.tag === item.tag);
    if (match2.length > 0)
      return (_a3 = match2.find((t2) => t2.format === item.format)) != null ? _a3 : match2[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar(item)) {
    obj = item.value;
    let match2 = tags.filter((t2) => {
      var _a4;
      return (_a4 = t2.identify) == null ? void 0 : _a4.call(t2, obj);
    });
    if (match2.length > 1) {
      const testMatch = match2.filter((t2) => t2.test);
      if (testMatch.length > 0)
        match2 = testMatch;
    }
    tagObj = (_b = match2.find((t2) => t2.format === item.format)) != null ? _b : match2.find((t2) => !t2.format);
  } else {
    obj = item;
    tagObj = tags.find((t2) => t2.nodeClass && obj instanceof t2.nodeClass);
  }
  if (!tagObj) {
    const name2 = (_d = (_c = obj == null ? void 0 : obj.constructor) == null ? void 0 : _c.name) != null ? _d : typeof obj;
    throw new Error(`Tag not resolved for ${name2} value`);
  }
  return tagObj;
}
function stringifyProps(node, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
  if (tag)
    props.push(doc.directives.tagString(tag));
  return props.join(" ");
}
function stringify2(item, ctx, onComment, onChompKeep) {
  var _a3, _b;
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if ((_a3 = ctx.resolvedAliases) == null ? void 0 : _a3.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node = isNode2(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
  if (!tagObj)
    tagObj = getTagObject(ctx.doc.schema.tags, node);
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = ((_b = ctx.indentAtStart) != null ? _b : 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/stringify/stringifyPair.js
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  var _a3, _b;
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode2(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection(key) || !isNode2(key) && typeof key === "object") {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify2(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str === "" ? "?" : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vsb, vcb, valueComment;
  if (isNode2(value)) {
    vsb = !!value.spaceBefore;
    vcb = value.commentBefore;
    valueComment = value.comment;
  } else {
    vsb = false;
    vcb = null;
    valueComment = null;
    if (value && typeof value === "object")
      value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substring(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify2(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (keyComment || vsb || vcb) {
    ws = vsb ? "\n" : "";
    if (vcb) {
      const cs = commentString(vcb);
      ws += `
${indentComment(cs, ctx.indent)}`;
    }
    if (valueStr === "" && !ctx.inFlow) {
      if (ws === "\n")
        ws = "\n\n";
    } else {
      ws += `
${ctx.indent}`;
    }
  } else if (!explicitKey && isCollection(value)) {
    const vs0 = valueStr[0];
    const nl0 = valueStr.indexOf("\n");
    const hasNewline = nl0 !== -1;
    const flow = (_b = (_a3 = ctx.inFlow) != null ? _a3 : value.flow) != null ? _b : value.items.length === 0;
    if (hasNewline || !flow) {
      let hasPropsLine = false;
      if (hasNewline && (vs0 === "&" || vs0 === "!")) {
        let sp0 = valueStr.indexOf(" ");
        if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
          sp0 = valueStr.indexOf(" ", sp0 + 1);
        }
        if (sp0 === -1 || nl0 < sp0)
          hasPropsLine = true;
      }
      if (!hasPropsLine)
        ws = `
${ctx.indent}`;
    }
  } else if (valueStr === "" || valueStr[0] === "\n") {
    ws = "";
  }
  str += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/log.js
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    console.warn(warning);
  }
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/yaml-1.1/merge.js
var MERGE_KEY = "<<";
var merge3 = {
  identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
  default: "key",
  tag: "tag:yaml.org,2002:merge",
  test: /^<<$/,
  resolve: () => Object.assign(new Scalar(Symbol(MERGE_KEY)), {
    addToJSMap: addMergeToJSMap
  }),
  stringify: () => MERGE_KEY
};
var isMergeKey = (ctx, key) => (merge3.identify(key) || isScalar(key) && (!key.type || key.type === Scalar.PLAIN) && merge3.identify(key.value)) && (ctx == null ? void 0 : ctx.doc.schema.tags.some((tag) => tag.tag === merge3.tag && tag.default));
function addMergeToJSMap(ctx, map4, value) {
  value = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (isSeq(value))
    for (const it of value.items)
      mergeValue(ctx, map4, it);
  else if (Array.isArray(value))
    for (const it of value)
      mergeValue(ctx, map4, it);
  else
    mergeValue(ctx, map4, value);
}
function mergeValue(ctx, map4, value) {
  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map4 instanceof Map) {
      if (!map4.has(key))
        map4.set(key, value2);
    } else if (map4 instanceof Set) {
      map4.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map4, key)) {
      Object.defineProperty(map4, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map4;
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
function addPairToJSMap(ctx, map4, { key, value }) {
  if (isNode2(key) && key.addToJSMap)
    key.addToJSMap(ctx, map4, value);
  else if (isMergeKey(ctx, key))
    addMergeToJSMap(ctx, map4, value);
  else {
    const jsKey = toJS(key, "", ctx);
    if (map4 instanceof Map) {
      map4.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map4 instanceof Set) {
      map4.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map4)
        Object.defineProperty(map4, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map4[stringKey] = jsValue;
    }
  }
  return map4;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode2(key) && (ctx == null ? void 0 : ctx.doc)) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node of ctx.anchors.keys())
      strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/nodes/Pair.js
function createPair(key, value, ctx) {
  const k = createNode(key, void 0, ctx);
  const v = createNode(value, void 0, ctx);
  return new Pair(k, v);
}
var Pair = class {
  constructor(key, value = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key;
    this.value = value;
  }
  clone(schema4) {
    let { key, value } = this;
    if (isNode2(key))
      key = key.clone(schema4);
    if (isNode2(value))
      value = value.clone(schema4);
    return new Pair(key, value);
  }
  toJSON(_, ctx) {
    const pair = (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx, pair, this);
  }
  toString(ctx, onComment, onChompKeep) {
    return (ctx == null ? void 0 : ctx.doc) ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
  }
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/stringify/stringifyCollection.js
function stringifyCollection(collection, ctx, options) {
  var _a3;
  const flow = (_a3 = ctx.inFlow) != null ? _a3 : collection.flow;
  const stringify5 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify5(collection, ctx, options);
}
function stringifyBlockCollection({ comment: comment2, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment3 = null;
    if (isNode2(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment3 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode2(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify2(item, itemCtx, () => comment3 = null, () => chompKeep = true);
    if (comment3)
      str2 += lineComment(str2, itemIndent, commentString(comment3));
    if (chompKeep && comment3)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment2) {
    str += "\n" + indentComment(commentString(comment2), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
  const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode2(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode2(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode2(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment2 = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && (ik == null ? void 0 : ik.comment)) {
        comment2 = ik.comment;
      }
    }
    if (comment2)
      reqNewline = true;
    let str = stringify2(item, itemCtx, () => comment2 = null);
    if (i < items.length - 1)
      str += ",";
    if (comment2)
      str += lineComment(str, itemIndent, commentString(comment2));
    if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
      reqNewline = true;
    lines.push(str);
    linesAtValue = lines.length;
  }
  const { start, end: end2 } = flowChars;
  if (lines.length === 0) {
    return start + end2;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
    }
    if (reqNewline) {
      let str = start;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      return `${str}
${indent}${end2}`;
    } else {
      return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end2}`;
    }
  }
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment2, chompKeep) {
  if (comment2 && chompKeep)
    comment2 = comment2.replace(/^\n+/, "");
  if (comment2) {
    const ic = indentComment(commentString(comment2), indent);
    lines.push(ic.trimStart());
  }
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/nodes/YAMLMap.js
function findPair(items, key) {
  const k = isScalar(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k)
        return it;
      if (isScalar(it.key) && it.key.value === k)
        return it;
    }
  }
  return void 0;
}
var YAMLMap = class extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(schema4) {
    super(MAP, schema4);
    this.items = [];
  }
  static from(schema4, obj, ctx) {
    const { keepUndefined, replacer } = ctx;
    const map4 = new this(schema4);
    const add3 = (key, value) => {
      if (typeof replacer === "function")
        value = replacer.call(obj, key, value);
      else if (Array.isArray(replacer) && !replacer.includes(key))
        return;
      if (value !== void 0 || keepUndefined)
        map4.items.push(createPair(key, value, ctx));
    };
    if (obj instanceof Map) {
      for (const [key, value] of obj)
        add3(key, value);
    } else if (obj && typeof obj === "object") {
      for (const key of Object.keys(obj))
        add3(key, obj[key]);
    }
    if (typeof schema4.sortMapEntries === "function") {
      map4.items.sort(schema4.sortMapEntries);
    }
    return map4;
  }
  add(pair, overwrite) {
    var _a3;
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair == null ? void 0 : pair.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev2 = findPair(this.items, _pair.key);
    const sortEntries = (_a3 = this.schema) == null ? void 0 : _a3.sortMapEntries;
    if (prev2) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar(prev2.value) && isScalarValue(_pair.value))
        prev2.value.value = _pair.value;
      else
        prev2.value = _pair.value;
    } else if (sortEntries) {
      const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i === -1)
        this.items.push(_pair);
      else
        this.items.splice(i, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key) {
    const it = findPair(this.items, key);
    if (!it)
      return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    var _a3;
    const it = findPair(this.items, key);
    const node = it == null ? void 0 : it.value;
    return (_a3 = !keepScalar && isScalar(node) ? node.value : node) != null ? _a3 : void 0;
  }
  has(key) {
    return !!findPair(this.items, key);
  }
  set(key, value) {
    this.add(new Pair(key, value), true);
  }
  toJSON(_, ctx, Type) {
    const map4 = Type ? new Type() : (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(map4);
    for (const item of this.items)
      addPairToJSMap(ctx, map4, item);
    return map4;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx.allNullValues && this.hasAllNullValues(false))
      ctx = Object.assign({}, ctx, { allNullValues: true });
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
    });
  }
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/common/map.js
var map3 = {
  collection: "map",
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map4, onError) {
    if (!isMap(map4))
      onError("Expected a mapping for this tag");
    return map4;
  },
  createNode: (schema4, obj, ctx) => YAMLMap.from(schema4, obj, ctx)
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/nodes/YAMLSeq.js
var YAMLSeq = class extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(schema4) {
    super(SEQ, schema4);
    this.items = [];
  }
  add(value) {
    this.items.push(value);
  }
  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return void 0;
    const it = this.items[idx];
    return !keepScalar && isScalar(it) ? it.value : it;
  }
  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === "number" && idx < this.items.length;
  }
  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key}.`);
    const prev2 = this.items[idx];
    if (isScalar(prev2) && isScalarValue(value))
      prev2.value = value;
    else
      this.items[idx] = value;
  }
  toJSON(_, ctx) {
    const seq2 = [];
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(seq2);
    let i = 0;
    for (const item of this.items)
      seq2.push(toJS(item, String(i++), ctx));
    return seq2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
  static from(schema4, obj, ctx) {
    const { replacer } = ctx;
    const seq2 = new this(schema4);
    if (obj && Symbol.iterator in Object(obj)) {
      let i = 0;
      for (let it of obj) {
        if (typeof replacer === "function") {
          const key = obj instanceof Set ? it : String(i++);
          it = replacer.call(obj, key, it);
        }
        seq2.items.push(createNode(it, void 0, ctx));
      }
    }
    return seq2;
  }
};
function asItemIndex(key) {
  let idx = isScalar(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/common/seq.js
var seq = {
  collection: "seq",
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq2, onError) {
    if (!isSeq(seq2))
      onError("Expected a sequence for this tag");
    return seq2;
  },
  createNode: (schema4, obj, ctx) => YAMLSeq.from(schema4, obj, ctx)
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/common/string.js
var string = {
  identify: (value) => typeof value === "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (str) => str,
  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({ actualString: true }, ctx);
    return stringifyString(item, ctx, onComment, onChompKeep);
  }
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/common/null.js
var nullTag = {
  identify: (value) => value == null,
  createNode: () => new Scalar(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar(null),
  stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/core/bool.js
var boolTag = {
  identify: (value) => typeof value === "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
  stringify({ source, value }, ctx) {
    if (source && boolTag.test.test(source)) {
      const sv = source[0] === "t" || source[0] === "T";
      if (value === sv)
        return source;
    }
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/stringify/stringifyNumber.js
function stringifyNumber({ format: format2, minFractionDigits, tag, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n = JSON.stringify(value);
  if (!format2 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    let i = n.indexOf(".");
    if (i < 0) {
      i = n.length;
      n += ".";
    }
    let d = minFractionDigits - (n.length - i - 1);
    while (d-- > 0)
      n += "0";
  }
  return n;
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/core/float.js
var floatNaN = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str));
    const dot = str.indexOf(".");
    if (dot !== -1 && str[str.length - 1] === "0")
      node.minFractionDigits = str.length - dot - 1;
    return node;
  },
  stringify: stringifyNumber
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/core/int.js
var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
function intStringify(node, radix, prefix) {
  const { value } = node;
  if (intIdentify(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
var intOct = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
  stringify: (node) => intStringify(node, 8, "0o")
};
var int = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
  stringify: (node) => intStringify(node, 16, "0x")
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/core/schema.js
var schema = [
  map3,
  seq,
  string,
  nullTag,
  boolTag,
  intOct,
  int,
  intHex,
  floatNaN,
  floatExp,
  float
];

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/json/schema.js
function intIdentify2(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
var stringifyJSON = ({ value }) => JSON.stringify(value);
var jsonScalars = [
  {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify: stringifyJSON
  },
  {
    identify: (value) => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON
  },
  {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true$|^false$/,
    resolve: (str) => str === "true",
    stringify: stringifyJSON
  },
  {
    identify: intIdentify2,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
    stringify: ({ value }) => intIdentify2(value) ? value.toString() : JSON.stringify(value)
  },
  {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (str) => parseFloat(str),
    stringify: stringifyJSON
  }
];
var jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    return str;
  }
};
var schema2 = [map3, seq].concat(jsonScalars, jsonError);

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js
var binary = {
  identify: (value) => value instanceof Uint8Array,
  default: false,
  tag: "tag:yaml.org,2002:binary",
  resolve(src, onError) {
    if (typeof atob === "function") {
      const str = atob(src.replace(/[\n\r]/g, ""));
      const buffer = new Uint8Array(str.length);
      for (let i = 0; i < str.length; ++i)
        buffer[i] = str.charCodeAt(i);
      return buffer;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src;
    }
  },
  stringify({ comment: comment2, type, value }, ctx, onComment, onChompKeep) {
    if (!value)
      return "";
    const buf = value;
    let str;
    if (typeof btoa === "function") {
      let s = "";
      for (let i = 0; i < buf.length; ++i)
        s += String.fromCharCode(buf[i]);
      str = btoa(s);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    if (!type)
      type = Scalar.BLOCK_LITERAL;
    if (type !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      const n = Math.ceil(str.length / lineWidth);
      const lines = new Array(n);
      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
        lines[i] = str.substr(o, lineWidth);
      }
      str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment: comment2, type, value: str }, ctx, onComment, onChompKeep);
  }
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js
function resolvePairs(seq2, onError) {
  var _a3;
  if (isSeq(seq2)) {
    for (let i = 0; i < seq2.items.length; ++i) {
      let item = seq2.items[i];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = (_a3 = pair.value) != null ? _a3 : pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema4, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema4);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i++), it);
      let key, value;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value = it[key];
        } else {
          throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
        }
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
var pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
var YAMLOMap = class extends YAMLSeq {
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = YAMLOMap.tag;
  }
  toJSON(_, ctx) {
    if (!ctx)
      return super.toJSON(_);
    const map4 = /* @__PURE__ */ new Map();
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(map4);
    for (const pair of this.items) {
      let key, value;
      if (isPair(pair)) {
        key = toJS(pair.key, "", ctx);
        value = toJS(pair.value, key, ctx);
      } else {
        key = toJS(pair, "", ctx);
      }
      if (map4.has(key))
        throw new Error("Ordered maps must not include duplicate keys");
      map4.set(key, value);
    }
    return map4;
  }
  static from(schema4, iterable, ctx) {
    const pairs2 = createPairs(schema4, iterable, ctx);
    const omap2 = new this();
    omap2.items = pairs2.items;
    return omap2;
  }
};
YAMLOMap.tag = "tag:yaml.org,2002:omap";
var omap = {
  collection: "seq",
  identify: (value) => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq2, onError) {
    const pairs2 = resolvePairs(seq2, onError);
    const seenKeys = [];
    for (const { key } of pairs2.items) {
      if (isScalar(key)) {
        if (seenKeys.includes(key.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key.value}`);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs2);
  },
  createNode: (schema4, iterable, ctx) => YAMLOMap.from(schema4, iterable, ctx)
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js
function boolStringify({ value, source }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
var trueTag = {
  identify: (value) => value === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar(true),
  stringify: boolStringify
};
var falseTag = {
  identify: (value) => value === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
  resolve: () => new Scalar(false),
  stringify: boolStringify
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/yaml-1.1/float.js
var floatNaN2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str.replace(/_/g, "")),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str.replace(/_/g, "")));
    const dot = str.indexOf(".");
    if (dot !== -1) {
      const f = str.substring(dot + 1).replace(/_/g, "");
      if (f[f.length - 1] === "0")
        node.minFractionDigits = f.length;
    }
    return node;
  },
  stringify: stringifyNumber
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/yaml-1.1/int.js
var intIdentify3 = (value) => typeof value === "bigint" || Number.isInteger(value);
function intResolve2(str, offset, radix, { intAsBigInt }) {
  const sign = str[0];
  if (sign === "-" || sign === "+")
    offset += 1;
  str = str.substring(offset).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n2 = BigInt(str);
    return sign === "-" ? BigInt(-1) * n2 : n2;
  }
  const n = parseInt(str, radix);
  return sign === "-" ? -1 * n : n;
}
function intStringify2(node, radix, prefix) {
  const { value } = node;
  if (intIdentify3(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
var intBin = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 2, opt),
  stringify: (node) => intStringify2(node, 2, "0b")
};
var intOct2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 1, 8, opt),
  stringify: (node) => intStringify2(node, 8, "0")
};
var int2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (str, _onError, opt) => intResolve2(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 16, opt),
  stringify: (node) => intStringify2(node, 16, "0x")
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/yaml-1.1/set.js
var YAMLSet = class extends YAMLMap {
  constructor(schema4) {
    super(schema4);
    this.tag = YAMLSet.tag;
  }
  add(key) {
    let pair;
    if (isPair(key))
      pair = key;
    else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
      pair = new Pair(key.key, null);
    else
      pair = new Pair(key, null);
    const prev2 = findPair(this.items, pair.key);
    if (!prev2)
      this.items.push(pair);
  }
  get(key, keepPair) {
    const pair = findPair(this.items, key);
    return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key, value) {
    if (typeof value !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev2 = findPair(this.items, key);
    if (prev2 && !value) {
      this.items.splice(this.items.indexOf(prev2), 1);
    } else if (!prev2 && value) {
      this.items.push(new Pair(key));
    }
  }
  toJSON(_, ctx) {
    return super.toJSON(_, ctx, Set);
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
  static from(schema4, iterable, ctx) {
    const { replacer } = ctx;
    const set3 = new this(schema4);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value of iterable) {
        if (typeof replacer === "function")
          value = replacer.call(iterable, value, value);
        set3.items.push(createPair(value, null, ctx));
      }
    return set3;
  }
};
YAMLSet.tag = "tag:yaml.org,2002:set";
var set2 = {
  collection: "map",
  identify: (value) => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  createNode: (schema4, iterable, ctx) => YAMLSet.from(schema4, iterable, ctx),
  resolve(map4, onError) {
    if (isMap(map4)) {
      if (map4.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map4);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map4;
  }
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
  const num = (n) => asBigInt ? BigInt(n) : Number(n);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node) {
  let { value } = node;
  let num = (n) => n;
  if (typeof value === "bigint")
    num = (n) => BigInt(n);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node);
  let sign = "";
  if (value < 0) {
    sign = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
var intTime = {
  identify: (value) => typeof value === "bigint" || Number.isInteger(value),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
  stringify: stringifySexagesimal
};
var floatTime = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (str) => parseSexagesimal(str, false),
  stringify: stringifySexagesimal
};
var timestamp = {
  identify: (value) => value instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str) {
    const match2 = str.match(timestamp.test);
    if (!match2)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year, month, day, hour, minute, second] = match2.map(Number);
    const millisec = match2[7] ? Number((match2[7] + "00").substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    const tz = match2[8];
    if (tz && tz !== "Z") {
      let d = parseSexagesimal(tz, false);
      if (Math.abs(d) < 30)
        d *= 60;
      date -= 6e4 * d;
    }
    return new Date(date);
  },
  stringify: ({ value }) => {
    var _a3;
    return (_a3 = value == null ? void 0 : value.toISOString().replace(/(T00:00:00)?\.000Z$/, "")) != null ? _a3 : "";
  }
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
var schema3 = [
  map3,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct2,
  int2,
  intHex2,
  floatNaN2,
  floatExp2,
  float2,
  binary,
  merge3,
  omap,
  pairs,
  set2,
  intTime,
  floatTime,
  timestamp
];

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/tags.js
var schemas = /* @__PURE__ */ new Map([
  ["core", schema],
  ["failsafe", [map3, seq, string]],
  ["json", schema2],
  ["yaml11", schema3],
  ["yaml-1.1", schema3]
]);
var tagsByName = {
  binary,
  bool: boolTag,
  float,
  floatExp,
  floatNaN,
  floatTime,
  int,
  intHex,
  intOct,
  intTime,
  map: map3,
  merge: merge3,
  null: nullTag,
  omap,
  pairs,
  seq,
  set: set2,
  timestamp
};
var coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:merge": merge3,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set2,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName, addMergeTag) {
  const schemaTags = schemas.get(schemaName);
  if (schemaTags && !customTags) {
    return addMergeTag && !schemaTags.includes(merge3) ? schemaTags.concat(merge3) : schemaTags.slice();
  }
  let tags = schemaTags;
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags = tags.concat(tag);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  if (addMergeTag)
    tags = tags.concat(merge3);
  return tags.reduce((tags2, tag) => {
    const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
    if (!tagObj) {
      const tagName = JSON.stringify(tag);
      const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
    }
    if (!tags2.includes(tagObj))
      tags2.push(tagObj);
    return tags2;
  }, []);
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/Schema.js
var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
var Schema = class {
  constructor({ compat, customTags, merge: merge4, resolveKnownTags, schema: schema4, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
    this.name = typeof schema4 === "string" && schema4 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name, merge4);
    this.toStringOptions = toStringDefaults != null ? toStringDefaults : null;
    Object.defineProperty(this, MAP, { value: map3 });
    Object.defineProperty(this, SCALAR, { value: string });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
  }
  clone() {
    const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy.tags = this.tags.slice();
    return copy;
  }
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/stringify/stringifyDocument.js
function stringifyDocument(doc, options) {
  var _a3;
  const lines = [];
  let hasDirectives = options.directives === true;
  if (options.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode2(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify2(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify2(doc.contents, ctx));
  }
  if ((_a3 = doc.directives) == null ? void 0 : _a3.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/doc/Document.js
var Document2 = class {
  constructor(value, replacer, options) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const opt = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      stringKeys: false,
      uniqueKeys: true,
      version: "1.2"
    }, options);
    this.options = opt;
    let { version } = opt;
    if (options == null ? void 0 : options._directives) {
      this.directives = options._directives.atDocument();
      if (this.directives.yaml.explicit)
        version = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version });
    this.setSchema(version, options);
    this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
  }
  clone() {
    const copy = Object.create(Document2.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy.commentBefore = this.commentBefore;
    copy.comment = this.comment;
    copy.errors = this.errors.slice();
    copy.warnings = this.warnings.slice();
    copy.options = Object.assign({}, this.options);
    if (this.directives)
      copy.directives = this.directives.clone();
    copy.schema = this.schema.clone();
    copy.contents = isNode2(this.contents) ? this.contents.clone(copy.schema) : this.contents;
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  add(value) {
    if (assertCollection(this.contents))
      this.contents.add(value);
  }
  addIn(path, value) {
    if (assertCollection(this.contents))
      this.contents.addIn(path, value);
  }
  createAlias(node, name2) {
    if (!node.anchor) {
      const prev2 = anchorNames(this);
      node.anchor = !name2 || prev2.has(name2) ? findNewAnchor(name2 || "a", prev2) : name2;
    }
    return new Alias(node.anchor);
  }
  createNode(value, replacer, options) {
    let _replacer = void 0;
    if (typeof replacer === "function") {
      value = replacer.call({ "": value }, "", value);
      _replacer = replacer;
    } else if (Array.isArray(replacer)) {
      const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
      const asStr = replacer.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer = replacer.concat(asStr);
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options != null ? options : {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
      this,
      anchorPrefix || "a"
    );
    const ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects != null ? aliasDuplicateObjects : true,
      keepUndefined: keepUndefined != null ? keepUndefined : false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node = createNode(value, tag, ctx);
    if (flow && isCollection(node))
      node.flow = true;
    setAnchors();
    return node;
  }
  createPair(key, value, options = {}) {
    const k = this.createNode(key, null, options);
    const v = this.createNode(value, null, options);
    return new Pair(k, v);
  }
  delete(key) {
    return assertCollection(this.contents) ? this.contents.delete(key) : false;
  }
  deleteIn(path) {
    if (isEmptyPath(path)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
  }
  get(key, keepScalar) {
    return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
  }
  getIn(path, keepScalar) {
    if (isEmptyPath(path))
      return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
    return isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
  }
  has(key) {
    return isCollection(this.contents) ? this.contents.has(key) : false;
  }
  hasIn(path) {
    if (isEmptyPath(path))
      return this.contents !== void 0;
    return isCollection(this.contents) ? this.contents.hasIn(path) : false;
  }
  set(key, value) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key], value);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key, value);
    }
  }
  setIn(path, value) {
    if (isEmptyPath(path)) {
      this.contents = value;
    } else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path), value);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path, value);
    }
  }
  setSchema(version, options = {}) {
    if (typeof version === "number")
      version = String(version);
    let opt;
    switch (version) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        if (this.directives)
          this.directives.yaml.version = version;
        else
          this.directives = new Directives({ version });
        opt = { resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options.schema instanceof Object)
      this.schema = options.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this.contents, jsonArg != null ? jsonArg : "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  toString(options = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
      const s = JSON.stringify(options.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }
    return stringifyDocument(this, options);
  }
};
function assertCollection(contents2) {
  if (isCollection(contents2))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/errors.js
var YAMLError = class extends Error {
  constructor(name2, pos, code2, message) {
    super();
    this.name = name2;
    this.code = code2;
    this.message = message;
    this.pos = pos;
  }
};
var YAMLParseError = class extends YAMLError {
  constructor(pos, code2, message) {
    super("YAMLParseError", pos, code2, message);
  }
};
var YAMLWarning = class extends YAMLError {
  constructor(pos, code2, message) {
    super("YAMLWarning", pos, code2, message);
  }
};
var prettifyError = (src, lc) => (error2) => {
  if (error2.pos[0] === -1)
    return;
  error2.linePos = error2.pos.map((pos) => lc.linePos(pos));
  const { line, col } = error2.linePos[0];
  error2.message += ` at line ${line}, column ${col}`;
  let ci = col - 1;
  let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
  if (ci >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci - 39, lineStr.length - 79);
    lineStr = "\u2026" + lineStr.substring(trimStart);
    ci -= trimStart - 1;
  }
  if (lineStr.length > 80)
    lineStr = lineStr.substring(0, 79) + "\u2026";
  if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
    let prev2 = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
    if (prev2.length > 80)
      prev2 = prev2.substring(0, 79) + "\u2026\n";
    lineStr = prev2 + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count = 1;
    const end2 = error2.linePos[1];
    if (end2 && end2.line === line && end2.col > col) {
      count = Math.max(1, Math.min(end2.col - col, 80 - ci));
    }
    const pointer = " ".repeat(ci) + "^".repeat(count);
    error2.message += `:

${lineStr}
${pointer}
`;
  }
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/resolve-props.js
function resolveProps(tokens, { flow, indicator, next: next2, offset, onError, parentIndent, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment2 = "";
  let commentSep = "";
  let hasNewline = false;
  let reqSpace = false;
  let tab = null;
  let anchor = null;
  let tag = null;
  let newlineAfterProp = null;
  let comma = null;
  let found = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    if (tab) {
      if (atNewline && token.type !== "comment" && token.type !== "newline") {
        onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      }
      tab = null;
    }
    switch (token.type) {
      case "space":
        if (!flow && (indicator !== "doc-start" || (next2 == null ? void 0 : next2.type) !== "flow-collection") && token.source.includes("	")) {
          tab = token;
        }
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment2)
          comment2 = cb;
        else
          comment2 += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment2)
            comment2 += token.source;
          else if (!found || indicator !== "seq-item-ind")
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag)
          newlineAfterProp = token;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow != null ? flow : "collection"}`);
        found = token;
        atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last2 = tokens[tokens.length - 1];
  const end2 = last2 ? last2.offset + last2.source.length : offset;
  if (reqSpace && next2 && next2.type !== "space" && next2.type !== "newline" && next2.type !== "comma" && (next2.type !== "scalar" || next2.source !== "")) {
    onError(next2.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  }
  if (tab && (atNewline && tab.indent <= parentIndent || (next2 == null ? void 0 : next2.type) === "block-map" || (next2 == null ? void 0 : next2.type) === "block-seq"))
    onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
  return {
    comma,
    found,
    spaceBefore,
    comment: comment2,
    hasNewline,
    anchor,
    tag,
    newlineAfterProp,
    end: end2,
    start: start != null ? start : end2
  };
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/util-contains-newline.js
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/util-flow-indent-check.js
function flowIndentCheck(indent, fc, onError) {
  if ((fc == null ? void 0 : fc.type) === "flow-collection") {
    const end2 = fc.end[0];
    if (end2.indent === indent && (end2.source === "]" || end2.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end2, "BAD_INDENT", msg, true);
    }
  }
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/util-map-includes.js
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || isScalar(a) && isScalar(b) && a.value === b.value;
  return items.some((pair) => isEqual(pair.key, search));
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/resolve-block-map.js
var startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError, tag) {
  var _a3, _b;
  const NodeClass = (_a3 = tag == null ? void 0 : tag.nodeClass) != null ? _a3 : YAMLMap;
  const map4 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bm.offset;
  let commentEnd = null;
  for (const collItem of bm.items) {
    const { start, key, sep, value } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key != null ? key : sep == null ? void 0 : sep[0],
      offset,
      onError,
      parentIndent: bm.indent,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep) {
        commentEnd = keyProps.end;
        if (keyProps.comment) {
          if (map4.comment)
            map4.comment += "\n" + keyProps.comment;
          else
            map4.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.newlineAfterProp || containsNewline(key)) {
        onError(key != null ? key : start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (((_b = keyProps.found) == null ? void 0 : _b.indent) !== bm.indent) {
      onError(offset, "BAD_INDENT", startColMsg);
    }
    ctx.atKey = true;
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    ctx.atKey = false;
    if (mapIncludes(ctx, map4.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep != null ? sep : [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      parentIndent: bm.indent,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if ((value == null ? void 0 : value.type) === "block-map" && !valueProps.hasNewline)
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map4.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map4.items.push(pair);
    }
  }
  if (commentEnd && commentEnd < offset)
    onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
  map4.range = [bm.offset, offset, commentEnd != null ? commentEnd : offset];
  return map4;
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/resolve-block-seq.js
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError, tag) {
  var _a3;
  const NodeClass = (_a3 = tag == null ? void 0 : tag.nodeClass) != null ? _a3 : YAMLSeq;
  const seq2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = bs.offset;
  let commentEnd = null;
  for (const { start, value } of bs.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value,
      offset,
      onError,
      parentIndent: bs.indent,
      startOnNewline: true
    });
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if (value && value.type === "block-seq")
          onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        commentEnd = props.end;
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, start, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value, onError);
    offset = node.range[2];
    seq2.items.push(node);
  }
  seq2.range = [bs.offset, offset, commentEnd != null ? commentEnd : offset];
  return seq2;
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/resolve-end.js
function resolveEnd(end2, offset, reqSpace, onError) {
  let comment2 = "";
  if (end2) {
    let hasSpace = false;
    let sep = "";
    for (const token of end2) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment2)
            comment2 = cb;
          else
            comment2 += sep + cb;
          sep = "";
          break;
        }
        case "newline":
          if (comment2)
            sep += source;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source.length;
    }
  }
  return { comment: comment2, offset };
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
var blockMsg = "Block collections are not allowed within flow collections";
var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError, tag) {
  var _a3, _b;
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const NodeClass = (_a3 = tag == null ? void 0 : tag.nodeClass) != null ? _a3 : isMap2 ? YAMLMap : YAMLSeq;
  const coll = new NodeClass(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i = 0; i < fc.items.length; ++i) {
    const collItem = fc.items[i];
    const { start, key, sep, value } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key != null ? key : sep == null ? void 0 : sep[0],
      offset,
      onError,
      parentIndent: fc.indent,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep && !value) {
        if (i === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(
          key,
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop:
          for (const st of start) {
            switch (st.type) {
              case "comma":
              case "space":
                break;
              case "comment":
                prevItemComment = st.source.substring(1);
                break loop;
              default:
                break loop;
            }
          }
        if (prevItemComment) {
          let prev2 = coll.items[coll.items.length - 1];
          if (isPair(prev2))
            prev2 = (_b = prev2.value) != null ? _b : prev2.key;
          if (prev2.comment)
            prev2.comment += "\n" + prevItemComment;
          else
            prev2.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep, null, props, onError);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      ctx.atKey = true;
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      ctx.atKey = false;
      const valueProps = resolveProps(sep != null ? sep : [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep)
            for (const st of sep) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && value.source && value.source[0] === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map4 = coll;
        if (mapIncludes(ctx, map4.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map4.items.push(pair);
      } else {
        const map4 = new YAMLMap(ctx.schema);
        map4.flow = true;
        map4.items.push(pair);
        const endRange = (valueNode != null ? valueNode : keyNode).range;
        map4.range = [keyNode.range[0], endRange[1], endRange[2]];
        coll.items.push(map4);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset;
  if (ce && ce.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name2 = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name2} must end with a ${expectedEnd}` : `${name2} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end2 = resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end2.comment) {
      if (coll.comment)
        coll.comment += "\n" + end2.comment;
      else
        coll.comment = end2.comment;
    }
    coll.range = [fc.offset, cePos, end2.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/compose-collection.js
function resolveCollection(CN2, ctx, token, onError, tagName, tag) {
  const coll = token.type === "block-map" ? resolveBlockMap(CN2, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq(CN2, ctx, token, onError, tag) : resolveFlowCollection(CN2, ctx, token, onError, tag);
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  if (tagName)
    coll.tag = tagName;
  return coll;
}
function composeCollection(CN2, ctx, token, props, onError) {
  var _a3, _b, _c;
  const tagToken = props.tag;
  const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (token.type === "block-seq") {
    const { anchor, newlineAfterProp: nl } = props;
    const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor != null ? anchor : tagToken;
    if (lastProp && (!nl || nl.offset < lastProp.offset)) {
      const message = "Missing newline after block sequence props";
      onError(lastProp, "MISSING_CHAR", message);
    }
  }
  const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
  if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.tagName && expType === "seq") {
    return resolveCollection(CN2, ctx, token, onError, tagName);
  }
  let tag = ctx.schema.tags.find((t2) => t2.tag === tagName && t2.collection === expType);
  if (!tag) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag = kt;
    } else {
      if (kt) {
        onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${(_a3 = kt.collection) != null ? _a3 : "scalar"}`, true);
      } else {
        onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      }
      return resolveCollection(CN2, ctx, token, onError, tagName);
    }
  }
  const coll = resolveCollection(CN2, ctx, token, onError, tagName, tag);
  const res = (_c = (_b = tag.resolve) == null ? void 0 : _b.call(tag, coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options)) != null ? _c : coll;
  const node = isNode2(res) ? res : new Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if (tag == null ? void 0 : tag.format)
    node.format = tag.format;
  return node;
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/resolve-block-scalar.js
function resolveBlockScalar(ctx, scalar, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i = lines.length - 1; i >= 0; --i) {
    const content = lines[i][1];
    if (content === "" || content === "\r")
      chompStart = i;
    else
      break;
  }
  if (chompStart === 0) {
    const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end3 = start + header.length;
    if (scalar.source)
      end3 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start, end3, end3] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i = 0; i < chompStart; ++i) {
    const [indent, content] = lines[i];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i;
      if (trimIndent === 0 && !ctx.atRoot) {
        const message = "Block scalar values in collections must be indented";
        onError(offset, "BAD_INDENT", message);
      }
      break;
    }
    offset += indent.length + content.length + 1;
  }
  for (let i = lines.length - 1; i >= chompStart; --i) {
    if (lines[i][0].length > trimIndent)
      chompStart = i + 1;
  }
  let value = "";
  let sep = "";
  let prevMoreIndented = false;
  for (let i = 0; i < contentStart; ++i)
    value += lines[i][0].slice(trimIndent) + "\n";
  for (let i = contentStart; i < chompStart; ++i) {
    let [indent, content] = lines[i];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src}`;
      onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep === " ")
        sep = "\n";
      else if (!prevMoreIndented && sep === "\n")
        sep = "\n\n";
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep === "\n")
        value += "\n";
      else
        sep = "\n";
    } else {
      value += sep + content;
      sep = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i = chompStart; i < lines.length; ++i)
        value += "\n" + lines[i][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end2 = start + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start, end2, end2] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode = source[0];
  let indent = 0;
  let chomp = "";
  let error2 = -1;
  for (let i = 1; i < source.length; ++i) {
    const ch = source[i];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n = Number(ch);
      if (!indent && n)
        indent = n;
      else if (error2 === -1)
        error2 = offset + i;
    }
  }
  if (error2 !== -1)
    onError(error2, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment2 = "";
  let length = source.length;
  for (let i = 1; i < props.length; ++i) {
    const token = props[i];
    switch (token.type) {
      case "space":
        hasSpace = true;
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment2 = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode, indent, chomp, comment: comment2, length };
}
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first2 = split[0];
  const m = first2.match(/^( *)/);
  const line0 = (m == null ? void 0 : m[1]) ? [m[1], first2.slice(m[1].length)] : ["", first2];
  const lines = [line0];
  for (let i = 1; i < split.length; i += 2)
    lines.push([split[i], split[i + 1]]);
  return lines;
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js
function resolveFlowScalar(scalar, strict, onError) {
  const { offset, type, source, end: end2 } = scalar;
  let _type;
  let value;
  const _onError = (rel, code2, msg) => onError(offset + rel, code2, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source, _onError);
      break;
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset, offset + source.length, offset + source.length]
      };
  }
  const valueEnd = offset + source.length;
  const re = resolveEnd(end2, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re.comment,
    range: [offset, valueEnd, re.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  var _a3;
  let first2, line;
  try {
    first2 = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch (e) {
    first2 = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match2 = first2.exec(source);
  if (!match2)
    return source;
  let res = match2[1];
  let sep = " ";
  let pos = first2.lastIndex;
  line.lastIndex = pos;
  while (match2 = line.exec(source)) {
    if (match2[1] === "") {
      if (sep === "\n")
        res += sep;
      else
        sep = "\n";
    } else {
      res += sep + match2[1];
      sep = " ";
    }
    pos = line.lastIndex;
  }
  const last2 = /[ \t]*(.*)/sy;
  last2.lastIndex = pos;
  match2 = last2.exec(source);
  return res + sep + ((_a3 = match2 == null ? void 0 : match2[1]) != null ? _a3 : "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i = 1; i < source.length - 1; ++i) {
    const ch = source[i];
    if (ch === "\r" && source[i + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset } = foldNewline(source, i);
      res += fold;
      i = offset;
    } else if (ch === "\\") {
      let next2 = source[++i];
      const cc = escapeCodes[next2];
      if (cc)
        res += cc;
      else if (next2 === "\n") {
        next2 = source[i + 1];
        while (next2 === " " || next2 === "	")
          next2 = source[++i + 1];
      } else if (next2 === "\r" && source[i + 1] === "\n") {
        next2 = source[++i + 1];
        while (next2 === " " || next2 === "	")
          next2 = source[++i + 1];
      } else if (next2 === "x" || next2 === "u" || next2 === "U") {
        const length = { x: 2, u: 4, U: 8 }[next2];
        res += parseCharCode(source, i + 1, length, onError);
        i += length;
      } else {
        const raw = source.substr(i - 1, 2);
        onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i;
      let next2 = source[i + 1];
      while (next2 === " " || next2 === "	")
        next2 = source[++i + 1];
      if (next2 !== "\n" && !(next2 === "\r" && source[i + 2] === "\n"))
        res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset) {
  let fold = "";
  let ch = source[offset + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset += 1;
    ch = source[offset + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset };
}
var escapeCodes = {
  "0": "\0",
  a: "\x07",
  b: "\b",
  e: "\x1B",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	",
  v: "\v",
  N: "\x85",
  _: "\xA0",
  L: "\u2028",
  P: "\u2029",
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(source, offset, length, onError) {
  const cc = source.substr(offset, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code2 = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code2)) {
    const raw = source.substr(offset - 2, length + 2);
    onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code2);
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/compose-scalar.js
function composeScalar(ctx, token, tagToken, onError) {
  const { value, type, comment: comment2, range } = token.type === "block-scalar" ? resolveBlockScalar(ctx, token, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  let tag;
  if (ctx.options.stringKeys && ctx.atKey) {
    tag = ctx.schema[SCALAR];
  } else if (tagName)
    tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
  else if (token.type === "scalar")
    tag = findScalarTagByTest(ctx, value, token, onError);
  else
    tag = ctx.schema[SCALAR];
  let scalar;
  try {
    const res = tag.resolve(value, (msg) => onError(tagToken != null ? tagToken : token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar(res) ? res : new Scalar(res);
  } catch (error2) {
    const msg = error2 instanceof Error ? error2.message : String(error2);
    onError(tagToken != null ? tagToken : token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag.format)
    scalar.format = tag.format;
  if (comment2)
    scalar.comment = comment2;
  return scalar;
}
function findScalarTagByName(schema4, value, tagName, tagToken, onError) {
  var _a3;
  if (tagName === "!")
    return schema4[SCALAR];
  const matchWithTest = [];
  for (const tag of schema4.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test)
        matchWithTest.push(tag);
      else
        return tag;
    }
  }
  for (const tag of matchWithTest)
    if ((_a3 = tag.test) == null ? void 0 : _a3.test(value))
      return tag;
  const kt = schema4.knownTags[tagName];
  if (kt && !kt.collection) {
    schema4.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema4[SCALAR];
}
function findScalarTagByTest({ atKey, directives, schema: schema4 }, value, token, onError) {
  var _a3;
  const tag = schema4.tags.find((tag2) => {
    var _a4;
    return (tag2.default === true || atKey && tag2.default === "key") && ((_a4 = tag2.test) == null ? void 0 : _a4.test(value));
  }) || schema4[SCALAR];
  if (schema4.compat) {
    const compat = (_a3 = schema4.compat.find((tag2) => {
      var _a4;
      return tag2.default && ((_a4 = tag2.test) == null ? void 0 : _a4.test(value));
    })) != null ? _a3 : schema4[SCALAR];
    if (tag.tag !== compat.tag) {
      const ts = directives.tagString(tag.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag;
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js
function emptyScalarPosition(offset, before2, pos) {
  if (before2) {
    if (pos === null)
      pos = before2.length;
    for (let i = pos - 1; i >= 0; --i) {
      let st = before2[i];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset -= st.source.length;
          continue;
      }
      st = before2[++i];
      while ((st == null ? void 0 : st.type) === "space") {
        offset += st.source.length;
        st = before2[++i];
      }
      break;
    }
  }
  return offset;
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/compose-node.js
var CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
  const atKey = ctx.atKey;
  const { spaceBefore, comment: comment2, anchor, tag } = props;
  let node;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node = composeAlias(ctx, token, onError);
      if (anchor || tag)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node = composeScalar(ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node = composeCollection(CN, ctx, token, props, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    default: {
      const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError(token, "UNEXPECTED_TOKEN", message);
      node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (atKey && ctx.options.stringKeys && (!isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
    const msg = "With stringKeys, all keys must be strings";
    onError(tag != null ? tag : token, "NON_STRING_KEY", msg);
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment2) {
    if (token.type === "scalar" && token.source === "")
      node.comment = comment2;
    else
      node.commentBefore = comment2;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node.srcToken = token;
  return node;
}
function composeEmptyNode(ctx, offset, before2, pos, { spaceBefore, comment: comment2, anchor, tag, end: end2 }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset, before2, pos),
    indent: -1,
    source: ""
  };
  const node = composeScalar(ctx, token, tag, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment2) {
    node.comment = comment2;
    node.range[2] = end2;
  }
  return node;
}
function composeAlias({ options }, { offset, source, end: end2 }, onError) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset + source.length;
  const re = resolveEnd(end2, valueEnd, options.strict, onError);
  alias.range = [offset, valueEnd, re.offset];
  if (re.comment)
    alias.comment = re.comment;
  return alias;
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/compose-doc.js
function composeDoc(options, directives, { offset, start, value, end: end2 }, onError) {
  const opts = Object.assign({ _directives: directives }, options);
  const doc = new Document2(void 0, opts);
  const ctx = {
    atKey: false,
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value != null ? value : end2 == null ? void 0 : end2[0],
    offset,
    onError,
    parentIndent: 0,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd(end2, contentEnd, false, onError);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset, contentEnd, re.offset];
  return doc;
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/composer.js
function getErrorPos(src) {
  if (typeof src === "number")
    return [src, src + 1];
  if (Array.isArray(src))
    return src.length === 2 ? src : [src[0], src[1]];
  const { offset, source } = src;
  return [offset, offset + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  var _a3;
  let comment2 = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i = 0; i < prelude.length; ++i) {
    const source = prelude[i];
    switch (source[0]) {
      case "#":
        comment2 += (comment2 === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (((_a3 = prelude[i + 1]) == null ? void 0 : _a3[0]) !== "#")
          i += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment: comment2, afterEmptyLine };
}
var Composer = class {
  constructor(options = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source, code2, message, warning) => {
      const pos = getErrorPos(source);
      if (warning)
        this.warnings.push(new YAMLWarning(pos, code2, message));
      else
        this.errors.push(new YAMLParseError(pos, code2, message));
    };
    this.directives = new Directives({ version: options.version || "1.2" });
    this.options = options;
  }
  decorate(doc, afterDoc) {
    const { comment: comment2, afterEmptyLine } = parsePrelude(this.prelude);
    if (comment2) {
      const dc = doc.contents;
      if (afterDoc) {
        doc.comment = doc.comment ? `${doc.comment}
${comment2}` : comment2;
      } else if (afterEmptyLine || doc.directives.docStart || !dc) {
        doc.commentBefore = comment2;
      } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
        let it = dc.items[0];
        if (isPair(it))
          it = it.key;
        const cb = it.commentBefore;
        it.commentBefore = cb ? `${comment2}
${cb}` : comment2;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment2}
${cb}` : comment2;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc.errors, this.errors);
      Array.prototype.push.apply(doc.warnings, this.warnings);
    } else {
      doc.errors = this.errors;
      doc.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  *compose(tokens, forceDoc = false, endOffset = -1) {
    for (const token of tokens)
      yield* this.next(token);
    yield* this.end(forceDoc, endOffset);
  }
  *next(token) {
    switch (token.type) {
      case "directive":
        this.directives.add(token.source, (offset, message, warning) => {
          const pos = getErrorPos(token);
          pos[0] += offset;
          this.onError(pos, "BAD_DIRECTIVE", message, warning);
        });
        this.prelude.push(token.source);
        this.atDirectives = true;
        break;
      case "document": {
        const doc = composeDoc(this.options, this.directives, token, this.onError);
        if (this.atDirectives && !doc.directives.docStart)
          this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
        this.decorate(doc, false);
        if (this.doc)
          yield this.doc;
        this.doc = doc;
        this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(token.source);
        break;
      case "error": {
        const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
        const error2 = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
        if (this.atDirectives || !this.doc)
          this.errors.push(error2);
        else
          this.doc.errors.push(error2);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const msg = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
          break;
        }
        this.doc.directives.docEnd = true;
        const end2 = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
        this.decorate(this.doc, true);
        if (end2.comment) {
          const dc = this.doc.comment;
          this.doc.comment = dc ? `${dc}
${end2.comment}` : end2.comment;
        }
        this.doc.range[2] = end2.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
    }
  }
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({ _directives: this.directives }, this.options);
      const doc = new Document2(void 0, opts);
      if (this.atDirectives)
        this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
      doc.range = [0, endOffset, endOffset];
      this.decorate(doc, false);
      yield doc;
    }
  }
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/parse/cst-visit.js
var BREAK2 = Symbol("break visit");
var SKIP2 = Symbol("skip children");
var REMOVE2 = Symbol("remove item");
function visit2(cst, visitor) {
  if ("type" in cst && cst.type === "document")
    cst = { start: cst.start, value: cst.value };
  _visit(Object.freeze([]), cst, visitor);
}
visit2.BREAK = BREAK2;
visit2.SKIP = SKIP2;
visit2.REMOVE = REMOVE2;
visit2.itemAtPath = (cst, path) => {
  let item = cst;
  for (const [field, index2] of path) {
    const tok = item == null ? void 0 : item[field];
    if (tok && "items" in tok) {
      item = tok.items[index2];
    } else
      return void 0;
  }
  return item;
};
visit2.parentCollection = (cst, path) => {
  const parent2 = visit2.itemAtPath(cst, path.slice(0, -1));
  const field = path[path.length - 1][0];
  const coll = parent2 == null ? void 0 : parent2[field];
  if (coll && "items" in coll)
    return coll;
  throw new Error("Parent collection not found");
};
function _visit(path, item, visitor) {
  let ctrl = visitor(item, path);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i = 0; i < token.items.length; ++i) {
        const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK2)
          return BREAK2;
        else if (ci === REMOVE2) {
          token.items.splice(i, 1);
          i -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/parse/cst.js
var BOM = "\uFEFF";
var DOCUMENT = "";
var FLOW_END = "";
var SCALAR2 = "";
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR2:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/parse/lexer.js
function isEmpty2(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var hexDigits = new Set("0123456789ABCDEFabcdef");
var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
var flowIndicatorChars = new Set(",[]{}");
var invalidAnchorChars = new Set(" ,[]{}\n\r	");
var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
var Lexer = class {
  constructor() {
    this.atEnd = false;
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    this.buffer = "";
    this.flowKey = false;
    this.flowLevel = 0;
    this.indentNext = 0;
    this.indentValue = 0;
    this.lineEndPos = null;
    this.next = null;
    this.pos = 0;
  }
  *lex(source, incomplete = false) {
    var _a3;
    if (source) {
      if (typeof source !== "string")
        throw TypeError("source is not a string");
      this.buffer = this.buffer ? this.buffer + source : source;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next2 = (_a3 = this.next) != null ? _a3 : "stream";
    while (next2 && (incomplete || this.hasChars(1)))
      next2 = yield* this.parseNext(next2);
  }
  atLineEnd() {
    let i = this.pos;
    let ch = this.buffer[i];
    while (ch === " " || ch === "	")
      ch = this.buffer[++i];
    if (!ch || ch === "#" || ch === "\n")
      return true;
    if (ch === "\r")
      return this.buffer[i + 1] === "\n";
    return false;
  }
  charAt(n) {
    return this.buffer[this.pos + n];
  }
  continueScalar(offset) {
    let ch = this.buffer[offset];
    if (this.indentNext > 0) {
      let indent = 0;
      while (ch === " ")
        ch = this.buffer[++indent + offset];
      if (ch === "\r") {
        const next2 = this.buffer[indent + offset + 1];
        if (next2 === "\n" || !next2 && !this.atEnd)
          return offset + indent + 1;
      }
      return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
    }
    if (ch === "-" || ch === ".") {
      const dt = this.buffer.substr(offset, 3);
      if ((dt === "---" || dt === "...") && isEmpty2(this.buffer[offset + 3]))
        return -1;
    }
    return offset;
  }
  getLine() {
    let end2 = this.lineEndPos;
    if (typeof end2 !== "number" || end2 !== -1 && end2 < this.pos) {
      end2 = this.buffer.indexOf("\n", this.pos);
      this.lineEndPos = end2;
    }
    if (end2 === -1)
      return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end2 - 1] === "\r")
      end2 -= 1;
    return this.buffer.substring(this.pos, end2);
  }
  hasChars(n) {
    return this.pos + n <= this.buffer.length;
  }
  setNext(state) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state;
    return null;
  }
  peek(n) {
    return this.buffer.substr(this.pos, n);
  }
  *parseNext(next2) {
    switch (next2) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line = this.getLine();
    if (line === null)
      return this.setNext("stream");
    if (line[0] === BOM) {
      yield* this.pushCount(1);
      line = line.substring(1);
    }
    if (line[0] === "%") {
      let dirEnd = line.length;
      let cs = line.indexOf("#");
      while (cs !== -1) {
        const ch = line[cs - 1];
        if (ch === " " || ch === "	") {
          dirEnd = cs - 1;
          break;
        } else {
          cs = line.indexOf("#", cs + 1);
        }
      }
      while (true) {
        const ch = line[dirEnd - 1];
        if (ch === " " || ch === "	")
          dirEnd -= 1;
        else
          break;
      }
      const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line.length - n);
      this.pushNewline();
      return "stream";
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line.length - sp);
      yield* this.pushNewline();
      return "stream";
    }
    yield DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd)
      return this.setNext("line-start");
    if (ch === "-" || ch === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const s = this.peek(3);
      if ((s === "---" || s === "...") && isEmpty2(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return s === "---" ? "doc" : "stream";
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty2(this.charAt(1)))
      this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd)
      return this.setNext("block-start");
    if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty2(ch1)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n;
      return yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line = this.getLine();
    if (line === null)
      return this.setNext("doc");
    let n = yield* this.pushIndicators();
    switch (line[n]) {
      case "#":
        yield* this.pushCount(line.length - n);
      case void 0:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        return "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        n += yield* this.parseBlockScalarHeader();
        n += yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - n);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl, sp;
    let indent = -1;
    do {
      nl = yield* this.pushNewline();
      if (nl > 0) {
        sp = yield* this.pushSpaces(false);
        this.indentValue = indent = sp;
      } else {
        sp = 0;
      }
      sp += yield* this.pushSpaces(true);
    } while (nl + sp > 0);
    const line = this.getLine();
    if (line === null)
      return this.setNext("flow");
    if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty2(line[3])) {
      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
      if (!atFlowEndMarker) {
        this.flowLevel = 0;
        yield FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n = 0;
    while (line[n] === ",") {
      n += yield* this.pushCount(1);
      n += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n += yield* this.pushIndicators();
    switch (line[n]) {
      case void 0:
        return "flow";
      case "#":
        yield* this.pushCount(line.length - n);
        return "flow";
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? "flow" : "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "flow";
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ":": {
        const next2 = this.charAt(1);
        if (this.flowKey || isEmpty2(next2) || next2 === ",") {
          this.flowKey = false;
          yield* this.pushCount(1);
          yield* this.pushSpaces(true);
          return "flow";
        }
      }
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote = this.charAt(0);
    let end2 = this.buffer.indexOf(quote, this.pos + 1);
    if (quote === "'") {
      while (end2 !== -1 && this.buffer[end2 + 1] === "'")
        end2 = this.buffer.indexOf("'", end2 + 2);
    } else {
      while (end2 !== -1) {
        let n = 0;
        while (this.buffer[end2 - 1 - n] === "\\")
          n += 1;
        if (n % 2 === 0)
          break;
        end2 = this.buffer.indexOf('"', end2 + 1);
      }
    }
    const qb = this.buffer.substring(0, end2);
    let nl = qb.indexOf("\n", this.pos);
    if (nl !== -1) {
      while (nl !== -1) {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = qb.indexOf("\n", cs);
      }
      if (nl !== -1) {
        end2 = nl - (qb[nl - 1] === "\r" ? 2 : 1);
      }
    }
    if (end2 === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      end2 = this.buffer.length;
    }
    yield* this.pushToIndex(end2 + 1, false);
    return this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i = this.pos;
    while (true) {
      const ch = this.buffer[++i];
      if (ch === "+")
        this.blockScalarKeep = true;
      else if (ch > "0" && ch <= "9")
        this.blockScalarIndent = Number(ch) - 1;
      else if (ch !== "-")
        break;
    }
    return yield* this.pushUntil((ch) => isEmpty2(ch) || ch === "#");
  }
  *parseBlockScalar() {
    let nl = this.pos - 1;
    let indent = 0;
    let ch;
    loop:
      for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
        switch (ch) {
          case " ":
            indent += 1;
            break;
          case "\n":
            nl = i2;
            indent = 0;
            break;
          case "\r": {
            const next2 = this.buffer[i2 + 1];
            if (!next2 && !this.atEnd)
              return this.setNext("block-scalar");
            if (next2 === "\n")
              break;
          }
          default:
            break loop;
        }
      }
    if (!ch && !this.atEnd)
      return this.setNext("block-scalar");
    if (indent >= this.indentNext) {
      if (this.blockScalarIndent === -1)
        this.indentNext = indent;
      else {
        this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
      }
      do {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = this.buffer.indexOf("\n", cs);
      } while (nl !== -1);
      if (nl === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        nl = this.buffer.length;
      }
    }
    let i = nl + 1;
    ch = this.buffer[i];
    while (ch === " ")
      ch = this.buffer[++i];
    if (ch === "	") {
      while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
        ch = this.buffer[++i];
      nl = i - 1;
    } else if (!this.blockScalarKeep) {
      do {
        let i2 = nl - 1;
        let ch2 = this.buffer[i2];
        if (ch2 === "\r")
          ch2 = this.buffer[--i2];
        const lastChar = i2;
        while (ch2 === " ")
          ch2 = this.buffer[--i2];
        if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
          nl = i2;
        else
          break;
      } while (true);
    }
    yield SCALAR2;
    yield* this.pushToIndex(nl + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end2 = this.pos - 1;
    let i = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i]) {
      if (ch === ":") {
        const next2 = this.buffer[i + 1];
        if (isEmpty2(next2) || inFlow && flowIndicatorChars.has(next2))
          break;
        end2 = i;
      } else if (isEmpty2(ch)) {
        let next2 = this.buffer[i + 1];
        if (ch === "\r") {
          if (next2 === "\n") {
            i += 1;
            ch = "\n";
            next2 = this.buffer[i + 1];
          } else
            end2 = i;
        }
        if (next2 === "#" || inFlow && flowIndicatorChars.has(next2))
          break;
        if (ch === "\n") {
          const cs = this.continueScalar(i + 1);
          if (cs === -1)
            break;
          i = Math.max(i, cs - 2);
        }
      } else {
        if (inFlow && flowIndicatorChars.has(ch))
          break;
        end2 = i;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("plain-scalar");
    yield SCALAR2;
    yield* this.pushToIndex(end2 + 1, true);
    return inFlow ? "flow" : "doc";
  }
  *pushCount(n) {
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos += n;
      return n;
    }
    return 0;
  }
  *pushToIndex(i, allowEmpty) {
    const s = this.buffer.slice(this.pos, i);
    if (s) {
      yield s;
      this.pos += s.length;
      return s.length;
    } else if (allowEmpty)
      yield "";
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "-":
      case "?":
      case ":": {
        const inFlow = this.flowLevel > 0;
        const ch1 = this.charAt(1);
        if (isEmpty2(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
          if (!inFlow)
            this.indentNext = this.indentValue + 1;
          else if (this.flowKey)
            this.flowKey = false;
          return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let i = this.pos + 2;
      let ch = this.buffer[i];
      while (!isEmpty2(ch) && ch !== ">")
        ch = this.buffer[++i];
      return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
    } else {
      let i = this.pos + 1;
      let ch = this.buffer[i];
      while (ch) {
        if (tagChars.has(ch))
          ch = this.buffer[++i];
        else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
          ch = this.buffer[i += 3];
        } else
          break;
      }
      return yield* this.pushToIndex(i, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === "\n")
      return yield* this.pushCount(1);
    else if (ch === "\r" && this.charAt(1) === "\n")
      return yield* this.pushCount(2);
    else
      return 0;
  }
  *pushSpaces(allowTabs) {
    let i = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i];
    } while (ch === " " || allowTabs && ch === "	");
    const n = i - this.pos;
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos = i;
    }
    return n;
  }
  *pushUntil(test2) {
    let i = this.pos;
    let ch = this.buffer[i];
    while (!test2(ch))
      ch = this.buffer[++i];
    return yield* this.pushToIndex(i, false);
  }
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/parse/line-counter.js
var LineCounter = class {
  constructor() {
    this.lineStarts = [];
    this.addNewLine = (offset) => this.lineStarts.push(offset);
    this.linePos = (offset) => {
      let low = 0;
      let high = this.lineStarts.length;
      while (low < high) {
        const mid = low + high >> 1;
        if (this.lineStarts[mid] < offset)
          low = mid + 1;
        else
          high = mid;
      }
      if (this.lineStarts[low] === offset)
        return { line: low + 1, col: 1 };
      if (low === 0)
        return { line: 0, col: offset };
      const start = this.lineStarts[low - 1];
      return { line: low, col: offset - start + 1 };
    };
  }
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/parse/parser.js
function includesToken(list2, type) {
  for (let i = 0; i < list2.length; ++i)
    if (list2[i].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list2) {
  for (let i = 0; i < list2.length; ++i) {
    switch (list2[i].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i;
    }
  }
  return -1;
}
function isFlowToken(token) {
  switch (token == null ? void 0 : token.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent2) {
  var _a3;
  switch (parent2.type) {
    case "document":
      return parent2.start;
    case "block-map": {
      const it = parent2.items[parent2.items.length - 1];
      return (_a3 = it.sep) != null ? _a3 : it.start;
    }
    case "block-seq":
      return parent2.items[parent2.items.length - 1].start;
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev2) {
  var _a3;
  if (prev2.length === 0)
    return [];
  let i = prev2.length;
  loop:
    while (--i >= 0) {
      switch (prev2[i].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break loop;
      }
    }
  while (((_a3 = prev2[++i]) == null ? void 0 : _a3.type) === "space") {
  }
  return prev2.splice(i, prev2.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
var Parser3 = class {
  constructor(onNewLine) {
    this.atNewLine = true;
    this.atScalar = false;
    this.indent = 0;
    this.offset = 0;
    this.onKeyLine = false;
    this.stack = [];
    this.source = "";
    this.type = "";
    this.lexer = new Lexer();
    this.onNewLine = onNewLine;
  }
  *parse(source, incomplete = false) {
    if (this.onNewLine && this.offset === 0)
      this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source, incomplete))
      yield* this.next(lexeme);
    if (!incomplete)
      yield* this.end();
  }
  *next(source) {
    this.source = source;
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source.length;
      return;
    }
    const type = tokenType(source);
    if (!type) {
      const message = `Not a YAML token: ${source}`;
      yield* this.pop({ type: "error", offset: this.offset, message, source });
      this.offset += source.length;
    } else if (type === "scalar") {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = "scalar";
    } else {
      this.type = type;
      yield* this.step();
      switch (type) {
        case "newline":
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine)
            this.onNewLine(this.offset + source.length);
          break;
        case "space":
          if (this.atNewLine && source[0] === " ")
            this.indent += source.length;
          break;
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
          if (this.atNewLine)
            this.indent += source.length;
          break;
        case "doc-mode":
        case "flow-error-end":
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source.length;
    }
  }
  *end() {
    while (this.stack.length > 0)
      yield* this.pop();
  }
  get sourceToken() {
    const st = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st;
  }
  *step() {
    const top = this.peek(1);
    if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
      while (this.stack.length > 0)
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top)
      return yield* this.stream();
    switch (top.type) {
      case "document":
        return yield* this.document(top);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(top);
      case "block-scalar":
        return yield* this.blockScalar(top);
      case "block-map":
        return yield* this.blockMap(top);
      case "block-seq":
        return yield* this.blockSequence(top);
      case "flow-collection":
        return yield* this.flowCollection(top);
      case "doc-end":
        return yield* this.documentEnd(top);
    }
    yield* this.pop();
  }
  peek(n) {
    return this.stack[this.stack.length - n];
  }
  *pop(error2) {
    const token = error2 != null ? error2 : this.stack.pop();
    if (!token) {
      const message = "Tried to pop an empty stack";
      yield { type: "error", offset: this.offset, source: "", message };
    } else if (this.stack.length === 0) {
      yield token;
    } else {
      const top = this.peek(1);
      if (token.type === "block-scalar") {
        token.indent = "indent" in top ? top.indent : 0;
      } else if (token.type === "flow-collection" && top.type === "document") {
        token.indent = 0;
      }
      if (token.type === "flow-collection")
        fixFlowSeqItems(token);
      switch (top.type) {
        case "document":
          top.value = token;
          break;
        case "block-scalar":
          top.props.push(token);
          break;
        case "block-map": {
          const it = top.items[top.items.length - 1];
          if (it.value) {
            top.items.push({ start: [], key: token, sep: [] });
            this.onKeyLine = true;
            return;
          } else if (it.sep) {
            it.value = token;
          } else {
            Object.assign(it, { key: token, sep: [] });
            this.onKeyLine = !it.explicitKey;
            return;
          }
          break;
        }
        case "block-seq": {
          const it = top.items[top.items.length - 1];
          if (it.value)
            top.items.push({ start: [], value: token });
          else
            it.value = token;
          break;
        }
        case "flow-collection": {
          const it = top.items[top.items.length - 1];
          if (!it || it.value)
            top.items.push({ start: [], key: token, sep: [] });
          else if (it.sep)
            it.value = token;
          else
            Object.assign(it, { key: token, sep: [] });
          return;
        }
        default:
          yield* this.pop();
          yield* this.pop(token);
      }
      if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
        const last2 = token.items[token.items.length - 1];
        if (last2 && !last2.sep && !last2.value && last2.start.length > 0 && findNonEmptyIndex(last2.start) === -1 && (token.indent === 0 || last2.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
          if (top.type === "document")
            top.end = last2.start;
          else
            top.items.push({ start: last2.start });
          token.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const doc = {
          type: "document",
          offset: this.offset,
          start: []
        };
        if (this.type === "doc-start")
          doc.start.push(this.sourceToken);
        this.stack.push(doc);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc) {
    if (doc.value)
      return yield* this.lineEnd(doc);
    switch (this.type) {
      case "doc-start": {
        if (findNonEmptyIndex(doc.start) !== -1) {
          yield* this.pop();
          yield* this.step();
        } else
          doc.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        doc.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc);
    if (bv)
      this.stack.push(bv);
    else {
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === "map-value-ind") {
      const prev2 = getPrevProps(this.peek(2));
      const start = getFirstKeyStartProps(prev2);
      let sep;
      if (scalar.end) {
        sep = scalar.end;
        sep.push(this.sourceToken);
        delete scalar.end;
      } else
        sep = [this.sourceToken];
      const map4 = {
        type: "block-map",
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{ start, key: scalar, sep }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map4;
    } else
      yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        scalar.props.push(this.sourceToken);
        return;
      case "scalar":
        scalar.source = this.source;
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        yield* this.pop();
        break;
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map4) {
    var _a3;
    const it = map4.items[map4.items.length - 1];
    switch (this.type) {
      case "newline":
        this.onKeyLine = false;
        if (it.value) {
          const end2 = "end" in it.value ? it.value.end : void 0;
          const last2 = Array.isArray(end2) ? end2[end2.length - 1] : void 0;
          if ((last2 == null ? void 0 : last2.type) === "comment")
            end2 == null ? void 0 : end2.push(this.sourceToken);
          else
            map4.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          it.start.push(this.sourceToken);
        }
        return;
      case "space":
      case "comment":
        if (it.value) {
          map4.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          if (this.atIndentedComment(it.start, map4.indent)) {
            const prev2 = map4.items[map4.items.length - 2];
            const end2 = (_a3 = prev2 == null ? void 0 : prev2.value) == null ? void 0 : _a3.end;
            if (Array.isArray(end2)) {
              Array.prototype.push.apply(end2, it.start);
              end2.push(this.sourceToken);
              map4.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map4.indent) {
      const atMapIndent = !this.onKeyLine && this.indent === map4.indent;
      const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
      let start = [];
      if (atNextItem && it.sep && !it.value) {
        const nl = [];
        for (let i = 0; i < it.sep.length; ++i) {
          const st = it.sep[i];
          switch (st.type) {
            case "newline":
              nl.push(i);
              break;
            case "space":
              break;
            case "comment":
              if (st.indent > map4.indent)
                nl.length = 0;
              break;
            default:
              nl.length = 0;
          }
        }
        if (nl.length >= 2)
          start = it.sep.splice(nl[1]);
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map4.items.push({ start });
            this.onKeyLine = true;
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "explicit-key-ind":
          if (!it.sep && !it.explicitKey) {
            it.start.push(this.sourceToken);
            it.explicitKey = true;
          } else if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map4.items.push({ start, explicitKey: true });
          } else {
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken], explicitKey: true }]
            });
          }
          this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (it.explicitKey) {
            if (!it.sep) {
              if (includesToken(it.start, "newline")) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else {
                const start2 = getFirstKeyStartProps(it.start);
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                });
              }
            } else if (it.value) {
              map4.items.push({ start: [], key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start, key: null, sep: [this.sourceToken] }]
              });
            } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
              const start2 = getFirstKeyStartProps(it.start);
              const key = it.key;
              const sep = it.sep;
              sep.push(this.sourceToken);
              delete it.key;
              delete it.sep;
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: start2, key, sep }]
              });
            } else if (start.length > 0) {
              it.sep = it.sep.concat(start, this.sourceToken);
            } else {
              it.sep.push(this.sourceToken);
            }
          } else {
            if (!it.sep) {
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            } else if (it.value || atNextItem) {
              map4.items.push({ start, key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [], key: null, sep: [this.sourceToken] }]
              });
            } else {
              it.sep.push(this.sourceToken);
            }
          }
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (atNextItem || it.value) {
            map4.items.push({ start, key: fs, sep: [] });
            this.onKeyLine = true;
          } else if (it.sep) {
            this.stack.push(fs);
          } else {
            Object.assign(it, { key: fs, sep: [] });
            this.onKeyLine = true;
          }
          return;
        }
        default: {
          const bv = this.startBlockValue(map4);
          if (bv) {
            if (bv.type === "block-seq") {
              if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
                yield* this.pop({
                  type: "error",
                  offset: this.offset,
                  message: "Unexpected block-seq-ind on same line with key",
                  source: this.source
                });
                return;
              }
            } else if (atMapIndent) {
              map4.items.push({ start });
            }
            this.stack.push(bv);
            return;
          }
        }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq2) {
    var _a3;
    const it = seq2.items[seq2.items.length - 1];
    switch (this.type) {
      case "newline":
        if (it.value) {
          const end2 = "end" in it.value ? it.value.end : void 0;
          const last2 = Array.isArray(end2) ? end2[end2.length - 1] : void 0;
          if ((last2 == null ? void 0 : last2.type) === "comment")
            end2 == null ? void 0 : end2.push(this.sourceToken);
          else
            seq2.items.push({ start: [this.sourceToken] });
        } else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          seq2.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(it.start, seq2.indent)) {
            const prev2 = seq2.items[seq2.items.length - 2];
            const end2 = (_a3 = prev2 == null ? void 0 : prev2.value) == null ? void 0 : _a3.end;
            if (Array.isArray(end2)) {
              Array.prototype.push.apply(end2, it.start);
              end2.push(this.sourceToken);
              seq2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (it.value || this.indent <= seq2.indent)
          break;
        it.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== seq2.indent)
          break;
        if (it.value || includesToken(it.start, "seq-item-ind"))
          seq2.items.push({ start: [this.sourceToken] });
        else
          it.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq2.indent) {
      const bv = this.startBlockValue(seq2);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it = fc.items[fc.items.length - 1];
    if (this.type === "flow-error-end") {
      let top;
      do {
        yield* this.pop();
        top = this.peek(1);
      } while (top && top.type === "flow-collection");
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          if (!it || it.sep)
            fc.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          if (!it || it.value)
            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          if (!it || it.value)
            fc.items.push({ start: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (!it || it.value)
            fc.items.push({ start: [], key: fs, sep: [] });
          else if (it.sep)
            this.stack.push(fs);
          else
            Object.assign(it, { key: fs, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      if (bv)
        this.stack.push(bv);
      else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent2 = this.peek(2);
      if (parent2.type === "block-map" && (this.type === "map-value-ind" && parent2.indent === fc.indent || this.type === "newline" && !parent2.items[parent2.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === "map-value-ind" && parent2.type !== "flow-collection") {
        const prev2 = getPrevProps(parent2);
        const start = getFirstKeyStartProps(prev2);
        fixFlowSeqItems(fc);
        const sep = fc.end.splice(1, fc.end.length);
        sep.push(this.sourceToken);
        const map4 = {
          type: "block-map",
          offset: fc.offset,
          indent: fc.indent,
          items: [{ start, key: fc, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map4;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type) {
    if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      while (nl !== 0) {
        this.onNewLine(this.offset + nl);
        nl = this.source.indexOf("\n", nl) + 1;
      }
    }
    return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent2) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const prev2 = getPrevProps(parent2);
        const start = getFirstKeyStartProps(prev2);
        start.push(this.sourceToken);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, explicitKey: true }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const prev2 = getPrevProps(parent2);
        const start = getFirstKeyStartProps(prev2);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(start, indent) {
    if (this.type !== "comment")
      return false;
    if (this.indent <= indent)
      return false;
    return start.every((st) => st.type === "newline" || st.type === "space");
  }
  *documentEnd(docEnd) {
    if (this.type !== "doc-mode") {
      if (docEnd.end)
        docEnd.end.push(this.sourceToken);
      else
        docEnd.end = [this.sourceToken];
      if (this.type === "newline")
        yield* this.pop();
    }
  }
  *lineEnd(token) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop();
        yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      case "space":
      case "comment":
      default:
        if (token.end)
          token.end.push(this.sourceToken);
        else
          token.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
    }
  }
};

// ../../node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/public-api.js
function parseOptions(options) {
  const prettyErrors = options.prettyErrors !== false;
  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseDocument2(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser3(lineCounter == null ? void 0 : lineCounter.addNewLine);
  const composer = new Composer(options);
  let doc = null;
  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}
function parse6(src, reviver, options) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options === void 0 && reviver && typeof reviver === "object") {
    options = reviver;
  }
  const doc = parseDocument2(src, options);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options));
}

// ../../node_modules/.pnpm/markmap-lib@0.17.2_markmap-common@0.18.9/node_modules/markmap-lib/dist/browser/index.mjs
var import_markdown_it_katex = __toESM(require_markdown_it_katex(), 1);
function initializeMarkdownIt() {
  const md = lib_default({
    html: true,
    breaks: true
  });
  md.use(ins_plugin).use(ins_plugin2).use(sub_plugin).use(sup_plugin);
  return md;
}
function createTransformHooks(transformer2) {
  return {
    transformer: transformer2,
    parser: new Hook(),
    beforeParse: new Hook(),
    afterParse: new Hook(),
    retransform: new Hook()
  };
}
function definePlugin(plugin2) {
  return plugin2;
}
var svgMarked = '<svg width="16" height="16" viewBox="0 -3 24 24"><path d="M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2m-9 14-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8z"/></svg>\n';
var svgUnmarked = '<svg width="16" height="16" viewBox="0 -3 24 24"><path fill-rule="evenodd" d="M6 5a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1zM3 6a3 3 0 0 1 3-3h12a3 3 0 0 1 3 3v12a3 3 0 0 1-3 3H6a3 3 0 0 1-3-3v-5z" clip-rule="evenodd"/></svg>\n';
var name$5 = "checkbox";
var images = {
  " ": svgUnmarked.trim(),
  x: svgMarked.trim()
};
var plugin$3 = definePlugin({
  name: name$5,
  transform(transformHooks) {
    transformHooks.parser.tap((md) => {
      md.core.ruler.before("inline", "checkbox", (state) => {
        for (let i = 2; i < state.tokens.length; i += 1) {
          const token = state.tokens[i];
          if (token.type === "inline" && token.content) {
            const prevType = state.tokens[i - 1].type;
            const prevPrevType = state.tokens[i - 2].type;
            if (prevType === "heading_open" || prevType === "paragraph_open" && prevPrevType === "list_item_open") {
              token.content = token.content.replace(
                /^\[(.)\] /,
                (m, g) => images[g] ? `${images[g]} ` : m
              );
            }
          }
        }
        return false;
      });
    });
    return {};
  }
});
var pluginCheckbox = plugin$3;
var name$4 = "frontmatter";
var pluginFrontmatter = definePlugin({
  name: name$4,
  transform(transformHooks) {
    transformHooks.beforeParse.tap((_md, context) => {
      var _a3;
      const { content } = context;
      if (!/^---\r?\n/.test(content))
        return;
      const match2 = /\n---\r?\n/.exec(content);
      if (!match2)
        return;
      const raw = content.slice(4, match2.index).trimEnd();
      let frontmatter;
      try {
        frontmatter = parse6(raw.replace(/\r?\n|\r/g, "\n"));
        if (frontmatter == null ? void 0 : frontmatter.markmap) {
          frontmatter.markmap = normalizeMarkmapJsonOptions(
            frontmatter.markmap
          );
        }
      } catch (e) {
        return;
      }
      context.frontmatter = frontmatter;
      context.parserOptions = {
        ...context.parserOptions,
        ...(_a3 = frontmatter == null ? void 0 : frontmatter.markmap) == null ? void 0 : _a3.htmlParser
      };
      context.content = content.slice(match2.index + match2[0].length);
      context.contentLineOffset = content.slice(0, match2.index).split("\n").length + 1;
    });
    return {};
  }
});
function normalizeMarkmapJsonOptions(options) {
  if (!options)
    return;
  ["color", "extraJs", "extraCss"].forEach((key) => {
    if (options[key] != null)
      options[key] = normalizeStringArray(options[key]);
  });
  ["duration", "maxWidth", "initialExpandLevel"].forEach((key) => {
    if (options[key] != null)
      options[key] = normalizeNumber(options[key]);
  });
  return options;
}
function normalizeStringArray(value) {
  let result;
  if (typeof value === "string")
    result = [value];
  else if (Array.isArray(value))
    result = value.filter((item) => item && typeof item === "string");
  return (result == null ? void 0 : result.length) ? result : void 0;
}
function normalizeNumber(value) {
  if (isNaN(+value))
    return;
  return +value;
}
function patchJSItem(urlBuilder2, item) {
  if (item.type === "script" && item.data.src) {
    return {
      ...item,
      data: {
        ...item.data,
        src: urlBuilder2.getFullUrl(item.data.src)
      }
    };
  }
  return item;
}
function patchCSSItem(urlBuilder2, item) {
  if (item.type === "stylesheet" && item.data.href) {
    return {
      ...item,
      data: {
        ...item.data,
        href: urlBuilder2.getFullUrl(item.data.href)
      }
    };
  }
  return item;
}
var name$3 = "hljs";
var preloadScripts$1 = [
  `@highlightjs/cdn-assets@${"11.8.0"}/highlight.min.js`
].map((path) => buildJSItem(path));
var styles$1 = [
  `@highlightjs/cdn-assets@${"11.8.0"}/styles/default.min.css`
].map((path) => buildCSSItem(path));
var config$1 = {
  versions: {
    hljs: "11.8.0"
  },
  preloadScripts: preloadScripts$1,
  styles: styles$1
};
var plugin$2 = definePlugin({
  name: name$3,
  config: config$1,
  transform(transformHooks) {
    var _a3, _b, _c;
    let loading;
    const preloadScripts2 = ((_b = (_a3 = plugin$2.config) == null ? void 0 : _a3.preloadScripts) == null ? void 0 : _b.map(
      (item) => patchJSItem(transformHooks.transformer.urlBuilder, item)
    )) || [];
    const autoload = () => {
      loading || (loading = loadJS(preloadScripts2));
      return loading;
    };
    let enableFeature = noop;
    transformHooks.parser.tap((md) => {
      md.set({
        highlight: (str, language) => {
          enableFeature();
          const { hljs } = window;
          if (hljs) {
            return hljs.highlightAuto(str, language ? [language] : void 0).value;
          }
          autoload().then(() => {
            transformHooks.retransform.call();
          });
          return str;
        }
      });
    });
    transformHooks.beforeParse.tap((_, context) => {
      enableFeature = () => {
        context.features[name$3] = true;
      };
    });
    return {
      styles: (_c = plugin$2.config) == null ? void 0 : _c.styles
    };
  }
});
var pluginHljs = plugin$2;
function addDefaultVersions(paths, name2, version) {
  return paths.map((path) => {
    if (typeof path === "string" && !path.includes("://")) {
      if (!path.startsWith("npm:")) {
        path = `npm:${path}`;
      }
      const prefixLength = 4 + name2.length;
      if (path.startsWith(`npm:${name2}/`)) {
        path = `${path.slice(0, prefixLength)}@${version}${path.slice(
          prefixLength
        )}`;
      }
    }
    return path;
  });
}
var name$2 = "katex";
var preloadScripts = [
  `katex@${"0.16.8"}/dist/katex.min.js`
].map((path) => buildJSItem(path));
var webfontloader = buildJSItem(
  `webfontloader@${"1.6.28"}/webfontloader.js`
);
webfontloader.data.defer = true;
var styles = [`katex@${"0.16.8"}/dist/katex.min.css`].map(
  (path) => buildCSSItem(path)
);
var config2 = {
  versions: {
    katex: "0.16.8",
    webfontloader: "1.6.28"
  },
  preloadScripts,
  scripts: [
    {
      type: "iife",
      data: {
        fn: (getMarkmap) => {
          window.WebFontConfig = {
            custom: {
              families: [
                "KaTeX_AMS",
                "KaTeX_Caligraphic:n4,n7",
                "KaTeX_Fraktur:n4,n7",
                "KaTeX_Main:n4,n7,i4,i7",
                "KaTeX_Math:i4,i7",
                "KaTeX_Script",
                "KaTeX_SansSerif:n4,n7,i4",
                "KaTeX_Size1",
                "KaTeX_Size2",
                "KaTeX_Size3",
                "KaTeX_Size4",
                "KaTeX_Typewriter"
              ]
            },
            active: () => {
              getMarkmap().refreshHook.call();
            }
          };
        },
        getParams({ getMarkmap }) {
          return [getMarkmap];
        }
      }
    },
    webfontloader
  ],
  styles
};
var plugin$1 = definePlugin({
  name: name$2,
  config: config2,
  transform(transformHooks) {
    var _a3, _b, _c, _d;
    let loading;
    const preloadScripts2 = ((_b = (_a3 = plugin$1.config) == null ? void 0 : _a3.preloadScripts) == null ? void 0 : _b.map(
      (item) => patchJSItem(transformHooks.transformer.urlBuilder, item)
    )) || [];
    const autoload = () => {
      loading || (loading = loadJS(preloadScripts2));
      return loading;
    };
    const renderKatex = (source, displayMode) => {
      const { katex } = window;
      if (katex) {
        return katex.renderToString(source, {
          displayMode,
          throwOnError: false
        });
      }
      autoload().then(() => {
        transformHooks.retransform.call();
      });
      return source;
    };
    let enableFeature = noop;
    transformHooks.parser.tap((md) => {
      md.use(import_markdown_it_katex.default);
      ["math_block", "math_inline"].forEach((key) => {
        const fn = (tokens, idx) => {
          enableFeature();
          const result = renderKatex(tokens[idx].content, !!tokens[idx].block);
          return result;
        };
        md.renderer.rules[key] = fn;
      });
    });
    transformHooks.beforeParse.tap((_, context) => {
      enableFeature = () => {
        context.features[name$2] = true;
      };
    });
    transformHooks.afterParse.tap((_, context) => {
      var _a22;
      const markmap = (_a22 = context.frontmatter) == null ? void 0 : _a22.markmap;
      if (markmap) {
        ["extraJs", "extraCss"].forEach((key) => {
          var _a32, _b2;
          const value = markmap[key];
          if (value) {
            markmap[key] = addDefaultVersions(
              value,
              name$2,
              ((_b2 = (_a32 = plugin$1.config) == null ? void 0 : _a32.versions) == null ? void 0 : _b2.katex) || ""
            );
          }
        });
      }
    });
    return {
      styles: (_c = plugin$1.config) == null ? void 0 : _c.styles,
      scripts: (_d = plugin$1.config) == null ? void 0 : _d.scripts
    };
  }
});
var pluginKatex = plugin$1;
var name$1 = "npmUrl";
var pluginNpmUrl = definePlugin({
  name: name$1,
  transform(transformHooks) {
    transformHooks.afterParse.tap((_, context) => {
      const { frontmatter } = context;
      const markmap = frontmatter == null ? void 0 : frontmatter.markmap;
      if (markmap) {
        ["extraJs", "extraCss"].forEach((key) => {
          const value = markmap[key];
          if (value) {
            markmap[key] = value.map((path) => {
              if (path.startsWith("npm:")) {
                return transformHooks.transformer.urlBuilder.getFullUrl(
                  path.slice(4)
                );
              }
              return path;
            });
          }
        });
      }
    });
    return {};
  }
});
var name = "sourceLines";
var plugin = definePlugin({
  name,
  transform(transformHooks) {
    transformHooks.parser.tap((md) => {
      md.renderer.renderAttrs = wrapFunction(
        md.renderer.renderAttrs,
        (renderAttrs2, token) => {
          let attrs = renderAttrs2(token);
          if (token.block && token.map) {
            attrs += ` data-lines=${token.map.join(",")}`;
          }
          return attrs;
        }
      );
    });
    return {};
  }
});
var pluginSourceLines = plugin;
var plugins = [
  pluginFrontmatter,
  pluginKatex,
  pluginHljs,
  pluginNpmUrl,
  pluginCheckbox,
  pluginSourceLines
];
var builtInPlugins = plugins;
function cleanNode(node) {
  while (!node.content && node.children.length === 1) {
    node = node.children[0];
  }
  while (node.children.length === 1 && !node.children[0].content) {
    node = {
      ...node,
      children: node.children[0].children
    };
  }
  return {
    ...node,
    children: node.children.map(cleanNode)
  };
}
var Transformer = class {
  constructor(plugins2 = builtInPlugins) {
    this.assetsMap = {};
    this.urlBuilder = new UrlBuilder();
    this.hooks = createTransformHooks(this);
    this.plugins = plugins2.map(
      (plugin2) => typeof plugin2 === "function" ? plugin2() : plugin2
    );
    const assetsMap = {};
    for (const { name: name2, transform } of this.plugins) {
      assetsMap[name2] = transform(this.hooks);
    }
    this.assetsMap = assetsMap;
    const md = initializeMarkdownIt();
    this.md = md;
    this.hooks.parser.call(md);
  }
  transform(content, fallbackParserOptions) {
    var _a3;
    const context = {
      content,
      features: {},
      contentLineOffset: 0,
      parserOptions: fallbackParserOptions
    };
    this.hooks.beforeParse.call(this.md, context);
    const html3 = this.md.render(context.content, {});
    this.hooks.afterParse.call(this.md, context);
    const root3 = cleanNode(buildTree(html3, context.parserOptions));
    root3.content || (root3.content = `${((_a3 = context.frontmatter) == null ? void 0 : _a3.title) || ""}`);
    return { ...context, root: root3 };
  }
  getAssets(keys) {
    const styles2 = [];
    const scripts = [];
    keys != null ? keys : keys = this.plugins.map((plugin2) => plugin2.name);
    for (const assets of keys.map((key) => this.assetsMap[key])) {
      if (assets) {
        if (assets.styles)
          styles2.push(...assets.styles);
        if (assets.scripts)
          scripts.push(...assets.scripts);
      }
    }
    return {
      styles: styles2.map((item) => patchCSSItem(this.urlBuilder, item)),
      scripts: scripts.map((item) => patchJSItem(this.urlBuilder, item))
    };
  }
  getUsedAssets(features) {
    const keys = this.plugins.map((plugin2) => plugin2.name).filter((name2) => features[name2]);
    return this.getAssets(keys);
  }
};

// ../ABConverter/converter/abc_markmap.ts
var transformer = new Transformer();
var abc_list2mindmap2 = ABConvert.factory({
  id: "list2markmap",
  name: "\u5217\u8868\u5230\u8111\u56FE (markmap)",
  process_param: "string" /* text */,
  process_return: "HTMLElement" /* el */,
  process: (el, header, content) => {
    list2markmap(content, el);
    markmap_event(el);
    return el;
  }
});
function list2markmap(markdown, div) {
  const { root: root3, features } = transformer.transform(markdown.trim());
  const assets = transformer.getUsedAssets(features);
  if (ABCSetting.env == "obsidian" || ABCSetting.env == "obsidian-min") {
    let height_adapt = 30 + markdown.split("\n").length * 15;
    if (height_adapt > 1e3)
      height_adapt = 1e3;
    const id = Math.random().toString(36).substring(2);
    const svg_div = document.createElement("div");
    div.appendChild(svg_div);
    svg_div.classList.add("ab-markmap-div");
    svg_div.id = "ab-markmap-div-" + id;
    const html_str = `<svg class="ab-markmap-svg" id="ab-markmap-${id}" data-json='${JSON.stringify(root3)}' style="height:${height_adapt}px"></svg>`;
    svg_div.innerHTML = html_str;
  } else {
    div.classList.add("ab-raw");
    div.innerHTML = `<div class="ab-raw-data" type-data="markmap" content-data='${markdown}'></div>`;
  }
  {
  }
  {
  }
  {
  }
  return div;
}

// ../ABConverter/index.ts
ABCSetting.env = "obsidian";

// ab_manager/abm_code/ABReplacer_CodeBlock.ts
var import_obsidian2 = require("obsidian");

// ab_manager/abm_cm/ABReplacer_Widget.ts
var import_obsidian = require("obsidian");
var import_view = require("@codemirror/view");
var _ABReplacer_Widget = class extends import_view.WidgetType {
  constructor(rangeSpec, editor) {
    super();
    this.rangeSpec = rangeSpec;
    this.global_editor = editor;
  }
  toDOM(view) {
    this.div = document.createElement("div");
    this.div.setAttribute("type_header", this.rangeSpec.header);
    this.div.addClasses(["ab-replace", "cm-embed-block"]);
    let dom_note = document.createElement("div");
    this.div.appendChild(dom_note);
    dom_note.classList.add("ab-note", "drop-shadow");
    ABConvertManager.autoABConvert(dom_note, this.rangeSpec.header, this.rangeSpec.content, this.rangeSpec.selector);
    if (this.global_editor) {
      let dom_edit = this.div.createEl("div", {
        cls: ["ab-button", "ab-button-1", "edit-block-button"],
        attr: { "aria-label": "Edit the block - " + this.rangeSpec.header }
      });
      if (import_obsidian.Platform.isMobileApp || import_obsidian.Platform.isPhone || import_obsidian.Platform.isTablet) {
        dom_edit.classList.remove("edit-block-button");
      }
      dom_edit.empty();
      dom_edit.appendChild((0, import_obsidian.sanitizeHTMLToDom)(_ABReplacer_Widget.STR_ICON_CODE2));
      dom_edit.onclick = () => {
        this.moveCursor();
      };
    }
    if (this.global_editor) {
      let dom_edit = this.div.createEl("div", {
        cls: ["ab-button", "ab-button-2", "edit-block-button"],
        attr: { "aria-label": "Refresh the block" }
      });
      dom_edit.empty();
      dom_edit.appendChild((0, import_obsidian.sanitizeHTMLToDom)(_ABReplacer_Widget.STR_ICON_REFRESH));
      dom_edit.onclick = () => {
        abConvertEvent(this.div);
        this.moveCursor(-1);
      };
    }
    return this.div;
  }
  moveCursor(line_offset = 0) {
    if (this.global_editor) {
      const editor = this.global_editor;
      let pos = getCursorPos(editor, this.rangeSpec.from_ch);
      if (pos) {
        pos.line += line_offset;
        if (line_offset < 0) {
          pos.ch = 0;
          editor.setCursor(pos);
        } else {
          editor.setCursor(pos);
          editor.replaceRange("OF", pos);
          editor.replaceRange("", pos, { line: pos.line, ch: pos.ch + 2 });
        }
      }
    }
    return;
    function getCursorPos(editor, total_ch) {
      let count_ch = 0;
      let list_text = editor.getValue().split("\n");
      for (let i = 0; i < list_text.length; i++) {
        if (count_ch + list_text[i].length >= total_ch)
          return { line: i, ch: total_ch - count_ch };
        count_ch = count_ch + list_text[i].length + 1;
      }
      return null;
    }
  }
};
var ABReplacer_Widget = _ABReplacer_Widget;
ABReplacer_Widget.STR_ICON_CODE2 = `<svg xmlns="http://www.w3.org/2000/svg" stroke-linecap="round"
      stroke-linejoin="round" data-darkreader-inline-stroke="" stroke-width="2"
      viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" style="--darkreader-inline-stroke:currentColor;">
    <path d="m18 16 4-4-4-4"></path>
    <path d="m6 8-4 4 4 4"></path>
    <path d="m14.5 4-5 16"></path>
  </svg>`;
ABReplacer_Widget.STR_ICON_REFRESH = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
      xml:space="preserve"
      viewBox="-80 -80 650 650" width="24" height="24" fill="currentColor" stroke="currentColor" style="--darkreader-inline-stroke:currentColor;">
    <g>
      <g>
        <path d="M468.999,227.774c-11.4,0-20.8,8.3-20.8,19.8c-1,74.9-44.2,142.6-110.3,178.9c-99.6,54.7-216,5.6-260.6-61l62.9,13.1
          c10.4,2.1,21.8-4.2,23.9-15.6c2.1-10.4-4.2-21.8-15.6-23.9l-123.7-26c-7.2-1.7-26.1,3.5-23.9,22.9l15.6,124.8
          c1,10.4,9.4,17.7,19.8,17.7c15.5,0,21.8-11.4,20.8-22.9l-7.3-60.9c101.1,121.3,229.4,104.4,306.8,69.3
          c80.1-42.7,131.1-124.8,132.1-215.4C488.799,237.174,480.399,227.774,468.999,227.774z"/>
        <path d="M20.599,261.874c11.4,0,20.8-8.3,20.8-19.8c1-74.9,44.2-142.6,110.3-178.9c99.6-54.7,216-5.6,260.6,61l-62.9-13.1
          c-10.4-2.1-21.8,4.2-23.9,15.6c-2.1,10.4,4.2,21.8,15.6,23.9l123.8,26c7.2,1.7,26.1-3.5,23.9-22.9l-15.6-124.8
          c-1-10.4-9.4-17.7-19.8-17.7c-15.5,0-21.8,11.4-20.8,22.9l7.2,60.9c-101.1-121.2-229.4-104.4-306.8-69.2
          c-80.1,42.6-131.1,124.8-132.2,215.3C0.799,252.574,9.199,261.874,20.599,261.874z"/>
      </g>
    </g>
  </svg>`;

// ab_manager/abm_code/ABReplacer_CodeBlock.ts
var ABReplacer_CodeBlock = class {
  static processor(src, blockEl, ctx) {
    ABCSetting.global_ctx = ctx;
    const root_div = document.createElement("div");
    blockEl.appendChild(root_div);
    root_div.classList.add("ab-replace");
    const list_src = src.split("\n");
    let header = "";
    let header_indent_prefix = "";
    if (list_src.length) {
      const match2 = list_src[0].match(ABReg.reg_header_noprefix);
      if (match2 && match2[5]) {
        header = match2[5];
        header_indent_prefix = match2[1];
      }
    }
    const src_without_indent = list_src.slice(1).map(
      (line) => line.startsWith(header_indent_prefix) ? line.substring(header_indent_prefix.length) : line
    ).join("\n");
    const calc_margin = header_indent_prefix.replace(/\t/g, "    ").length;
    root_div.setAttribute("style", "margin-left: " + calc_margin * 0.5 + "rem;");
    const dom_note = root_div.createDiv({
      cls: ["ab-note", "drop-shadow"]
    });
    let dom_replaceEl = dom_note.createDiv({
      cls: ["ab-replaceEl"]
    });
    if (header != "") {
      ABConvertManager.autoABConvert(dom_replaceEl, header, src_without_indent);
    } else {
      ABConvertManager.getInstance().m_renderMarkdownFn(src, dom_replaceEl, ctx);
    }
    let dom_edit = root_div.createEl("div", {
      cls: ["ab-button", "ab-button-2", "edit-block-button"],
      attr: { "aria-label": "Refresh the block" }
    });
    dom_edit.empty();
    dom_edit.appendChild((0, import_obsidian2.sanitizeHTMLToDom)(ABReplacer_Widget.STR_ICON_REFRESH));
    dom_edit.onclick = () => {
      abConvertEvent(root_div);
    };
    const button_show = () => {
      dom_edit.show();
    };
    const button_hide = () => {
      dom_edit.hide();
    };
    button_hide();
    dom_note.onmouseover = button_show;
    dom_note.onmouseout = button_hide;
    dom_edit.onmouseover = button_show;
    dom_edit.onmouseout = button_hide;
  }
};

// ab_manager/abm_cm/ABStateManager.ts
var import_view2 = require("@codemirror/view");
var import_state = require("@codemirror/state");
var import_obsidian5 = require("obsidian");

// config/ABSettingTab.ts
var import_obsidian4 = require("obsidian");

// ab_manager/abm_cm/ABSelector_Md.ts
function autoMdSelector(mdText = "") {
  let list_mdSelectorRangeSpec = [];
  let list_text = mdText.split("\n");
  let codeBlockFlag = "";
  let map_line_ch = [0];
  let count_ch = 0;
  for (let line of list_text) {
    count_ch = count_ch + line.length + 1;
    map_line_ch.push(count_ch);
  }
  for (let i = 0; i < list_text.length; i++) {
    const line = list_text[i];
    if (codeBlockFlag == "") {
      const match2 = line.match(ABReg.reg_code);
      if (match2 && match2[3]) {
        codeBlockFlag = match2[1] + match2[3];
      }
    } else {
      if (line.indexOf(codeBlockFlag) == 0) {
        codeBlockFlag = "";
      }
      continue;
    }
    for (let selecotr of list_mdSelector) {
      if (selecotr.match.test(line)) {
        let sim = selecotr.selector(list_text, i);
        if (!sim)
          continue;
        list_mdSelectorRangeSpec.push({
          from_ch: map_line_ch[sim.from_line],
          to_ch: map_line_ch[sim.to_line] - 1,
          header: sim.header,
          selector: sim.selector,
          content: sim.content,
          prefix: sim.prefix
        });
        i = sim.to_line - 1;
        codeBlockFlag = "";
        break;
      }
    }
  }
  return list_mdSelectorRangeSpec;
}
function generateSelectorInfoTable(el) {
  const table_p = el.createEl("div", {
    cls: ["ab-setting", "md-table-fig1"]
  });
  const table2 = table_p.createEl("table", {
    cls: ["ab-setting", "md-table-fig2"]
  });
  {
    const thead = table2.createEl("thead");
    const tr = thead.createEl("tr");
    tr.createEl("th", { text: "Selector Name" });
    tr.createEl("th", { text: "First-line Regular" });
    tr.createEl("th", { text: "Enable" });
  }
  const tbody = table2.createEl("tbody");
  for (let item of list_mdSelector) {
    const tr = tbody.createEl("tr");
    tr.createEl("td", { text: item.name });
    tr.createEl("td", { text: String(item.match) });
    tr.createEl("td", { text: item.is_disable ? "No" : "Yes" });
  }
  return table_p;
}
var list_mdSelector = [];
function registerMdSelector(simp) {
  var _a3;
  list_mdSelector.push({
    id: simp.id,
    name: simp.name,
    match: simp.match,
    detail: (_a3 = simp.detail) != null ? _a3 : "",
    selector: simp.selector,
    is_disable: false
  });
}

// ab_manager/abm_cm/ABSelector_MdBase.ts
function easySelector(list_text, from_line, selector, frist_reg) {
  let mdRange = {
    from_line: from_line - 1,
    to_line: from_line + 1,
    header: "",
    selector,
    levelFlag: "",
    content: "",
    prefix: ""
  };
  if (from_line <= 0)
    return null;
  const first_line_match = list_text[from_line].match(frist_reg);
  if (!first_line_match)
    return null;
  mdRange.prefix = first_line_match[1];
  mdRange.levelFlag = first_line_match[3];
  let header_line_match;
  if (list_text[from_line - 1].indexOf(mdRange.prefix) == 0 && ABReg.reg_emptyline_noprefix.test(list_text[from_line - 1]) && from_line > 1) {
    mdRange.from_line = from_line - 2;
  }
  header_line_match = list_text[mdRange.from_line].match(ABReg.reg_header);
  if (!header_line_match)
    return null;
  if (header_line_match[1] != mdRange.prefix)
    return null;
  mdRange.header = header_line_match[5];
  return mdRange;
}
function easySelector_headtail(list_text, from_line, selector, frist_reg) {
  let mdRange = {
    from_line,
    to_line: from_line + 1,
    header: "",
    selector,
    levelFlag: "",
    content: "",
    prefix: ""
  };
  if (from_line <= 0)
    return null;
  const first_line_match = list_text[from_line].match(frist_reg);
  if (!first_line_match)
    return null;
  mdRange.prefix = first_line_match[1];
  mdRange.levelFlag = first_line_match[3];
  mdRange.header = first_line_match[4];
  return mdRange;
}
var mdSelector_headtail = {
  id: "mdit",
  name: "mdit:::\u5934\u5C3E\u9009\u62E9\u5668",
  detail: "\u4EE5`:::`\u5F00\u5934\u548C\u7ED3\u5C3E\uFF0C\u5904\u7406\u5668\u540D\u5199\u5728\u7B2C\u4E00\u4E2A`:::`\u7684\u540E\u9762\uFF0C\u4E0D\u9700\u8981\u52A0`[]`\u3002\u5176\u5B9E\u5C31\u548C\u4EE3\u7801\u5757\u5DEE\u4E0D\u591A\uFF0C\u8FD9\u4E5F\u662FVuePress\u7684\u4E00\u4E2Amd\u6269\u5C55\u8BED\u6CD5",
  match: ABReg.reg_mdit_head,
  selector: (list_text, from_line) => {
    let mdRangeTmp = easySelector_headtail(list_text, from_line, "mdit", ABReg.reg_mdit_head);
    if (!mdRangeTmp)
      return null;
    const mdRange = mdRangeTmp;
    let last_nonempty = from_line;
    let codeBlockFlag = "";
    for (let i = from_line + 1; i < list_text.length; i++) {
      const line = list_text[i];
      if (codeBlockFlag == "") {
        const match2 = line.match(ABReg.reg_code);
        if (match2 && match2[3]) {
          codeBlockFlag = match2[1] + match2[3];
          continue;
        }
      } else {
        if (line.indexOf(codeBlockFlag) == 0)
          codeBlockFlag = "";
        continue;
      }
      if (line.indexOf(mdRange.prefix) != 0)
        break;
      const line2 = line.replace(mdRange.prefix, "");
      if (ABReg.reg_emptyline_noprefix.test(line2)) {
        continue;
      }
      last_nonempty = i;
      if (line2.indexOf(mdRange.levelFlag) == 0) {
        last_nonempty = i;
        break;
      }
    }
    mdRange.to_line = last_nonempty + 1;
    mdRange.content = list_text.slice(from_line + 1, mdRange.to_line - 1).map((line) => {
      return line.replace(mdRange.prefix, "");
    }).join("\n");
    return mdRange;
  }
};
registerMdSelector(mdSelector_headtail);
var mdSelector_list = {
  id: "list",
  name: "\u5217\u8868\u9009\u62E9\u5668",
  match: ABReg.reg_list,
  detail: "\u5728\u5217\u8868\u7684\u4E0A\u4E00/\u4E24\u884C\u52A0\u4E0A`[\u5904\u7406\u5668\u540D]`\u7684header\uFF0C\u6CE8\u610Fheader\u5FC5\u987B\u548C\u5217\u8868\u9996\u884C\u4F4D\u4E8E\u540C\u4E00\u5C42\u6B21",
  selector: (list_text, from_line) => {
    let mdRangeTmp = easySelector(list_text, from_line, "list", ABReg.reg_list);
    if (!mdRangeTmp)
      return null;
    const mdRange = mdRangeTmp;
    let last_nonempty = from_line;
    for (let i = from_line + 1; i < list_text.length; i++) {
      const line = list_text[i];
      if (line.indexOf(mdRange.prefix) != 0)
        break;
      const line2 = line.replace(mdRange.prefix, "");
      if (ABReg.reg_list_noprefix.test(line2)) {
        last_nonempty = i;
        continue;
      }
      if (ABReg.reg_indentline_noprefix.test(line2)) {
        last_nonempty = i;
        continue;
      }
      if (ABReg.reg_emptyline_noprefix.test(line2)) {
        continue;
      }
      break;
    }
    mdRange.to_line = last_nonempty + 1;
    mdRange.content = list_text.slice(from_line, mdRange.to_line).map((line) => {
      return line.replace(mdRange.prefix, "");
    }).join("\n");
    return mdRange;
  }
};
registerMdSelector(mdSelector_list);
var mdSelector_code = {
  id: "code",
  name: "\u4EE3\u7801\u9009\u62E9\u5668",
  match: ABReg.reg_code,
  detail: "\u5728\u4EE3\u7801\u5757\u7684\u4E0A\u4E00/\u4E24\u884C\u52A0\u4E0A`[\u5904\u7406\u5668\u540D]`\u7684header\uFF0C\u6CE8\u610Fheader\u5FC5\u987B\u548C\u4EE3\u7801\u5757\u9996\u884C\u4F4D\u4E8E\u540C\u4E00\u5C42\u6B21",
  selector: (list_text, from_line) => {
    let mdRangeTmp = easySelector(list_text, from_line, "code", ABReg.reg_code);
    if (!mdRangeTmp)
      return null;
    const mdRange = mdRangeTmp;
    let last_nonempty = from_line;
    for (let i = from_line + 1; i < list_text.length; i++) {
      const line = list_text[i];
      if (line.indexOf(mdRange.prefix) != 0)
        break;
      const line2 = line.replace(mdRange.prefix, "");
      if (ABReg.reg_emptyline_noprefix.test(line2)) {
        continue;
      }
      last_nonempty = i;
      if (line2.indexOf(mdRange.levelFlag) == 0) {
        last_nonempty = i;
        break;
      }
    }
    mdRange.to_line = last_nonempty + 1;
    mdRange.content = list_text.slice(from_line, mdRange.to_line).map((line) => {
      return line.replace(mdRange.prefix, "");
    }).join("\n");
    return mdRange;
  }
};
registerMdSelector(mdSelector_code);
var mdSelector_quote = {
  id: "quote",
  name: "\u5F15\u7528\u5757\u9009\u62E9\u5668",
  match: ABReg.reg_quote,
  detail: "\u5728\u5F15\u7528\u5757\u7684\u4E0A\u4E00/\u4E24\u884C\u52A0\u4E0A`[\u5904\u7406\u5668\u540D]`\u7684header\uFF0C\u6CE8\u610Fheader\u5FC5\u987B\u548C\u5F15\u7528\u5757\u9996\u884C\u4F4D\u4E8E\u540C\u4E00\u5C42\u6B21",
  selector: (list_text, from_line) => {
    let mdRangeTmp = easySelector(list_text, from_line, "quote", ABReg.reg_quote);
    if (!mdRangeTmp)
      return null;
    const mdRange = mdRangeTmp;
    let last_nonempty = from_line;
    for (let i = from_line + 1; i < list_text.length; i++) {
      const line = list_text[i];
      if (line.indexOf(mdRange.prefix) != 0)
        break;
      const line2 = line.replace(mdRange.prefix, "");
      if (ABReg.reg_quote_noprefix.test(line2)) {
        last_nonempty = i;
        continue;
      }
      break;
    }
    mdRange.to_line = last_nonempty + 1;
    mdRange.content = list_text.slice(from_line, mdRange.to_line).map((line) => {
      return line.replace(mdRange.prefix, "");
    }).join("\n");
    return mdRange;
  }
};
registerMdSelector(mdSelector_quote);
var mdSelector_table = {
  id: "table",
  name: "\u8868\u683C\u9009\u62E9\u5668",
  match: ABReg.reg_table,
  detail: "\u5728\u8868\u683C\u7684\u4E0A\u4E00/\u4E24\u884C\u52A0\u4E0A`[\u5904\u7406\u5668\u540D]`\u7684header\uFF0C\u6CE8\u610Fheader\u5FC5\u987B\u548C\u8868\u683C\u9996\u884C\u4F4D\u4E8E\u540C\u4E00\u5C42\u6B21",
  selector: (list_text, from_line) => {
    let mdRangeTmp = easySelector(list_text, from_line, "table", ABReg.reg_table);
    if (!mdRangeTmp)
      return null;
    const mdRange = mdRangeTmp;
    let last_nonempty = from_line;
    for (let i = from_line + 1; i < list_text.length; i++) {
      const line = list_text[i];
      if (line.indexOf(mdRange.prefix) != 0)
        break;
      const line2 = line.replace(mdRange.prefix, "");
      if (ABReg.reg_table_noprefix.test(line2)) {
        last_nonempty = i;
        continue;
      }
      break;
    }
    mdRange.to_line = last_nonempty + 1;
    mdRange.content = list_text.slice(from_line, mdRange.to_line).map((line) => {
      return line.replace(mdRange.prefix, "");
    }).join("\n");
    return mdRange;
  }
};
registerMdSelector(mdSelector_table);
var mdSelector_heading = {
  id: "heading",
  name: "\u6807\u9898\u9009\u62E9\u5668",
  match: ABReg.reg_heading,
  detail: "\u5728\u6807\u9898\u7684\u4E0A\u4E00/\u4E24\u884C\u52A0\u4E0A`[\u5904\u7406\u5668\u540D]`\u7684header\uFF0C\u6CE8\u610Fheader\u5FC5\u987B\u548C\u6807\u9898\u9996\u884C\u4F4D\u4E8E\u540C\u4E00\u5C42\u6B21",
  selector: (list_text, from_line) => {
    let mdRangeTmp = easySelector(list_text, from_line, "heading", ABReg.reg_heading);
    if (!mdRangeTmp)
      return null;
    const mdRange = mdRangeTmp;
    let last_nonempty = from_line;
    let codeBlockFlag = "";
    for (let i = from_line + 1; i < list_text.length; i++) {
      const line = list_text[i];
      if (codeBlockFlag == "") {
        const match3 = line.match(ABReg.reg_code);
        if (match3 && match3[3]) {
          codeBlockFlag = match3[1] + match3[3];
          continue;
        }
      } else {
        if (line.indexOf(codeBlockFlag) == 0)
          codeBlockFlag = "";
        continue;
      }
      if (line.indexOf(mdRange.prefix) != 0)
        break;
      const line2 = line.replace(mdRange.prefix, "");
      if (ABReg.reg_emptyline_noprefix.test(line2)) {
        continue;
      }
      const match2 = line2.match(ABReg.reg_heading_noprefix);
      if (!match2) {
        last_nonempty = i;
        continue;
      }
      if (match2[3].length < mdRange.levelFlag.length) {
        break;
      }
      last_nonempty = i;
    }
    mdRange.to_line = last_nonempty + 1;
    mdRange.content = list_text.slice(from_line, mdRange.to_line).map((line) => {
      return line.replace(mdRange.prefix, "");
    }).join("\n");
    return mdRange;
  }
};
registerMdSelector(mdSelector_heading);

// locales/helper.ts
var import_obsidian3 = require("obsidian");

// locales/en.ts
var en_default = {
  "see website for detail": `See 
    <a href="https://lincdocs.github.io/AnyBlock/README.show.html">website</a>
    /
    <a href="https://github.com/LincZero/obsidian-any-block">github</a>
    for more details`,
  "Selector manager": "Selector manager",
  "Selector manager2": "This section is for query only and cannot be edited",
  "AliasSystem manager": "Alias system manager",
  "AliasSystem manager2": "It can be viewed in the main page using the `[info_alias]` processor",
  "AliasSystem manager3": "This section can also be modified by opening the `data.json` file in the plugin folder",
  "AliasSystem manager4": "Add a new registration instruction",
  "AliasSystem manager5": "Add a new registration instructionAdd a new registration instruction (old, will not be used)",
  "Convertor manager": "Convertor manager",
  "Convertor manager2": "It can be viewed in the main page using the `[info_converter]` processor",
  "Convertor manager3": "This section is for query only and cannot be edited",
  "Custom alias": "Custom alias",
  "Custom alias2": "Alias matching rule",
  "Custom alias3": "If `/` is used to enclose it, it indicates a regular expression.",
  "Custom alias4": "Alias replacement",
  "Custom alias5": "The parameter-based replacement function is currently not available. It will be enabled only when there is a need for multiple users.",
  "Custom processor": "Custom processor - deprecated",
  "Custom processor2": "Processor id",
  "Custom processor3": "Without conflicting with other processors",
  "Custom processor4": "Processor name",
  "Custom processor5": "You can fill it in freely. It's for your own reference",
  "Custom processor6": "Processor matching rule",
  "Custom processor7": "Using `/` including it indicates a regular expression",
  "Custom processor8": "Processor replacement",
  "Custom processor9": "Using `/` including it indicates a regular expression",
  "Submit": "Submit",
  "Edit": "Edit",
  "Refresh": "Refresh",
  "Delete": "Delete",
  "Save": "Save",
  "Cancel": "Cancel",
  "Close": "Close"
};

// locales/zh-cn.ts
var zh_cn_default = {
  "see website for detail": `\u67E5\u770B 
    <a href="https://lincdocs.github.io/AnyBlock/README.show.html">website</a>
    /
    <a href="https://github.com/LincZero/obsidian-any-block">github</a>
    \u6587\u6863\u4EE5\u83B7\u53D6\u66F4\u591A\u7EC6\u8282`,
  "Selector manager": "\u9009\u62E9\u5668\u7684\u7BA1\u7406",
  "Selector manager2": "\u8FD9\u4E00\u90E8\u5206\u4EC5\u4F9B\u67E5\u8BE2\u4E0D\u53EF\u7F16\u8F91",
  "AliasSystem manager": "Alias system manager",
  "AliasSystem manager2": "\u8FD9\u90E8\u5206\u5185\u5BB9\u53EF\u4EE5\u4F7F\u7528 `[info_alias]` \u5904\u7406\u5668\u5728\u4E3B\u9875\u9762\u4E2D\u67E5\u770B",
  "AliasSystem manager3": "\u8FD9\u90E8\u5206\u4E5F\u53EF\u4EE5\u6253\u5F00\u63D2\u4EF6\u6587\u4EF6\u5939\u4E2D\u7684 `data.json` \u6587\u4EF6\u4FEE\u6539",
  "AliasSystem manager4": "\u6DFB\u52A0\u65B0\u7684\u6CE8\u518C\u6307\u4EE4",
  "AliasSystem manager5": "\u6DFB\u52A0\u65B0\u7684\u6CE8\u518C\u6307\u4EE4 - \u65E7\u7248\uFF0C\u5C06\u5F03\u7528",
  "Convertor manager": "\u8F6C\u6362\u5668/\u5904\u7406\u5668\u7684\u7BA1\u7406",
  "Convertor manager2": "\u8FD9\u90E8\u5206\u5185\u5BB9\u53EF\u4EE5\u4F7F\u7528 `[info_converter]` \u5904\u7406\u5668\u5728\u4E3B\u9875\u9762\u4E2D\u67E5\u770B",
  "Convertor manager3": "\u8FD9\u4E00\u90E8\u5206\u4EC5\u4F9B\u67E5\u8BE2\u4E0D\u53EF\u7F16\u8F91",
  "Custom alias": "\u81EA\u5B9A\u4E49\u522B\u540D",
  "Custom alias2": "\u522B\u540D\u5339\u914D\u89C4\u5219",
  "Custom alias3": "\u82E5\u7528`/`\u5305\u62EC\u8D77\u6765\u5219\u8868\u793A\u6B63\u5219",
  "Custom alias4": "\u522B\u540D\u66FF\u6362\u4E3A",
  "Custom alias5": "\u6682\u4E0D\u5F00\u653E\u5E26\u53C2\u6570\u7684\u66FF\u6362\u529F\u80FD\uFF0C\u5982\u591A\u4EBA\u9700\u8981\u624D\u5F00\u653E",
  "Custom processor": "\u81EA\u5B9A\u4E49\u5904\u7406\u5668 - \u5C06\u5E9F\u5F03",
  "Custom processor2": "\u5904\u7406\u5668\u552F\u4E00id",
  "Custom processor3": "\u4E0D\u4E0E\u5176\u4ED6\u5904\u7406\u5668\u51B2\u7A81\u5373\u53EF",
  "Custom processor4": "\u6CE8\u518C\u5668\u540D",
  "Custom processor5": "\u53EF\u4EE5\u968F\u4FBF\u586B\uFF0C\u7ED9\u81EA\u5DF1\u770B\u7684",
  "Custom processor6": "\u6CE8\u518C\u5668\u5339\u914D\u540D",
  "Custom processor7": "\u7528 `/` \u5305\u62EC\u8D77\u6765\u5219\u8868\u793A\u6B63\u5219",
  "Custom processor8": "\u6CE8\u518C\u5668\u66FF\u6362\u4E3A",
  "Custom processor9": "\u7528 `/` \u5305\u62EC\u8D77\u6765\u5219\u8868\u793A\u6B63\u5219",
  "Submit": "\u63D0\u4EA4",
  "Edit": "\u7F16\u8F91",
  "Refresh": "\u5237\u65B0",
  "Delete": "\u5220\u9664",
  "Save": "\u4FDD\u5B58",
  "Cancel": "\u53D6\u6D88",
  "Close": "\u5173\u95ED"
};

// locales/helper.ts
var localeMap = {
  en: en_default,
  "zh": zh_cn_default,
  "zh-TW": zh_cn_default
};
var locale = localeMap[(0, import_obsidian3.getLanguage)()];
function t(str) {
  return locale && locale[str] || en_default[str];
}

// config/ABSettingTab.ts
var AB_SETTINGS = {
  select_list: "ifhead" /* ifhead */,
  select_quote: "ifhead" /* ifhead */,
  select_code: "ifhead" /* ifhead */,
  select_heading: "ifhead" /* ifhead */,
  select_brace: "yes" /* yes */,
  decoration_source: "none" /* none */,
  decoration_live: "block" /* block */,
  decoration_render: "block" /* block */,
  is_neg_level: false,
  alias_use_default: true,
  alias_user: [
    {
      "regex": "|alias_demo|",
      "replacement": "|addClass(ab-custom-text-red)|addClass(ab-custom-bg-blue)|"
    },
    {
      "regex": "/\\|alias_reg_demo\\|/",
      "replacement": "|addClass(ab-custom-text-red)|addClass(ab-custom-bg-blue)|"
    }
  ],
  user_processor: [{
    "id": "alias2_demo",
    "name": "alias2_demo",
    "match": "alias2_demo",
    "process_alias": "|addClass(ab-custom-text-blue)|addClass(ab-custom-bg-red)|"
  }],
  is_debug: false,
  enhance_refresh_time: 2e3,
  inline_split: "/\\| |,  |\uFF0C |\\.  |\u3002 |:  |\uFF1A /"
};
var ABSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app2, plugin2) {
    super(app2, plugin2);
    this.plugin = plugin2;
    ABCSetting.is_debug = this.plugin.settings.is_debug;
    ABReg.inline_split = new RegExp(this.plugin.settings.inline_split.slice(1, -1));
    if (!plugin2.settings.alias_use_default) {
      ABAlias_json.length = 0;
    }
    for (let item of plugin2.settings.alias_user) {
      let newReg;
      if (/^\/.*\/$/.test(item.regex)) {
        newReg = new RegExp(item.regex.slice(1, -1));
      } else {
        newReg = item.regex;
      }
      ABAlias_json.push({
        regex: newReg,
        replacement: item.replacement
      });
    }
    for (let item of plugin2.settings.user_processor) {
      ABConvert.factory(item);
    }
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    let settings = this.plugin.settings;
    const div_url = containerEl.createEl("div");
    div_url.empty();
    div_url.appendChild((0, import_obsidian4.sanitizeHTMLToDom)(t("see website for detail")));
    containerEl.createEl("hr", { cls: "bright-color" });
    new import_obsidian4.Setting(containerEl).setName(t("Selector manager")).setHeading();
    containerEl.createEl("p", { text: t("Selector manager2") });
    this.selectorPanel = generateSelectorInfoTable(containerEl);
    containerEl.createEl("hr", { cls: "bright-color" });
    new import_obsidian4.Setting(containerEl).setName(t("AliasSystem manager")).setHeading();
    containerEl.createEl("p", { text: t("AliasSystem manager2") });
    containerEl.createEl("p", { text: t("AliasSystem manager3") });
    new import_obsidian4.Setting(containerEl).setName(t("AliasSystem manager4")).addButton((component) => {
      component.setIcon("plus-circle").onClick((e) => {
        new ABModal_alias(this.app, async (result) => {
          let newReg;
          if (/^\/.*\/$/.test(result.regex)) {
            newReg = new RegExp(result.regex.slice(1, -1));
          } else {
            newReg = result.regex;
          }
          ABAlias_json.push({
            regex: newReg,
            replacement: result.replacement
          });
          await this.plugin.saveSettings();
        }).open();
      });
    });
    new import_obsidian4.Setting(containerEl).setName(t("AliasSystem manager5")).addButton((component) => {
      component.setIcon("plus-circle").onClick((e) => {
        new ABProcessorModal(this.app, async (result) => {
          ABConvert.factory(result);
          settings.user_processor.push(result);
          await this.plugin.saveSettings();
          this.processorPanel.remove();
          const div2 = containerEl.createEl("div");
          ABConvertManager.autoABConvert(div2, "info_converter", "", "null_content");
          this.processorPanel = div2;
        }).open();
      });
    });
    containerEl.createEl("hr", { cls: "bright-color" });
    new import_obsidian4.Setting(containerEl).setName("").setHeading();
    containerEl.createEl("p", { text: t("Convertor manager") });
    containerEl.createEl("p", { text: t("Convertor manager2") });
    containerEl.createEl("p", { text: t("Convertor manager3") });
    const div = containerEl.createEl("div");
    ABConvertManager.autoABConvert(div, "info_converter", "", "null_content");
    this.processorPanel = div;
  }
};
var ABProcessorModal = class extends import_obsidian4.Modal {
  constructor(app2, onSubmit) {
    super(app2);
    this.args = {
      id: "",
      name: "",
      match: "",
      process_alias: ""
    };
    this.onSubmit = onSubmit;
  }
  onOpen() {
    let { contentEl } = this;
    contentEl.setText(t("Custom processor"));
    contentEl.createEl("p", { text: "" });
    new import_obsidian4.Setting(contentEl).setName(t("Custom processor2")).setDesc(t("Custom processor3")).addText((text4) => {
      text4.onChange((value) => {
        this.args.id = value;
      });
    });
    new import_obsidian4.Setting(contentEl).setName(t("Custom processor4")).setDesc(t("Custom processor5")).addText((text4) => {
      text4.onChange((value) => {
        this.args.name = value;
      });
    });
    new import_obsidian4.Setting(contentEl).setName(t("Custom processor6")).setDesc(t("Custom processor7")).addText((text4) => {
      text4.onChange((value) => {
        this.args.match = value;
      });
    });
    new import_obsidian4.Setting(contentEl).setName(t("Custom processor8")).setDesc(t("Custom processor9")).addText((text4) => {
      text4.onChange((value) => {
        this.args.process_alias = value;
      });
    });
    new import_obsidian4.Setting(contentEl).addButton((btn) => {
      btn.setButtonText(t("Submit")).setCta().onClick(() => {
        if (this.args.id && this.args.name && this.args.match && this.args.process_alias) {
          this.close();
          this.onSubmit(this.args);
        }
      });
    });
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};
var ABModal_alias = class extends import_obsidian4.Modal {
  constructor(app2, onSubmit) {
    super(app2);
    this.args = {
      regex: "",
      replacement: ""
    };
    this.onSubmit = onSubmit;
  }
  onOpen() {
    let { contentEl } = this;
    contentEl.setText(t("Custom alias"));
    contentEl.createEl("p", { text: "" });
    new import_obsidian4.Setting(contentEl).setName(t("Custom alias2")).setDesc(t("Custom alias3")).addText((text4) => {
      text4.onChange((value) => {
        this.args.regex = value;
      });
    });
    new import_obsidian4.Setting(contentEl).setName(t("Custom alias4")).setDesc(t("Custom alias5")).addText((text4) => {
      text4.onChange((value) => {
        this.args.replacement = value;
      });
    });
    new import_obsidian4.Setting(contentEl).addButton((btn) => {
      btn.setButtonText(t("Submit")).setCta().onClick(() => {
        if (this.args.regex && this.args.replacement) {
          this.close();
          this.onSubmit(this.args);
        }
      });
    });
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};

// ab_manager/abm_cm/ABStateManager.ts
var global_timer = null;
var ABStateManager = class {
  constructor(plugin_this) {
    this.replace_this = this;
    this.decorationField = import_state.StateField.define({
      create: (editorState) => {
        return import_view2.Decoration.none;
      },
      update: (decorationSet, tr) => {
        return this.onUpdate(decorationSet, tr);
      },
      provide: (f) => import_view2.EditorView.decorations.from(f)
    });
    this.plugin_this = plugin_this;
    let ret = this.constructor_init();
    if (this.plugin_this.settings.is_debug)
      console.log(">>> ABStateManager, initialFileName:", this.initialFileName, "initRet:", ret);
    if (ret)
      this.setStateEffects();
    {
      if (global_timer !== null) {
        window.clearInterval(global_timer);
        global_timer = null;
      }
      if (plugin_this.settings.enhance_refresh_time > 0) {
        if (plugin_this.settings.enhance_refresh_time < 500)
          plugin_this.settings.enhance_refresh_time = 500;
        global_timer = window.setInterval(() => {
          if (plugin_this.settings.is_debug)
            console.log("    auto refresh event:", this.initialFileName);
          abConvertEvent(document, true);
        }, plugin_this.settings.enhance_refresh_time);
      }
    }
    abConvertEvent(document);
  }
  constructor_init() {
    var _a3;
    const view = this.plugin_this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
    if (!view)
      return false;
    this.view = view;
    this.initialFileName = (_a3 = this.view.file) == null ? void 0 : _a3.basename;
    this.editor = this.view.editor;
    this.editorView = this.editor.cm;
    this.editorState = this.editorView.state;
    this.is_prev_cursor_in = true;
    this.prev_decoration_mode = "none" /* none */;
    this.prev_editor_mode = 0 /* NONE */;
    return true;
  }
  destructor() {
    if (this.plugin_this.settings.is_debug)
      console.log("<<< ABStateManager, initialFileName:", this.initialFileName);
    if (global_timer !== null) {
      window.clearInterval(global_timer);
      global_timer = null;
    }
  }
  setStateEffects() {
    let stateEffects = [];
    if (!this.editorState.field(this.decorationField, false)) {
      stateEffects.push(import_state.StateEffect.appendConfig.of(
        [this.decorationField]
      ));
    }
    this.editorView.dispatch({ effects: stateEffects });
    return true;
  }
  onUpdate(decorationSet, tr) {
    let editor_mode = this.getEditorMode();
    let decoration_mode;
    if (editor_mode == 1 /* SOURCE */) {
      decoration_mode = this.plugin_this.settings.decoration_source;
    } else if (editor_mode == 2 /* SOURCE_LIVE */) {
      decoration_mode = this.plugin_this.settings.decoration_live;
    } else {
      decoration_mode = this.plugin_this.settings.decoration_render;
    }
    return this.onUpdate_refresh(decorationSet, tr, decoration_mode, editor_mode);
  }
  onUpdate_refresh(decorationSet, tr, decoration_mode, editor_mode) {
    if (decoration_mode == "none" /* none */) {
      if (decoration_mode != this.prev_decoration_mode) {
        decorationSet = decorationSet.update({
          filter: (from, to, value) => {
            return false;
          }
        });
      } else {
      }
      this.is_prev_cursor_in = true;
      this.prev_decoration_mode = decoration_mode;
      this.prev_editor_mode = editor_mode;
      return decorationSet;
    }
    try {
      decorationSet = decorationSet.map(tr.changes);
    } catch (e) {
      console.warn("decorationSet map error, maybe paste ab at end", e);
    }
    const list_rangeSpec = autoMdSelector(this.getMdText(tr));
    let list_decoration_nochange = [];
    let list_decoration_change = [];
    const cursorSpec = this.getCursorCh(tr);
    const cursorSpec_last = this.getCursorCh();
    let is_current_cursor_in = false;
    for (let rangeSpec of list_rangeSpec) {
      let isCursorIn = false;
      let isCursonIn_last = false;
      if (cursorSpec.from >= rangeSpec.from_ch && cursorSpec.from <= rangeSpec.to_ch || cursorSpec.to >= rangeSpec.from_ch && cursorSpec.to <= rangeSpec.to_ch) {
        isCursorIn = true;
      }
      if (cursorSpec_last.from >= rangeSpec.from_ch && cursorSpec_last.from <= rangeSpec.to_ch || cursorSpec_last.to >= rangeSpec.from_ch && cursorSpec_last.to <= rangeSpec.to_ch) {
        isCursonIn_last = true;
      }
      if (isCursorIn) {
        is_current_cursor_in = true;
        const decoration = import_view2.Decoration.mark({ class: "ab-line-yellow" });
        list_decoration_change.push(decoration.range(rangeSpec.from_ch, rangeSpec.to_ch));
      } else if (isCursonIn_last) {
        const decoration = import_view2.Decoration.replace({
          widget: new ABReplacer_Widget(rangeSpec, this.editor)
        });
        list_decoration_change.push(decoration.range(rangeSpec.from_ch, rangeSpec.to_ch));
      } else {
        const decoration = import_view2.Decoration.replace({
          widget: new ABReplacer_Widget(rangeSpec, this.editor)
        });
        list_decoration_nochange.push(decoration.range(rangeSpec.from_ch, rangeSpec.to_ch));
      }
    }
    if (list_decoration_change.length == 0 && is_current_cursor_in == this.is_prev_cursor_in && decoration_mode == this.prev_decoration_mode && editor_mode == this.prev_editor_mode) {
      return decorationSet;
    }
    let debug_count1 = 0, debug_count2 = 0, debug_count3 = 0, debug_count4 = 0;
    decorationSet = decorationSet.update({
      filter(from, to, value) {
        for (let i = 0; i < list_decoration_nochange.length; i++) {
          const item = list_decoration_nochange[i];
          if (item.from == from && item.to == to) {
            debug_count1++;
            list_decoration_nochange.splice(i, 1);
            return true;
          }
        }
        debug_count1++;
        debug_count2++;
        return false;
      }
    });
    for (const item of list_decoration_nochange) {
      debug_count3++;
      decorationSet = decorationSet.update({
        add: [item]
      });
    }
    for (const item of list_decoration_change) {
      debug_count4++;
      decorationSet = decorationSet.update({
        add: [item]
      });
    }
    if (this.plugin_this.settings.is_debug)
      console.log(`ab cm \u88C5\u9970\u96C6\u53D8\u5316: ${debug_count1} -${debug_count2}+${debug_count3}+${debug_count4}`);
    this.is_prev_cursor_in = is_current_cursor_in;
    this.prev_decoration_mode = decoration_mode;
    this.prev_editor_mode = editor_mode;
    return decorationSet;
  }
  getEditorMode() {
    var _a3;
    let editor_dom = (_a3 = this.plugin_this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView)) == null ? void 0 : _a3.containerEl;
    if (!editor_dom) {
      return 0 /* NONE */;
    }
    let str = editor_dom == null ? void 0 : editor_dom.getAttribute("data-mode");
    if (str == "source") {
      editor_dom = editor_dom == null ? void 0 : editor_dom.getElementsByClassName("markdown-source-view")[0];
      if (editor_dom == null ? void 0 : editor_dom.classList.contains("is-live-preview"))
        return 2 /* SOURCE_LIVE */;
      else
        return 1 /* SOURCE */;
    } else if (str == "preview") {
      return 3 /* PREVIEW */;
    } else {
      return 0 /* NONE */;
    }
  }
  getCursorCh(tr) {
    var _a3, _b;
    const ranges = (_b = (_a3 = tr == null ? void 0 : tr.state) == null ? void 0 : _a3.selection) == null ? void 0 : _b.ranges;
    if (ranges && ranges.length == 1) {
      return {
        from: ranges[0].from,
        to: ranges[0].to
      };
    }
    let cursor_from_ch = 0;
    let cursor_to_ch = 0;
    let list_text = this.editor.getValue().split("\n");
    for (let i = 0; i <= this.editor.getCursor("to").line; i++) {
      if (this.editor.getCursor("from").line == i) {
        cursor_from_ch = cursor_to_ch + this.editor.getCursor("from").ch;
      }
      if (this.editor.getCursor("to").line == i) {
        cursor_to_ch = cursor_to_ch + this.editor.getCursor("to").ch;
        break;
      }
      cursor_to_ch += list_text[i].length + 1;
    }
    return {
      from: cursor_from_ch,
      to: cursor_to_ch
    };
  }
  getMdText(tr) {
    var _a3, _b;
    const mdText = (_b = (_a3 = tr == null ? void 0 : tr.state) == null ? void 0 : _a3.doc) == null ? void 0 : _b.toString();
    if (mdText) {
      return mdText;
    }
    return this.editor.getValue();
  }
  setPos(cursorSepc) {
    window.setTimeout(() => {
      const newSelection = import_state.EditorSelection.create([
        import_state.EditorSelection.range(cursorSepc, cursorSepc)
      ]);
      this.editorView.dispatch({
        selection: newSelection
      });
    }, 50);
  }
};

// ab_manager/abm_html/ABSelector_PostHtml.ts
var import_html_to_md = __toESM(require_dist());
var import_obsidian7 = require("obsidian");

// ab_manager/abm_html/ABReplacer_Render.ts
var import_obsidian6 = require("obsidian");
var ABReplacer_Render = class extends import_obsidian6.MarkdownRenderChild {
  constructor(containerEl, header, content, selectorName = "replacer_default") {
    super(containerEl);
    this.header = header;
    this.content = content;
    this.selectorName = selectorName;
  }
  onload() {
    const div = this.containerEl.createDiv({
      cls: ["ab-replace", "cm-embed-block"]
    });
    div.setAttribute("type_header", this.header);
    const dom_note = div.createDiv({
      cls: ["ab-note", "drop-shadow"]
    });
    let dom_replaceEl = dom_note.createDiv({
      cls: ["ab-replaceEl"]
    });
    ABConvertManager.autoABConvert(dom_replaceEl, this.header, this.content, this.selectorName);
    this.containerEl.replaceWith(div);
    let dom_edit2 = div.createEl("div", {
      cls: ["ab-button", "ab-button-1", "edit-block-button"],
      attr: { "aria-label": "Refresh the block" }
    });
    dom_edit2.empty();
    dom_edit2.appendChild((0, import_obsidian6.sanitizeHTMLToDom)(ABReplacer_Widget.STR_ICON_REFRESH));
    dom_edit2.onclick = () => {
      abConvertEvent(div);
    };
    const dom_edit = div.createEl("div", {
      cls: ["ab-button", "ab-button-2", "edit-block-button", "ab-button-select"]
    });
    const dom_edit_mask = dom_edit.createEl("button", {});
    dom_edit_mask.empty();
    dom_edit_mask.appendChild((0, import_obsidian6.sanitizeHTMLToDom)(`<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-down"><path d="m6 9 6 6 6-6"/></svg>`));
    const dom_edit_select = dom_edit.createEl("select", {
      attr: { "aria-label": "Change the block - " + this.header }
    });
    const first_dom_option = dom_edit_select.createEl("option", {
      text: "\u590D\u5408\u683C\u5F0F:" + this.header,
      attr: { "value": this.header, "title": this.header }
    });
    first_dom_option.selected = true;
    let header_name_flag = "";
    for (let item of ABConvertManager.getInstance().getConvertOptions()) {
      const dom_option = dom_edit_select.createEl("option", {
        text: item.name,
        attr: { "value": item.id }
      });
      if (this.header == item.id) {
        header_name_flag = item.name;
      }
    }
    if (header_name_flag != "") {
      first_dom_option.setText(header_name_flag);
    }
    dom_edit_select.onchange = () => {
      const new_header = dom_edit_select.options[dom_edit_select.selectedIndex].value;
      const new_dom_replaceEl = dom_note.createDiv({
        cls: ["ab-replaceEl"]
      });
      ABConvertManager.autoABConvert(new_dom_replaceEl, new_header, this.content, this.selectorName);
      dom_replaceEl.replaceWith(new_dom_replaceEl);
      dom_replaceEl = new_dom_replaceEl;
    };
    const button_show = () => {
      dom_edit.show();
      dom_edit2.show();
    };
    const button_hide = () => {
      dom_edit.hide();
      dom_edit2.hide();
    };
    button_hide();
    dom_note.onmouseover = button_show;
    dom_note.onmouseout = button_hide;
    dom_edit.onmouseover = button_show;
    dom_edit.onmouseout = button_hide;
    dom_edit2.onmouseover = button_show;
    dom_edit2.onmouseout = button_hide;
  }
};
ABReplacer_Render.str_icon_code2 = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="m18 16 4-4-4-4"></path><path d="m6 8-4 4 4 4"></path><path d="m14.5 4-5 16"></path></svg>`;

// ab_manager/abm_html/ABSelector_PostHtml.ts
var ABSelector_PostHtml = class {
  static processor(el, ctx) {
    var _a3, _b, _c, _d, _e, _f, _g;
    ABCSetting.global_ctx = ctx;
    if (this.settings.decoration_render == "none" /* none */)
      return;
    const mdSrc = getSourceMarkdown(el, ctx);
    if (!mdSrc) {
      if (false)
        console.log(" -- ABPosthtmlManager.processor, called by 'ReRender'");
      if (!el.classList.contains("markdown-rendered") && !((_c = (_b = (_a3 = el.parentElement) == null ? void 0 : _a3.parentElement) == null ? void 0 : _b.classList) == null ? void 0 : _c.contains("block-language-dataviewjs")) && !((_f = (_e = (_d = el.parentElement) == null ? void 0 : _d.parentElement) == null ? void 0 : _e.classList) == null ? void 0 : _f.contains("block-language-dataview")))
        return;
      const calloutEl = el.querySelector(":scope>div>div.callout-content");
      if (calloutEl) {
        el = calloutEl;
        el.classList.add("ab-note");
      }
      findABBlock_recurve(el);
      return;
    } else {
      const is_start = mdSrc.from_line == 0 || mdSrc.content_all.split("\n").slice(0, mdSrc.from_line).join("\n").trim() == "";
      const is_end = mdSrc.to_line == mdSrc.to_line_all;
      let is_newContent = false;
      let is_subContent = false;
      let cache_item = {
        name: ctx.sourcePath,
        content: mdSrc.content_all
      };
      ;
      (() => {
        var _a4, _b2, _c2;
        const ppEl = (_b2 = (_a4 = el.parentElement) == null ? void 0 : _a4.parentElement) == null ? void 0 : _b2.parentElement;
        if (!ppEl) {
          is_newContent = false;
          is_subContent = true;
          return;
        } else if (ppEl.classList.contains("markdown-embed-content")) {
          is_newContent = false;
          is_subContent = true;
          return;
        }
        const view = this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
        const path = (_c2 = view == null ? void 0 : view.file) == null ? void 0 : _c2.path;
        if (path && path !== ctx.sourcePath) {
          if (this.settings.is_debug)
            console.log(` !! Cache check: [${path}] use ![[${ctx.sourcePath}]] `);
          is_newContent = false;
          is_subContent = true;
          return;
        }
        const containerEl = view == null ? void 0 : view.containerEl;
        if (!containerEl || containerEl.getAttribute("data-mode") != "preview" || containerEl.getAttribute("data-type") != "markdown") {
          if (this.settings.is_debug)
            console.log(` !! Cache check: [${path}] use ![[${ctx.sourcePath}]] in no readmode`, containerEl);
          is_newContent = false;
          is_subContent = true;
          return;
        }
        for (let item of cache_map) {
          if (item.name == ctx.sourcePath) {
            cache_item = item;
            break;
          }
        }
        if (!cache_item) {
          cache_map.push(cache_item);
          is_newContent = true;
          if (this.settings.is_debug)
            console.log(" !! \u65E0\u7F13\u5B58 -> \u6709\u4FEE\u6539, perform a global refresh (rebuildView): ", cache_item, ctx);
        } else {
          if (cache_item.content != mdSrc.content_all) {
            cache_item.content = mdSrc.content_all;
            is_newContent = true;
            if (this.settings.is_debug)
              console.log(" !! \u6709\u7F13\u5B58, \u5185\u5BB9\u53D8 -> \u6709\u4FEE\u6539, perform a global refresh (rebuildView): ", cache_item, ctx);
          } else {
            is_newContent = false;
          }
        }
      })();
      if (is_newContent || is_start) {
        selected_els = [];
        selected_mdSrc = null;
      }
      if (this.settings.is_debug) {
        console.log(
          ` -- ABPosthtmlManager.processor, called by 'ReadMode'. [current] [${mdSrc.from_line},${mdSrc.to_line})/${mdSrc.to_line_all}. ${is_start ? "is_start " : ""}${is_end ? "is_end " : ""}[last] ${selected_mdSrc && selected_mdSrc.header ? "in ABBlock: " + selected_mdSrc.header + ". " : ""}`
        );
      }
      if (!is_subContent && is_newContent) {
        if (/\n((\s|>\s|-\s|\*\s|\+\s)*)(%%)?(\[((?!toc)(?!TOC)[0-9a-zA-Z\u4e00-\u9fa5].*)\]):?(%%)?\s*\n/.test(cache_item.content) || /\n((\s|>\s|-\s|\*\s|\+\s)*)(:::)\s?(\S*)\n/.test(cache_item.content)) {
          const leaf = (_g = this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView)) == null ? void 0 : _g.leaf;
          if (!leaf) {
            return;
          }
          leaf.rebuildView();
          return;
        }
      }
      for (let i = 0; i < el.children.length; i++) {
        const subEl = el.children[i];
        findABBlock_cross(subEl, ctx, is_end, i);
      }
      if (is_end) {
        findABBlock_end();
      }
    }
  }
};
function findABBlock_recurve(targetEl) {
  var _a3;
  for (let i = 0; i < targetEl.children.length; i++) {
    const contentEl = targetEl.children[i];
    if (!(contentEl instanceof HTMLUListElement || contentEl instanceof HTMLQuoteElement || contentEl instanceof HTMLPreElement || contentEl instanceof HTMLTableElement))
      continue;
    const headerEl = i == 0 ? null : targetEl.children[i - 1];
    if (i == 0 || !(headerEl instanceof HTMLParagraphElement)) {
      if (contentEl instanceof HTMLUListElement || contentEl instanceof HTMLQuoteElement)
        findABBlock_recurve(contentEl);
      continue;
    }
    const header_match = headerEl.getText().match(ABReg.reg_header);
    if (!header_match) {
      if (contentEl instanceof HTMLUListElement || contentEl instanceof HTMLQuoteElement)
        findABBlock_recurve(contentEl);
      continue;
    }
    const header_str = header_match[5];
    const newEl = document.createElement("div");
    newEl.addClass("ab-re-rendered");
    (_a3 = headerEl.parentNode) == null ? void 0 : _a3.insertBefore(newEl, headerEl.nextSibling);
    ABConvertManager.autoABConvert(newEl, header_str, (0, import_html_to_md.default)(contentEl.innerHTML), "postHtml");
    contentEl.hide();
    headerEl.hide();
  }
}
function findABBlock_end() {
  abConvertEvent(document);
}
var cache_map = [];
var selected_els = [];
var selected_mdSrc = null;
function findABBlock_cross(targetEl, ctx, is_last = false, sub_index) {
  const current_mdSrc = getSourceMarkdown(targetEl, ctx);
  if (!current_mdSrc) {
    return false;
  }
  if (selected_mdSrc && selected_mdSrc.header) {
    if (!selected_mdSrc.seFlag) {
      if (current_mdSrc.type == "list" || current_mdSrc.type == "code" || current_mdSrc.type == "quote" || current_mdSrc.type == "table") {
        if (current_mdSrc.type == "list") {
          if (current_mdSrc.header.indexOf("2") == 0)
            current_mdSrc.header = "list" + current_mdSrc.header;
        }
        selected_els.push(targetEl);
        selected_mdSrc.to_line = current_mdSrc.to_line;
        if (sub_index == 0) {
          selected_mdSrc.content += "\n\n" + current_mdSrc.content;
        }
        ;
        const replaceEl = selected_els.pop();
        if (replaceEl) {
          ctx.addChild(new ABReplacer_Render(replaceEl, selected_mdSrc.header, selected_mdSrc.content.split("\n").slice(2).join("\n"), selected_mdSrc.type));
          for (const el of selected_els) {
            el.hide();
          }
          ;
          selected_mdSrc = null;
          selected_els = [];
        }
      } else if (current_mdSrc.type == "heading" || current_mdSrc.type == "mdit") {
        selected_els.push(targetEl);
        selected_mdSrc.to_line = current_mdSrc.to_line;
        if (sub_index == 0) {
          selected_mdSrc.content += "\n\n" + current_mdSrc.content;
        }
        ;
        selected_mdSrc.seFlag = current_mdSrc.seFlag;
      } else {
        selected_mdSrc = null;
        selected_els = [];
      }
    } else {
      if ((current_mdSrc.type == "mdit_tail" || current_mdSrc.type == "mdit") && selected_mdSrc.seFlag.length == current_mdSrc.seFlag.length) {
        selected_els.push(targetEl);
        selected_mdSrc.to_line = current_mdSrc.to_line;
        if (sub_index == 0) {
          selected_mdSrc.content += "\n\n" + current_mdSrc.content;
        }
        ;
        const replaceEl = selected_els.pop();
        if (replaceEl) {
          ctx.addChild(new ABReplacer_Render(replaceEl, selected_mdSrc.header, selected_mdSrc.content.split("\n").slice(2, -1).join("\n"), selected_mdSrc.type));
          for (const el of selected_els) {
            el.hide();
          }
          ;
          selected_mdSrc = null;
          selected_els = [];
        }
      } else if (current_mdSrc.type == "heading" && selected_mdSrc.seFlag.length > current_mdSrc.seFlag.length) {
        const replaceEl = selected_els.pop();
        if (replaceEl) {
          ctx.addChild(new ABReplacer_Render(replaceEl, selected_mdSrc.header, selected_mdSrc.content.split("\n").slice(2).join("\n"), selected_mdSrc.type));
          for (const el of selected_els) {
            el.hide();
          }
          ;
          selected_mdSrc = null;
          selected_els = [];
        }
      } else if (is_last) {
        selected_els.push(targetEl);
        selected_mdSrc.to_line = current_mdSrc.to_line;
        if (sub_index == 0) {
          selected_mdSrc.content += "\n\n" + current_mdSrc.content;
        }
        ;
        const replaceEl = selected_els.pop();
        if (replaceEl) {
          ctx.addChild(new ABReplacer_Render(replaceEl, selected_mdSrc.header, selected_mdSrc.content.split("\n").slice(2).join("\n"), selected_mdSrc.type));
          for (const el of selected_els) {
            el.hide();
          }
          ;
          selected_mdSrc = null;
          selected_els = [];
        }
      } else {
        selected_els.push(targetEl);
        selected_mdSrc.to_line = current_mdSrc.to_line;
        if (sub_index == 0) {
          selected_mdSrc.content += "\n\n" + current_mdSrc.content;
        }
        ;
      }
    }
  }
  if (!selected_mdSrc || !selected_mdSrc.header) {
    if (current_mdSrc.type == "header" || current_mdSrc.type == "mdit") {
      selected_mdSrc = current_mdSrc;
      selected_els = [targetEl];
    } else {
      selected_mdSrc = null;
      selected_els = [];
    }
  }
  if (is_last) {
    selected_els = [];
    selected_mdSrc = null;
  }
}
function getSourceMarkdown(sectionEl, ctx) {
  let info = ctx.getSectionInfo(sectionEl);
  if (!info) {
    return null;
  }
  const {
    text: text4,
    lineStart,
    lineEnd
  } = info;
  const list_text = text4.split("\n");
  const list_content = list_text.slice(lineStart, lineEnd + 1);
  let range = {
    to_line_all: list_text.length,
    from_line: lineStart,
    to_line: list_text.length - lineEnd < 3 && list_text.slice(lineEnd + 1, list_text.length).join("\n").trim() == "" ? list_text.length : lineEnd + 1,
    content: list_content.join("\n").replace(/(\n)+$/, ""),
    content_all: text4,
    type: "",
    header: "",
    seFlag: "",
    prefix: ""
  };
  if (sectionEl instanceof HTMLUListElement) {
    range.type = "list";
    const match2 = list_content[0].match(ABReg.reg_list);
    if (!match2)
      return range;
    range.prefix = match2[1];
  } else if (sectionEl instanceof HTMLQuoteElement) {
    range.type = "quote";
    const match2 = list_content[0].match(ABReg.reg_quote);
    if (!match2)
      return range;
    range.prefix = match2[1];
  } else if (sectionEl instanceof HTMLPreElement) {
    range.type = "code";
    const match2 = list_content[0].match(ABReg.reg_code);
    if (!match2)
      return range;
    range.prefix = match2[1];
  } else if (sectionEl instanceof HTMLTableElement) {
    range.type = "table";
    const match2 = list_content[0].match(ABReg.reg_table);
    if (!match2)
      return range;
    range.prefix = match2[1];
  } else if (sectionEl instanceof HTMLHeadingElement) {
    range.type = "heading";
    const match2 = list_content[0].match(ABReg.reg_heading);
    if (!match2)
      return range;
    range.seFlag = match2[3];
  } else if (sectionEl instanceof HTMLParagraphElement) {
    range.type = "paragraph";
    const match_header = list_content[0].match(ABReg.reg_header);
    const match_mdit_head = list_content[0].match(ABReg.reg_mdit_head);
    const match_mdit_tail = list_content[0].match(ABReg.reg_mdit_tail);
    if (match_header) {
      range.type = "header";
      range.prefix = match_header[1];
      range.header = match_header[5];
    } else if (match_mdit_head) {
      range.type = "mdit";
      range.prefix = match_mdit_head[1];
      range.seFlag = match_mdit_head[3];
      range.header = match_mdit_head[4];
    } else if (match_mdit_tail) {
      range.type = "mdit_tail";
      range.prefix = match_mdit_tail[1];
      range.seFlag = match_mdit_tail[3];
    }
  } else {
    range.type = "other";
  }
  return range;
}

// main.ts
var AnyBlockPlugin = class extends import_obsidian8.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new ABSettingTab(this.app, this));
    ABConvertManager.getInstance().redefine_renderMarkdown((markdown, el, ctx) => {
      var _a3, _b, _c;
      el.classList.add("markdown-rendered");
      const mdrc = new import_obsidian8.MarkdownRenderChild(el);
      if (ctx)
        ctx.addChild(mdrc);
      else if (ABCSetting.global_ctx)
        ABCSetting.global_ctx.addChild(mdrc);
      import_obsidian8.MarkdownRenderer.render(this.app, markdown, el, (_c = (_b = (_a3 = this.app.workspace.getActiveViewOfType(import_obsidian8.MarkdownView)) == null ? void 0 : _a3.file) == null ? void 0 : _b.path) != null ? _c : "", mdrc);
    });
    ABCSetting.mermaid = (0, import_obsidian8.loadMermaid)();
    ABCSetting.mermaid.then((mermaid) => {
      const isDarkTheme = document.body.classList.contains("theme-dark");
      const theme = isDarkTheme ? "dark" : "light";
      mermaid.initialize({ theme });
    });
    this.registerMarkdownCodeBlockProcessor("ab", ABReplacer_CodeBlock.processor);
    this.registerMarkdownCodeBlockProcessor("anyblock", ABReplacer_CodeBlock.processor);
    {
      let abm;
      this.app.workspace.onLayoutReady(() => {
        abm == null ? void 0 : abm.destructor();
        abm = new ABStateManager(this);
      });
      this.registerEvent(
        this.app.workspace.on("file-open", (fileObj) => {
          abm == null ? void 0 : abm.destructor();
          abm = new ABStateManager(this);
        })
      );
      this.registerEvent(
        this.app.workspace.on("layout-change", () => {
          abm == null ? void 0 : abm.destructor();
          abm = new ABStateManager(this);
        })
      );
    }
    const htmlProcessor = ABSelector_PostHtml.processor.bind(this);
    this.registerMarkdownPostProcessor(htmlProcessor);
  }
  async loadSettings() {
    const data2 = await this.loadData();
    this.settings = Object.assign({}, AB_SETTINGS, data2);
    if (!data2) {
      this.saveData(this.settings);
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  onunload() {
  }
};
/*! @gera2ld/jsx-dom v2.2.2 | ISC License */
